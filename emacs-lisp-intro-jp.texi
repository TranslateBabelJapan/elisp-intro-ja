\input texinfo   @c -*-texinfo-*-
@comment %**start of header
@setfilename emacs-lisp-intro-jp
@c sethtmlfilename emacs-lisp-intro-jp.html
@settitle Programming in Emacs Lisp
@syncodeindex vr cp
@syncodeindex fn cp
@setchapternewpage odd
@finalout
@c ---------
@c @smallbook
@c @clear largebook
@iftex
@afourpaper
@set largebook
@end iftex
@c @set print-postscript-figures
@clear print-postscript-figures
@c ---------
@comment %**end of header 

@c <<<< Now set for largebook, no Postscript figures >>>>

@set edition-number 1.05
@set edition-number-jp 0.97
@set update-date 21 October 1997
@set update-date-jp 10 January 2000

@dircategory Editors
@direntry
* Emacs lisp Intro: (emacs-lisp-intro-jp). Programming Emacs Lisp (japanese).
@end direntry

@c ================ Included Figures ================

@c Set  print-postscript-figures  if you print PostScript figures.
@c If you clear this, the ten figures will be printed as ASCII diagrams.
@c (This is not relevant to Info, since Info only handles ASCII.) 
@c Your site may require editing changes to print PostScript; in this
@c case, search for `print-postscript-figures' and make appropriate changes.

@c ================ Size to Print Book ================

@c This manual can be printed in any of three different sizes.
@c In the above header, set @-commands appropriately.

@c     7 by 9.25 inches:          
@c              @smallbook
@c              @clear largebook

@c     8.5 by 11 inches:
@c              @set largebook

@c     European A4 size paper:   
@c              @afourpaper
@c              @set largebook

@c ================ How to Create an Info file ================

@c If you have `makeinfo' installed, run the following command  
@c (where  %  is the shell prompt): 

@c     % makeinfo emacs-lisp-intro.texi

@c or else, inside of GNU Emacs, find the `emacs-lisp-intro.texi' 
@c and then run: 

@c     M-x texinfo-format-buffer

@c After creating the Info file, edit your Info `dir' file
@c appropriately.  (The `dir' file is often in the `/usr/local/info/'
@c directory; you can use the START-INFO-DIR-ENTRY information below.)

@c ================ How to Create an HTML file ================

@c To convert to HTML format, apply `texi2html' or 
@c similar command to the `emacs-lisp-intro.texi' file.

@c ================ How to Typeset and Print ================

@c Note: unless you change it, this file does not format with the
@c obsolete `texinfo.tex 2.108'; use a more recent version.  This file
@c formats without error using `TeX 3.1415' and `texinfo.tex 2.145'.

@c If you do not include PostScript figures, run either of the
@c following command sequences, or similar commands suited to your
@c system: 

@c     % texi2dvi emacs-lisp-intro.texi
@c     % lpr -d emacs-lisp-intro.dvi

@c or else:

@c     % tex emacs-lisp-intro.texi
@c     % texindex emacs-lisp-intro.??
@c     % tex emacs-lisp-intro.texi
@c     % lpr -d emacs-lisp-intro.dvi

@c If you include the PostScript figures, you must convert the .dvi
@c file to a .ps file before printing.  Run either of the
@c following command sequences, or one similar:
@c
@c     % dvips -f < emacs-lisp-intro.dvi > emacs-lisp-intro.ps
@c
@c or else:
@c 
@c     % postscript -p < emacs-lisp-intro.dvi > emacs-lisp-intro.ps
@c

@c (Note: if you edit the book so as to change the length of the
@c table of contents, you may have to change the value of `pageno' below.)

@c ================ End of Formatting Sections ================

@c For next or subsequent edition:
@c   create function using with-output-to-temp-buffer
@c   create a major mode, with keymaps
@c   run an asynchronous process, like grep or diff
@c   use colors and fonts in X

@c For all sized formats: Experiment with smaller than normal amounts of
@c whitespace between chapters, sections, and paragraphs.
@tex
\global\chapheadingskip = 15pt plus 4pt minus 2pt
\global\secheadingskip = 12pt plus 3pt minus 2pt
\global\subsecheadingskip = 9pt plus 2pt minus 2pt
\global\parskip 2pt plus 1pt
@end tex

@c For 8.5 by 11 inch format: do not use such a small amount of
@c whitespace between paragraphs as in experiment above:
@ifset largebook
@tex
\global\parskip 6pt plus 1pt
@end tex
@end ifset

@c For all sized formats: Experiment with printing within-book cross
@c reference with ``...''  rather than [...]
@tex
% Need following so comma appears after section numbers.
\global\def\Ysectionnumberandtype{%
\ifnum\secno=0 \putwordChapter\xreftie\the\chapno, \space %
\else \ifnum \subsecno=0 \putwordSection\xreftie\the\chapno.\the\secno, \space %
\else \ifnum \subsubsecno=0 %
\putwordSection\xreftie\the\chapno.\the\secno.\the\subsecno, \space %
\else %
\putwordSection\xreftie\the\chapno.\the\secno.\the\subsecno.\the\subsubsecno, \space%
\fi \fi \fi }

\global\def\Yappendixletterandtype{%
\ifnum\secno=0 \putwordAppendix\xreftie'char\the\appendixno{}, \space%
\else \ifnum \subsecno=0 \putwordSection\xreftie'char\the\appendixno.\the\secno, \space %
\else \ifnum \subsubsecno=0 %
\putwordSection\xreftie'char\the\appendixno.\the\secno.\the\subsecno, \space %
\else %
\putwordSection\xreftie'char\the\appendixno.\the\secno.\the\subsecno.\the\subsubsecno, \space %
\fi \fi \fi }

\global\def\xrefX[#1,#2,#3,#4,#5,#6]{\begingroup
  \def\printedmanual{\ignorespaces #5}%
  \def\printednodename{\ignorespaces #3}%
  \setbox1=\hbox{\printedmanual}%
  \setbox0=\hbox{\printednodename}%
  \ifdim \wd0 = 0pt
    % No printed node name was explicitly given.
    \ifx\SETxref-automatic-section-title\relax %
      % Use the actual chapter/section title appear inside
      % the square brackets.  Use the real section title if we have it.
      \ifdim \wd1>0pt%
        % It is in another manual, so we don't have it.
        \def\printednodename{\ignorespaces #1}%
      \else
        \ifhavexrefs
          % We know the real title if we have the xref values.
          \def\printednodename{\refx{#1-title}}%
        \else
          % Otherwise just copy the Info node name.
          \def\printednodename{\ignorespaces #1}%
        \fi%
      \fi
      \def\printednodename{#1-title}%
    \else
      % Use the node name inside the square brackets.
      \def\printednodename{\ignorespaces #1}%
    \fi
  \fi
  %
  % If we use \unhbox0 and \unhbox1 to print the node names, TeX does not
  % insert empty discretionaries after hyphens, which means that it will
  % not find a line break at a hyphen in a node names.  Since some manuals
  % are best written with fairly long node names, containing hyphens, this
  % is a loss.  Therefore, we give the text of the node name again, so it
  % is as if TeX is seeing it for the first time.
  \ifdim \wd1 > 0pt
    \putwordsection{} ``\printednodename'' in \cite{\printedmanual}%
  \else
    % _ (for example) has to be the character _ for the purposes of the
    % control sequence corresponding to the node, but it has to expand
    % into the usual \leavevmode...\vrule stuff for purposes of
    % printing.  So we \turnoffactive for the \refx-snt, back on for the
    % printing, back off for the \refx-pg.
    {\turnoffactive \refx{#1-snt}{}}%
%    \space [\printednodename],\space                % <= original
%    \putwordsection{} ``\printednodename'',\space
    ``\printednodename'',\space
    \turnoffactive \putwordpage\tie\refx{#1-pg}{}%
  \fi
\endgroup}
@end tex

@c ----------------------------------------------------

@ignore
@ifinfo
@format
START-INFO-DIR-ENTRY
* Elisp Intro-j: (elisp-intro-jp). Programming in Emacs Lisp. (Japanese).
END-INFO-DIR-ENTRY
@end format
@end ifinfo
@end ignore

@ifinfo 
これは、初心者のための @cite{『Emacs Lisp によるプログラミング』} の入門
です。

Edition @value{edition-number}, @value{update-date}
日本語版 @value{edition-number-jp}, @value{update-date-jp}

Copyright (C) 1990, '91, '92, '93, '94, '95, '97 Free Software Foundation, Inc.
@c 1996, '97, '98 MATUSDA Shigeki.

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

@ignore 
Permission is granted to process this file through TeX
and print the results, provided the printed document
carries a copying permission notice identical to this
one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language, 
under the above conditions for modified versions, 
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.
@end ifinfo

@c half title; two lines here, so do not use `shorttitlepage'
@tex
{¥begingroup%
    ¥hbox{}¥vskip 1.5in ¥chaprm ¥chapmin
      ¥centerline{Emacs Lisp によるプログラミング}%
	¥endgroup}%
{¥begingroup¥hbox{}¥vskip 0.5in ¥chaprm ¥chapmin
      ¥centerline{初心者のための入門}%
	¥endgroup¥page¥hbox{}¥page}
@end tex

@titlepage
@title Emacs Lisp によるプログラミング
@subtitle 初心者のための入門
@subtitle Edition @value{edition-number}, @value{update-date}
@subtitle 日本語版 @value{edition-number-jp}, @value{update-date-jp}
@author Robert J. Chassell 著 @ 松田茂樹 訳

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1990, '91, '92, '93, '94, '95, '97 Free Software Foundation, Inc.
@c 1996, '97, '98 MATSUDA Shigeki.
@sp 2

Published by the Free Software Foundation, Inc.@*
59 Temple Place, Suite 330@*
Boston, MA 02111-1307 USA@*

@c Printed copies are available for $20 each.@*

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
@end titlepage

@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@end iftex

@node     Top,        Preface,  (dir),     (dir)
@comment  node-name,  next,     previous,  up

@ifinfo
この Info ファイルは、Programming in Emacs Lisp (An introduction) 1.05 
版の日本語訳です。翻訳元のファイルは GNU の配布の中に含まれている 
@file{emacs-lisp-intro-1.05.tar.gz} です。
@end ifinfo

@menu
* Preface::                     この文書の目的
* List Processing::             Lisp って何？
* Practicing Evaluation::       プログラムを走らせる
* Writing Defuns::              関数定義の書き方
* Buffer Walk Through::         バッファに関する幾つかの関数
* More Complex::                もうちょっと難しい関数
* Narrowing & Widening::        Emacs の注意を特定のリージョンにせばめる
* car cdr & cons::              Lisp における基本的な関数
* Cutting & Storing Text::      テキストの削除と保存
* List Implementation::         計算機の上でのリストの扱い
* Yanking::                     蓄えられたテキストのペースト
* Loops & Recursion::           プロセスの繰り返し
* Regexp Search::               正規表現の検索
* Counting Words::              繰り返しと正規表現の復習
* Words in a defun::            @code{defun} の中の単語を数える
* Readying a Graph::            グラフ表示関数の雛型
* Emacs Initialization::        @file{.emacs} ファイルの書き方
* Debugging::                   Emacs Lisp のデバッガの走らせ方
* Conclusion::                  基本はこれでおしまい
* the-the::                     Appendix: だぶった単語を見つけるには
* Kill Ring::                   Appendix: kill リングはどう働いているか？
* Full Graph::                  グラフにラベルを付けるには
* Index::                       
* About the Author::            

 --- The Detailed Node Listing ---

Preface

* On Reading this Text::        この文書を読むにあたって
* Who You Are::                 誰のために書かれたものか？
* Lisp History::                Lisp の歴史
* Note for Novices::            初心者の人へ
* Thank You::                   謝辞
* Translator Preface::          訳者まえがき

List Processing

* Lisp Lists::                  リストってなあに？
* Run a Program::               Lisp のリストはすぐに実行出来る
* Making Errors::               エラーを発生させる
* Names & Definitions::         シンボルや関数定義の名前
* Lisp Interpreter::            Lisp インタプリタの動作
* Evaluation::                  プログラムの実行
* Variables::                   変数の値を知る
* Arguments::                   引数：関数に情報を与えるもの
* set & setq::                  変数に値を設定する
* Summary::                     大切なポイント
* Error Message Exercises::     エラーメッセージについての練習問題

Lisp Lists

* Lisp Atoms::                  分解不可能な存在
* Whitespace in Lists::         リストを読みやすいよう整形する
* Typing Lists::                GNU Emacs がリストのタイプを助けてくれる

The Lisp Interpreter

* Byte Compiling::              実行速度を速めるための特殊なコード

Evaluation

* Evaluating Inner Lists::      リストの中のリスト...

Variables

* Void Variable::               値のないシンボルに対するエラーメッセージ

Arguments

* Data types::                  関数に渡されるデータの型
* Args as Variable or List::    引数には変数の値やリストも使える
* Variable Number of Arguments::  関数の中には、可変な数の引数を扱える
                                ものもある
* Wrong Type of Argument::      関数に間違った型の引数を与えると
* message::                     メッセージを表示する時に便利な関数

Setting the Value of a Variable

* Using set::                   値の設定
* Using setq::                  引用符をつけずに値を設定するには
* Counting::                    カウンタとしての @code{setq} の利用

Practicing Evaluation

* How to Evaluate::             編集コマンドのタイプするか @kbd{C-x C-e}
                                で評価を実行出来る。
* Buffer Names::                バッファとファイルの違い
* Getting Buffers::             バッファ名でなくバッファそのものを呼び出す
* Switching Buffers::           別のバッファに移るには
* Buffer Size & Locations::     ポイントの位置とバッファのサイズ
* Evaluation Exercise::         評価についての練習問題

How To Write Function Definitions

* Primitive Functions::         幾つかの関数は C で書かれている
* defun::                       特殊形式 @code{defun}
* Install::                     関数定義のインストール
* Interactive::                 関数をインタラクティブにする
* Interactive Options::         @code{interactive} の他のオプション
* Permanent Installation::      コードをずっとインストールしておきたい時
* let::                         局所変数の作成と初期化
* if::                          if とは？
* else::                        If--then--else 式
* Truth & Falsehood::           Lisp にとっての真と偽
* save-excursion::              ポイントやマークの位置、及びバッファの保存
* Review::                      復習
* defun Exercises::             関数定義についての練習問題

Install a Function Definition

* Change a defun::              関数定義の変更の仕方

Make a Function Interactive

* multiply-by-seven in detail::  インタラクティブバージョン

@code{let}

* Parts of let Expression::     @code{let} 式にはどんな部分があるか
* Sample let Expression::       @code{let} 式の例
* Uninitialized let Variables::  初期値をバインドしないとどうなるか

The @code{if} Special Form

* type-of-animal in detail::    @code{if} 式の例

@code{save-excursion}

* Template for save-excursion::  埋めるべきスロットは一つだけ

A Few Buffer--Related Functions

* Finding More::                情報の探し方
* simplified-beginning-of-buffer::  @code{goto-char}, @code{point-min}, 
                                そして @code{push-mark} を見てみよう
* mark-whole-buffer::           @code{beginning-of-buffer} と殆ど同じ
* append-to-buffer::            @code{save-excursion} と 
                                @code{insert-buffer-substring} を使う
* Buffer Related Review::       復習
* Buffer Exercises::            バッファについての練習問題 

The Definition of @code{mark-whole-buffer}

* Body of mark-whole-buffer::   本体は三行しかない

The Definition of @code{append-to-buffer}

* append interactive::          二つの部分からなるインタラクティブ式
* append-to-buffer body::       @code{let} 式との組み合わせ
* append save-excursion::       @code{save-excursion} はどう働くか

A Few More Complex Functions

* copy-to-buffer::              @code{set-buffer} と @code{get-buffer-create} を利用
* insert-buffer::               書き込み不可 と @code{or} の使い方
* beginning-of-buffer::         @code{goto-char}, @code{point-min}, そし
                                て @code{push-mark} を見てみる
* Second Buffer Related Review::  バッファについての練習問題(その２)
* &optional Exercise ::         &optional の練習問題

The Definition of @code{insert-buffer}

* insert interactive expression::  書き込み不可の状態の時の動作
* insert-buffer body::          本体には @code{or} と @code{let} がある
* if & or::                     @code{or} の代わりに @code{if} を使う
* insert or::                   @code{or} 式の動作について
* insert let::                  二つの @code{save-excursion} 式

The Interactive Expression in @code{insert-buffer}

* read-only buffer::            書き込み不可のバッファでは
* b for interactive::           

Complete Definition of @code{beginning-of-buffer}

* Optional Arguments::          
* beginning-of-buffer opt arg::  省略可能引数の例
* beginning-of-buffer complete::  完全版

@code{beginning-of-buffer} with an Argument

* large-case::                  大きなバッファでの割り算と掛け算
* small-case::                  括弧の中に何があるか

Narrowing and Widening

* narrowing advantages::        ナローイングの利点
* save-restriction::            特殊形式 @code{save-restriction}
* what-line::                   ポイントは今何行目にあるか
* narrow Exercise::             ナローイングの練習問題

@code{car}, @code{cdr}, @code{cons}：基本関数

* Strange Names::               寄り道: 何故こんな名前がついているか
* car & cdr::                   リストの一部を取り出すための関数
* cons::                        リストの構成
* nthcdr::                      @code{cdr} を何回もよびだす
* setcar::                      リストの最初の要素の変更
* setcdr::                      リストの残りの要素の変更
* cons Exercise::               cons についての練習問題

@code{cons}

* length::                      リストの長さを知る

Cutting and Storing Text

* Storing Text::                テキストはリストの中に保存される
* zap-to-char::                 テキストをある文字まで削除する
* kill-region::                 リージョンの削除
* delete-region::               脱線: C で書かれた関数について
* defvar::                      変数に初期値を与える
* copy-region-as-kill::         テキストの複写の定義
* cons & search-fwd Review::    cons と search-forward の復習
* search Exercises::            検索についての練習問題

@code{zap-to-char}

* zap-to-char interactive::     三つの部分からなるインタラクティブ式
* zap-to-char body::            ちょっと復習
* search-forward::              文字列検索の仕方
* progn::                       関数 @code{progn} について
* Summing up zap-to-char::      @code{point} と @code{search-forward} を使う
* v-18-zap-to-char::            version 18 での実装

The Version 18 Implementation

* progn body::                  @code{progn} 式の本体部分

@code{copy-region-as-kill}

* copy-region-as-kill body::    @code{copy-region-as-kill} の本体部分

The Body of @code{copy-region-as-kill}

* kill-append function::        関数 @code{kill-append}
* copy-region-as-kill else-part::  @code{copy-region-as-kill} の else-part 

How Lists are Implemented

* List Exercise::               List についての練習問題

Yanking Text Back

* Kill Ring Overview::          kill リングはリストである
* kill-ring-yank-pointer::      @code{kill-ring-yank-pointer} 変数について
* yank nthcdr Exercises::       ヤンクと nthcdr についての練習問題

Loops and Recursion

* while::                       特定のコードの繰り返し
* Recursion::                   再帰: 自分自身を呼び出す関数
* Looping exercise::            ループについての練習問題

@code{while}

* Loop Example::                リストを使った @code{while} ループ
* print-elements-of-list::      @code{while}, @code{car}, @code{cdr} の利用
* Incrementing Loop::           増加するカウンタを使ったループ
* Decrementing Loop::           減少するカウンタを使ったループ

A Loop with an Incrementing Counter

* Incrementing Example::        三角形に並んだ小石の数を数えてみる
* Inc Example parts::           関数定義はどんな部分からなるか
* Inc Example altogether::      関数を一つにまとめる

Loop with a Decrementing Counter

* Decrementing Example::        またまた浜辺の小石を数えてみる
* Dec Example parts::           関数定義はどんな部分からなるか
* Dec Example altogether::      関数を一つにまとめる

Recursion

* Recursion with list::         再帰のテストにリストを使う
* Recursive triangle function::  @code{while} ループを再帰で置き換える
* Recursion with cond::         別の条件分岐を用いた再帰の例

Recursion in Place of a Counter

* Recursive Example arg of 3::  引数が 3 の場合の再帰関数の動作

Regular Expression Searches

* sentence-end::                @code{sentence-end} の正規表現
* re-search-forward::           @code{search-forward} とほぼ同じ
* forward-sentence::            正規表現検索の単純な例
* forward-paragraph::           もうちょっと複雑な例
* etags::                       @file{TAGS} テーブルの作り方
* Regexp Review::               正規表現の復習
* re-search Exercises::         正規表現の練習問題

@code{forward-sentence}

* fwd-sentence while loops::    二つの @code{while} ループ
* fwd-sentence re-search::      正規表現検索

@code{forward-paragraph}: a Goldmine of Functions

* fwd-para let::                @code{let*} 式について
* fwd-para while::              前方に向かう場合の @code{while} ループ
* fwd-para between paragraphs::  パラグラフとパラグラフの間での動作
* fwd-para within paragraph::   パラグラフの内部での動作
* fwd-para no fill prefix::     fill prefix が無い場合
* fwd-para with fill prefix::   fill prefix が有る場合
* fwd-para summary::            @code{forward-paragraph} のまとめ

Counting: Repetition and Regexps

* Why Count Words::             Emacs には単語を数えるコマンドが欠けている
* count-words-region::          正規表現を使う。でも問題が...
* recursive-count-words::       リージョンに単語が一つも無い場合には
* Counting Exercise::           カウントに関する練習問題

The @code{count-words-region} Function

* Whitespace Bug::              @code{count-words-region} の空白についてのバグ

Counting Words in a @code{defun}

* Divide and Conquer::          遠大な計画は分割しよう
* Words and Symbols::           何を数えればよいか？
* Syntax::                      単語やシンボルは何から構成されているか
* count-words-in-defun::        @code{count-words} とほぼ同じ
* Several defuns::              一つのファイルにある複数の defun を数える
* Find a File::                 ファイルを見つける
* lengths-list-file::           沢山の定義の長さのリスト
* Several files::               異なるファイルの中の定義を数える
* Several files recursively::   異なるファイルの定義を再帰を使って数える
* Prepare the data::            データをグラフに表示するための準備

Count Words in @code{defuns} in Different Files

* append::                      あるリストを別のリストに追加する

Prepare the Data for Display in a Graph

* Sorting::                     リストをソートする
* Files List::                  ファイルのリストを作る

Readying a Graph

* Columns of a graph::          縦のグラフはどうやって表示すればよいか
* graph-body-print::            グラフ本体の表示
* recursive-graph-body-print::  グラフ本体の表示を再帰的に行う
* Printed Axes::                軸の表示
* Line Graph Exercise::         棒グラフについての練習問題

Your @file{.emacs} File

* Default Configuration::       Emacs のデフォルトは合理的である
* Site-wide Init::              サイトごとの初期化ファイルもある
* edit-options::                そのセッションでの変数の設定
* Beginning a Init File::       @code{.emacs file} の書き方
* Text and Auto-fill::          自動的に行を折り返す
* Mail Aliases::                Email の短縮アドレス
* Indent Tabs Mode::            @TeX{} ではタブを使わないようにするには
* Keybindings::                 個人的なキーバインディングを設定するには
* Loading Files::               ファイルを自動的にロード(評価)する
* Autoload::                    Autoload: 関数をすぐ使える状態に
* Simple Extension::            関数を定義し、キーにバインドする
* Keymaps::                     キーバインディングについて更に詳しく
* X11 Colors::                  Version 19 の X 上でのカラー表示
* V19 Miscellaneous::           ミニバッファを自動的なリサイズ etc.
* Mode Line::                   モード行のカスタマイズ

Debugging

* debug::                       組み込みデバッガの使い方
* debug-on-entry::              関数呼び出し時にデバッガを起動する
* debug-on-quit::               @kbd{C-g} を押した時にデバッガを起動する
* edebug::                      ソースレベルのデバッガ Edebug
* Debugging Exercises::         デバッグについての練習問題

Handling the Kill Ring

* rotate-yank-pointer::         リストの中でのポインタの移動と巡回
* yank::                        切り取ったテキストを貼り付ける
* yank-pop::                    ポインタが指しているテキストを貼り付ける

The @code{rotate-yank-pointer} Function

* rotate-yk-ptr body::          @code{rotate-yank-pointer} の本体

The Body of @code{rotate-yank-pointer}

* rotate-yk-ptr else-part::     @code{if} 式の else-part
* Remainder Function::          剰余関数 @code{%}
* rotate-yk-ptr remainder::     @code{rotate-yank-pointer} での @code{%} の利用
* kill-rng-yk-ptr last elt::    最後の要素を指している場合

@code{yank}

* rotate-yk-ptr arg::           @code{rotate-yank-pointer} に引数を渡す
* rotate-yk-ptr negative arg::  負の引数を渡す

A Graph with Labelled Axes

* Labelled Example::            最終的なグラフはどんな形になるか
* print-graph Varlist::         @code{print-graph} の中の @code{let} 式
* print-Y-axis::                縦軸のラベルの表示
* print-X-axis::                横軸のラベルの表示
* Print Whole Graph::           完全なグラフを表示する関数

The @code{print-Y-axis} Function

* Compute a Remainder::         割った余りの計算方法
* Y Axis Element::              Y 軸の各行の構成
* Y-axis-column::               Y 軸のラベルのリストの生成
* print-Y-axis Final::          縦軸の表示、最終版

The @code{print-X-axis} Function

* X Axis Tic Marks::            横軸に目盛記号を入れる

Printing the Whole Graph

* Test print-graph::            簡単なテスト
* Graphing words in defuns::    最終的なコードの実行
* Final Printed Graph::         これがグラフだ！

Graphing Numbers of Words and Symbols

* lambda::                      無名関数の書き方
* mapcar::                      要素のリストに関数を作用させる
* Another Bug::                 でもまだバグが潜んでいる @dots{}
@end menu

@iftex
@pageno = -9
@end iftex

@node     Preface, List Processing, Top, Top
@comment  node-name,  next,  previous,  up
@unnumbered 序文

GNU Emacs というエディタは大部分が Emacs Lisp と呼ばれるプログラミング言
語で書かれている。このプログラミング言語の中に書かれているコードは、計算
機がコマンドが与えられた時何をすべきかを教えるソフトウェア---命令の集ま
り---である。Emacs は、あなたが Emacs Lisp で新しいコードを書き、簡単に
拡張機能としてエディタに組み込むことが出来るよう設計されている。これが 
Emacs が「extensible editor (拡張可能エディタ)」と呼ばれる所以である。

(実際には、Emacs は通常エディタが出来ると思われている機能をはるかに上回
ることをやってのけるので、むしろ「extensible computing environment (拡
張可能計算機環境)」とでもいうべきだろう。まあ、ちょっと長ったらしいフレー 
ズになってしまうし、あなたが Emacs の中でする全てのこと---マヤ暦や月の満
ち欠けを調べたり、多項式を整理したり、コードをデバッグしたり、ファイルを
扱ったり、手紙を読んだり書いたりといったこと---はもっとも広い意味では編
集 (edit) の範疇に属するものではあるが。)

何はともあれ、Emacs Lisp はテキストエディタに関する言語と思われがちであ
るが、実際は計算機全体に関するプログラミング言語である。あなたはこの言語
を他のプログラミング言語と同じ様に使うことが出来るのだ。

多分、あなたはプログラミングを理解したいと思っていることだろう。あるいは、
Emacs の機能を拡張したいとか、プログラマになりたいと思っているかもしれな
い。

この Emacs Lisp についての文書は、その出発点を示すことを意図している。つ
まり、あなたをプログラミングの基本的な事柄に慣れさせ、更により大切なこと
だが、あなたが自分自身でより先に進むにはどうしたら良いかを示すことを目的
としている。

@menu
* On Reading this Text::        この文書を読むにあたって
* Who You Are::                 誰のために書かれたものか？
* Lisp History::                Lisp の歴史
* Note for Novices::            初心者の人へ
* Thank You::                   謝辞
* Translator Preface::          訳者まえがき
@end menu

@node On Reading this Text, Who You Are, Preface, Preface
@ifinfo
@heading このテキストを読むにあたって
@end ifinfo

この文書の中には、Emacs の中で走らせることの出来る小さなサンプルプログラ
ムが登場する。この文書を GNU Emacs の Info の中で読めば、そのプログラム
をその場で走らせることが出来る。(これは簡単に実行出来る。その方法はその
プログラムが出てきた時に説明する。) あるいは、この文書を印刷製本し Emacs 
が走っている計算機のそばに座りながら読むことだって出来る。(私はこの方法
が好きだ。私は印刷された本の方が好みなので。) たとえあなたの近くで Emacs 
が動いていなくても、この本を読むことは出来る。が、その場合はこれを小説か、
まだ行ったことのない国の旅行ガイドのように扱うのが良いだろう。面白いにし
ても実際とは違うものだ。

この文書の多くの部分は、GNU Emacs の中で使われるコードのガイドツアーとい
うべきことに費やされている。これらのツアーの目的は次の二つである。一つ目
は、あなたを実際に役立つコード (あなたが毎日使うコード) に親しませること。
二つ目は、あなたを Emacs を活用する方法に親しませることである。エディタ
がどのように実装されているかを見ることは面白いものである。また、私はあなた
がソースコードを眺める習慣を身に付けることを望んでいる。あなたはそこから
いろいろなこと学び、そしてアイディアを発掘することが出来る。GNU Emacs を
手に入れるということは、宝が隠されたドラゴンの洞窟を発見したようなものな
のである。

これらの例やガイドツアーを通して、エディタとしての Emacs を学んだり、プ
ログラミング言語としての Emacs Lisp を学習するだけでなく、Emacs が Lisp 
プログラミング環境であることを理解するきっかけが与えられることだろう。
GNU Emacs はプログラミングをサポートし、あなたが快適に使いこなしたくなる
ような様々な道具を与えてくれる。例えば @kbd{M-.} (@code{find-tag} コマン
ドを発生させるキー) なんかがそうだ。また、エディタ環境の一部であるバッファ
やその他のものを学べる。Emacs のこれらの特徴を学ぶことは、あなたが故郷に
帰る新しいルートを探すことに例えられよう。

@ignore
以上の他に、私は幾つかのプログラムを例として書き加えた。これらは例に過ぎ
ないが、プログラムは本物である。私はこのプログラムを使っているし、他の人
も利用している。あなたも使うことが出来る。
@end ignore

最後に、私はあなたがまだ知らないプログラミングの側面を学ぶために Emacs 
を利用して出来る幾つかのテクニックを伝えることが出来ればと思う。難解な事
柄を理解したり、何か新しいことをしたりする際、その解決方法にしばしば 
Emacs そのものを利用することが出来る。こういった自己完結性があることは、
単に気分が良いというだけでなく、実際に非常に便利なものである。

@node Who You Are, Lisp History, On Reading this Text, Preface
@comment  node-name,  next,  previous,  up
@unnumberedsec これは誰のために書かれたものか

@c (訳註：原題の "For whom this is written って、Hemigway の "For whom the
@c bell tolls." をもじってるんだろうか。)
この文書は、プログラマではない人々への、初歩的な入門書として書かれている。
もしあなたがプログラマであるなら、あなたはこのような簡単なものでは満足出
来まい。というのも、あなたは既にリファレンスマニュアルを読むのに熟達して
いるかもしれないし、その場合この文書のような書き方ではまどろっこしく感じ
るだろうからだ。

例えば、この文書を読んだある熟練したプログラマは、私に次のように言った。

@quotation
@i{僕は、リファレンスマニュアルから学ぶ方が好きなんだ。各々のパラグ
ラフに「ダイブして」そして各パラグラフの間で「息継ぎをする」感じだ。}

@i{僕はあるパラグラフの最後に辿り着いたら、その主題については終了したも
のと見倣すんだよ。つまり、(次のパラグラフでより詳しいことが説明されるよ
うな場合を除いて) 必要なことは全て分ったと考えるわけなんだ。だから無駄な
沢山の繰り返しがなくって、必要な情報が載っている個所へのポインタがきちん
と整備されているようなのがいいな。}
@end quotation

この入門書はこのような人のために書かれたのではない！

まず一つ目に、私は全てのことを少なくとも３回は繰り返すようにした。まずは
それを紹介し、次にそれがどんな場合に使われるかを見て、そして、別の使われ
方を見るか、それを復習するといった具合だ。

二つ目に、私はその主題についての全ての情報を一箇所にまとめるようなことは
殆どしなかった。ましてや、一つのパラグラフに押し込めるようなことは避けた。
これは個人的な考えだが、そういうやり方は読者に過剰な負担を強いることにな
る。その代わりに、私は各々の場合に必要なことだけを説明するように心がけた。
(時々は、後で正式に説明する時に戸惑うことのないよう、ちょっと先走った事
柄の説明も含めたりしたが。)

この文書を読む時は、あなたは全てのことを初めて学ぶものと考えられている。
取り上げられた幾つかの項目については、言わば、会えば会釈する程度の浅い付
き合いしかする必要がないものもある。あなたが本当に大切なことが何かに気付
き、それに集中することが出来るだけの十分なヒントを提供出来るように、この
文書をうまく構成出来ていればと思う。

あなたは、幾つかのパラグラフには「ダイブする」必要がある。それらには、別
のもっと楽な読み方があるわけではない。しかし、私はそのようなパラグラフの
数はなるべく押さえたつもりだ。この本は、そびえたつ山ではなく、ちゃんと登
ることができる丘であるように書かれている。

@iftex
この 『Emacs Lisp によるプログラミング』 ---初心者のための入門--- 
は次の本と兄弟関係にある。
@end iftex
@ifinfo
この @cite{Emacs Lisp によるプログラミング} ---初心者のための入門--- 
は次の本と兄弟関係にある。
@end ifinfo

@iftex
@cite{『The GNU Emacs Lisp Reference Manual』}. @footnote{日本語訳もある。
『GNU Emacs Lisp リファレンスマニュアル』Bil Lewis, Dan LaLiberte and
the GNU Manual Group 著、榎並嗣智 井田昌之監訳、発売 丸善、発行 透土社、
定価6796円、ISBN 4-924828-39-4}
@end iftex
@ifinfo
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}. 日本語訳もある。
透土社から出版されている。

@example
GNU Emacs Lisp リファレンスマニュアル
著 Bil Lewis, Dan LaLiberte and the GNU Manual Group.
監訳 榎並嗣智 井田昌之
発売 丸善
発行 透土社
定価 6796円(消費税含まず)
ISBN 4-924828-39-4
@end example
@end ifinfo

リファレンスマニュアルには、この入門書よりも詳しいことが載っている。また
リファレンスマニュアルでは、あるトピックについての全ての情報は一箇所に固
まっている。もしあなたが、上に挙げたプログラマのようなタイプなら、こっち
を読むべきだろう。また、勿論この入門書を読み終えた後、自分自身でプログラ
ミングをする場合には、リファレンスマニュアルがいろいろと便利であることが
納得出来るだろう。

@node Lisp History, Note for Novices, Who You Are, Preface
@unnumberedsec Lisp の歴史
@cindex Lisp history

Lisp は最初、1950年代の終わりに、マサチューセッツ工科大学で人工知能の研
究のために開発された。Lisp 言語が持つ素晴しい能力は、エディタのコマンド
を書くことは勿論のこと、他の目的についても優秀さを発揮した。 

@cindex Maclisp
@cindex Common Lisp
GNU Emacs Lisp は Maclisp の影響を多く受けている。Maclisp は1960年代に 
MIT で書かれた。Common Lisp の影響もいく分受けている。こちらは1980年代
に標準となった。しかしながら、Emacs Lisp は Common Lisp と比べて非常に単
純である。(標準的な Emacs の配布には、オプションとして @file{cl.el} が含
まれている。これは Emacs Lisp に多くの Common Lisp の機能を付け加えるた
めのものである。

@node Note for Novices, Thank You, Lisp History, Preface
@comment  node-name,  next,  previous,  up
@unnumberedsec 初心者の人へ

もしあなたが GNU Emacs について知らないとしても、この文書には何かしら役
に立つことが書かれているだろう。しかしながら、たとえ、コンピュータのスク
リーンの中を動き回るということだけでも良いから、Emacs を学ぶことを薦める。
あなたはオンラインのチュートリアルを使って自分自身でその使い方を学べる。
そのためには、@kbd{C-h t} とタイプするだけでよい。(これは @key{CTRL} 
キーと @kbd{h} キーを同時に押して離し、次に、@kbd{t} キーを押して離すこ
とを意味する。) (訳註：Mule ならば、@kbd{C-h T} で日本語や韓国語、タイ語
のチュートリアルが行える。)

また、私はしばしば Emacs の標準的なコマンドを、そのコマンドを引き起こす
キーを書き、その後に、そのコマンドの名前を括弧でくくって書くことで示した
りする。例えば @kbd{M-C-¥} (@code{indent-region}) といった感じだ。(もし
望むなら、そのコマンドを引き起こすためにタイプするキーを交換することも出
来る。これは、@dfn{リバインディング} (@dfn{rebinding}) と呼ばれる。
@ref{Keymaps, , キーマップ}, 参照)。この @kbd{M-C-¥} という省略形は、
@key{META} キーと @key{CTRL} キーと @key{¥} キーを同時にタイプすることを
示している。このような組み合わせはよくキーコードと呼ばれる。理由は、ピア
ノでコードを弾くのに似ているからである。もし、キーボードに @key{META} キー
が無ければ、@key{ESC} キーがその代わりになる。この場合は、@kbd{M-C-¥} は、
まず @key{ESC} を押して離し、ついで、@key{CTRL} と @key{¥} を同時にタイ
プすることを意味する。

もし、この文書を GNU Emacs の Info を使って読んでいるなら、この文書全て
をただ単にスペースバー、@key{SPC} を押し続けることで読んでしまうことが
出来る。(Info について学ぶには、@kbd{C-h i} とタイプし、ついで Info を選
択すれば良い。)

言葉の使い方についての注意だが、私が単独で Lisp という単語を使う場合は、
大概、Lisp の様々な方言にも通用する、一般的な事柄を述べている。しかし、
Emacs Lisp と言うときは特に GNU Emacs Lisp のことを言及している。

@node Thank You, Translator Preface, Note for Novices, Preface
@comment  node-name,  next,  previous,  up
@unnumberedsec 謝辞

執筆に際し助けて頂いた全ての人々に感謝します。特に、@r{Jim Blandy},
@r{Noah Friedman}, @w{Jim Kingdon}, @r{Roland McGrath}, @w{Frank
Ritter}, @w{Randy Simith}, @w{Richard M.@:Stallman}, そして、@w{Melissa
Weisshaus} に感謝します。また、@w{Philip Johnson} と @w{David Stampe} の
忍耐強い励ましにも感謝します。この文書の間違いは、全て私の責任です。

@node Translator Preface, , Thank You, Preface
@comment  node-name,  next,  previous,  up
@unnumberedsec 訳者まえがき

この文書は Robert J. Chassell 氏の『Programming in Emacs Lisp: A simple 
introduction』を訳したものです。個人用の訳なので拙い所も多く、また形式上
もあまりしっかりしてはいません。が、一応実用には耐えられるのではないかと
判断しています。また、訳者の実力不足のために訳に間違い等が含まれていると
思われますが、お気付きの方は連絡していただけると嬉しく思います。

また、@w{飯田義朗様}、@w{木村浩一様}、@w{幸田薫様}、@w{本田博通様}、
@w{山下健司様}には、以前の版での誤り、不具合等について指摘して頂きました。
この場をかりて深く感謝いたします。

@c ================ Beginning of main text ================

@tex
¥par¥vfill¥supereject
¥headings off
¥ifodd¥pageno 
    ¥par¥vfill¥supereject
¥else
    ¥par¥vfill¥supereject
    ¥page¥hbox{}¥page
    ¥par¥vfill¥supereject
¥fi
@end tex

@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@pageno = 1
@end iftex

@node List Processing, Practicing Evaluation, Preface, Top
@comment  node-name,  next,  previous,  up
@chapter List 処理

訓練を受けてない人にとっては、Lisp は奇妙なプログラミング言語である。
Lisp のコードの中には到る所に括弧が見受けられる。中には、Lisp と言う名前
は、`Lots of Isolated Silly Parentheses' を表わしているのだとほざく人ま
でいる。しかし、これは根拠のない主張である。Lisp は LISt Processing を表
わし、@emph{リスト} (や、リストのリスト) を両側を括弧で狭んで扱うプログ
ラミング言語である。括弧は、リストの境界を示している。時々、リストの頭に
アポストロフィ、即ち引用符 @samp{'} が付いていたりすることもある。リスト
は Lisp の基礎である。

@menu
* Lisp Lists::                  リストってなあに？
* Run a Program::               Lisp のリストはすぐに実行出来る
* Making Errors::               エラーを発生させる
* Names & Definitions::         シンボルや関数定義の名前
* Lisp Interpreter::            Lisp インタプリタの動作
* Evaluation::                  プログラムの実行
* Variables::                   変数の値を知る
* Arguments::                   引数：関数に情報を与えるもの
* set & setq::                  変数に値を設定する
* Summary::                     大切なポイント
* Error Message Exercises::     エラーメッセージについての練習問題
@end menu

@node Lisp Lists, Run a Program, List Processing, List Processing
@comment  node-name,  next,  previous,  up
@section Lisp のリスト
@cindex Lisp Lists

Lisp の中では、リストは @code{'(rose violet daisy buttercup)} という格好
をしている。このリストの頭には一つのアポストロフィが付いている。これは、
よりあなたが親しんでいるであろう次のような形のリストに書くことも出来る。
 
@example
@group
'(rose 
  violet 
  daisy 
  buttercup)
@end group
@end example

@noindent
このリストの要素は四つの異なる花の名前であり、各々が空白で区切られ、
括弧に囲まれている。これは石の壁に囲まれた広場の花を連想させる。
@cindex Flowers in a field

リストはまた、要素として数値を持つことも出来る。例えば、@code{(+ 2 2)} 
なんかがそうだ。このリストはプラスの符号 @samp{+} とその後に続く二つの 
@samp{2} を持っていて、各々は空白で区切られている。 
 
Lisp の中では、データとプログラムの両方が同じ様に表現される。つまり、こ
れらは共に、空白で区切られ括弧で囲まれた単語や数値や他のリストからなるリ
ストである。(プログラムがデータと似ているために、あるプログラムは容易に
他のプログラムのデータとして役に立つ; これが Lisp の極めて強力な特徴の一
つである.) (ついでに言っておくと、この直前の括弧で囲まれた補足は Lisp の
リストでは@emph{ない}。というのも、これらは @samp{;} と @samp{.} という
句読点を中に含んでいるからだ。)
 
@noindent
(訳註：日本語としては変かもしれないが、つじつまを合わせるために @samp{;} 
と @samp{.} を使った。)
 
ここで別のリストの例を挙げよう。今度は中にリストを含んでいる。
 
@example
'(this list has (a list inside of it))
@end example

このリストの構成要素は、@samp{this}, @samp{list}, @samp{has}, という単語
と、@samp{(a list inside of it)} というリストである。内部にある方のリス
トは、@samp{a}, @samp{list}, @samp{inside}, @samp{of}, @samp{it} という
単語からなっている。

@menu
* Lisp Atoms::                  分解不可能な存在
* Whitespace in Lists::         リストを読みやすいよう整形する
* Typing Lists::                GNU Emacs がリストのタイプを助けてくれる
@end menu

@node Lisp Atoms, Whitespace in Lists, Lisp Lists, Lisp Lists
@comment  node-name,  next,  previous,  up
@subsection Lisp のアトム
@cindex Lisp Atoms

Lisp の中では、今まで単語と呼んで来たものは、@dfn{atom} (@dfn{アトム}) と
呼ばれる。この言葉は歴史的には「これ以上分解出来ない」という意味を表わす
単語アトムから来ている。Lisp について話している限りは、我々がリストの中
で使ってきた単語は、それ以上小さなプログラムのパートには分解出来ない。そ
れは数字や @samp{+} みたいな一つの文字からなる記号でも同じである。一方リ
ストは、アトムと違って幾つかの部分に分解することが出来る。(@ref{car cdr
& cons, , @code{car} @code{cdr} & @code{cons}：基本関数}, 参照。)
 
  リストの中では各々のアトムは互いに空白で区切られている。また括弧のすぐ
隣りに位置することが出来る。

@cindex @samp{null list} defined
技術的な言い方をすると、Lisp のリストとは、空白で区切られた、いくつかの
アトムないしは他のリスト、あるいはアトムと他のリストの両方を括弧でくくっ
たものである。中には一つしかアトムが無くても良いし、全く無くても良い。中
に何も入っていないリストというのは @code{()} であるが、これは@dfn{空リス
ト} (@dfn{null list}) と呼ばれる。空リストは同時にアトムでもリストでもあ
る唯一のものである。

@cindex Symbolic expressions, introduced
@cindex @samp{expression} defined
@cindex @samp{form} defined
アトムやリストを表示したものは、@dfn{symbolic-expression}, もしくはもっ
と簡単に@dfn{Ｓ式}と呼ばれる。@dfn{Expression} という単語自身は、表示さ
れた表現か、あるいは計算機の内部に保持されているアトムやリストのどちらか
を表わす。@dfn{Expression} という言葉はしばしば曖昧に用いられる。(また、
多くの本では@dfn{形式} (@dfn{form}) という言葉が expression の同意語とし
て使われている。)

@noindent
(訳註：この訳では以下、expression を式、ないしはＳ式と訳していることが多
い。)

ついでだが、我々の世界を構成しているアトム(原子)がそう名付けられたのは、
それらが分割不可能と考えられていた時のことである。しかしその後、物理で言
うアトムは分割不可能ではないことが発見された。物質は、一つのアトムかほぼ
同じサイズの二つの部分に分裂する。(訳註：意味不明。) 物理で言うアトムは
まだその本当の性質が解明されぬままに時期尚早にして名付けられてしまった。
Lisp の中では、ある種のアトム、例えば配列 (array) は、複数の部分に分解出
来る。しかし、そのメカニズムはリストを分解する時のメカニズムとは違う。リ
ストの操作に関する限り、リストの中のアトムは分解不可能である。

英語におけるのと同様、Lisp のアトムを構成する文字要素は、一つの単語とし
ての文字とは違う。例えば、南アメリカナマケモノ (South American sloth) を
表わす @samp{ai} は @samp{a} と @samp{i} という二つの単語とは全く異なる。
 
自然の中には沢山の種類のアトムがあるが、Lisp の中には数種類のアトムしか
ない。例えば、37、511、1729といった@dfn{数値} (@dfn{number})、そして@ 
@samp{+}、@samp{foo}、や @samp{forward-line} といった@dfn{シンボル}
(@dfn{symbol}) なんかである。今まで挙げたリストの例の中に出てきた単語は
全てシンボルである。普段の Lisp の会話では、アトムという単語はあまり使わ
れないが、それはプログラマは普通今使っているアトムがどの種類のアトムかを
より限定的にみようとしているからである。Lisp のプログラミングはもっぱら
リストの中のシンボル (と、ときどき数値) についてのものである。
@c (ついでに言うと、今出てきた三つの単語を括弧でくくったものはちゃんしたリ
@c ストである。何故なら、それはアトムからなり(今の場合はシンボルである)、空
@c 白で区切られ、括弧でくくられており、Lisp でないような句読点は含んでない
@c からである。) (訳註：これは、(と、ときどき数値) の原文 (and sometimes
@c numbers) のことについて言っている。)
 
それに加えて、二つの二重引用符で挟まれたテキストは---それが一つの文であ
ろうと、あるいはパラグラフであろうとも---アトムである。例を挙げておこう。
@cindex Text between double quotation marks

@example 
     '(this list includes "text between quotation marks.")
@end example

@cindex @samp{string} defined
@noindent 
Lisp では句読点が入っていようが空白があろうが、全ての二重引用符で囲まれ
た文は一つのアトムである。この種のアトムは @dfn{文字列} (@dfn{string}) 
と呼ばれ、計算機が人間が読める形でメッセージを出す用途等に使われる。文字
列は数値ともシンボルとも違う種類のアトムであり、異なる使い方をされる。

@node Whitespace in Lists, Typing Lists, Lisp Atoms, Lisp Lists
@comment  node-name,  next,  previous,  up
@subsection リストの中の空白
@cindex Whitespace in lists

@example
@group
'(this list
   looks like this)
@end group
@end example

@noindent
は、次のリストと全く同じである。

@example
'(this list looks like this)
@end example

どちらの例も、Lisp にとっては @samp{this}、@samp{list}、@samp{looks}、
@samp{like}、そして @samp{this} というシンボルがこの順番で並んでいる全く
同じリストである。

余分な空白と改行は、人間がよりリストを見やすいようにするために用いられて
いる。Lisp が表現を読み取る時は、全ての余分な空白を除いてしまう(ただし、
最低一個の空白は残している。そうでないとアトムとアトムの区切りが分らなく
なってしまう)。

奇妙に思えるかもしれないが、今まで見てきた例で殆どの Lisp のリストがカバー
されてしまう。Lisp における他の全てのリストは、多かれ少なかれ、これらの
例のどれかに似ている。まあ、もっと長くなったり、複雑になったりはするが。
簡単にまとめると、リストは括弧に挟まれ、文字列は二重引用符に挟まれ、シン
ボルとは単語のようなもので、数値とは数のようなものである。(ある場合には、
角括弧や、ドット、それに他の特別な文字が使われたりもする。しかし、それら
が無くても我々はかなり先まで進める。)

@node Typing Lists,  , Whitespace in Lists, Lisp Lists
@comment  node-name,  next,  previous,  up
@subsection GNU Emacs によるリストのタイプの支援
@cindex Help typing lists
@cindex Formatting help

もし、あなたが Lisp のＳ式を GNU Emacs の Lisp Interaction mode もしくは 
Emacs Lisp mode の中でタイプしているなら、幾つかのコマンドを使って、Lisp 
のＳ式を整形し読みやすいものにすることが出来る。例えば @key{TAB} キーを
押すと、カーソルがある行を自動的に適当な分だけインデントしてくれる。リー
ジョン内のコードをきちんとインデントしてくれるコマンドは、@kbd{M-C-¥} に
バインドされている。インデントは、あなたが、どの要素がどのリストに属して
いるか見やすいように---サブリストの要素がそれを含んでいるようなリストの
要素よりも深くインデントされるように---設計されている。

更に、あなたが括弧を閉じる時に、Emacs は一時的にその括弧にマッチする開き
括弧の位置にジャンプする。そうすることでどの括弧に対応するかを確かめるこ
とが出来る。これは大変便利である。というのも、あなたが Lisp でタイプする
全てのリストについて、開き括弧には必ず閉じ括弧がきちんと対応していなけれ
ばならないからである。(@ref{Major Modes, , Major Modes, emacs, The GNU
Emacs Manual}, に Emacs の mode のより詳しい説明が書かれている。)

@node Run a Program, Making Errors, Lisp Lists, List Processing
@comment  node-name,  next,  previous,  up
@section プログラムの実行
@cindex Run a program
@cindex Program, running one

@cindex @samp{evaluate} defined
Lisp におけるリストは、たとえどんなリストであってもそのまま走らせることが
出来る。実際に走らせてみると (Lisp の専門用語では @dfn{評価} 
(@dfn{evaluate}) するという)、計算機は次の３つのうちいずれかの動作をする。
まずは、そのリストをそのまま返すだけで何もしない、もしくは、あなたにエラー
メッセージを返す、あるいは、リストの先頭のシンボルをコマンドとして扱い、
なにがしかのことをする。(普通は勿論、最後の動作があなたの求めるものであ
ろう。)

以前のセクションで挙げた例の中での、リストの頭に付けた単独のアポストロフィ 
@code{'} は、@dfn{引用符}ないしは @dfn{クウォート} (@dfn{quote}) と呼ば
れる。これがリストの頭に付いている場合は、何も付いていない場合と異なり、
Lisp はこのリストについては何もしなくていいんだなと解釈する。しかし、リ
ストの頭に引用符が付いていない場合は、リストの最初の項が特別な意味を持つ。
つまり、これは計算機が従うべき命令になるのだ。(Lisp ではこれらの命令は 
@emph{関数} (@emph{function}) と呼ばれる。) 以前挙げた @code{(+ 2 2)} と
いうリストには頭に引用符は付いていないので、Lisp は @code{+} が残りのリ
ストに関する何らかの命令であると解釈する。この場合は、残りの数を加えると
いうものである。

もし、この文章を GNU Emacs の Info の中で読んでいるのなら、次のようにし
てこのようなリストを評価することが出来る。カーソルを次のリストの右側の括
弧のすぐ後に持ってきて、@kbd{C-x C-e} とタイプするのである。

@example
(+ 2 2)
@end example

@noindent
エコー領域に @code{4} が見えたはずだ。(専門用語では、このことを「リスト
を評価する」と言う。エコー領域というのはスクリーンの最下行のことであり、
テキストを表示ないしは「エコー」する。) さて、同じことを頭に引用符が付
いたリストでやってみよう。カーソルを下のリストのすぐ後に移動させ、
@kbd{C-x C-e} とタイプする。

@example
'(this is a quoted list)
@end example

@noindent
この場合はエコー領域に @code{(this is a quoted list)} という文が見えたは
ずだ。

@cindex Lisp interpreter, explained
@cindex Interpreter, Lisp, explained
いずれの場合にも、あなたはコマンドを GNU Emacs の @dfn{Lisp インタプリタ}
(@dfn{Lisp interpreter}) と呼ばれるプログラムに渡している。つまり、イン
タプリタにそのＳ式を評価しろという命令を与えているのだ。Lisp インタプリ
タという名前は、Ｓ式の意味を提供する---つまりそれを解釈する---という人間
の仕事を表わす単語から来ている。

リストの一部ではない、単独のアトム---括弧に囲まれていないもの---を評価す
ることも出来る。この場合も Lisp インタプリタは人間が読むことの出来るＳ式
から、計算機の内部の言語への翻訳をする。しかし、これについて議論する前に 
(@ref{Variables, , 変数}, 参照)、まず我々がエラーを犯した場合に Lisp イン
タプリタが何をするかを見ていこう。

@node Making Errors, Names & Definitions, Run a Program, List Processing
@comment  node-name,  next,  previous,  up
@section エラーメッセージの出力
@cindex Generate an error message
@cindex Error message generation


まず、Lisp インタプリタがエラーメッセージを出すようなコマンドを与えてみ
よう。偶然このようなことをしてしまっても何も心配することはない。これは、
無害な操作である。実際、我々はしばしば意図的にエラーメッセージを出させる
ことがある。一旦専門用語を理解してしまえば、エラーメッセージから多くの情
報を得ることが出来る。そういう意味ではエラーメッセージと言うよりはヘルプ
メッセージと言うべきだろう。言わば他の国から来た旅行者にとっての道標のよ
うなものである。解読するのは大変だけれども、一度理解してしまえば正しい道
を教えてくれるというわけだ。

我々が行うのは、頭に引用符が付いていないにもかかわらず、先頭の要素が意味
あるコマンドでないようなリストを評価することである。ここに、我々がさっき
使ったリストとほぼ同じだが、頭に引用符が付いていないものがある。これの直
後にカーソルを持っていって、@kbd{C-x C-e} とタイプしてみよう。

@example
(this is an unquoted list)
@end example

@noindent
今回は次のようなメッセージがエコー領域に表示されたはずだ。

@example
Symbol's function definition is void:@: this
@end example

@noindent
(それと、端末がビープ音を鳴らしたかもしれない---鳴らすものもあるし、鳴ら
さないものもある。ランプが点滅したりするのもある。これは注意を引くための
装置である。) メッセージは他のキーをタイプするとすぐに消えてしまう。たと
えそれが単にカーソルを移動しただけであってもだ。

@cindex @samp{function} defined
我々が既に知っていることを基にして、このエラーメッセージをほぼ解読するこ
とが出来る。我々は @samp{シンボル} という単語の意味を知っている。今の場
合、リストの最初のアトムである単語 @samp{this} のことを指している。
@samp{関数} という単語は前に一度出て来た。これは極めて重要な単語である。
ここでは @dfn{関数} (@dfn{function}) とは計算機に何かやらせるための命令
の集まりである、とでも定義しておけば十分だろう。(技術的には、シンボルは
計算機に何処で命令を見つければよいかを教えていることになる。しかし、この
辺の事情は複雑だし、しばらくは無視して構わない。)

以上で、@samp{Symbol's function definition is void:@: this} というエラー
メッセージを理解することが出来るようになる。これは、シンボル (つまり、
@samp{this} という単語) には計算機が実行出来るような命令セットは定義され
ていないということである。

この、@samp{function definition is void} というちょっと奇妙なメッセージ
は Emacs Lisp の実装の仕方を表わすように書かれている。つまり、そのシンボ
ルに対して関数が定義されていない場合、命令が含まれているはずの場所が空@ 
(void) だというわけである。一方で、@code{(+ 2 2)} を評価した時にちゃんと
2に2を加えることが出来るということから、シンボル @code{+} は計算機が従う
べき命令セットを持っており、それらの命令は @code{+} に続く数を加えるとい
う物であるに違いないと推測出来る。

@node Names & Definitions, Lisp Interpreter, Making Errors, List Processing
@comment  node-name,  next,  previous,  up
@section シンボルの名前と関数定義
@cindex Symbol names

我々は今まで議論してきたことに基づいて、別の Lisp の特徴---それも極めて
大切な特徴---を述べることが出来る。即ち @code{+} のようなシンボルはそれ
自身は計算機が実行出来るような命令ではないということである。その代わりシ
ンボルは、多分、一時的に、命令の定義ないしは命令の集まりの位置を見つける
方法として使うことが出来る。我々に見えているのは、それを通して命令を見つ
けることの出来る名前なのである。人間の名前も同じ働きをする。私は 
@samp{Bob} として言及される。しかしながら、私は @samp{B}、@samp{o}、
@samp{b} という文字ではなく、一貫して特定の生命体に付随しているある意識
である。名前は私そのものではないが、私を示すのに使われる。

Lisp では、ある命令セットには幾つかの名前が付随している。例えば、数を
加えろという計算機の命令には、@code{+} というシンボルと同様、@code{plus} 
というシンボルも付随させることが出来る。(他の幾つかの Lisp の方言では実
際にそうなっている。) 人間の場合でも、私は @samp{Bob} だけではなく 
@samp{Robert} として呼ばれることもあるし、他の呼び方をされることもある。

一方で、一つのシンボルは、一度にただ一つの関数定義しか持つことが出来ない。
そうでないと、計算機がどの定義を使うべきか迷ってしまうからだ。仮にこれが
人間の場合であれば、@samp{Bob} という名前は世界で一人の人間にしかつけて
はいけないということである。ただし、名前に付随する関数定義は簡単に変更
することが出来る。(@ref{Install, , 関数定義のインストール}, 参照。)

Emacs Lisp はでかいので、関数が属する Emacs のパートが識別出来るようなシ
ンボルの名前を付け方をするのが普通である。というわけで、Texinfo を扱うため
の関数の名前は全て @samp{texinfo-} で始まっているし、メールを読むための 
(reading mail) 関数の名前は @samp{rmail-} で始まっている。

@node Lisp Interpreter, Evaluation, Names & Definitions, List Processing
@comment  node-name,  next,  previous,  up
@section Lisp インタプリタ
@cindex Lisp interpreter, what it does
@cindex Interpreter, what it does

これまでに見てきたことから、リストを評価するよう命令した時に Lisp インタ
プリタが何をするかを理解することが出来る。まずインタプリタは、list の頭
に、引用符が付いているか見る。もし付いていれば、単にそのリストを我々に渡
す。一方、付いていない場合はリストの先頭の要素を見に行き、それが関数の定
義を持っているかどうかを調べる。定義されている場合はその定義にある命令を
実行し、そうでなければエラーメッセージを表示する。

これが Lisp の動作である。単純だ。これに加えて若干複雑なこともある。それ
についてはすぐ後で説明するが、基本はこれだけである。勿論、Lisp のプログ
ラムを書く際には、関数の定義を書いたりそれに名前を付けるにはどうすればい
いか、あるいはそういうことをあなた自身や計算機が混乱しないように行うには
どうすればいいか等、他にも知らなければいけないことはあるが。

さて、さっき述べた「複雑なこと」の一つ目は、Lisp インタプリタは、リスト
に加えて引用符が付いておらず、括弧に囲まれてもいない単独のシンボルも評価
することが出来るということである。この場合、Lisp インタプリタはそのシン
ボルの値を@dfn{変数} (@dfn{variable}) として評価しようとする。このこと
については変数のセクションで説明することにする。(@ref{Variables, , 変数}, 
参照。)

@cindex Special form
複雑なことの二つ目は、幾つかの関数はその特殊性のために普通のやり方ではう
まく働かないことによる。このような関数は @dfn{特殊形式} (@dfn{special
form}) と呼ばれる。これらは、例えば関数を定義したりといった特別な用途を
持つ。次の幾つかのセクションでもっと大切な特殊形式を紹介するつもりだ。

三つ目の、そして最後の複雑なことはこうだ。もし現在 Lisp インタプリタが見
ている関数が特殊形式ではなく、しかもそれがリストの一部であるなら、Lispイ
ンタプリタはリストが内部にリストを含んでいないかどうかを見る。もし内部に
リストを含んでいれば、それがその内部でどういうことをするかを見る。そして、
その後にその外側のリストを処理する。また、もしその内部のリストが更に他の
リストを中に含んでいれば、まず、それを先に処理してからということになる。
即ち、Lisp インタプリタは常に一番内部のリストから処理していく。これは、
内部のリストの結果をそれを包む外側のＳ式で使う場合、内部のリストの結果が
どうなるかを見てから外側のリストを処理しなければいけないためである。

それ以外の場合は、インタプリタは左から右へＳ式を一つずつ処理していく。

@menu
* Byte Compiling::              実行速度を速めるための特殊なコード
@end menu

@node Byte Compiling,  , Lisp Interpreter, Lisp Interpreter
@subsection バイトコンパイル
@cindex Byte compiling

解釈の仕方について、もう一つ興味深いことがある。 Lisp インタプリタは二つ
の種類の物を解釈出来るということである。一つは人間が読めるコードであり、
我々は専らこれに焦点を当てている。もう一つは特別なプロセスコードであり、
これは@dfn{バイトコンパイル} (@dfn{byte compile}) されたコードで、人間に
読める代物ではない。バイトコンパイルされたコードは我々が読めるコードより
も速く走らせることが出来る。

人間が読めるコードをバイトコンパイルされたコードに変換することも出来る。
これは @code{byte-compile-file} 等の、コンパイルコマンドを走らせることに
よって行う。バイトコンパイルされたコードは普通、@file{.el} ではなく、
@file{.elc} という拡張子で終わるファイルに保存される。@file{emacs/lisp} 
などといったディレクトリィを覗けば、この両方の種類のファイルが見つかる。
我々が読むのは @file{.el} という拡張子の付いた方である。

実際問題として、あなたが Emacs をカスタマイズしたり拡張したりする場合に
は大抵はバイトコンパイルする必要はない。そして私もここではこの話題につい
ては述べない。@ref{Byte Compilation, , Byte Compilation, elisp, The GNU
Emacs Lisp Reference Manual}, を見ればバイトコンパイルについての全ての情
報が載っている。

@node Evaluation, Variables, Lisp Interpreter, List Processing
@comment  node-name,  next,  previous,  up
@section 評価
@cindex Evaluation

Lisp インタプリタがあるＳ式を処理している時、その動作は @dfn{評価} 
(@dfn{evaluation}) と呼ばれる。つまり、「インタプリタはＳ式を評価する」
のように言うわけだ。私はこの用語を以前にも何回か用いた。この単語はこの言
葉の日常会話での意味、@cite{Webster's New Collegiate Dictionary} (及び、
小学館 『プログレッシブ英和中辞典』) によれば「価値や量を確かめる、概算
する、見積もる」という意味、から来ている。

 Lisp インタプリタはＳ式を評価した後、大抵その関数の定義の中にある計算機
に対する命令を実行した時に出力する値を @dfn{返し} (@dfn{return})、そうで
ない場合は、おそらくその関数を処理するのを止めてエラーメッセージを出力す
る。(インタプリタは、急に別の関数を渡されることもあり得るし、あるいは、
いわゆる「無限ループ」に入って現在の処理を何回でも繰り返そうとするかもし
れない。が、これらの動作をすることはそれ程多くはないので、我々はこれらの
場合は無視することにする。) つまり殆どの場合、インタプリタは値を返す。

@cindex @samp{side effect} defined
インタプリタは値を返すと同時に、カーソルを動かしたり、ファイルをコピー
したりといった他の動作も行う。このような動作は、@dfn{副作用} 
(@dfn{side effect}) と呼ばれる。例えば結果を表示するとか、我々人間が重要
と考える動作もしばしば、Lisp インタプリタにとっては「副作用」でしかない。
この専門用語には異和感があるかもしれないが、副作用自体の使い方を学ぶのは
かなり簡単だということがその内分るだろう。

以上まとめると、Lisp インタプリタはＳ式を評価した時に、まず殆どの場合あ
る値を返し、大抵はある副作用を実行する。そして、そうでない場合はエラーを
出力する、ということになる。

@menu
* Evaluating Inner Lists::      リストの中のリスト...
@end menu

@node Evaluating Inner Lists,  , Evaluation, Evaluation
@comment  node-name,  next,  previous,  up
@subsection 内部のリストの評価
@cindex Inner list evaluation
@cindex Evaluating inner lists

もしあるリストの内部のリストが評価された場合、その外側のリストが評価され
る時には最初に内部のリストを評価した時に返った値を情報として使うことが出
来る。このことから、何故内部のリストが先に評価されるかが説明出来る。即ち、
内部のＳ式が返す値を外部のＳ式が用いるためである。

我々はこのプロセスを次のような例で実際に確かめることが出来る。次の式の直後
にカーソルを持っていき、@kbd{C-x C-e} とタイプしてみよう。

@example
(+ 2 (+ 3 3))
@end example

@noindent
数字の8がエコー領域に表示されたはずだ。

この例で起こったことはこうだ。まず Lisp インタプリタは内部のＳ式である 
@code{(+ 3 3)} を評価する。それに対して値6が返される。それによって外部
のＳ式があたかも @code{(+ 2 6)} であるように評価され、値8を返すことにな
る。これらを内部に含む評価すべきＳ式はこれ以上存在しないので、インタプ
リタはこの値をエコー領域に表示する。

さて、ここまでくれば @kbd{C-x C-e} で引き起こされるコマンドの名前を理解
することは簡単だ。このコマンドの名前は @code{eval-last-sexp} となってい
る。この中の @code{sexp} という文字は `symbolic expression' (Ｓ式) の略
である。ということで、これは直前のＳ式を評価する (evaluate last symbolic
expression) ことを表している。

実験的に、次に挙げる例のＳ式の直後の行の先頭やＳ式の内部にカーソルを持っ 
ていってＳ式を評価してみることも出来る。

これがその例である。

@example
(+ 2 (+ 3 3))
@end example

@noindent
もしカーソルをＳ式の直後の空行の先頭に置いて @kbd{C-x C-e} とタイプした
なら、その場合もやはり8がエコー領域に表示されることだろう。では次に、
カーソルをＳ式の内部に持っていこう。最後の括弧のすぐ右側の括弧の後にカー
ソルを持っていって (つまりカーソルは最後の括弧の上に見えている) そこで評
価したならば、エコー領域には6と表示される。これはコマンドが @code{(+ 3
3)} という式を評価したからである。

今度はカーソルを数字の直後に持っていこう。@kbd{C-x C-e} とするとその数字
そのものが返される。Lisp の中では、数字を評価した場合、その値自身が返さ
れる。これが数字がシンボルと違うところである。もし @code{+} みたいなシン
ボルを先頭に持つリストの直後でＳ式を評価したなら、返された値はその名前に
付随する関数の定義の中の命令を計算機が実行した結果が返ってくる。が、もし
シンボルそのものが評価されたなら別のことが起きる。これについては次のセク
ションで見ることにしよう。

@node Variables, Arguments, Evaluation, List Processing
@comment  node-name,  next,  previous,  up
@section 変数
@cindex Variables

Lisp の中では、シンボルは、関数定義を持つことが出来るのと同様に、ある値
を持つことが出来る。これら二つは全く別の物である。関数定義は計算機が従う
べき命令の集まりであるのに対し、値は数値とか名前のように、何か変化し得る
ものである。(このようなシンボルが変数と呼ばれるのはこのためである。) ど
んな Lisp のＳ式もシンボルの値になり得る。例えばシンボルや数値、リスト、
文字列なんかが値となることが出来る。値としてのシンボルはしばしば@dfn{変
数} (@dfn{variable}) と呼ばれる。

シンボルは、関数定義と値の両方を同時に持つことが出来る。この二つは分離さ
れているのだ。これは、ケンブリッジという名前がマサチューセッツの中のある
都市そのものを表わすのと同様に、その都市名に付随するなんらかの情報、例え
ば、「大きなプログラミングセンター」であるといった情報をも持ち得るのと似
ている。

@ignore
(結果として Emacs Lisp の中ではシンボルには更に別の二つの物が付随し得る
ことになる。property list と documentation string である。これらについて
は後で説明することにする。) 
@end ignore

このことを理解するもう一つの考え方を述べよう。それはシンボルを整理棚であ
ると見倣す方法である。関数定義はその引き出しの一つに入っており、値はまた
別の引き出しに入っている... という具合である。値の入っている引き出しの中
身は同じ棚の関数定義の入っている引き出しの中身に影響を与えることなく変え
ることが可能だし、逆も同様である。

変数 @code{fill-column} を例にとって、値を持つシンボルというものを説明し
てみよう。GNU Emacs の全てのバッファにおいて、このシンボルはある値にセッ
トされている。大抵は72か70であるが、他の値を持つこともある。この値が何か
を見るにはこのシンボル自身を評価してみれば良い。もしこの文章を GNU Emacs 
の Info で読んでいるなら、カーソルを次のシンボルの直後に持っていって 
@kbd{C-x C-e} とタイプするだけである。

@example
fill-column
@end example

@noindent
私が今 @kbd{C-x C-e} とタイプしてみたところ、Emacs はエコー領域に72と表
示した。これが、私がこの文章を書いている時に @code{fill-column} にセット
されている値である。あなたの Info のバッファではまた別の値が設定されてい
るかもしれない。変数として評価されて返す値は、ある関数が命令を実行した時
に値を返す時と全く同じように表示されることに注意しよう。Lisp インタプリ
タの立場からすると、どちらも返り値であることに違いはない。どんな種類のＳ
式から来ているかということは一旦その値が分ってしまえば重要ではないのだ。

シンボルはどんな値も持つことが出来る。あるいは専門用語を使っていうなら我々
は変数に72といった数値や @code{"such as this"} といった文字列や、
@code{(spruce pine oak)} を@dfn{バインド} (@dfn{bind}) (束縛とも言う) す
ることが出来る。変数に関数定義をバインドすることすら可能である。

シンボルに値を設定するには幾つか方法がある。その方法の一つについては、
@ref{set & setq, , 変数の値の設定}, を参照のこと。

@code{fill-column} という単語には周りに括弧がついていないことに注意しよ
う。これは我々がこのシンボルを関数の名前としては使わなかったためである。
@code{fill-column} がリストの最初、もしくは唯一の要素であった場合、Lisp
インタプリタはこれに付随する関数定義を見つけようとする。しかし、
@code{fill-column} は関数定義を持ってはいない。例えば次を評価してみよう。 

@example
(fill-column)
@end example

@noindent
@example
@group
@exdent すると次のようなエラーメッセージが出るはずだ。

Symbol's function definition is void:@: fill-column
@end group
@end example

@menu
* Void Variable::               値のないシンボルに対するエラーメッセージ
@end menu

@node Void Variable,  , Variables, Variables
@comment  node-name,  next,  previous,  up
@subsection 値のないシンボルに対するエラーメッセージ
@cindex Symbol without value error
@cindex Error for symbol without value

もし、値を持たないシンボルを評価しようとしたなら、エラーメッセージが返さ
れるはずだ。2に2を加える例で実験してみよう。次のＳ式のなかで最初の2の直
前にある @code{+} の直後にカーソルを持っていって @kbd{C-x C-e} とタイプ
してみよう。

@example
(+ 2 2)
@end example

@noindent
次のようなエラーメッセージを受けとるはずだ。

@example
Symbol's value as variable is void:@: +
@end example

@noindent
これは我々が見た最初のエラーメッセージとは違っている。さっきは 
@samp{Symbol's function definition is void:@: this} (シンボルの関数定義
が空です:@: this) というものだった。今回のケースではシンボルは変数として
の値を持っておらず、もう一方のケースではシンボル (@samp{this} という単語) 
は関数定義を持たなかった。

この @code{+} を使った実験の中でやったことは Lisp インタプリタに @code{+} を
評価させ、関数定義では無く変数の値を探させることである。そのためにカーソ
ルを前のようにリストを囲む括弧の後では無く、シンボルのすぐ右隣に持っていっ
たのだった。結果として Lisp インタプリタは直前のＳ式、この場合は @code{+} そ
のもの、を評価したのだ。 

@code{+} は関数定義は持っていても値は持ってはいないので、エラーメッセー
ジはシンボルの変数としての値が空だよと報告したのである。

@node Arguments, set & setq, Variables, List Processing
@comment  node-name,  next,  previous,  up
@section 引数
@cindex Arguments
@cindex Passing information to functions

どうしたら情報が関数に渡されるかを見るために、これまで何回か使ってきた2
に2を足す例をもう一度見てみよう。

@example
(+ 2 2)
@end example

もしこのＳ式を評価したなら数字の4がエコー領域に表示される。Lisp インタプ
リタがやったことは @code{+} の後に続く数字を加えることである。

@cindex @samp{argument} defined

@code{+} によって加えられた数字は関数 @code{+} の @dfn{引数}
(@dfn{argument}) と呼ばれる。これらの数字は関数に与えられる、もしくは
@dfn{渡される} (@dfn{pass} される) 情報である。

「argument」という単語は数学での用法から来ているもので、二人の人が議論す
るという意味ではない。そうではなく関数、今の場合でいうと @code{+} という
関数、に与えられる情報のことを指している。Lisp の中では関数に対する引数
は関数に続くアトムもしくはリストである。これらのアトムやリストを評価して
返された値が関数に渡されることになる。異なる関数は異なる数の引数を取り得
る。全く引数を取らない関数もある。@footnote{「argument」という単語が二つ
の異なる意味を持つようになった経緯を追ってみるのは、結構興味深いことであ
る。一つは数学での意味であり、もう一つは日常使われている英語での意味であ
る。@code{Oxford English Dictionary} によると、この単語は @samp{to make
clear, prove} (@samp{明確にする、証明する}) という意味のラテン語から来て
いるということだ。その結果、一方では「証明として与えられる証拠」から「与
えられた情報」という意味になり、それが Lisp での意味の方に派生していった。
しかし、もう一方では「他人が主張するのと対立するような主張をする」という
意味に派生し、それが議論することを表わす単語の意味になっていった。(ここ
でこの英単語が同時に二つの異なる定義を持っていることに注意しよう。これに
対して Emacs Lisp では、シンボルは同時に二つの関数定義を持つことは出来な
い。)}

@menu
* Data types::                  関数に渡されるデータの型
* Args as Variable or List::    引数には変数の値やリストも使える
* Variable Number of Arguments::  関数の中には、可変な数の引数を扱える
                                ものもある
* Wrong Type of Argument::      関数に間違った型の引数を与えると
* message::                     メッセージを表示する時に便利な関数
@end menu

@node Data types, Args as Variable or List, Arguments, Arguments
@comment  node-name,  next,  previous,  up
@subsection 引数のデータ型
@cindex Data types
@cindex Types of data
@cindex Arguments' data types

関数に渡されるデータの型はその関数がどんな種類の情報を必要としているかに
よる。@code{+} のような関数の引数は数値でなければならない。というのも 
@code{+} は数値を加える命令だからである。他の関数は引数として他の種類の
データを取る。

@findex concat
例えば、@code{concat} という関数は二つ以上のテキストの文字列を連結な
いしは合成して一つの文字列を作る。この場合の引数は文字列である。 
二つの文字文字列 @code{abc}, @code{def} を連結 (concatenate) すると、
@code{abcdef} という一つの文字列が出来る。これは次の例で確かめられる。

@example
(concat "abc" "def")
@end example

@noindent
このＳ式を評価すると @code{"abcdef"} という値が返される。

@code{substring} のような関数は引数として文字列と数値の両方を取る。これ
は文字列である最初の引数の部分文字列を返す関数である。引数の数値は
３つである。最初の引数は文字からなる文字列である。二番目と三番目の引
数は部分文字列の初めと終りの場所を示す数値であり、文字列の最初から
の(スペースや句読点も含めた)文字数を指定する。

例えば次を評価してみよう。

@example
(substring "The quick brown fox jumped." 16 19)
@end example

@noindent
@code{substring} に渡される文字列は、たとえスペースで区切られた複数の単
語からなっていたとしても一つのアトムであることに注意しよう。Lisp は二つ
の二重引用符の間に狭まれる全てを空白も含めて文字列の一部と数える。
@code{substring} という関数は一種の「アトム粉砕機 (atom smasher)」だと見
倣すことが出来る。というのもこいつは他の方法では分離できないアトムを取り
込み、その一部を抽出するからである。しかしながら、@code{substring} は文
字列である引数から部分文字列を抽出することが出来るだけで、他の種類の例え
ば数値とかシンボルであるアトムについてはそのようなことは出来ない。

@node Args as Variable or List, Variable Number of Arguments, Data types, Arguments
@comment  node-name,  next,  previous,  up
@subsection 引数には変数の値やリストも使える

引数は評価された時に値を返すシンボルであることも可能だ。例えば 
@code{fill-column} というシンボルそれ自身が評価された場合には、数値が返
される。この数値は加法演算にも使える。次のＳ式の後にカーソルを持っていっ
て @kbd{C-x C-e} とタイプしてみよう。

@example
(+ 2 fill-column)
@end example

@noindent
返される値は @code{fill-column} を単独で評価した場合に得られる数に2を加
えたものになるはずだ。私には74が返される。何故なら @code{fill-column} の
値が72であるからだ。

たった今見た様に、引数は評価された時に値を返すシンボルであり得る。それに
加えて、引数は評価された時に値を返すリストでもあっても良い。例えば次のＳ
式の中では関数 @code{concat} の引数は @w{@code{"The "}}, @w{@code{"red
foxes."}} そしてリスト @code{(+ 2 fill-column)} である。

@example
(concat "The " (+ 2 fill-column) " red foxes.")
@end example

@noindent
もしこのＳ式を評価したならエコー領域には @code{"The 74 red foxes."} が表
示されるはずだ。(最後の文字列を表示させるには @samp{The} という単語
の後と @samp{red} という単語の前に空白を入れなければならないことに注意。) 
(訳註：74の所は勿論場合に応じて変わる。)

@node Variable Number of Arguments, Wrong Type of Argument, Args as Variable or List, Arguments
@comment  node-name,  next,  previous,  up
@subsection 可変な数の引数
@cindex Variable number of arguments
@cindex Arguments, variable number of

例えば @code{concat}, @code{+}, @code{*} といった幾つかの関数では引数の
数は固定されていない。(@code{*} は乗法を表わすシンボルである。) これは次
に挙げる各々のＳ式を評価してみると分る。エコー領域に表示されるべき結果は
このテキストの中の @samp{@result{}} の後に書かれている。これは「を評価し
た結果は」と読み換えられる。

@need 1250
最初は引数がない場合である。

@example
@group
(+)       @result{} 0

(*)       @result{} 1
@end group
@end example

@need 1250
こちらは一つだけ引数を持っている。

@example
@group
(+ 3)     @result{} 3

(* 3)     @result{} 3
@end group
@end example

@need 1250
次では、各々三つずつ引数を持っている。

@example
@group
(+ 3 4 5) @result{} 12

(* 3 4 5) @result{} 60
@end group
@end example

@node Wrong Type of Argument, message, Variable Number of Arguments, Arguments
@comment  node-name,  next,  previous,  up
@subsection 関数に間違った型の引数を与えると
@cindex Wrong type of argument
@cindex Argument, wrong type of

ある関数に間違った型の引数が与えられると、Lisp インタプリタはエラーメッ
セージを返す。例えば、@code{+} という関数は引数の値として数値を要求する。
実験的に、これに数値ではなく @code{hello} というシンボルを与えてみよう。
次のＳ式の後にカーソルを持っていって @kbd{C-x C-e} とタイプしてみよう。

@example
(+ 2 'hello)
@end example

@noindent
そうするとエラーメッセージが表示される。この場合に起きたことはこうだ。
@code{+} は2に @code{'hello} を評価して返される値を加えようとした。しか
し返された値は @code{hello} というシンボルであり数値ではない。だが数値で
ないものを足すことは出来ない。そのために、@code{+} は加算を実行すること
が出来なかったのである。

普通、エラーメッセージは助けになるように、つまりあなたが一度読み方を修得
した後は意味が分るようなものであろうとする。この場合は

@example
Wrong type argument:@: number-or-marker-p, hello
@end example

@noindent
と言ってくる。(訳註：Emacs version 18 では @code{integer-or-marker-p} で
ある。Emacs version 19 からは浮動小数点数も扱うようになった。) エラーメッ
セージの最初の部分は極めて直接的だ。@samp{Wrong type argument} (引数の型
が違う) である。次に来るのはミステリアスな専門用語 
@w{@samp{number-or-marker-p}} である。この言葉はあなたに @code{+} という
関数が要求する引数のタイプを教えようとしている。

@code{number-or-marker-p} というシンボルの名前は、Lisp インタプリタが与
えられた情報 (引数の値) が数値 (number) もしくはマーカ (marker) (バッファ
での位置を表わす特殊なオブジェクト) であるかどうかを判定することを意味し
ている。今の場合、実際に行うのは @code{+} にちゃんと加えるべき整数が与え
られたかどうかのテストである。そして、マーカと呼ばれる特殊オブジェクトか
どうかもテストされる。これは Emacs Lisp 固有のものである。(Emacs の中で
はバッファ内での位置がマーカとして記録される。@kbd{C-@@} あるいは 
@kbd{C-@key{SPC}} というコマンドによってマークがセットされるとその位置が 
マーカとして保持されるのである。このマークは数---バッファの始まりからそ
の位置までの文字数---と考えることが出来る。) Emacs Lisp では @code{+} は
マーカの位置を示す数を数値として加えるのにも使うことが出来るわけである。

@code{number-or-marker-p} の中の @samp{p} は Lisp プログラミングの初期の
頃に始まったある試みの具体化である。@samp{p} は「述語 (predicate)」を表
わしている。初期の Lisp 研究者の間で用いられていた専門用語では「述語」は
ある属性が正しいかどうかを判定する関数のことを指していた。従って、
@samp{p}は @code{number-or-marker-p} が、与えられた引数が数値 (number) 
もしくは マーカであるかどうかを判定する関数の名前であることを意味してい
る。他の Lisp のシンボルで @samp{p} で終わるものに @code{zerop} がある。
これは引数が0という値であるかどうかを判定する関数である。同様に@ 
@code{listp} は引数がリストかどうかを判定する関数である。

さて、いよいよエラーメッセージの最後の部分 @code{hello} であるが、これ
は @code{+} に渡された引数の値である。もし加法演算に正しい型のオブジェク
トが与えられていたとするなら、渡される値は @code{hello} のようなシンボル
ではなく、例えば37のような数値であったはずである。もっとも、その場合は、
エラーメッセージは出ないけれども。

@node message,  , Wrong Type of Argument, Arguments
@comment  node-name,  next,  previous,  up
@subsection 関数 @code{message}
@findex message

@code{+} と同様、@code{message} という関数も引数の数は固定されていない。
この関数はユーザにメッセージを送るものだが、今説明したように、いろいろと
役に立つものである。

メッセージはエコー領域に表示される。例えば次のリストを評価することで、あ
なたのエコー領域にメッセージを表示させてみよう。

@example
(message "This message appears in the echo area!")
@end example

二重引用符に狭まれた文字列全体が一つの引数になっており、その全体が表示さ
れる。(この例ではメッセージそれ自身が二重引用符の中に入っていることに注
意しよう。これは、@code{message} という関数が返す値そのものがそうなって
いるからである。あなたが書くプログラムの中での普通の @code{message} の使
い方ではエコー領域に表示されるのは副作用によるものである。それには、二重
引用符は付いていない。このような例については @ref{multiply-by-seven in
detail, , インタラクティブな @code{multiply-by-seven}}, を参照のこと。)

しかしながら、もし @samp{%s} が二重引用符に挟まれた文字文字列に入ってい
たとしたら、関数 @code{message} は @samp{%s} をそのまま表示したりはせず
に、文字列に続く引数を見にいく。まずは二番目の引数を評価し、その結果を 
@samp{%s} のある所に代入して表示する。

次のＳ式の最後にカーソルを持っていって @kbd{C-x C-e} とタイプしてみるこ
とで、このことが確かめられる。

@example
(message "The name of this buffer is: %s." (buffer-name))
@end example

@noindent
Info の中では、@code{"The name of this buffer is: *info*."} という文がエ
コー領域に表示されたことだろう。@code{buffer-name} という関数は現在のバッ
ファ名を文字列として返す。@code{message} はそれを @code{%s} の位置に挿入
したのだ。

値を10進数として表示するには、@samp{%s} の代わりに @samp{%d} という関数
を同じように使う。例えば、現在の @code{fill-column} の値をエコー領域に表
示させるには次を評価すれば良い。

@example
(message "The value of fill-column is %d." fill-column)
@end example

@noindent
私の使っているシステムでは、このリストを評価した時点ではエコー領域には 
@code{"The value of fill-column is 72."} と表示された。

もし一つ以上の @samp{%s} が二重引用符で狭まれた文字列の中にあったとする
と、最初の @samp{%s} の位置にはその文字列に続く最初の引数の値が表示され、
二番目の @samp{%s} の位置には二番目の引数の値が表示され... という具合に
なる。例として次を評価してみよう。

@example
@group
(message "There are %d %s in the office!"
         (- fill-column 14) "pink elephants")
@end group
@end example

@noindent
かなり風変わりなメッセージが表示されたことと思う。私のシステムでは、
@code{"There are 58 pink elephants in the office!"}。のように表示された。

ここでは @code{(- fill-column 14)} というＳ式が評価され、その結果として
返された値が @samp{%d} の位置に挿入される。そして二重引用符で狭まれた 
@code{"pink elephants"} という文字列が一つの引数として扱われて、
@samp{%s} の位置に置かれる。 (つまり、二重引用符で挟まれた文字列は、評価
された時に、数値と同じ様にそれ自身を値として返すわけである。)

最後に、単なる数の計算ではなく、Ｓ式の中にＳ式を置き、@samp{%s} で置き換
えることで文章を作る例として、ちょっと複雑なものを挙げておこう。

@example
@group
(message "He saw %d %s"
         (- fill-column 34)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
@end group
@end example

この例では、@code{message} は３つの引数を取る。@code{"He saw %d %s"} と
いう文字列と、@code{(- fill-column 32)} というＳ式と、@code{concat} とい
う関数で始まるＳ式である。@code{(- fill-column 32)} を評価して得られた結
果は @samp{%d} の位置に挿入され、@code{concat} から始まるＳ式を評価して
返される値は @samp{%s} の位置に挿入される。

私がこの式を評価したところ、エコー領域には @code{"He saw 38 red foxes
leaping."} というメッセージが表示された。

@noindent
(訳註：日本語の例も挙げておく。Mule の内部では2バイトコードは3バイトで表
現されるため一文字3ポイントの勘定になる。)

@example
@group
(message "彼は %d 匹の%sのを見た。"
         (- fill-column 34)
         (concat "赤い"
                 (substring
                  "すばしこい茶色のきつねが跳んだ。" 24 33)
                 "が飛び跳ねる"))
@end group
@end example

@node set & setq, Summary, Arguments, List Processing
@comment  node-name,  next,  previous,  up
@section 変数の値の設定
@cindex Variable, setting value 
@cindex Setting value of variable

@cindex @samp{bind} defined
変数に値を格納する方法は幾つかある。一つの方法は、@code{set} もしくは 
@code{setq} という関数を使うことである。また別の方法として、@code{let} 
を使うというのもある。(@ref{let}, 参照). (このプロセスのことを専門用語で
は、変数に値をバインド (束縛) すると言う。)

この後のセクションでは @code{set} と @code{setq} の働きを説明するだけで
はなく、引数の渡され方の様子も述べることにする。

@menu
* Using set::                   値の設定
* Using setq::                  引用符をつけずに値を設定するには
* Counting::                    カウンタとしての @code{setq} の利用
@end menu

@node Using set, Using setq, set & setq, set & setq
@comment  node-name,  next,  previous,  up
@subsection @code{set} の利用
@findex set

シンボル @code{flowers} の値としてリスト @code{'(rose violet daisy
buttercup)} をセットするために、次のＳ式の後にカーソルを持っていって
@kbd{C-x C-e} とタイプして、この式を評価してみよう。

@example
(set 'flowers '(rose violet daisy buttercup))
@end example

@noindent
すると @code{(rose violet daisy buttercup)} というリストがエコー領域に表
示されたはずだ。これは関数 @code{set} によって返された (@emph{return} さ
れた) 値である。その副作用としてシンボル @code{flowers} が、このリストに
バインドされる。つまり、シンボル @code{flowers} は、変数とみなすことが出
来て、その値がこのリストであるようになったということである。(因みにこの
プロセスは、値をセットするという Lisp インタプリタにとっては副作用でしか
ないことが、我々人間にとっては主効果たりうるということの説明になっている。
Lisp インタプリタはエラーが出ない限り必ず値を返すが、副作用の方は、
そのように意図しないと出ないものなのである。)

さっきの @code{set} を使ったＳ式を評価した後では、@code{flowers} という
シンボルを評価することが出来るようになっている。そして、たった今、我々が
セットした値を返す。実際に次のシンボルの後にカーソルを持っていって 
@kbd{C-x C-e} とタイプしてみよう。

@example
flowers
@end example

@noindent
@code{flowers} を評価すると、エコー領域にリスト @code{(rose violet daisy 
buttercup)} が現れたはずだ。

もし間違えて頭に引用符を付けた @code{'flowers} の方を評価したとすると、
エコー領域に現れるのはこのシンボル @code{flowers} それ自身になる。引用符
を付けたやつを次に挙げておくので、評価してみて欲しい。

@example
'flowers
@end example

もう一つ注意すべきことは、@code{set} を利用する時は、@code{set} の引数に
は、それらを評価しようとする場合を除いて、必ず引用符を付ける必要があると
いうことである。先の例の場合では、引数 @code{flowers} 及び @code{(rose
violet daisy buttercup)} のどちらも評価したくはなかったので、両方に引用
符を付けている。(@code{set} の一番目の引数に引用符を付けなかった場合、ま
ずまっ先にその引数が評価される。これを @code{flowers} に対してやったとし
て、もしこのシンボルがまだ値を持っていなかったとすると、@samp{Symbol's
value as variable is void} というエラーメッセージが表示される。一方、も
し @code{flowers} がある値を返したとすると、@code{set} はそいつにある値を
設定しようとする。勿論こうなるのが正しい動作である状況もあるが、そういう
ことは稀である。)

@node Using setq, Counting, Using set, set & setq
@comment  node-name,  next,  previous,  up
@subsection @code{setq} の利用
@findex setq

実際問題として、大抵の場合は第一引数には引用符をつけることになるだろう。
@code{set} と引用符付きの第一引数の組み合わせというのは極めてよく使われ
るために、それに対して名前がついている。それが特殊形式 @code{setq} であ
る。この特殊形式はほぼ @code{set} と同じなのだが、第一引数に自動的に引用
符を付けてくれる所だけが違う。従ってあなた自身で引用符を付ける必要はない。
また、そのことに加えて、@code{setq} には、一つのＳ式の中で複数の異なる変
数に対して各々に異なる値をセットすることが出来る、という便利さもある。

@code{setq} を使って @code{carnivores} という変数に @code{'(lion tiger
leopard)} というリストをセットするには次のＳ式が使われる。

@example
(setq carnivores '(lion tiger leopard))
@end example

@noindent
これは @code{set} を使ったものと、第一引数に引用符が付いていないことを除
き、全く同じである。(@samp{setq} の @code{q} は @code{quote} を意味して
いる。) @code{set} を使うと上のＳ式は次のようになる。

@example
(set 'carnivores '(lion tiger leopard))
@end example

また、@code{setq} は異なる変数の各々に異なる値をセットすることも出来ると
書いた。この場合には一番目の引数には二番目の引数の値がバインドされ、三番
目の引数には四番目の引数の値がバインドされ、という風になる。例えば次のＳ
式を使うとシンボル @code{tree} には樹木のリストを、シンボル 
@code{herbivores} には草食動物のリストをセットすることが出来る。

@example
@group
(setq trees '(pine fir oak maple) 
      herbivores '(gazelle antelope zebra))
@end group
@end example

@noindent
(このＳ式は一行で書いても構わないのだが、そうなるとページの大きさには合
わなってしまう。人間が読む場合には、こういう形式の方が読みやすいことがお
分りいただけると思う。)

@noindent
(訳註：因みに、日本語なら次のようになる。)

@example
@group
(setq 樹木 '(松 モミ 樫 楓) 
      草食動物 '(ガゼル レイヨウ シマウマ))
@end group
@end example

これまで何度か「セットする」という言葉を使ってきたけれども、@code{set} 
とか @code{setq} の働きにはもう一つの捉え方がある。それは @code{set} や 
@code{setq} はそのシンボルを特定のリストへの@emph{ポイント}にする、とい
うものだ。このような考え方は大変一般的であり、この後の章で、少なくとも一
つ、名前の中にそのポインタを持つシンボルに出逢うことになる。そういう名前
が付けられたのはそのシンボルに、ある値、より詳しくはリスト、がセットされ
ているためである。もう一つの言い方では、そのシンボルはそのリストへのポイ
ンタに設定されているという風に表現出来る。

@node Counting,  , Using setq, set & setq
@comment  node-name,  next,  previous,  up
@subsection カウント
@cindex Counting

次の例は、@code{setq} をカウンタとして利用する方法を説明してくれる。これ
は、プログラムの中である部分が何回繰り返されたかを数える場合に使うもので
ある。最初に変数を0に設定し、その後、プログラムの中でその部分が現われる
ごとに一つずつ足していくのである。そのためにはカウンタとなる一つの変数に
加えて二つのＳ式を用意する必要がある。初めにこのカウンタを0にセットする
ための @code{setq} 式と、評価されるごとにその変数を一ずつ増やすための 
@code{setq} 式である。

@example
@group
(setq counter 0)                ; @r{これをイニシャライザと呼ぼう。}

(setq counter (+ counter 1))    ; @r{これはインクリメンタと呼ぶ。}

counter                         ; @r{これはカウンタ。}
@end group
@end example

@noindent
(@samp{;} に続く文はコメントである。@ref{Change a defun, , 関数定義の変更}, 参照。)

もし最初のイニシャライザであるＳ式 @code{(setq counter 0)} を評価してか
ら三番目の @code{counter} というＳ式を評価したなら、エコー領域には数値0
が表示される。次に二番目のインクリメンタのＳ式 @code{(setq counter (+
counter 1))} を評価すると、カウンタは一つ増える。従って、ここでもう一度 
@code{counter} を評価するとエコー領域には数字1が表示される。その後も二番
目のＳ式を評価するごとに値は増えていく。

インクリメンタ @code{(setq counter (+ counter 1))} が評価されると Lisp 
インタプリタは最初にもっとも内側にあるリストを評価する。このリストを評価
するために、まず @code{counter}, 次に1が評価される。変数 @code{counter} 
を評価すると、その時の値が返される。それが数 @code{1} とともに @code{+} 
に渡されて足し合わされる。で、その和は内側のリストの値として @code{setq} 
に渡され、カウンタに新しい値が設定されることになる。以上のようにして、変
数 @code{counter} の値が変更される。

@node Summary, Error Message Exercises, set & setq, List Processing
@comment  node-name,  next,  previous,  up
@section まとめ

Lisp を学ぶことは、最初の道が急な坂であるような丘を登るようなものである。
あなたが現在登っているのはもっとも急な部分である。先に進むに従って、より
楽に進めるようになるはずだ。

まとめると

@itemize @bullet

@item
Lisp のプログラムはリストもしくは単一のアトムからなるＳ式で出来ている。

@item
リストは0以上のアトムもしくはリストからなる。これらは空白文字で区切ら
れており、括弧で囲まれている。リストの中身は空であっても良い。

@item
アトムは幾つかの文字からなるシンボルである。例えば 
@code{forward-paragraph} とか一つの文字からなる @code{+}、二重引用符に両
側を挟まれた文字列からなる文字列、それに数値などがそうである。

@item
数値は評価されるとそれ自身を返す。

@item
二重引用符で挟まれた文字列を評価した時もそれ自身を返す。

@item
シンボルそのものを評価すると、その値が返される。

@item
リストを評価すると、Lisp インタプリタはまずそのリストの一番目のシンボル
を見にいき、そのシンボルにバインドされている関数定義を見る。そしてその定
義の中にある命令を実行する。

@item
引用符 @code{'} があると Lisp インタプリタはその後に続くＳ式を書かれたま
まの形で返し、二重引用符が無い場合のように評価したりはしない。

@item
引数は関数に渡される情報である。ある関数に渡される引数は、その関数を先頭
に持つリストの残りの要素を評価したものにある。

@item
関数は評価された時は (エラーが起きない限り) 常にある値を返す。また、それ
に加えて「副作用」と呼ばれる効果を生ずる。多くの場合、その関数を使う第一
の目的はその副作用を生じさせることにある。
@end itemize

@node Error Message Exercises,  , Summary, List Processing
@comment  node-name,  next,  previous,  up
@section 練習問題

幾つか単純な練習問題を挙げておく。

@itemize @bullet
@item
括弧に挟まれない適当なシンボルを評価することにより、エラーメッセージを発
生させなさい。

@item
1ではなく2ずつ増えるカウンタを作りなさい。

@item
評価された時にエコー領域に何かメッセージを表示するようなＳ式を書きなさい。
@end itemize

@node Practicing Evaluation, Writing Defuns, List Processing, Top
@comment  node-name,  next,  previous,  up
@chapter 実際の評価の仕方
@cindex Practicing evaluation
@cindex Evaluation practice

Emacs Lisp での関数の定義の書き方を学ぶ前に、ちょっと時間を取って、今ま
で書いてきた様々なＳ式を評価する方法について述べておこう。これらのＳ式は
関数を最初の (そしてしばしば唯一の) 要素として持つリストである。幾つかの
バッファに関連する関数は、単純であるし、興味深くもあるので、これらの関数
から始めようと思う。また、別のセクションで、同じくバッファに関連する他の
コードについて、それらがどのように書かれているか見てみるつもりだ。

@menu
* How to Evaluate::             編集コマンドのタイプするか @kbd{C-x C-e}
                                で評価を実行出来る。
* Buffer Names::                バッファとファイルの違い
* Getting Buffers::             バッファ名でなくバッファそのものを呼び出す
* Switching Buffers::           別のバッファに移るには
* Buffer Size & Locations::     ポイントの位置とバッファのサイズ
* Evaluation Exercise::         評価についての練習問題
@end menu

@node How to Evaluate, Buffer Names, Practicing Evaluation, Practicing Evaluation
@ifinfo
@heading 評価の仕方
@end ifinfo

Emacs Lisp に対して、カーソルを動かすとかスクリーンをスクロールするなど
の編集コマンドを与える場合、@i{あなたは常に (最初の要素が関数であるよう
な) あるＳ式を評価している。これが Emacs の動作の基本である。}

@cindex @samp{interactive function} defined
@cindex @samp{command} defined
あなたが何かキーを押すと、そのことで Lisp インタプリタはあるＳ式を評価す
る。そういう風にしてあなたは求む結果を得るのである。たとえプレーンテキス
トをタイプしている時でも、Emacs Lisp の関数を評価させているのだ。この場
合に呼ばれるのは @code{self-insert-command} であり、これは、単にあなたが
タイプした文字を挿入するものである。キーを押すことで評価されるような関数
は@dfn{インタラクティブ} (@dfn{interactive}) な関数、あるいは、@dfn{コマ
ンド} (@dfn{command}) と呼ばれる。関数をインタラクティブにする方法は関数
の定義の書き方の章で説明することにする。@ref{Interactive, , 関数をインタ
ラクティブにする}, 参照。

キーボードコマンドをタイプするのに加えて、我々はもう一つＳ式を評価する方
法を学んだのだった。それはカーソルをリストの終端に持っていって @kbd{C-x
C-e} とタイプするやり方である。他にも同様にＳ式を評価する方法がある。そ
れらについては他のセクションでその都度説明するつもりだ。

評価されるのに使われることに加えて、次の幾つかのセクションで出てくる関数
は、それらそのものが元々重要である。これらの関数を学習することで、バッファ
とファイルの違いやバッファを切り替える方法、そしてその中での位置を定める
方法についてよく理解出来るようになるだろう。

@node Buffer Names, Getting Buffers, How to Evaluate, Practicing Evaluation
@comment  node-name,  next,  previous,  up
@section バッファの名前
@findex buffer-name
@findex buffer-file-name

@code{buffer-name} と @code{buffer-file-name} という二つの関数を見てみる
と、ファイルとバッファの違いがよく分るだろう。@code{(buffer-name)} とい
うＳ式を評価すると、バッファの名前がエコー領域に表示される。一方、
@code{(buffer-file-name)} を評価すると、バッファに関連付けられているファ
イルの名前がエコー領域に表示される。普通は @code{(buffer-name)} で返され
る名前は、それに関連付けられているファイルの名前と一致しており、
@code{(buffer-file-name)} はそのファイルのフルパスを返す。

ファイルとバッファは異なる種類の物である。ファイルというのは計算機に記録
されている情報であり、それを消去しない限りはずっと残っているものである。
一方でバッファは Emacs の内部の情報であり、その時々のセッション (訳註：
つまり、Emacs を起動して終了するまで) が終わると(もしくはそのバッファを 
kill すると) 消え去ってしまうものである。普通はバッファはファイルからコ
ピーした情報を保持している。このことを、バッファがそのファイルに@dfn{ビ
ジット} (@dfn{visit}) しているという。我々はこのコピーに対して編集などの
仕事を行う。バッファに対する変更はそのバッファをセーブするまではファイル
には反映されない。バッファをセーブすると、バッファの内容はファイルにコピー
されて、そのまま記録されることになる。

もしこの文を GNU Emacs の Info で読んでいるのであれば、以下のＳ式の直後
にカーソルを持っていって @kbd{C-x C-e} とタイプすることで、各々の式を評
価することが出来る。

@example
@group
(buffer-name)

(buffer-file-name)
@end group
@end example

@noindent
私がこれらの式を評価してみたところ、@code{(buffer-name)} を評価すると 
@file{"introduction.texinfo"} という値が返され、
@code{(buffer-file-name)} を評価すると 
@file{"/gnu/work/intro/introduction.texinfo"} が返ってきた。前者がバッファ
の名前で、後者はそのファイル名である。(Ｓ式の中の括弧は、Lisp インタプリ
タが @code{buffer-name} と @code{buffer-file-name} を関数として扱ってい
ることを示している。もし括弧が無ければ、インタプリタはそのシンボルを変数
として評価しようとしただろう。詳しくは @ref{Variables, , 変数}, を参照。)

ファイルとバッファは違うものであるにも関わらず、しばしばバッファのことを
ファイルと言ったり、また、その逆を言ったりする人は多い。実際、大抵の人は
「私はファイルを編集している」といい、「私はファイルにセーブしようとして
いるバッファを編集している」などとは言ったりはしない。それでも殆どの場合、
状況から言いたいことは通じてしまう。しかしながら計算機のプログラムを扱う
場合は、その違いを心に留めておくことが重要だ。計算機は人間のように賢くは
ないのである。

@cindex Buffer, history of word
ところで `buffer' という言葉は衝突の際の衝撃を吸収するクッションを表わす
言葉から来ている。初期の計算機では、バッファはファイルと計算機の中央演算
処理装置 (CPU) の間のクッションの役目をしていた。ファイルを保存するドラ
ムやテープと CPU は互いに全く異なる装置であり、速度も全然違っている。バッ
ファは各々が互いに効果的に作業出来るようにするものだった。その後、バッファ
は中継ぎとか、一時的な保管場所とかいう意味から変化して作業する場所を示す
ようになった。この変化は小さな港から巨大な町への変化と似ている。かつては
単に船に積まれる貨物が一時的に保管される場所でしかなかった所が、ビジネス
や文化の中心としての存在になってしまったのである。

さて、全てのバッファが必ず何らかのファイルに関連付けられているわけではな
い。例えば @code{emacs} という単独のコマンドで、ファイルを指定せずに 
Emacs のセッションを始めた場合、Emacs は @file{*scratch*} というバッファ
の画面からスタートする。このバッファはどのファイルにもビジットしていない。
同様に @file{*Help*} というバッファもどのファイルにも関連付けられてはい
ない。

@cindex @code{nil}, history of word
もし @file{*scratch*} バッファに切り替えて @code{(buffer-name)} とタイプ
し、その直後にカーソルを置いて @kbd{C-x C-e} とタイプしてそのＳ式を評価
したなら、@code{"*scratch*"} という名前が返り、エコー領域に表示される。
つまり、バッファの名前は @code{"*scratch*"} である。しかし、同じことを
@code{(buffer-file-name)} でやったなら、エコー領域には @code{nil} と表示
される。nil は「無 (nothing)」を表わすラテン語の単語である。この場合は@ 
@file{*scratch*} バッファがどのファイルにも関連付けられていないことを意
味している。(Lisp では @code{nil} は「偽 (false)」という意味や、空のリス
トである @code{()} の同意語としても使われる。)

ついでに言っておくと、もしあなたが、@file{*scratch*} バッファにいて、ある
Ｓ式が返す値をエコー領域ではなく @file{*scratch*} バッファそのものに表示
したい場合は、@kbd{C-x C-e} の代わりに @kbd{C-u C-x C-e} とタイプすれば
良い。こうすると、値はＳ式のすぐ後に表示される。つまり @file{*scratch*} 
バッファには次のように表示される。

@example
(buffer-name)"*scratch*"
@end example

@noindent
これは Info の中では実行出来ない。というのも Info バッファは書き込み不可
(read-only) であり、勝手にバッファの中身を修正したりすることは出来ないか
らである。しかし、編集可能なバッファであれば、どのバッファであろうと実行
出来る。コードや文書(例えばこのマニュアルなんか)を書いている時には、この
機能は大変便利である。

@node Getting Buffers, Switching Buffers, Buffer Names, Practicing Evaluation
@comment  node-name,  next,  previous,  up
@section バッファの獲得
@findex current-buffer
@findex other-buffer
@cindex Getting a buffer

@code{buffer-name} という関数はバッファの@emph{名前}を返す。従って、バッ
ファ@emph{そのもの}を取り出すには、別の関数が必要になる。これは 
@code{current-buffer} という関数である。コードの中でこの関数を使うと、バッ
ファそのものが得られる。

名前と、その名前がついているオブジェクトないしは実体とは、互いに異なって
いる。あなたはあなたの名前とは違う。あなたは、他の人からその名前で呼ばれ
る一人の人間である。もしあなたが George と話したいと頼んだ時に、
@samp{G}, @samp{e}, @samp{o}, @samp{r}, @samp{g}, @samp{e} という文字の
書かれたカードを渡されたとしたら、あなたは面白いとは思うかもしれないが、
本来の要求は満たされない。あなたは名前と話したいというのではなく、その名
前を持つ人間と話したいのだから。バッファもそれと同じだ。スクラッチバッファ
の名前は @file{*scratch*} である。しかし、その名前はバッファそのものでは
ない。ということで、バッファそのものを取り出すときは、
@code{current-buffer} のような関数が必要なわけである。

しかしながら、事情はもう少し複雑である。例えば @code{current-buffer} を
すぐ後で実験するように、Ｓ式の中で評価したとする。そうすると、バッファの
中身ではなく、バッファの名前のみが表示される。Emacs がこのように動作する
のには二つの理由がある。そのバッファは何千行もあるかもしれない---これは
手軽に表示出来るというものではない。そして他のバッファで、名前は違っても
中身は同じものがあるかもしれない。それらを区別するのは、大変大切なことで
ある。

さて、これがこの関数を含むＳ式である。

@example
(current-buffer)
@end example

@noindent
もし、ごく普通にこのＳ式を評価したとすると、エコー領域には 
@file{#<buffer *info*>} のように表示される。このように特殊な様式で表示す 
ることで、バッファの名前ではなく、そのバッファ自身が返されたことを示して
いるのである。

ついでに言うと、プログラムの中には数値やシンボルをタイプすることは出来る
が、表示されているバッファについてはそんなことは出来ない。バッファを取り
込む唯一の方法は @code{current-buffer} のような関数を使うことなのである。

関連する関数に @code{other-buffer} というのがある。これは、今、現在いる
バッファ、つまりカレントバッファを除いてもっとも最近選択したバッファを返
す。もし直前に @file{*scratch*} バッファに行って帰ってきたとしたら、
@code{other-buffer} は、このバッファを返す。

このことは次のＳ式を評価することで確かめられる。

@example
(other-buffer)
@end example

@noindent
エコー領域には @file{#<buffer *scratch*>} もしくは、あなたが最近行って帰っ
てきたバッファの名前が表示されたはずだ。

@node Switching Buffers, Buffer Size & Locations, Getting Buffers, Practicing Evaluation
@comment  node-name,  next,  previous,  up
@section バッファ間の移動
@findex switch-to-buffer
@findex set-buffer
@cindex Switching to a buffer

@code{other-buffer} という関数はこれを引数とする関数から呼ばれた場合には
実際にそのバッファの中身を提供する。これは @code{other-buffer} と 
@code{switch-to-buffer} を使って他のバッファに切り替えることで確かめられ
る。

が、その前に、@code{switch-to-buffer} という関数を簡単に紹介しておこう。
Info バッファから @code{(buffer-name)} を評価するために @file{*scratch*} 
バッファに行って戻ってくる際に、多分あなたはまず @kbd{C-x b} とタイプし、
そしてミニバッファにどのバッファに移るか尋ねるプロンプトが出た時に 
@file{*scratch*} とタイプしたのではないだろうか。この時のキーストローク 
@kbd{C-x b} は Lisp インタプリタに対してインタラクティブに Emacs Lisp の
関数 @code{switch-to-buffer} を評価させているのである。前にも言ったよう
に Emacs はこのようにして動作している。また別のキーストロークはまた別の
関数を呼び出したり走らせたりする。例えば @kbd{C-f} は@ 
@code{forward-char} を呼び出すし、@kbd{M-e} は @code{forward-sentence} 
を呼び出す、といった感じである。

Ｓ式の中で @code{switch-to-buffer} と書いて、そいつに移るべきバッファを
与えると、@kbd{C-x b} と全く同じようにしてバッファを切り替えることが出来
る。

@need 1000
ここにそのＳ式を挙げておく。

@example
(switch-to-buffer (other-buffer))
@end example

@noindent
@code{switch-to-buffer} というシンボルはこのリストの最初の要素であるから、
Lisp インタプリタは、こいつを関数として扱い、それに定義されている命令を
実行する。しかし、その前に、内側に括弧に挟まれた @code{other-buffer} が
あることを発見し、こちらを先に解釈する。@code{other-buffer} は、このリス
トの最初の (そしてこの場合は唯一の) 要素であるから、Lisp インタプリタは
この関数を走らせる。するとこいつは別のバッファを返す。次にインタプリタは
返ってきたバッファを @code{switch-to-buffer} に引数として渡して、この関
数を走らせる。そうして Emacs は他のバッファに切り替わる。もし、この文書
を Info で読んでいるなら早速試してみよう。上のＳ式を評価するのである。
(戻ってくるには、@kbd{C-x b @key{RET}} とタイプする。)

後の方のセクションに出てくるプログラミングの例では 
@code{switch-to-buffer} よりも @code{set-buffer} という関数の方をより多
く見かけるだろう。これは計算機のプログラムと人間の違いによる。人間は目を
持ち今作業している計算機の端末の上にそのバッファを見たいと思うものである。
これはいうまでもなく当たり前のことである。しかしながら、プログラムは目を
持たない。プログラムがバッファを扱っている時には、バッファはスクリーンに
見えていなくたって良いのである。

@code{switch-to-buffer} は人間のために設計されており、二つのことを行う。
一つは Emacs が注意を向けているバッファを切り替えることであり、もう一つ
は画面に見えているバッファを切り替えることである。一方、
@code{set-buffer} の方は一つの仕事しかしない。単に計算機が注意を向けてい
るバッファを別のバッファに切り替えるだけである。画面に見えているウィンド
ウはそのままだ (勿論、普通はそのコマンドが終了するまでは何も起こらない。)

@cindex @samp{call} defined
ここでまた別の専門用語を紹介しよう。@dfn{呼び出す} (@dfn{call}) という言
葉である。最初のシンボルが関数であるリストを評価すると、その関数が呼び出
される。(call される。)この時の呼び出すという単語の使い方は、「呼び出す」
ことで実体としての関数が何かをやってくれることから来ている---本物の配管
工を「呼び出す」と水洩れを直してくれるのと一緒である。

@node Buffer Size & Locations, Evaluation Exercise, Switching Buffers, Practicing Evaluation
@comment  node-name,  next,  previous,  up
@section バッファのサイズとポイントの位置
@cindex Size of buffer
@cindex Buffer size
@cindex Point location
@cindex Location of point

最後に、簡単な関数を幾つか見てみよう。@code{buffer-size}, @code{point},
@code{point-min}, そして @code{point-max} である。これらはバッファのサイ
ズとその中でのポイントの位置の情報を与えてくれるものである。

@code{buffer-size} という関数は現在のバッファの大きさを教えてくれる。
つまり、そのバッファの中の文字の数を返すのである。

@example
(buffer-size)
@end example

@noindent
これをいつものように、Ｓ式の最後にカーソルを持っていって @kbd{C-x C-e} 
とタイプすることで評価してみよう。

@cindex @samp{point} defined
Emacs の中では現在のカーソルの位置はポイントと呼ばれる。@code{(point)} 
というＳ式はバッファの始まりからポイントまでの文字数を返す。それによって
現在のカーソルの場所が分る。

次のＳ式をこのバッファの中でいつも通りに評価すればポイントまでの文字数が
分る。

@example
(point)
@end example

@noindent
これを書いているときには、@code{point} の値は121905であった。この 
@code{point} という関数は、このマニュアルの後の方に出てくる幾つかの例の
中では頻繁に使われる。

勿論ポイントの値はバッファの中での位置に依存している。次の場所でポイント
を評価すれば、その値はさっきよりも大きくなっているはずである。

@example
(point)
@end example

@noindent
私の場合この場所でのポイントの値は122376であった。これは両方のＳ式の間に
(空白も含めて) 471文字あることを示している。(訳註：Mule では、内部的にマ
ルチバイト文字の先頭にリーディングキャラクタを付けて扱うので、例えば2バ
イト文字一つは3ポイントに数えられる。)

@cindex @samp{narrowing} defined
@code{point-min} という関数はちょっと @code{point} に似ているが、こちら
はカレントバッファ中のポイントの値の中で許される最小の値を返す。この値は 
@dfn{ナローイング} (@dfn{narrowing}) が有効になっていない限り1という数値
である。(ナローイングというのは、あなた自身もしくはプログラムの操作をバッ
ファの特定部分に制限してしまうある仕組みである。詳しくは @ref{Narrowing
& Widening, , ナローイングとワイドニング}, を参照のこと。) 同様に、
@code{point-max} というのはカレントバッファ中のポイントの値の中で許され
る最大の値を返す。

@node Evaluation Exercise,  , Buffer Size & Locations, Practicing Evaluation
@section 練習問題

あなたが作業しているファイルを一つ開いて、その中央辺りまで行きなさい。そ
して、そのバッファ名、ファイル名、長さ、及びファイルの中での位置を調べな
さい。

@node Writing Defuns, Buffer Walk Through, Practicing Evaluation, Top
@comment  node-name,  next,  previous,  up
@chapter 関数定義の書き方
@cindex Definition writing
@cindex Function definition writing
@cindex Writing a function definition

Lisp インタプリタがリストを評価する場合、まずリストの最初のシンボルが関
数定義を持っているかどうか、別の言い方をするとシンボルから関数定義へのポ
インタがあるかを見にいく。もしそうであれば、計算機はその定義に含まれる命
令を実行する。関数定義を持つシンボルのことを単に関数と言う。 (ただし、正
確には定義が関数なのであり、シンボルはそれを指しているだけである。)

@menu
* Primitive Functions::         幾つかの関数は C で書かれている
* defun::                       特殊形式 @code{defun}
* Install::                     関数定義のインストール
* Interactive::                 関数をインタラクティブにする
* Interactive Options::         @code{interactive} の他のオプション
* Permanent Installation::      コードをずっとインストールしておきたい時
* let::                         局所変数の作成と初期化
* if::                          if とは？
* else::                        If--then--else 式
* Truth & Falsehood::           Lisp にとっての真と偽
* save-excursion::              ポイントやマークの位置、及びバッファの保存
* Review::                      復習
* defun Exercises::             関数定義についての練習問題
@end menu

@node Primitive Functions, defun, Writing Defuns, Writing Defuns
@ifinfo
@heading プリミティブな関数について
@end ifinfo
@cindex Primitive functions
@cindex Functions, primitive

@cindex C language primitives
@cindex Primitives written in C

全ての関数は C 言語で書かれた少数の @dfn{プリミティブ} (@dfn{primitive}) 
な関数を除いて、別の関数を使って定義されている。関数を書く場合にはそれを 
Emacs Lisp を使って書き、他の関数を部品として使うことになる。あなたが使
う関数はそれ自身 (あなたが書いたものを含めて) Emacs Lisp で書かれたもの
かもしれないし、C で書かれたプリミティブなものかもしれない。プリミティブ
な関数も Emacs Lisp で書かれているのものと全く同じように使われ、同じよう
に振舞う。これらが C で書かれているのは、十分な能力を持ち、C を走らせる
ことが出来るどの計算機でも簡単に GNU Emacs が動くようにするためである。

再度強調しておくけれども、Emacs Lisp のコードを書く場合、C で書かれた関
数を使う場合と Emacs Lisp で書かれた関数を使う場合とで区別をつける必要は
全くない。違いは全く無視して構わない。私がこの区別のことを書いたのは、単
に知っていた方が面白いからである。実際、調査でもしない限り、既に書かれて
いる関数が Emacs Lisp で書かれているか C で書かれているかは判断出来ない。

@node defun, Install, Primitive Functions, Writing Defuns
@comment  node-name,  next,  previous,  up
@section 特殊形式 @code{defun}
@findex defun
@cindex Special form of @code{defun}

@cindex @samp{function definition} defined
Lisp では @code{mark-whole-buffer} のようなシンボルには、その関数が呼ば
れた時に計算機が何をすべきかを教えるコードが付随している。このコードのこ
とを @dfn{関数定義} (@dfn{function definition}) といい、シンボル 
@code{defun} で始まるＳ式を評価した時に作られる。(これは @emph{define
function} の略である。) @code{defun} は通常とは別の引数の評価の仕方をす
るために、@dfn{特殊形式} (@dfn{special form}) と呼ばれる。

この後に続く幾つかのセクションでは、例えば @code{mark-whole-buffer} のよ
うに Emacs のソースコードの中から関数定義を見ていくことにする。が、この
セクションではもっと単純な関数定義を説明し、それがどんなものなのかを、ま
ず理解してもらうことにしよう。簡単な例にするために算数についての例にする。
算数を使った例が嫌いな人達もいるとは思うが、あなたがそうだとしてもがっく
りくる必要はない。この入門書の残りに出てくる殆どのコードには算数とか数学
は出てこない。出てくる例は、大体が何がしかの意味でテキストに関わるもので
ある。

関数定義は @code{defun} という単語に続けて、次のような最大五つの部分を加
えたものである。

@enumerate
@item
関数定義が付けられるシンボルの名前。

@item
関数に渡される引数のリスト。もし一つも引数をつけない場合、ここは空リスト 
@code{()} にする。

@item
関数を説明する文章。(技術的には省略可能であるが、書くことが強く望まれて
いる。)

@item
省略可能。この関数をインタラクティブにする、つまり @kbd{M-x} に続けて関
数名をタイプするか、適当なキーないしはキーコードをタイプすることで使うこ
とが出来るようにするためのＳ式を書く。

@cindex @samp{body} defined
@item
計算機に何をすべきかを命令するコードを書く。即ち、関数定義の本体である。
@end enumerate

この関数定義の五つの部分の各々にスロットを割当てて、次のようなテンプレー
トにして整理しておくと役に立つだろう。

@example
@group
(defun @var{関数名} (@var{引数}@dots{})
  "@var{オプションの説明文字列}@dots{}"
  (interactive @var{引数情報}) ; @r{省略可能}
  @var{本体}@dots{})
@end group
@end example

一つの例として、引数に7をかける関数のコードを挙げる。(この例はインタラ
クティブではない。@ref{Interactive, , 関数をインタラクティブにする}, を
見よ。)

@example
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end example

この定義は括弧と @code{defun} というシンボルで始まり、関数の名前が続いて
いる。

@cindex @samp{argument list} defined
関数の名前の次にはこの関数に渡される引数のリストが来る。このリストは 
@dfn{引数リスト} (@dfn{argument list}) と呼ばれる。今の場合、このリスト
の要素は @code{number} というシンボル一つだけである。この関数が使われる
時には、このシンボルは関数の引数として使われる値にバインドされる。

引数の名前として @code{number} という単語を選ぶ代わりに他の名前を選んで
も良い。例えば @code{multiplicand} という単語でも良かった。私が `number' 
という単語を選んだのは、このスロットにどういう種類の値が要求されるかが分
るからである。しかし、このスロットに置かれる値がこの関数の働きの中でどう
いう役割を果たすかを示すという意味で `multiplicand' という単語を選ぶのも
悪くなかった。@code{foogle} としても構わないが、これは良い選択だとは思え
ない。これでは何のことか分らない。どういう名前にするかはプログラマ次第だ
が、関数の意味を明確にするようなものが選ばれるべきである。

実の所、引数リストの中のシンボルにはどんな名前でも選ぶことが出来る。たと
え、他の関数の中で使われているシンボル名であっても良いのである。引数リス
トの中で使われる名前は、その特定の定義の中だけでしか使われないプライベー
トなものであるからだ。この定義の中では、他のどんな関数定義の中にある同じ
名前のシンボルとも異なる実体を指すのである。例えば、あなたが家族の間では 
`Shorty' というニックネームをつけられているとしよう。この場合、あなたの
家族の誰かが `Shorty' という場合には、それはあなたのことを指している。し
かしあなたの家族以外の所、例えば映画の中などでは `Shorty' というのは別の
誰かを指している。引数リストの中の名前はその関数の中だけで通用するものな
ので、この関数の本体の中でそのシンボルの値をどう変えたとしても外での値に
は何の影響もないというわけだ。似たような効果が @code{let} を使ったＳ式の
場合でも見られる。(@ref{let, , @code{let}}, 参照。)

@ignore
ここで、`number' という単語を二通りの方法で議論したことにも注意しよう。
一つはコードの中に現れるシンボルとして、もう一つはこの関数が評価される時
に置き換わる何かの名前として、である。一つ目の場合には、@code{number} は
シンボルである。これは数値ではない。関数の中ではこれはある変数であって、
その値が問題となる数値なのだが、我々の主な興味はそのシンボルとしての振舞
いであった。一方で、関数について話す場合には、我々の興味は @var{number} 
という単語をある数値で置き換えることにある。二つの違いを明確にするために、
それぞれの使い方に従って二通りの書き方をすることにしよう。この関数がどう
働くかについて話す時は、@var{number} と書く。一方、関数そのものの中でシ
ンボルとして話すときには @code{number} と書くことにしよう。
@end ignore

引数リストの次には、関数についての説明である、説明文字列が来る。これは 
@w{@kbd{C-h f}} に続けてその関数の名前をタイプした時に表示される内容であ
る。ついでに言っておくと、あなたが説明文字列を書く場合には、最初の一行は
完結した一つの文にすべきである。というのも、@code{apropos} のような幾つ
かのコマンドは複数行に渡って書かれた説明文の文字列のうちの最初の一行だけ
しか表示しないからである。また、二行目も書く場合はこれをインデントすべき
ではない。何故なら、@kbd{C-h f} (@code{describe-function}) を使ったとき
に変な表示のされかたをするからである。説明文字列は省略可能ではあるが、大
変役に立つものなので、関数を書く際にはなるべく書くようにすべきである。

@findex * @r{(multiplication)}
さっきの例での三行目は関数定義の本体をなしている。 (普通の関数定義は勿論
これよりもっと長い。) 今の場合、この本体は @code{(* 7 number)} というリ
ストであり、@var{number} の値に7をかけることを定めている。(Emacs Lisp で
は @code{*} は掛け算を表わす関数である。同様に @code{+} は足し算を表わす。)

@code{multiply-by-seven} という関数を使う場合、引数 @code{number} はあな
たが実際に使いたい値に評価される。次の例では @code{multiply-by-seven} の
使い方を示している。ただし、まだこれを評価しないように！

@example
(multiply-by-seven 3)
@end example

@noindent
次のセクションで詳しく述べるが、今の例ではシンボル @code{number} に3とい
う値が与えられた、ないしは「バインドされた」わけである。@code{number} は
関数定義の括弧の中にあるが、@code{multiply-by-seven} という関数に渡され
る引数は括弧の外にあることに注意しておこう。関数定義の中に括弧があるのは、
計算機が引数のリストが何処で終わり、残りの部分が何処から始まるかを知るた
めにあるのである。

この例を評価すると多分エラーメッセージが出るだろう。(試してみよう！) こ
れは、我々は確かに関数定義を書いたのだが、まだその定義を計算機に伝えてい
ない---つまり、まだ Emacs にこの関数定義をインストール (もしくはロード) 
していない---ためである。インストールの仕方については次のセクションで説
明する。

@node Install, Interactive, defun, Writing Defuns
@comment  node-name,  next,  previous,  up
@section 関数定義のインストール
@cindex Install a Function Definition
@cindex Definition installation
@cindex Function definition installation

もし Emacs の Info の中でこれを読んでいるのなら、先に関数の定義を評価し、
次に @code{(multiply-by-seven 3)} を評価することで、
@code{multiply-by-seven} という関数を試してみることが出来る。この下に関
数定義の写しを書いておくので、その直後にカーソルを持っていって @kbd{C-x
C-e} とタイプしよう。そうすると、エコー領域に @code{multiply-by-seven} 
と表示される。(これは関数定義を評価した時に返す値はその関数の名前である
ことを示している。) 同時に、こうすることで関数定義がインストールされる。

@example
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end example

@noindent
この @code{defun} を評価することで、たった今 Emacs に 
@code{multiply-by-seven} がインストールされた。今ではこの関数は 
@code{forward-word} やあなたが編集に使う他の関数と全く同様、Emacs の一部
である。(@code{multiply-by-seven} はあなたが Emacs を終了するまでインス
トールされたままになっている。このコードを Emacs を起動するたびに再ロー
ドする方法については、
@ref{Permanent Installation, , コードをずっとインストールしておくには}, 
を見よ。)

@code{multiply-by-seven} をインストールしたことでどうなったかは、次の例
を評価することで見ることが出来る。カーソルを次のＳ式の直後に持っていって 
@kbd{C-x C-e} とタイプしてよう。エコー領域には21という数字が表示されたは
ずだ。

@example
(multiply-by-seven 3)
@end example

もし望むなら、@kbd{C-h f} (@code{describe-function}) に続けてこの関数の
名前 @code{multiply-by-seven} をタイプすることで、この関数定義の説明を読
むことも出来る。そうすると、@file{*Help*} というウィンドウに次のように表
示される。

@example
@group
multiply-by-seven: Multiply NUMBER by seven.
@end group
@end example

@noindent
(スクリーンを元の一つのウィンドウに戻すには、@kbd{C-x 1} とタイプすれば
良い。)

@menu
* Change a defun::              関数定義の変更の仕方
@end menu

@node Change a defun,  , Install, Install
@comment  node-name,  next,  previous,  up
@subsection 関数定義の変更
@cindex Changing a function definition
@cindex Function definition, how to change
@cindex Definition, how to change

@code{multiply-by-seven} の中のコードを変更したい場合は、単にそれを書き
直すだけである。古いものを新しいバージョンに置き換えるには、その関数定義
をもう一度評価すれば良い。これが Emacs の中のコードを修正する方法である。
極めて単純だ。

例として、@code{multiply-by-seven} という関数を7をかけるのではなく、その
数自身を7回加えるものに変更することが出来る。結果としては同じ答えが得ら
れるけれども、途中の道筋は違っている。同時にコードの中にコメントを加えよ
う。これは Emacs には無視されるけれども、人間が読む場合には便利だなあと
か解りやすいとか思うはずだ。今回は、これが二番目のバージョンであるという
コメントを書いておくことにする。

@example
@group
(defun multiply-by-seven (number) ; @r{二番目のバージョン}
  "Multiply NUMBER by seven."
  (+ number number number number number number number))
@end group
@end example

@cindex Comments in Lisp code
コメントはセミコロン @samp{;} の後に続いている。Lisp では、セミコロンの
後に続く全てのものはコメントである。行の終わりがコメントの終わりになる。
二行以上に渡ってコメントを書きたい場合は各々の行をセミコロンで始める。

@ref{Beginning a Init File, , @file{.emacs} の書き方},及び 
@ref{Comments, , Comments, elisp, The GNU Emacs Lisp Reference Manual}, 
にコメントについて、より詳しく説明されている。

今のバージョンの @code{multiply-by-seven} 関数をインストールするには最初
のものをインストールした時と全く同じようにして評価してやれば良い。つまり、
カーソルを最後の括弧のすぐ後に持ってきて @kbd{C-x C-e} とタイプすれば良
いのである。

まとめると、Emacs でコードを書く方法は次の通りである。まずは関数を書き、
インストールし、テストしてみる。で、不具合を修正したり拡張したりして再
度インストールするという具合だ。

@node Interactive, Interactive Options, Install, Writing Defuns
@comment  node-name,  next,  previous,  up
@section 関数をインタラクティブにする
@cindex Interactive functions
@findex interactive

関数をインタラクティブなものにするには、特殊形式 @code{interactive} で始
まるリストを説明文字列のすぐ後に置けばよい。インタラクティブな関数はユー
ザーが @kbd{M-x} に続けて関数の名前をタイプすることで呼び出すことが出来る。
あるいは、その関数にバインドしたキーをタイプしてもよい。例えば、
@kbd{C-n} とタイプすると @code{next-line} が呼ばれるし、@kbd{C-x h} とタ
イプすると @code{mark-whole-buffer} が呼ばれる。

面白いことに、インタラクティブな関数をインタラクティブに呼び出すと、返さ
れる値は自動的にはエコー領域に表示されない。これはインタラクティブな関数
はしばしば、単語分や一行分前に進んだりするなどの副作用を目的に呼ぶのであっ
て、返される値のことは気にしないからである。もしキーをタイプするごとにエ
コー領域に値が表示されたら、随分と欝陶しいことだろう。

特殊形式 @code{interactive} を使いつつエコー領域に値を表示する方法につい
て説明するために、 @code{multiply-by-seven} のインタラクティブバージョン
を作ってみよう。

@need 1250
これがそのコードである。

@example
@group
(defun multiply-by-seven (number) ; @r{インタラクティブバージョン}
  "Multiply NUMBER by seven."
  (interactive "p")
  (message "The result is %d" (* 7 number)))
@end group
@end example

@noindent
このコードはカーソルをコードのすぐ後に持っていって @code{C-x C-e} とタイ
プすることでインストール出来る。ちゃんと、この関数の名前がエコー領域に表
示されただろうか。次からこのコードを使うには、まず @kbd{C-u} に続けて数
をタイプし、その後に @kbd{M-x multiply-by-seven} とタイプして @kbd{RET} 
を押せば良い。エコー領域に、@samp{The result is @dots{}} という文に続い
て計算結果が表示されるはずだ。

もっと一般的に言うと、このような関数は次の二通りの内どちらかの方法で呼び
出すことが出来る。

@enumerate
@item
まず渡されるべき数を含む前置引数をタイプする。ついで @kbd{M-x} と関数名
をタイプする、例えば @kbd{C-u 3 M-x forward-sentence}、とする。

@item
あるいは、その関数にバインドされたキーないしはキーコードをタイプする。例
えば @kbd{C-u 3 M-e}。
@end enumerate

@noindent
今挙げた二つの例では、どちらの場合もポイントが３つの文だけ前方に移動する。
(この関数を例として扱った理由は、@code{multiply-by-seven} はどのキーにも
バインドされてはいないので、キーバインディングの例としては使えないからで
ある。)

(コマンドをキーにバインドする方法については @ref{Keybindings, , 幾つかのキーバインディング}, を参照のこと。)

前置引数をインタラクティブな関数に渡すには、@kbd{M-3 M-e} のように
@kbd{META} キーに続けて数をタイプする方法と、@kbd{C-u 3 M-e} のように 
@kbd{C-u} に続けて数をタイプする方法とがある。(もし @kbd{C-u} の後に何も
数をタイプしなかった場合、デフォルトでは4が渡される。)

@menu
* multiply-by-seven in detail:: インタラクティブバージョン
@end menu

@node multiply-by-seven in detail,  , Interactive, Interactive
@comment  node-name,  next,  previous,  up
@subsection インタラクティブな @code{multiply-by-seven}

インタラクティブバージョンの @code{multiply-by-seven} の中の特殊形式 
@code{interactive} の使い方と、関数 @code{message} を見てみよう。もう一
度この関数の定義を書いておく。

@example
@group
(defun multiply-by-seven (number) ; @r{インタラクティブバージョン}
  "Multiply NUMBER by seven."
  (interactive "p")
  (message "The result is %d" (* 7 number)))
@end group
@end example

この関数の中ではＳ式 @code{(interactive "p")} は二つの要素からなるリスト
である。@code{"p"} は Emacs に対し、この関数に前置引数を渡し、その値を関
数の引数として使うことを知らせるためのものである。

引数は数になる。これは @code{number} というシンボルが

@example
(message "The result is %d" (* 7 number))
@end example

@noindent
という行の中である数にバインドされるという意味である。例えば、前置引数が
5だとすると、Lisp インタプリタはこの行を次のように評価することになる。

@example
(message "The result is %d" (* 7 5))
@end example

@noindent
(もし、この文章を GNU Emacs の中で読んでいるなら、このＳ式をあなた自身で
評価することが出来る。) 最初にインタプリタは内側にあるリストを評価する。
今の場合は @code{(* 7 5)} である。これは値35を返す。次にその外側のリスト
が評価される。つまり、二番目及び残りの要素の値が @code{message} という関
数に渡される。

前に見たように、@code{message} は特に一行のメッセージをユーザに送るため
の Emacs Lisp の関数であった。(@ref{message, , 関数 @code{message}}, 参
照。) 手短に言うと、関数 @code{message} は最初の引数をエコー領域に表示す
るのだが、@samp{%d}, @samp{%s}, 及び @samp{%c} だけは例外で、これらの制
御文字列の内のどれかが現れた時は、残りの二番目以降の引数を順に見に行き、
その値をこれらがある場所に挿入して表示する。

@code{multiply-by-seven} という関数では、制御文字列として @samp{%d} が使
われ、これは数を要求する。今の場合ならその値は @code{(* 7 5)} を評価して
返された35という数である。その結果、@samp{%d} の場所には35が表示され、メッ
セージは @samp{The result is 35} となるわけである。

(ここで注意だが、@code{multiply-by-seven} という関数を呼んだ場合、メッセー
ジは引用符無しで表示される。しかし @code{message} をそのまま呼んだ場合に
は、二重引用符で囲まれている。これは @code{message} が返す値そのものは 
@code{message} が先頭にあるＳ式を評価した場合にエコー領域に表示されるも
ので、これには引用符がついているのだが、これが他の関数の中に埋め込まれて
使用された場合、表示されるものは @code{message} が副作用として出力するも
ので、これには二重引用符がついていないからである。)

@node Interactive Options, Permanent Installation, Interactive, Writing Defuns
@comment  node-name,  next,  previous,  up
@section @code{interactive} の他のオプション
@cindex Options for @code{interactive}
@cindex Interactive options

上の例で @code{multiply-by-seven} は @code{interactive} の引数として 
@code{"p"}を使っている。この引数がある場合、Emacs はあなたが、@kbd{C-u} 
に続けて数をタイプするか、@kbd{Meta} キーに続けて数をタイプするかして、
このコマンドに引数として数を渡すものと解釈する。Emacs はこのような 
@code{interactive} の引数を20種類以上用意している。大抵の場合、これらの
オプションの内にあなたが望む通りの情報を関数に渡すものが一つか二つはある
はずだ。(@ref{Interactive Codes, , Code Characters for
@code{interactive}, elisp, The GNU Emacs Lisp Reference Manual}, 参照。)

例えば @samp{r} という文字の場合、Emacs はその関数にその時のリージョンの
最初と最後の位置 (その時のポイントとマークの値) を二つの別々の引数として
渡す。使い方は例えばこんな風だ。

@example
(interactive "r")
@end example

あるいは、@samp{B} であれば、Emacs はバッファの名前を聞いてきて、入力し
た値をその関数に渡す。もう少し詳しく言うと、Emacs はミニバッファにプロン
プトを出して、ユーザーに名前を要求する。この時のプロンプトには @samp{B} 
に続く値が使われるので、例えば、@code{"BAppend to buffer:@: "} とか書い
ておく。Emacs はただ単にプロンプトを出すだけではなくて、判断出来る分だけ
の入力があれば、@kbd{TAB} キーを押すことで補完までしてくれる。

関数に二つ以上の引数を渡したい場合、@code{interactive} に続けて複数の文
字列を付け加えることで、各々の引数に情報を渡すことが出来る。この場合その
情報は、各々の引数に @code{interactive} に書いたのと同じ順序で渡される。
付け加える文字列は、各々の部分を @samp{¥n}, 即ち改行コードで区切る。例え
ば @code{"BAppend to buffer:@: "} に続けて @samp{¥n} と @samp{r} を書い
たりする。こうすると、Emacs はプロンプトでバッファ名を要求すると同時にポ
イントとマークの値もその関数に渡してくれる---三つの引数全てを渡してくれ
るのである。

この場合の関数定義は次のような形式になる。@code{buffer}, @code{start}, 
及び、@code{end} は @code{interactive} がバッファとその時のリージョンの
始まりと終わりをバインドするシンボルである。

@example
@group
(defun @var{関数名} (buffer start end)
  "@var{説明文字列}@dots{}"
  (interactive "BAppend to buffer:@: ¥nr")
  @var{関数の本体}@dots{})
@end group
@end example

@noindent
(プロンプトのコロンの後の空白は、プロンプトを出す時の見栄えをよくするた
めのものである。@code{append-to-buffer} という関数はまさにこのようになっ
ている。@ref{append-to-buffer, , @code{append-to-buffer} の定義}, 参照。)

あるいは、もし上に挙げたような特定の文字による引数の与え方があなたの目的
に合わない場合、あなた自身の引数をリストとして @code{interactive} に渡す
ことも可能である。@ref{Using interactive, ,Using @code{Interactive},
elisp, The GNU Emacs Lisp Reference Manual}, にこの上級テクニックについ
てのより詳しい解説がある。

@node Permanent Installation, let, Interactive Options, Writing Defuns
@comment  node-name,  next,  previous,  up
@section コードをずっとインストールしておくには
@cindex Install code permanently
@cindex Permanent code installation
@cindex Code installation

関数定義を評価することで一旦その関数をインストールすると、Emacs を終了す
るまでその関数はインストールされたままになっている。一方、次に Emacs の
新しいセッションを開始した時は、その関数定義を再度評価するまでその関数は
インストールされない。

ある時点で、Emacs の新しいセッションを始める時に自動的にインストールした
いと思うかもしれない。方法は幾つかある。

@itemize @bullet
@item 
もし、自分自身で書いたコードがあれば、その関数定義のコードをあなたの初期
化ファイル @file{.emacs} の中に書き込む。そうすると Emacs を起動した時に 
この @file{.emacs} というファイルが自動的に評価されて、その中に書かれた
全ての関数がインストールされる。@ref{Emacs Initialization, ,
@file{.emacs} ファイル}, 参照。

@item
あるいは、インストールしたい関数の定義を一つのファイル、もしくは関数ごと
に複数のファイルに書いておき、@code{load} という関数を使って Emacs にそ
れを評価させてそれらの関数をインストールするという方法もある。
@ref{Loading Files, , ファイルのロード}, 参照。

@item
また、あなたのいるサイト全体でそのコードを使いたい場合は、普通はその関数
を @file{site-init.el} 呼ばれるファイルに書いておく。このファイルは 
Emacs を作成する時に自動的にロードされる。こうすることで、あなたの計算機
を使う全ての人がその関数を利用出来るようになる。(Emacs distribution の中
の @file{INSTALL} ファイルを参照のこと。)
@end itemize

最後に、もしあなたが Emacs を使う全ての人が欲しくなるようなコードを書い
たなら、そのコピーをネットワーク上にポストしたり、Free Software
Foundation に送ることが出来る。(そうする場合には、どうかポストする前にコー
ドに copy left の注意書きを添付して欲しい。) コピーを Free Software
Foundation に送った場合、次の Emacs のリリース時にはそれを含めて配布され
るかもしれない。大体において、ここ数年はこのような寄付によって Emacs が
成長してきたのである。

@node let, if, Permanent Installation, Writing Defuns
@comment  node-name,  next,  previous,  up
@section @code{let}
@findex let

@code{let} 式は、Lisp では多くの関数定義の中で必要となる特殊形式である。
非常によく使われるものなので、このセクションの中で @code{let} について説
明することにする。

@code{let} は、シンボルに値をバインドする際に、Lisp インタプリタがその関
数以外の関数の中で使われている同じ名前の変数と混同しないようにするために
使用される。何故こんな関数が必要なのかということを納得するために、次の様
な状況を考えよう。あなたは自分自身の家を持っていて、それを「家」と呼んで
いるとする。例えば、「そろそろ家にもペンキ塗りが必要だなあ」という風に使
うわけである。しかし、あなたが友人宅を訪問し、そこのホストの人が「家」と
言った場合、大抵それはあなたの家ではなく@emph{彼の}家のことを指している。
即ち、同じ「家」という言葉で言及されてはいても別のものなわけである。もし
彼が彼自身の家のことを言っていて、あなたがあなた自身の家を思い浮かべてい
たなら混乱してしまうことであろう。同じことが Lisp についても言える。ある
関数で使われている変数と同じ名前の変数が他の関数でも使われていて、しかも
その二つが同じ値を持つことを期待されてはいない時である。

@cindex @samp{local variable} defined
@code{let} という特殊形式を使うことでこのような混乱を防ぐことが出来る。
@code{let} は @dfn{ローカル変数} (@dfn{local variable}) と呼ばれるものを
発生させる。これは、その @code{let} 式の外にある同じ名前の変数からは隔離
されている変数である。訪問先のホストの人が「家」という時は彼は彼自身の家
を指しているのであって、あなたの家を指しているのではないのと似たようなも
のだ。 (引数リストの中のシンボルも同じような働きをする。@ref{defun, ,
特殊形式 @code{defun}}, を見よ。)

@code{let} 式によって発生したローカル変数の値が保持されているのは、その
@code{let} 式の中@emph{だけ}である。(そして、その中のＳ式はその 
@code{let} 式の中だけで呼ばれる。) 従って、ローカル変数はその @code{let} 
式の外には全く影響を与えない。

@code{let} は一度に複数の変数を発生させることが出来る。また、@code{let} 
は各々の変数に初期値を設定する。あなたが指定すればその値になるし、そうし
なければ @code{nil} が設定される。(専門用語では、このことを「その変数に
値をバインドする」と言う。) @code{let} は変数を発生させ、それに値をバイ
ンドした後、本体のコードを実行し、本体の中の最後のＳ式の値を返す。(実行 
(Execute) するというのは、リストを評価するという意味の専門用語である。こ
れはこの単語の「実質的な効果を与える (to give practical effect to)」とい
う意味での使い方から来ている (@cite{Oxford English Dictionary})。あなた
はある動作を引き起こすためにＳ式を評価しているのだから、この場合「実行」
するというのは評価するのと同義であろう。)

@menu
* Parts of let Expression::     @code{let} 式にはどんな部分があるか
* Sample let Expression::       @code{let} 式の例
* Uninitialized let Variables:: 初期値をバインドしないとどうなるか
@end menu

@node Parts of let Expression, Sample let Expression, let, let
@comment  node-name,  next,  previous,  up
@subsection @code{let} 式の構成部分
@cindex @code{let} expression, parts of
@cindex Parts of @code{let} expression

@cindex @samp{varlist} defined
@code{let} というＳ式は三つの部分からなるリストである。最初の部分はシン
ボル @code{let} である。二番目の部分は @dfn{変数リスト} (@dfn{varlist}) 
と呼ばれるリストであり、各々の要素はシンボルそのものであるか、最初の要素
がシンボルである二つの要素からなるリストであるかのどちらかであり、三番目
の部分は @code{let} 式の本体である。本体部分は大抵、一つないしは複数のリ
ストからなる。

@code{let} 式のテンプレートは次のように書ける。

@example
(let @var{変数リスト} @var{本体}@dots{})
@end example
    
@noindent
変数リストの中のシンボルは特殊形式 @code{let} 式によって初期値を設定され
る変数である。単独のシンボルそのものの場合は、初期値 @code{nil} が設定さ
れる。また、最初の要素がシンボルであるような二つの要素からなるリストの場
合、その最初のシンボルに対して Lisp インタプリタが二番目の要素を評価した
時に返される値が設定される。

というわけで、変数リストは @code{(thread (needles 3))} という感じの式に
なる。この場合だと、@code{let} 式の中で Emacs はシンボル @code{thread} 
を初期値 @code{nil} に、シンボル @code{needles} を初期値3にバインドする。

@code{let} 式を書く場合にすることは、適切なＳ式を @code{let} 式のテンプ
レートの中に置くことである。

もし、変数リストが二つ要素のリストからなる場合、といっても大抵はそうなの
だが、@code{let} 式のテンプレートは次のようになる。

@example
@group
(let ((@var{変数} @var{値})
      (@var{変数} @var{値})
      @dots{})
      @var{本体}@dots{})
@end group
@end example

@node Sample let Expression, Uninitialized let Variables, Parts of let Expression, let
@comment  node-name,  next,  previous,  up
@subsection @code{let} 式の例
@cindex Sample @code{let} expression
@cindex @code{let} expression sample

次のＳ式は二つの変数 @code{zebra} と @code{tiger} を発生させ、それに対し
て初期値を与えている。@code{let} 式の本体は関数 @code{message} を呼び出
すリストである。

@example
@group
(let ((zebra 'stripes)
      (tiger 'fierce))
  (message "One kind of animal has %s and another is %s."
           zebra tiger))
@end group
@end example

ここで、変数リストは @code{((zebra 'stripes) (tiger 'fierce))} である。

二つの変数は @code{zebra} と @code{tiger} である。各々の変数は二つの要素
からなるリストの最初の要素であり、その値はそのリストの二番目の要素になっ
ている。Emacs は変数リストの中で @code{zebra} を @code{stripes} にバイン
ドし、また、@code{tiger} を @code{fierce} にバインドしている。この場合、
値は両方とも引用符のついたシンボルである。値は勿論、他のリストや文字列で
あっても構わない。@code{let} 式の本体は変数を含むリストの後に来る。今の
場合は本体は関数 @code{message} を使ったリストであり、エコー領域に文字列
を表示する。

いつものようにカーソルを最後の括弧の直後に置いて @kbd{C-x C-e} とタイプ
することで上の例を評価することが出来る。そうすると、エコー領域に次のよう
に表示されるだろう。

@example
"One kind of animal has stripes and another is fierce."
@end example

以前見たように、@code{message} 関数は最初の引数を @samp{%s} を除いて表示
する。今の場合、最初の @samp{%s} の所には変数 @code{zebra} の値が表示さ
れ、二番目の @samp{%s} の所には変数 @code{tiger} の値が表示される。

@node Uninitialized let Variables,  , Sample let Expression, let
@comment  node-name,  next,  previous,  up
@subsection @code{let} 式の変数宣言の中で初期値を設定しなかった場合
@cindex Uninitialized @code{let} variables
@cindex @code{let} variables uninitialized

もし、@code{let} 式の中で変数に特定の初期値をバインドしなかったとすると、
それらの値は自動的に @code{nil} にバインドされる。次の例を見てみよう。

@example
@group
(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "Here are %d variables with %s, %s, and %s value."
   birch pine fir oak))
@end group
@end example

@noindent
ここで、変数リストは @code{((birch 3) pine fir (oak 'some))} である。

このＳ式をいつもの通りに評価したなら、エコー領域には次のように表示される
だろう。

@example
"Here are 3 variables with nil, nil, and some value."
@end example

@noindent
この場合には Emacs はシンボル @code{birch} に3という数をバインドし、シン
ボル @code{pine} と @code{fir} には @code{nil} をバインドし、更にシンボ
ル @code{oak} には @code{some} をバインドしている。

@code{let} 式の最初の部分で、変数 @code{pine} と @code{fir} は単独のアト
ムであり、括弧で囲まれてはいないことに注意しよう。これは、これらの変数を 
@code{nil}, 即ち空リストにバインドするためである。しかし、@code{oak} の
方は、@code{some} にバインドするので、リスト @code{(oak 'some)} の一部と
なっている。同様に、@code{birch} も3にバインドするので、この数と一緒のリ
ストに入っている。(数値は評価された時にそれ自身の値を返すので、引用符は
必要ない。また、message の中にこの数を表示する際は、@samp{%s} ではなくて、
@samp{%d} を使っている。) そして、これら四つの変数がひとつのグループとし
てリストの中に入り、@code{let} 式の本体と区別されているわけである。

@node if, else, let, Writing Defuns
@comment  node-name,  next,  previous,  up
@section 特殊形式 @code{if}
@findex if
@cindex Conditional with @code{if}

@code{defun} と @code{let} に続く三つ目の特殊形式は、条件分岐
(conditional) @code{if} である。この特殊形式は計算機になんらかの判断をさ
せる時に使われる。@code{if} を使わなくても関数定義を書くことも出来るが、
頻繁に使うものであるし、重要でもあるので、ここに含めることにする。これは
例えば、@code{beginning-of-buffer} という関数の中で使われている。

@code{if} の背後にある基本的な考え方は「@emph{もし}(if)、テストした結果
が真@emph{ならば}(then)Ｓ式を評価する」というものだ。テストした結果が真
でなければ、Ｓ式は評価はされない。例えば、「もし、暖かくて太陽が出ていた
なら、ビーチへ行こう。」というような判断をするようなものだ。

@cindex @samp{if-part} defined
@cindex @samp{then-part} defined
Lisp で書かれる @code{if} 式では、`then' という単語は使われない。テスト
と実行は @code{if} を最初の要素とするリストの二番目と三番目の要素である。
にも関わらず、@code{if} 式のテスト部分は @dfn{if-part} と呼ばれ、二番目
の引数は @dfn{then-part} と呼ばれることが多い。

また、@code{if} 式が書かれる場合、真か偽かのテストは普通、@code{if} と同
じ行に書かれる。しかし、テストが真であった場合に実行される ``then-part'' 
は二行目以降に書かれる。こうすることで、@code{if} 式がより読みやすいもの
になる。

@example
@group
(if @var{真偽テスト}
    @var{テストが真である場合に実行する動作})
@end group
@end example

@noindent
真偽テスト (true-or-false-test) の部分は List インタプリタにより評価され
るＳ式である。

次にいつものようにして実行出来る例を挙げておく。テスト部分は5が4よりも大
きいかどうかを判断するものだ。そうであれば、@samp{5 is greater than 4!} 
というメッセージが表示される。

@example
@group
(if (> 5 4) ; @r{if-part}
    (message "5 is greater than 4!"))  ; @r{then-part}
@end group
@end example

@noindent
(関数 @code{>} は最初の引数が二番目の引数よりも大きいかどうかを判断し、
そうであれば真を返すものである。)
@findex > (greater than)

勿論、実際に使う場合には、@code{if} 式のテスト部分は常に @code{(> 5 4)} 
に固定されていたりはしない。その代わりに、少なくとも一つの変数が、前もっ
て分らない値にバインドされる。(もし、前もって値が分っているなら、テスト
する必要などない！)

例えば、その値は関数定義の引数にバインドされたりする。次の関数定義では、
関数に渡される値は動物の性格である。もし、@code{characteristic} にバイン
ドされる値が @code{fierce} であれば、@samp{It's a tiger!} というメッセー
ジが表示される。そうでなければ、@code{nil} が返される。

@example
@group
(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.  If the
CHARACTERISTIC is the symbol `fierce', then warn of a tiger."
  (if (equal characteristic 'fierce)
      (message "It's a tiger!")))
@end group
@end example

@noindent
もし、これを GNU Emacs の中で読んでいるなら、上の関数定義を評価すること
で、Emacs にインストールすることが出来る。そうすると、次の二つのＳ式を評
価して結果を見ることも出来るようになる。

@example
@group
(type-of-animal 'fierce)

(type-of-animal 'zebra)
@end group
@end example

@c Following sentences rewritten to prevent overfull hbox.
@noindent
@code{(type-of-animal 'fierce)} を評価すると、エコー領域には @code{"It's
a tiger"} と表示されるはずだ。一方、@code{(type-of-animal 'zebra)} を評
価すると、@code{nil} が表示される。

@menu
* type-of-animal in detail::    @code{if} 式の例
@end menu
@node type-of-animal in detail,  , if, if
@comment  node-name,  next,  previous,  up
@subsection 関数 @code{type-of-animal} の詳細

@code{type-of-animal} 関数を詳しく見てみよう。

@code{type-of-animal} の関数定義は二つのテンプレートのスロットを埋めるこ
とで書かれている。一つは全体の関数定義のテンプレートで、もう一つは 
@code{if} 式のテンプレートである。

インタラクティブでない関数の関数定義のテンプレートは次の通りである。

@example
@group
(defun @var{関数名} (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  @var{本体}@dots{})
@end group
@end example

このテンプレートに当てはめると、各部分は次のようになる。

@example
@group
(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.  If the
CHARACTERISTIC is the symbol `fierce', then warn of a tiger."
  @var{本体: } @code{if} @var{式})
@end group
@end example

今の場合、関数の名前は @code{type-of-animal} である。これは引数を一つ取
る。引数リストの後に、複数行に渡る説明文字列が続く。例の中にもちゃんと説
明文字列を入れるのは、全ての関数定義に説明文字列を入れるのが良い習慣であ
るからである。関数定義の本体部分は @code{if} 式からなっている。

@code{if} 式のテンプレートは次の通りである。

@example
@group
(if @var{真偽テスト}
    @var{テストが真の場合に実行する動作})
@end group
@end example

@code{type-of-animal} 関数では、@code{if} に関する実際のコードは次のよう
になっている。

@example
@group
(if (equal characteristic 'fierce)
    (message "It's a tiger!")))
@end group
@end example

ここで、真偽テストの部分は次のＳ式である。

@example
(equal characteristic 'fierce)
@end example

@noindent
Lisp では、@code{equal} は最初の引数と二番目の引数が等しいかどうかを判定
する関数である。二番目の引数は引用符つきのシンボル @code{'fierce} であり、
一番目の引数は @code{characteristic} というシンボルの値---つまり、この関
数に渡される引数の値である。

先に行った @code{type-of-animal} の最初の実行では、@code{fierce} が 
@code{type-of-animal} に渡した。@code{fierce} は @code{fierce} と等しい
ので、Ｓ式 @code{(equal characteristic 'fierce)} は真の値を返す。この場
合は、@code{if} は二番目の引数、つまり @code{if} 式の then-part である 
@code{(message "It's tiger!")} を評価する。

一方、@code{type-of-animal} の二番目の実行では @code{zebra} を引数として
渡した。@code{zebra} は @code{fierce} ではないので、then-part は評価され
ず、@code{if} 式は @code{nil} を返す。

@node else, Truth & Falsehood, if, Writing Defuns
@comment  node-name,  next,  previous,  up
@section If--then--else 式
@cindex Else

@code{if} 式は、オプションとして @dfn{else-part} と呼ばれる三番目の引き
数を持つことが出来る。これは真偽テストが偽を返した場合のためのものである。
この場合は @code{if} 式の二番目の引数である then-part は評価@emph{されず}、
代わりに三番目の引数である else-part が評価@emph{される}。このことは、曇
りの日なんかに、「もし、晴れて暖かかったらビーチに行こう。そうでなかった
ら、本でも読むか！」というふうに、代わりの選択肢を考えるのに当てはめてみ
れば納得出来るだろう。

``else'' という単語は Lisp のコードの中には出てこない。単に、else-part 
は @code{if} 式の中の then-part の次にくる要素というだけである。実際に 
Lisp のコードを書く場合、else-part は新しく改行してから then-part よりは
少ないインデントで書き始めるのが普通である。

@example
@group
(if @var{真偽テスト}
    @var{テストが真の場合に実行する動作})
  @var{テストが偽の場合に実行する動作})
@end group
@end example

例えば次の @code{if} 式は、いつも通りに評価すると、@samp{4 is not
greater than 5!} というメッセージを表示するものである。

@example
@group
(if (> 4 5) ; @r{if-part}
    (message "5 is greater than 4!")  ; @r{then-part}
  (message "4 is not greater than 5!")) ; @r{else-part}
@end group
@end example

@noindent
異なるレベルのインデントをすることで、then-part と else-part の区別がし
やすくなることに注意しよう。(GNU Emacs は @code{if} 式を自動的に正しくイ
ンデントするコマンドを幾つか備えている。@ref{Typing Lists, , GNU Emacs
によるリストのタイプの支援}, を参照のこと。)

@code{type-of-animal} の @code{if} 式に新しく else-part の部分を追加する
だけで、この関数を拡張することが出来る。

次のバージョンの @code{type-of-animal} の関数定義を評価してインストール
すれば、その後の、異なる引数を渡すような二つのＳ式を評価して、結果を見る
ことも出来るようになる。

@example
@group
(defun type-of-animal (characteristic) ; @r{二番目のバージョン}
  "Print message in echo area depending on CHARACTERISTIC.  If the
CHARACTERISTIC is the symbol `fierce', then warn of a tiger; else say
it's not fierce."
  (if (equal characteristic 'fierce)
      (message "It's a tiger!")
    (message "It's not fierce!")))
@end group
@end example
@sp 1

@example
(type-of-animal 'fierce)

(type-of-animal 'zebra)
@end example

@c Following sentence rewritten to prevent overfull hbox.
@noindent
@code{(type-of-animal 'fierce)} を評価すると、エコー領域には @code{"It's
a tiger"} と表示されるはずだ。一方、@code{(type-of-animal 'zebra)} を評
価すると、@code{"It's not fierce!"} と表示される。

(勿論、@var{characteristic} が @code{ferocious} (獰猛) であったなら、
@code{"It's not fierce!"} と表示されるが、これは間違いである。コードを書
く場合は、@code{if} によってこのような引数がテストされる可能性を考慮に入
れて、それに応じてプログラムを書かなければならない。)

@node Truth & Falsehood, save-excursion, else, Writing Defuns
@comment  node-name,  next,  previous,  up
@section Lisp における真と偽
@cindex Truth and falsehood in Lisp
@cindex Falsehood and truth in Lisp
@findex nil

@code{if} 式の中の真偽テストについては、触れておかなければならない重要な
側面がある。今までは、真とか偽とかいう言葉を、述語の値としてあたかも新し
い Lisp のオブジェクトとして話してきた。しかし実際は「偽」というのは単に
我々が親しんできた良き友 @code{nil} なのである。そして、その他は全て---
どんなものであっても---「真」である。

真であるか否かテストされるＳ式は、評価した結果が @code{nil} 以外の値であ
れば @dfn{true} と判断される。別の言い方をすると、テストの結果は返された
値が47のような数値や、@code{"hello"} というような文字列、あるいは 
@code{flowers} というような (@code{nil} 以外の) シンボルや、リストであっ
たり、はたまたバッファであったりする場合でも真であると解釈されるわけであ
る。

このことを説明する前に、@code{nil} について説明せねばならないだろう。

Lisp ではシンボル @code{nil} は二つの意味を持つ。一つ目は空リストである。
そして二つ目は偽であり、真偽テストの結果が間違いであった場合に返る値であ
る。@code{nil} は空リストとして @code{()} のように書いても良いし、
@code{nil} と書いてもよい。Lisp にとっては、@code{()} と @code{nil} は全
く同じものである。しかし、人間にとっては @code{nil} は偽を表わすのに使い、
@code{()} は空リストを表わすのに使うのが普通だろう。

Lisp では @code{nil}以外---即ち空リスト以外---の全ての値は真と解釈される。 
これは、評価した時に空リスト以外の何かを返すものは、@code{if} 式のテスト
で真と判断されることを意味する。例えば、もしテストの部分に数値を置いたと
すると、Lisp では数値は評価された時には自分自身を返すように出来ているの
だから、結果としてこの場合の @code{if} 式でのテストは真となる。テストの
結果が偽となるのはＳ式を評価して @code{nil}、即ち、空リストが返る時だけ
である。

次に挙げる二つのＳ式を評価してみることで、このことを確かめることが出来る。

最初の例では、@code{if} 式のテストの結果、数字の4が評価され、その数自身
が返される。結果として then-part が評価され、エコー領域に @samp{true} が
表示される。二番目の例としては、@code{nil} は偽を表わすので 結果として 
else-part が評価され、エコー領域に @samp{false} と表示される。

@example
@group
(if 4
    'true
  'false)
@end group

@group
(if nil
    'true
  'false)
@end group
@end example

ついでながら、もしテストで真を返すような適当な値が見つからなければ、Lisp 
インタプリタは真を表わすためにシンボル @code{t} を返す。例えば、@code{(>
5 4)} は評価された場合 @code{t} を返す。これもいつものようにして確認出来
る。

@example
(> 5 4)
@end example

@noindent
一方、この関数は偽である場合は @code{nil} を返す。

@example
(> 4 5)
@end example

@node save-excursion, Review, Truth & Falsehood, Writing Defuns
@comment  node-name,  next,  previous,  up
@section @code{save-excursion}
@findex save-excursion
@cindex Region, what it is
@cindex Preserving point, mark, and buffer
@cindex Point, mark, buffer preservation
@findex point
@findex mark

関数 @code{save-excursion} は、この章で説明する4番目の、そして最後の特殊
形式である。

編集用の Emacs Lisp プログラムでは、関数 @code{save-excursion} は大変よ
く使用されるものである。これは、ポイントとマークの位置をセーブし、関数の
本体を実行し、そしてその際にポイントとマークの位置が変わったなら、それを
元の位置に戻す。ポイントとマークが意外な場所に動いて、驚いたり、困惑した
りするのを防ぐことがこの関数の主な目的である。

しかしながら、@code{save-excursion} について議論する前に GNU Emacs にお
いて、ポイントとマークがどういうものであるかを復習しておくのが良いだろう。
@dfn{Point} は現在のカーソルの位置である。カーソルが何処にあろうと、それ
がポイントである。より正確に言うと、カーソルが文字の上にあるような端末で
は、ポイントは、その文字の左端の位置にある。Emacs Lisp ではポイントは整
数である。バッファの最初の文字は1であり、二番目の文字は2であり... といっ
た感じだ。関数 @code{point} は現在の位置を数として返す。各々のバッファが
それ自身のポイントの位置を持っている。

@noindent
(訳註：より具体的に言うと、カーソルがバッファの先頭の文字の上にある場合
には、ポイントの値は1になることになる。また、二文字目以降は、日本語等の
場合は事情が変わる。例えば Mule では2バイトコードは3バイトで表現されるの
で、ポイントの数は一文字あたり3ずつずれる勘定になる。)

@dfn{mark} は、ポイントとはまた別の、バッファにおけるある位置を指し示す
ものである。その値は @kbd{C-@kbd{SPC}} (@code{set-mark-command}) で設定
される。マークが設定されている場合、@kbd{C-x C-x}
(@code{exchange-point-and-mark}) を使ってカーソルをマークにジャンプさせ、
以前ポイントがあった場所にマークを設定することが出来る。更に、もし他のマー
クが既にあった場合、以前のマークはマークリングに保存される。多くのマーク
をこうして保存することが出来る。@kbd{C-u C-@kbd{SPC}} とタイプすることで、
以前保存されたマークに順にさかのぼって行くことが出来る。

バッファの中で、ポイントとマークに挟まれた部分を @dfn{リージョン}
(@dfn{region}) と呼ぶ。リージョンに関するコマンドは沢山ある。例えば、
@code{center-region}、@code{count-lines-region}、@code{kill-region}、そ
して @code{print-region} なんかがそうである。

特殊形式 @code{save-excursion} はポイントとマークの位置を保存し、この特
殊形式内の本体部分のコードが Emacs Lisp によって評価された後に、その位置
を復元する。 こうして、例えばポイントがあるテキストの先頭にあり、あるコー
ドがその位置をバッファの最後に移動してしまったとしても、本体部分のＳ式が
評価され終わった後に @code{save-excursion} がポイントを元の位置に戻して
くれる。

Emacs ではユーザーが予期しない所でも、しばしば内部的にポイントの位置を動
かしていることがある。例えば @code{count-lines-region} なんかもポイント
の位置を移動している。予期しない、また(ユーザーの立場からみて)不必要な移
動によってユーザーが煩わされるの防ぐために、@code{save-excursion} は頻繁
に使われる。@code{save-excursion} を使うのは家の中を住み心地の良いものに
しておくことと一緒である。

家の中がきちんと整理されているかどうかを確認するために、
@code{save-excursion} は、たとえ、その内部のコードがうまく動かない場合に
も(専門用語を使ってより正確に言うと、「異常終了した場合にも」)、ちゃんと
ポイントとマークの位置を復元してくれる。この機能は大変役に立つ。

@code{save-excursion} は単にポイントとマークの値を記録するだけでなく、カ
ントバッファも保持していて、それを復元してくれる。これは、バッファを変更
するようなコードを書いても、@code{save-excursion} が元のバッファに戻して
くれることを意味している。実際、@code{append-to-buffer} の中では、
@code{save-excursion} はその目的で使われている。(@ref{append-to-buffer, ,
@code{append-to-buffer} の定義}, 参照。)

@menu
* Template for save-excursion:: 埋めるべきスロットは一つだけ
@end menu

@node Template for save-excursion,  , save-excursion, save-excursion
@comment  node-name,  next,  previous,  up
@subsection @code{save-excursion} 式のテンプレート

@code{save-excursion} のテンプレートは極めて単純である。

@example
@group
(save-excursion
  @var{本体}@dots{})
@end group
@end example

@noindent
関数の本体は一つないしは複数のＳ式であり、それらが順に Lisp インタプリタ
によって評価されていく。もし本体に二つ以上のＳ式があったとすると、
@code{save-excursion} という関数自体の値としては、それらの内最後のＳ式の 
値が返される。他のＳ式は単に副作用として評価されるのである。
@code{save-excursion} 自体は (ポイントとマークを復元するという) 副作用だ
けのために用いられる。

より詳しく書くと、@code{save-excursion} 式のテンプレートは次のように書け
る。

@example
@group
(save-excursion
  @var{本体の一番目の式}
  @var{本体の二番目の式}
  @var{本体の三番目の式}
   @dots{}
  @var{本体の最後の式})
@end group
@end example

@noindent
ここでＳ式は、シンボルそのものか、もしくはリストである。

Emacs Lisp のコードでは、@code{save-excursion} 式は、@code{let} 式の中で
よく使われる。次のような感じだ。

@example
@group
(let @var{変数リスト}
  (save-excursion
    @var{本体}@dots{}))
@end group
@end example
  
@node Review, defun Exercises, save-excursion, Writing Defuns
@comment  node-name,  next,  previous,  up
@section 復習

ここまでの幾つかの章で、かなりの数の関数と特殊形式を紹介してきた。ここで
それらを簡単にまとめておくと同時に、そこでは触れなかった類似の関数なんか
も紹介しておくことにする。

@table @code
@item eval-last-sexp
現在のポイントの位置より前方の最後のＳ式を評価する。通常はＳ式が返す値は
エコー領域に表示されるが、引数つきで呼び出された時だけはカレントバッファ
に表示する。普通は、@kbd{C-x C-e} にバインドされている。

@item defun
関数を定義する。この特殊形式は最大5つの部分からなる。関数の名前、関数に
渡される引数のリスト、説明文字列、オプションのインタラクティブ宣言、そし
て関数定義の本体である。

@need 1250
例)

@example
@group
(defun back-to-indentation ()
  "Point to first visible character on line."
  (interactive)
  (beginning-of-line 1)
  (skip-chars-forward " ¥t"))
@end group
@end example

@item interactive
インタプリタに対してその関数がインタラクティブに使用出来ることを宣言する。
この特殊形式の後に関数に渡す引数に関する情報として複数の部分からなる文字
列が続くことがある。これらの部分の中にはインタプリタに対してその情報を求
めるプロンプトを出すよう要求するものもある。この文字列の中では各々の部分
が改行コード @samp{¥n} によって区切られている。

よく使われるコード文字には、次のようなものがある。

@table @code
@item b
現在存在するバッファ。

@item f
現在存在するファイル。

@item p
数値である 前置引数。(`p' が小文字であることに注意。)

@item r
二つの数値引数としてのポイントとマークを、小さい方を先に並べたもの。この
コード文字のみが二つの引数の列を特定する。(他は一つだけ。)
@end table

コード文字の完全なリストについては @ref{Interactive Codes, ,
Code Characters for @samp{interactive}, elisp, The GNU Emacs Lisp
Reference Manual}, を参照。

@item let
変数リストが @code{let} の本体部分のコードのみに対して使われることを宣言
し、かつ、それらの変数に @code{nil} ないしは指定した初期値を与える。そし
て、@code{let} 式の本体部分にあるＳ式を評価し、その中の最後のＳ式を評価
した値を返す。@code{let} 式の本体の内部では、Lisp インタプリタはその 
@code{let} 式の外部にある同じ名前の変数は見ない。

@need 1250
例)

@example
@group
(let ((foo (buffer-name))
      (bar (buffer-size)))
  (message
   "This buffer is %s and has %d characters."
   foo bar))
@end group
@end example

@item save-excursion 
この特殊形式の本体部分を評価する直前のポイントとマークの位置、及びカレン
トバッファを保存する。そして本体実行後、ポイントとマークの位置及びバッファ
を復元する。

@need 1250
例)

@example
@group
(message "We are %d characters into this buffer."
         (- (point)
            (save-excursion
              (goto-char (point-min)) (point))))
@end group
@end example

@item if
この関数の最初の引数を評価する。そして、もしその値が真であれば、二番目の
引数を評価し、そうでない場合、三番目の引数があればそれを評価する。

特殊形式 @code{if} は@dfn{条件分岐} (@dfn{conditional}) と呼ばれる。
Emacs Lisp には他にも@dfn{条件分岐}があるが、@code{if} はその中でも多分
もっともよく使われるものであろう。

@need 1250
例）

@example
@group
(if (string= (int-to-string 19)
             (substring (emacs-version) 10 12))
    (message "This is version 19 Emacs")
  (message "This is not version 19 Emacs"))
@end group
@end example

@item equal
@itemx eq
二つのオブジェクトが同じであるかどうかをテストする。@code{equal} の方は、
両者が同じ構造と中身を持ちさえすれば、真を返す。一方、@code{eq} の方は、
引数が両方とも実際に同じオブジェクトである時のみ真を返す。
@findex equal
@findex eq

@need 1250
@item <
@itemx >
@itemx <= 
@itemx >=
関数 @code{<} は、最初の引数が二番目の引数よりも小さいかどうかをテストす
る。これと対をなす関数 @code{>} は、最初の引数が二番目よりも大きいかどう
かをテストする。同様に、@code{<=} は最初の引数が二番目の引数以下であるか
どうかを、@code{>=} は最初の引数が二番目の引数以上であるかどうかをテスト
する。どの場合でも引数は両方とも数値でなければいけない。

@item message
エコー領域にメッセージを表示する。このメッセージは一行のみでなければなら
ない。最初の引数は @samp{%s}, @samp{%d}, あるいは @samp{%c} を中に含む文
字列であり、これらはその後に続く引数におきかえられる。@samp{%s} の部分に
入る引数は文字列かシンボルでなければならない。また、@samp{%d} の部分に入
る引数は、数でなければならない。@samp{%c} の所に入る引数も数でなければな
らないが、こちらはそれに対応する ascii コードの文字が表示される。

@item setq
@itemx set
関数 @code{setq} は最初の引数に二番目の引数の値をセットする。最初の引数
は @code{setq} により、自動的に引用符が付けられる。続けて引数のペアを書
いた場合、それらについても同じことをする。もう一方の関数 @code{set} の方
は、二つの引数しか取ることが出来ない。また、その引数は両方ともまず最初に
評価され、その後、二番目の引数を評価して返された値を最初の引数を評価して
返された値にセットする。

@item buffer-name  
引数は持たず、バッファ名前を文字列として返す。

@itemx buffer-file-name
引数は持たず、バッファがビジットしているファイルの名前を返す。

@item current-buffer
Emacs がアクティブであるようなバッファの中身を返す。これはスクリーンに見
えているバッファとは限らない。

@item other-buffer
(@code{other-buffer} に引数として渡したバッファ及び、カレントバッファを
除いて) もっとも最近選択したバッファの中身を返す。

@item switch-to-buffer
Emacs にとってアクティブなバッファを選択し、カレントウィンドウに表示して
ユーザーが見えるようにする。普通は @kbd{C-x b} にバインドされている。

@item set-buffer
これからプログラムを走らせるバッファに Emacs を切り替える。ただし、表示
しているウィンドウはそのままである。

@item buffer-size
カレントバッファの文字数を返す。

@item point
現在のカーソル位置の値をそのバッファの最初の位置からの文字数として返す。

@item point-min
カレントバッファの中で許される最小のポイントの値を返す。ナローイングが有
効でない場合は1である。

@item point-max
カレントバッファの中で許される最大のポイントの値を返す。ナローイングが有
効でない場合はバッファの最後の位置に一致する。
@end table

@need 1500
@node defun Exercises,  , Review, Writing Defuns
@section 練習問題

@itemize @bullet
@item
引数の値を二倍するインタラクティブでない関数を書きなさい。また、それをイ
ンタラクティブにしなさい。

@item
現在の @code{fill-column} の値が関数に渡される引数よりも大きいかどうか判
定し、もしそうなら適当なメッセージを表示するような関数を書きなさい。
@end itemize

@node Buffer Walk Through, More Complex, Writing Defuns, Top
@comment  node-name,  next,  previous,  up
@chapter バッファに関する幾つかの関数

この章では、GNU Emacs で使われている関数を、幾つか詳しく見てみることにす
る。こういうことは、``walk-through'' と呼ばれる。これらの関数は Lisp コー 
ドの例として扱うのであるが、最初の単純化された例を除いて、決して「机上」
のものではない。実際に GNU Emacs で使われている現実のコードである。これ
らの関数定義から多くのことを学ぶことが出来る。この章で説明する関数は、皆
バッファに関連したものである。他のものについては後で学ぶことにしよう。

@menu
* Finding More::                情報の探し方
* simplified-beginning-of-buffer::  @code{goto-char}, @code{point-min}, 
                                そして @code{push-mark} を見てみよう
* mark-whole-buffer::           これは @code{beginning-of-buffer} と殆ど同じ
* append-to-buffer::            これは @code{save-excursion} と
                                @code{insert-buffer-substring} の利用している。
* Buffer Related Review::       復習
* Buffer Exercises::            バッファについての練習問題 
@end menu

@node Finding More, simplified-beginning-of-buffer, Buffer Walk Through, Buffer Walk Through
@section 情報の探し方

@findex describe-function, @r{introduced}
@cindex Find function documentation
この walk-through の中では、新しく出て来た関数はその都度、時には細かく、
時には簡単に、説明することにする。出て来た関数に興味を持った場合は、
@kbd{C-h f} に続けてその関数名をタイプして @kbd{RET} を押せば、どんな 
Emacs Lisp 関数についても何時でも、完全な説明文を見ることが出来る。同様
に変数についても @kbd{C-h v} に続けてその変数名(と @kbd{RET}) を押せば、
その変数の完全な説明文を見ることが出来る。

@cindex Find source of function
また、もしその関数の元のソースを見たくなったら、関数 @code{find-tag} を
使ってその関数に飛ぶことが出来る。まず @kbd{M-.} とタイプし (即ち、
@kbd{META} キーとピリオドキーを同時に押すか、または @kbd{ESC} キーを押し
てからピリオドキーを押し), 出てきたプロンプトに対してソースコードを見た
い関数の名前、例えば @code{mark-whole-buffer} 等、をタイプする。すると、
Emacs はバッファを切り替えて、その関数のソースコードをスクリーンに表示し
てくれる。元のバッファに戻るには、@kbd{C-x b @kbd{RET}} とタイプすれば良
い。

@cindex TAGS table, specifying
@findex find-tag
あなたの使っている Emacs のデフォルトの初期値いかんでは `タグテーブル' 
を指定する必要があるかもしれない。これは @file{TAGS} と呼ばれるファイル
である。@file{emacs/src} ディレクトリにあるファイルを指定することになる
場合が殆どであろう。その場合 @code{M-x visit-tags-table} コマンドを使っ
て、

@file{/usr/local/lib/emacs/19.23/src/TAGS}

などのようにパス名を指定する。@ref{Tags, , Tag Tables, emacs, The GNU
Emacs Manual}, 参照。
また、自分自身のものを作成する方法については @ref{etags, , 自分自身の
@file{TAGS} ファイルの作成}, を見よ。

Emacs Lisp に慣れてしまってからは、ソースコードを眺めるために頻繁に 
@code{find-tag} を使うことになるだろう。そして自分自身の @file{TAGS} テー
ブルを作ることになるはずだ。

@cindex Library, as term for `file'
ついでに付け加えておくと、Lisp コードを含むファイルは便宜上ライブラリ 
(@code{library}) と呼ばれる。このメタファは、一般的なライブラリではなく、
例えば法律とか工学とかのような特定分野のライブラリから来ている。各々の
ライブラリないしはファイルには特定のトピックや動作に関する関数が含まれて
いる。例えば、@file{abbrev.el} には省略等のショートカットキーを扱う関数
が、また @file{help.el} にはオンラインヘルプを扱う関数が収められている、
といった感じである。(時には複数のライブラリが一つの動作に関するコードを
提供していることもある。電子メールを読むためのコードを提供する 
@file{rmail@dots{}} ファイルなんかがそうだ。) @code{The GNU Emacs 
Manual} を見れば、「@kbd{C-h p} コマンドによって標準的な Emacs Lisp ライ
ブラリをトピックをキーワードにして検索することが出来る」と言った記述を
見つけることが出来る。

@node simplified-beginning-of-buffer, mark-whole-buffer, Finding More, Buffer Walk Through
@comment  node-name,  next,  previous,  up
@section 簡略版 @code{beginning-of-buffer} の定義
@findex simplified-beginning-of-buffer

まず @code{beginning-of-buffer} という関数から始めるのが良いであろう。こ
の関数には既に慣れているだろうし、理解するのも易しいからだ。インタラクティ
ブなコマンドとして使われるものであろうと、@code{beginning-of-buffer} は
カーソルをバッファの先頭に移動させ、以前の位置にマークを置く。この関数は
大抵は @kbd{M-<} にバインドされている。

この章では、この関数の短縮されたバージョンを説明することで、これがどうい
うふうに使われることが多いのかを示そう。この短縮版も上に書いたような動作
をするが複雑なオプションは付いていない。完全版については別のセクションで
説明することにする。(@ref{beginning-of-buffer, ,
@code{beginning-of-buffer} の完全な定義}, 参照。)

コードを見る前に、どんな関数定義が含まれているかを考えてみよう。まず、関
数をインタラクティブにするための、即ち @kbd{M-x beginning-of-buffer} と
タイプしたり、あるいは @kbd{M-<} といったキーコードをタイプすることで呼
び出せるようにするためのＳ式を含んでいなければならない。また、バッファの
元の位置にマークするためのコードも必要だ。更にカーソルをバッファの先頭に
移動するコードも入っていなくてはならない。

これがこの関数の短縮版の完全なテキストである。

@example
@group
(defun simplified-beginning-of-buffer ()
  "Move point to the beginning of the buffer; 
leave mark at previous position."
  (interactive)
  (push-mark)
  (goto-char (point-min)))
@end group
@end example

他の関数定義と同様に、この定義も特殊形式 @code{defun} に続く五つの部
分からなっている。

@enumerate
@item
名前: この場合は @code{simplified-beginning-of-buffer}。

@item
引数リスト: この場合は空リスト @code{()}

@item
説明文字列

@item
インタラクティブにするためのＳ式

@item
本体
@end enumerate

@noindent
この関数定義では、引数リストは空である。これは、この関数が引数を必要とし
ないことを意味する。(もっとも完全版の方の定義を見れば、そちらにはオプショ
ンの引数を渡すことが出来ることが分る。)

インタラクティブにするためのＳ式は、Emacs にこの関数がインタラクティブに
使われることを伝えるための物である。今の場合 @code{interactive} は引数を
持たない。というのも @code{simplified-beginning-of-buffer} は引数を必要
としないからである。

関数の本体部分は次の二行からなる。

@example
@group
(push-mark)
(goto-char (point-min))
@end group
@end example

一行目は @code{(push-mark)} というＳ式である。このＳ式が Lisp インタプリ
タによって評価されると、カーソルが何処にあろうと、その位置にマークが設定
される。マークの位置はマークリングに保存される。

二行目は @code{(goto-char (point-min))} である。このＳ式はカーソルをバッ
ファ内での最小ポイント、即ちバッファの先頭に移動する。(あるいは、もし 
ナローイングがかかっていれば、アクセス出来る範囲内での最初の位置に移動す
る。@ref{Narrowing & Widening, , ナローイングとワイドニング}, 参照。)

@code{push-mark} コマンドによって、@code{(goto-char (point-min))} でカー
ソルがバッファの先頭に飛ぶ前に、そのカーソルの位置にマークがセットされる。
結果として、もし元の位置に戻ろうと思えば、@kbd{C-x C-x} によって元の位置
に戻ることが出来る。

これがこの関数定義の全てである!

@findex describe-function
もし、このようなコードを読んでいて @code{goto-char} のようによく知らない
関数に出くわしたとする。その場合には @code{describe-function} コマンドを
使ってこれがどんな関数かを見ることが出来る。このコマンドを使うには、まず 
@kbd{C-h f} とタイプし、次に知りたい関数の名前をタイプしてから @kbd{RET} 
を押せば良い。@code{describe-function} コマンドは @file{*Help*} ウィンド
ウにその関数の説明文字列を表示してくれる。例えば @code{goto-char} の説明
文は次の通りである。

@example
@group
One arg, a number.  Set point to that number.
Beginning of buffer is position (point-min),
end is (point-max).
@end group
@end example

@noindent
(@code{describe-function} はプロンプトを出す時にデフォルトの値としてその
時のカーソルの直前にあるシンボルの値を設定する。従って、カーソルをその関
数の直後に持っていって @kbd{C-h f @key{RET}} とタイプすることも出来る。)

@code{end-of-buffer} 関数についても @code{beginning-of-buffer} とほぼ同
じである。ただし、関数の本体部分で、@code{(goto-char (point-min))} の部
分が @code{(goto-char (point-max))} となっている。

@node mark-whole-buffer, append-to-buffer, simplified-beginning-of-buffer, Buffer Walk Through
@comment  node-name,  next,  previous,  up
@section @code{mark-whole-buffer} の定義
@findex mark-whole-buffer

関数 @code{mark-whole-buffer} も、関数 
@code{simplified-beginning-of-buffer} と同じくらい簡単に理解出来る。
ただし、今回は単純化したものではなく完全な関数を見ることにする。

@code{mark-whole-buffer} 関数は @code{beginning-of-buffer} 関数ほどには
頻繁には使われない。しかし、同じくらい有用である。この関数はポイントをバッ
ファの先頭に、マークをバッファの最後に置くことで、バッファ全体をリージョ
ンとして指定する。また、大抵は @kbd{C-x h} にバインドされている。

@need 1250
この関数の完全なコードは次の通りである。

@example
@group
(defun mark-whole-buffer ()
  "Put point at beginning and mark at end of buffer."
  (interactive)
  (push-mark (point))
  (push-mark (point-max))
  (goto-char (point-min)))
@end group
@end example

他の全ての関数と同様、@code{mark-whole-buffer} も関数定義のテンプレート
にきちんと当てはまっている。このテンプレートは次のようなものだった。

@example
@group
(defun @var{関数名} (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  (@var{インタラクティブ式}@dots{})
  @var{本体}@dots{})
@end group
@end example

この関数の動作であるが、関数名は @code{mark-whole-buffer} である。引数リ
ストが空リスト @samp{()} になっているので、この関数は引数を必要としない
ことが分る。次に説明文字列が来ている。

次の行は @code{(interactive)} である。これをつけると Emacs はこの関数を
インタラクティブに使えるものとみなす。ここら辺のことは前節の
@code{simplified-beginning-of-buffer} 関数の所でも説明した通りである。

@menu
* Body of mark-whole-buffer::   本体は三行しかない
@end menu

@node Body of mark-whole-buffer,  , mark-whole-buffer, mark-whole-buffer
@comment  node-name,  next,  previous,  up
@subsection @code{mark-whole-buffer} の本体

関数 @code{mark-whole-buffer} の本体は次の三行からなる。

@example
@group
(push-mark (point))
(push-mark (point-max))
(goto-char (point-min))
@end group
@end example

この三行のうち最初の行はＳ式 @code{(push-mark (point))} である。

この行は関数 @code{simplified-beginning-of-buffer} の本体の最初の行の 
@code{(push-mark)} と全く同じ働きをする。どちらの場合にも Lisp インタプ
リタはカーソルの現在の位置にマークを設定する。

私には何故 @code{mark-whole-buffer} 関数では @code{(push-mark (point))} 
と書かれ、@code{beginning-of-buffer} 関数では @code{(push-mark)} と書か
れているか分らない。多分、このコードを書いた人は @code{(push-mark)} の引
数は省略可能で、引数を受け取らない場合、デフォルトでは自動的に現在のポイ
ントの位置にマークが設定されるということを知らなかったんだろうと思う。あ
るいはこのＳ式が次の行と同じような構造になるように書いたのかもしれない。
いずれにしてもこの行によって Emacs はポイントの位置を決定し、その位置に
マークを設定する。

@code{mark-whole-buffer} の次の行は @code{(push-mark (point-max))} であ
る。このＳ式は、バッファの中でポイントの数が最大の位置にマークを設定する。
これは大抵はバッファの最後である。(もし、バッファがナローイングされてい
れば、バッファの中のアクセス可能な範囲での最後尾になる。ナローイングにつ
いての詳細は @ref{Narrowing & Widening, , ナローイングとワイドニング}, 
参照。) このマークが設定された時点で、現在のポイントの位置に設定されてい
た、以前のマークは解除される。しかし、Emacs は最近設定されたマークの位置
と同様、その位置を記憶している。もし戻りたければ、@kbd{C-u C-@key{SPC}} 
を二度タイプすることで、その位置に戻ることが出来る。

さて、いよいよ最後の行の @code{(goto-char (point-min))} である。これは 
@code{beginning-of-buffer} と全く同じように書かれている。このＳ式はカー
ソルをバッファの中でポイントが最小の位置に移動させる。つまり、バッファの
先頭(もしくはアクセス可能な範囲での先頭)に移動させるのである。その結果、
ポイントはバッファの先頭に移動し、バッファの最後尾にマークが設定される。
このようにして、バッファ全体がリージョンになる。

@node append-to-buffer, Buffer Related Review, mark-whole-buffer, Buffer Walk Through
@comment  node-name,  next,  previous,  up
@section @code{append-to-buffer} の定義
@findex append-to-buffer

@code{append-to-buffer} コマンドも @code{mark-whole-buffer} コマンドと同
じくらい単純な構造をしている。このコマンドがすることはカレントバッファの
リージョン(つまり、バッファ中のポイントとマークある部分) を指定したバッ
ファに複写することである。

@findex insert-buffer-substring
@code{append-to-buffer} コマンドは、リージョンを複写するのに関数 
@code{insert-buffer-substring} を使う。この関数は名前から察せられる通り、
バッファのある部分から文字からなる文字列、即ち「部分文字列」を取り出して、
それを他のバッファに挿入する。関数 @code{append-to-buffer} の大部分は 
@code{insert-buffer-substring} がうまく動作するような状態に設定すること
に関するものである。このコードはテキストが写されるバッファとそのコピー元
となるリージョンの両方の指定が必要となる。この関数の完全なコードは次の通
りである。

@example
@group
(defun append-to-buffer (buffer start end)
  "Append to specified buffer the text of the region.
It is inserted into that buffer before its point.
@end group

@group
When calling from a program, give three arguments:
a buffer or the name of one, and two character numbers
specifying the portion of the current buffer to be copied."
  (interactive "BAppend to buffer:@: ¥nr")
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (set-buffer (get-buffer-create buffer))
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

この関数は一連のテンプレートが埋められたものと見倣すと理解しやすい。

最も外側のテンプレートは、関数定義のものである。今の場合、次のようになっ 
ている(幾つか既に埋めてあるスロットもある)。

@example
@group
(defun append-to-buffer (buffer start end)
  "@var{説明文字列}@dots{}"
  (interactive "BAppend to buffer:@: ¥nr")
  @var{本体}@dots{})
@end group
@end example

最初の一行は関数の名前とその三つの引数を含んでいる。引数はテキストが複写
される行き先のバッファ及び、複写元のリージョンを指定する @code{start} と 
@code{end} である。

関数の次の部分には簡潔で完全な説明が記されている。

@menu
* append interactive::          二つの部分からなるインタラクティブ式
* append-to-buffer body::       @code{let} 式との組み合わせ
* append save-excursion::       @code{save-excursion} はどう働くか
@end menu

@node append interactive, append-to-buffer body, append-to-buffer, append-to-buffer
@comment  node-name,  next,  previous,  up
@subsection インタラクティブ式 @code{append-to-buffer}

@code{append-to-buffer} という関数はインタラクティブに使われる関数なので、
@code{interactive} 式が必要である。(@code{interactive} について復習する
には、@ref{Interactive, , 関数をインタラクティブにする}, を見よ。)

@example
(interactive "BAppend to buffer:@: ¥nr")
@end example

@noindent
このＳ式は二重引用符に囲まれた引数を持ち、その引数は @samp{¥n} によって
分けられた二つの部分からなっている。

一つ目の部分は @samp{BAppend to buffer:@:} である。ここで、@samp{B} は 
Emacs に対し、この関数に渡すバッファ名を尋ねるように要求している。これに
よって Emacs はミニバッファに @samp{B} に続く文字列---今の場合は 
@samp{Append to buffer:@: }---からなるプロンプトを出して、ユ-ザーに名前
を入力するよう促す。Emacs はこの関数の引数リストにある変数 @code{buffer} 
に、そこで指定されたバッファをバインドするのである。

改行コード @samp{¥n} は引数の最初の部分と二つ目の部分を分けるために用
いられる。@samp{¥n} の次には @samp{r} が続いているが、これは関数の引数リ
ストの中の @code{buffer} に続く二つのシンボル (つまり、@code{start} と 
@code{end}) にポイントとマークの値をバインドすることを示している。

@node append-to-buffer body, append save-excursion, append interactive, append-to-buffer
@comment  node-name,  next,  previous,  up
@subsection @code{append-to-buffer} の本体

関数 @code{append-to-buffer} の本体部分は @code{let} から始まっている。

以前見たように (@ref{let, , @code{let}}, を参照) @code{let} 式の目的は、
@code{let} 式内部だけで使われる変数を一つないしは複数作り、それに初期値
を与えることである。これは、そのような変数は @code{let} 式外部の同じ名前
の変数と混同されることがない、ということを意味している。

@code{let} 式の部分をアウトラインにして @code{append-to-buffer} のテンプ
レートを書いてみる。これによって @code{let} 式がどういうふうに関数に組み込
まれているかが分る。

@example
@group
(defun append-to-buffer (buffer start end)
  "@var{説明文字列}@dots{}"
  (interactive "BAppend to buffer:@: ¥nr")
  (let ((@var{変数} @var{値}))
        @var{本体}@dots{})
@end group
@end example

@code{let} 式は三つの要素を持っている。

@enumerate
@item
シンボル @code{let}。

@item
変数リストの中身。今の場合は二つの要素からなるリスト @code{(@var{variable}
@var{value})} が一つあるだけ。


@item
@code{let} 式の本体。
@end enumerate

関数 @code{append-to-buffer} の中では変数リストは次のようになっている。

@example
(oldbuf (current-buffer))
@end example

@noindent
@code{let} 式のこの部分では、変数 @code{oldbuf} が 
@code{(current-buffer)} を評価して返された値にバインドされる。変数 
@code{oldbuf} は現在作業しているバッファの記録のために使われるものである。

変数リストの要素は一組の括弧に囲まれている。これによって Lisp インタプリ
タは変数リストと @code{let} 式の本体を区別出来るのである。その結果として
変数リストの中の、二つの要素からなるリストであるような要素は更に一組の括
弧によって囲まれることになる。ということで、この行は次のようになる。

@example
@group
(let ((oldbuf (current-buffer)))
  @dots{} )
@end group
@end example

@noindent
ひょっとすると @code{oldbuf} の前に二つの括弧があることに驚くかもしれな
いが、@code{oldbuf} の前の最初の括弧は変数リストの区切りを示すものであり、
次の括弧は二つの要素からなるリスト @code{(oldbuf (current-buffer))} の最
初の括弧であることさえ分れば問題ないだろう。

@node append save-excursion,  , append-to-buffer body, append-to-buffer
@comment  node-name,  next,  previous,  up
@subsection @code{append-to-buffer} の中の @code{save-excursion}

@code{append-to-buffer} の中の @code{let} 式の本体は 
@code{save-excursion} 式からなっている。

関数 @code{save-excursion} はポイントとマークの位置を保存し、
@code{save-excursion} の本体部分のＳ式の実行が完了した時点でそれらを元の
位置に戻す。更に @code{save-excursion} は元々のバッファが何であったかも
憶えていて、そのバッファに戻してくれる。@code{save-excursion} は 
@code{append-to-buffer} の中でこのように使われている。

@cindex Indentation for formatting
@cindex Formatting convention
ついでだが、ここで Lisp の関数の書式としては、通常複数の行に広がって括弧
で閉じられているようなものは全て、最初のシンボルよりも深くインデントされ
ていることに注意しておいた方が良いだろう。今回の関数定義の中では次のよう
に @code{let} 式は @code{defun} よりも深くインデントされている。

@example
@group
(defun @dots{}
  @dots{}
  @dots{}
  (let@dots{}
    (save-excursion
      @dots{}
@end group
@end example

@noindent
このように書式を工夫することで、@code{save-excursion} の本体部分の二行が 
@code{save-excursion} に付随する括弧で囲まれていることが簡単に見てとれる。
同様に、@code{save-excursion} それ自身が @code{let} に付随する括弧で囲ま
れていることもすぐに分る。

@example
@group
(let ((oldbuf (current-buffer)))
  (save-excursion
    (set-buffer (get-buffer-create buffer))
    (insert-buffer-substring oldbuf start end))))
@end group
@end example

関数 @code{save-excursion} の使い方は、次のテンプレートのスロットが埋め
られているものだと思うとよく理解出来るだろう。

@example
@group
(save-excursion
  @var{本体の最初の式}
  @var{本体の二番目の式}
   @dots{}
  @var{本体の最後の式})
@end group
@end example

@noindent
この関数では @code{save-excursion} には二つのＳ式しか含まれていない。そ
の本体は次の通りである。

@example
@group
(set-buffer (get-buffer-create buffer))
(insert-buffer-substring oldbuf start end)
@end group
@end example

関数 @code{append-to-buffer} が評価されると、@code{save-excursion} の本体
部分の二つのＳ式が順に評価される。最後のＳ式の値が @code{save-excursion} 
関数の値として返される。もう一方のＳ式は単に副作用だけのために評価される。

@code{save-excursion} の本体の最初の行は、現在のバッファを 
@code{append-to-buffer} の引数の最初の引数で指定されたものに切り替えるた
めに関数  @code{set-buffer} を使っている。(バッファの切替は副作用である。
前にも言ったように Lisp にとっての副作用こそが我々の主目的であることが多
い。) 二行目がこの関数の本来の作業を行う。

関数 @code{set-buffer} は Emacs の注意をテキストをコピーしようとしている
バッファの方に向けさせる。そのバッファから @code{save-excursion} によっ
て元のバッファに帰ってくるのである。

@example
(set-buffer (get-buffer-create buffer))
@end example

このリストのもっとも内側にあるＳ式は @code{(get-buffer-create buffer)} 
というものである。このＳ式は @code{get-buffer-create} 関数を使っている。
これはその名前のバッファの内容を取り込むか、もし存在しない場合は新しくそ
の名前を持つバッファを作成する。これは @code{append-to-buffer} 関数を使
うことで、それ以前には存在してなかったバッファにもテキストを出力すること
が出来ることを示している。

@code{get-buffer-create} はまた @code{set-buffer} が不必要なエラーに遭遇
するのを防いでもいる。つまり @code{set-buffer} を使う時は行き先のバッファ
が存在している必要があるのだ。もしありもしないバッファを指定したりすると 
Emacs はそこで仕事をやめてしまう。存在しないバッファである場合には 
@code{get-buffer-create} がそのバッファを作ってくれるので、
@code{set-buffer} は常にバッファを得ることが出来るというわけである。

@code{append-to-buffer} の最後の行はテキストを追加する働きをする。

@example
(insert-buffer-substring oldbuf start end)
@end example

@noindent
関数 @code{insert-buffer-substring} は最初の引数で指定されたバッファ
@emph{から}文字列をコピーし、それを現在のバッファに挿入する。今の場合は 
@code{insert-buffer-substring} の引数は @code{let} で生成されバインドさ
れた変数 @code{oldbuf} の値であり、これは @code{append-to-buffer} コマン
ドを実行した時点でのカレントバッファである。

@code{insert-buffer-substring} が作業を終えると、@code{save-excursion} 
が元のバッファに戻してくれる。そうして @code{append-to-buffer} の仕事は
完了する。

骨組みだけ書くと、本体部分がやっていることは次の通りである。

@example
@group
(let (@code{oldbuf}@var{を}@code{current-buffer}@var{の値にバインド})
  (save-excursion                       ; @r{バッファの状態の保存}
    @var{バッファ切替}
    @var{現在のバッファに}@code{oldbuf}@var{から部分文字列を挿入})

  @var{終わったら元のバッファに戻る}
@var{終了後は}@code{oldbuf}@var{の局所的な意味は消え去る}

@end group
@end example

以上まとめると、@code{append-to-buffer} は次のような働きをする。まずはカ
レントバッファの値を @code{oldbuf} という変数に保存する。次に別のバッファ
をユーザーから聞き出し、もし必要なら新規に作成して、そのバッファに移る。
@code{oldbuf} の値を利用して元のバッファのリージョン内のテキストを取り出
し新しいバッファに挿入する。そして最後に @code{save-excursion} を用いて
元のバッファに戻る。

@code{append-to-buffer} を見ていく中で、かなり複雑な関数を探検したことと
思う。@code{let} や @code{save-excursion} の使い方も見られたし、複数のバッ
ファ間の行き来の仕方も見た。他の多くの関数定義の中でもこのようにして 
@code{let}, @code{save-excursion}, そして @code{set-buffer} を利用している。

@node Buffer Related Review, Buffer Exercises, append-to-buffer, Buffer Walk Through
@comment  node-name,  next,  previous,  up
@section 復習

ここで、この章で議論した様々な関数について簡単にまとめておく。

@table @code
@item describe-function  
@itemx describe-variable
関数ないしは変数の説明文字列を表示する。通常は、@kbd{C-h f} と 
@kbd{C-h v} にバインドされている。

@item find-tag
関数のソースや変数を含むファイルを探して、そのバッファに移り、その関数や
変数が定義されている位置にポイントを移動する。通常は @kbd{M-.} にバイン
ドされている。(これは、@key{META} キーを押して終止符を押すという意味で
ある。)

@item save-excursion
ポイントとマークの位置を保存し、@code{save-excursion} の引数が評価された
後で、それらの値を元に戻す。また、カレントバッファも憶えていて、そのバッ
ファに戻してくれる。

@item push-mark
マークを現在の位置に設定し、直前のマークの値を、マークリングに記録する。
このマークは、バッファ内の位置を示し、たとえそのバッファにテキストが追加
されたり削除されたりしても、その相対的な位置を保持してくれる。

@item goto-char
ポイントを引数の値で指定された位置に移動する。引数は数値あるいはマーカ、も
しくは @code{(point-min)} のように位置を表わす数値を返すようなＳ式でなけれ
ばならない。

@item insert-buffer-substring
この関数に引数として渡されたバッファのリージョンを現在のバッファに挿入す
る。

@item mark-whole-buffer
バッファ全体をリージョンに設定する。普通は @kbd{C-x h} にバインドされて
いる。

@item set-buffer
Emacs が注目しているバッファを他のバッファに切り替える。が、ディスプレイ
しているウィンドウは変更しない。人間が他のバッファで作業したい時よりかは
プログラムの中でよく使われるものである。

@item get-buffer-create  
@itemx get-buffer
ある名前を持つバッファを見つける。その名前のバッファが無い場合は新しく作
る。@code{get-buffer} はもしその名前のバッファが無い場合には @code{nil} 
を返す。
@end table

@need 1500
@node Buffer Exercises,  , Buffer Related Review, Buffer Walk Through
@section 練習問題

@itemize @bullet
@item
あなた自身の @code{simplified-end-of-buffer} を書きなさい。そして、それ
が実際に動くことかどうかテストしてみなさい。

@item
@code{find-tag} を利用して、@code{copy-to-buffer} 関数のソースを見つけな
さい。
@end itemize

@node More Complex, Narrowing & Widening, Buffer Walk Through, Top
@comment  node-name,  next,  previous,  up
@chapter もう少し複雑な関数

この章では、前の章で学んだことを基礎により複雑な関数を見ていくことにする。
@code{copy-to-buffer} 関数は、一つの定義の中で @code{save-excursion} を
二回使う方法を示してくれる。一方、@code{insert-buffer} 関数の方は 
@code{interactive} 式の中での @key{*} の使い方と、@code{or} の使い方、
そして、オブジェクトの名前と、その名前のついたオブジェクトとの違いについ
て教えてくれる。

@menu
* copy-to-buffer::              @code{set-buffer} と @code{get-buffer-create} を利用
* insert-buffer::               書き込み不可 と @code{or} の使い方
* beginning-of-buffer::         @code{goto-char}, @code{point-min}, そし
                                て @code{push-mark} を見てみる
* Second Buffer Related Review::  バッファについての練習問題(その２)
* &optional Exercise ::         &optional の練習問題
@end menu

@node copy-to-buffer, insert-buffer, More Complex, More Complex
@comment  node-name,  next,  previous,  up
@section @code{copy-to-buffer} の定義
@findex copy-to-buffer

@code{append-to-buffer} がどのように動作するかを理解した後であれば、
@code{copy-to-buffer} の方も簡単に理解出来る。この関数はテキストを他のバッ
ファにコピーする。ただし、そのバッファに付け加えるのではなく、以前あった
テキストを置き換えてしまう。@code{copy-to-buffer} 関数のコードは 
@code{append-to-buffer} のコードとほぼ同じであるが、@code{erase-buffer} 
を使い、また @code{save-excursion} を二回使っている点が違う。
(@code{append-to-buffer} の説明については @ref{append-to-buffer, ,
@code{append-to-buffer} の定義}, を参照。)

@code{copy-to-buffer} の本体は次の通りである。

@example
@group
@dots{}
(interactive "BCopy to buffer:@: ¥nr")
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (set-buffer (get-buffer-create buffer))
      (erase-buffer)
      (save-excursion
        (insert-buffer-substring oldbuf start end)))))
@end group
@end example

このコードは @code{append-to-buffer} とそっくりである。
@code{append-to-buffer} の定義との違いが現れるのは、テキストがコピーされ
るバッファに移ってからである。つまり、この後 @code{copy-to-buffer} 関数
では以前の内容を消去してしまう。(これが、「置き換え」と言った意味である。
Emacs ではテキストを置き換える場合、以前の内容をまず消去し、次に新しいテ
キストを挿入する。) 以前の内容を消去した後、もう一度 
@code{save-excursion} が使われる。そして新しいテキストが挿入される。

何故 @code{save-excursion} が二回も使われるのか？ それを理解するために、
もう一度この関数が何をやっているか見てみよう。

@need 1250
大ざっぱには、@code{copy-to-buffer} の本体は次のようになっている。

@example
@group
(let (@code{oldbuf}@var{を}@code{current-buffer}@var{の値にバインド})
  (save-excursion         ; @r{最初の @code{save-excursion}。}
    @var{バッファ切替}
      (erase-buffer)
      (save-excursion     ; @r{二番目の @code{save-excursion}。}
        @var{現在のバッファに}@code{oldbuf}@var{から部分文字列を挿入})))
@end group
@end example

最初の @code{save-excursion} は Emacs にテキストのコピー元のバッファを返
している。これは当たり前のことで、@code{append-to-buffer} でも同じような
使われ方をしていたのだった。では何故二番目が必要なのか？ 理由は、
@code{insert-buffer-substring} が常にポイントを挿入されたリージョンの
@emph{最後}に移動してしまうからである。二番目の @code{save-excursion} 
があるおかげで、Emacs は挿入されたテキストの最初の位置にポイントを移動す
る。大抵の状況では、ユーザーは挿入されたテキストの最初の位置にポイントが
あるほうを好むものである。(勿論、@code{copy-to-buffer} 関数は終了時に元
居たバッファに戻る---しかし、もしユーザが@emph{次に}コピー先のバッファに
移ったとすると、ポイントはそのテキストの先頭に移動してくれるというわけで
ある。このように、二番目の @code{save-excursion} はちょっぴり気の効いた
働きをしてくれるものなのだ。)

@node insert-buffer, beginning-of-buffer, copy-to-buffer, More Complex
@comment  node-name,  next,  previous,  up
@section @code{insert-buffer} の定義
@findex insert-buffer

@code{insert-buffer} もまた、バッファに関する関数である。このコマンドは
他のバッファをカレントバッファの@emph{中に}挿入する。これは 
@code{append-to-buffer} や @code{copy-to-buffer} と逆である。これらの方
は、カレントバッファ@emph{から}リージョンを取り出して他のバッファにコピー
するのであった。

更に、このコードは @dfn{read-only} なバッファに関する @code{interactive} 
の使い方や、オブジェクトの名前と、その名前のついたオブジェクトそのものと
の違いの重要性を理解させてくれる。これがそのコードである。

@example
@group
(defun insert-buffer (buffer)
  "Insert after point the contents of BUFFER.
Puts mark after the inserted text.
BUFFER may be a buffer or a buffer name."
  (interactive "*bInsert buffer:@: ")
@end group
@group
  (or (bufferp buffer)
      (setq buffer (get-buffer buffer)))
  (let (start end newmark)
    (save-excursion
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
@end group
@group
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark)))
@end group
@end example

他の関数定義と同様に、テンプレートを使ってこの関数のアウトラインを見るこ
とが出来る。

@example
@group
(defun insert-buffer (buffer)
  "@var{説明文字列}@dots{}"
  (interactive "*bInsert buffer:@: ")
  @var{本体}@dots{})
@end group
@end example

@menu
* insert interactive expression::  書き込み不可の状態の時の動作
* insert-buffer body::          本体には @code{or} と @code{let} がある
* if & or::                     @code{or} の代わりに @code{if} を使う
* insert or::                   @code{or} 式の動作について
* insert let::                  二つの @code{save-excursion} 式
@end menu

@node insert interactive expression, insert-buffer body, insert-buffer, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection @code{insert-buffer} の中のインタラクティブ式
@findex interactive, @r{example use of}

@code{insert-buffer} ではインタラクティブ宣言の引数には二つの部分がある。
一つはアスタリスク @samp{*} であり、もう一つは @samp{bInsert buffer:@: } 
である。

@menu
* read-only buffer::            書き込み不可のバッファでは
* b for interactive::           
@end menu

@node read-only buffer, b for interactive, insert interactive expression, insert interactive expression
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec 書き込み不可のバッファ
@cindex Read-only buffer
@cindex Asterisk for read-only buffer
@findex * @r{for read-only buffer}

アスタリスクはバッファが read-only---つまり変更出来ないバッファである場合
のためのものである。もし、@code{insert-buffer} が read-only なバッファで呼
ばれた場合、エコー領域にその旨を知らせるメッセージが表示され、ビープ音が
鳴るか、画面が明滅する。「あなたはこのバッファに如何なるものも挿入しては
いけませんよ」というわけである。アスタリスクの後には、次の引数と分離するた
めに改行コードを付ける必要はない。

@node b for interactive,  , read-only buffer, insert interactive expression
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec インタラクティブ式の中の @samp{b}

インタラクティブ式の次の引数は小文字の @samp{b} から始まっている。(これ
は @code{append-to-buffer} のコードの中のとは違うことに注意。こっちでは
大文字の @samp{B} を使っていたのだった。@ref{append-to-buffer, ,
@code{append-to-buffer} の定義}, 参照。)
小文字の @samp{b} は Lisp インタプリタに @code{insert-buffer} の引数が存
在するバッファないしは、その名前でなければならないことを示している。(大
文字の @samp{B} オプションの方は存在しないバッファであっても良い。)
Emacs はプロンプトを出してバッファの名前を要求し、同時にデフォルトのバッ
ファも提示してくれる。名前の補完もやってくれる。もし、ここで存在しないバッ
ファを指定すると、``No match'' というメッセージを受け取る。端末によって
はビープ音がするかもしれない。

@node insert-buffer body, if & or, insert interactive expression, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection 関数 @code{insert-buffer} の本体部分

関数 @code{insert-buffer} の本体は、主に二つの部分からなっている。一つは 
@code{or} 式であり、もう一つは @code{let} 式である。@code{or} 式を使う目
的は、引数 @code{buffer} がバッファの名前ではなくちゃんとバッファそのも
のにバインドされていることを確認することである。@code{let} 式の本体は、
他のバッファをカレントバッファに挿入するコードを含んでいる。

@need 1250
大まかに言って、二つのＳ式は次のように @code{insert-buffer} 関数の中に組
み込まれている。

@example
@group
(defun insert-buffer (buffer)
  "@var{説明文字列}@dots{}"
  (interactive "*bInsert buffer:@: ")
  (or @dots{}
      @dots{}
@end group
@group
  (let (@var{変数リスト})
      @code{let}@var{の本体}@dots{} )
@end group
@end example

引数 @code{buffer} がバッファの名前ではなくバッファそのものにバインドさ
れているかを @code{or} 式がどのようにして確かめているかを理解するには、
最初に関数 @code{or} を理解する必要がある。

が、その前にまずこの部分を @code{if} を使って書き直してみたい。そうすれ
ばより身近な方法で何がなされているかを見ることが出来るだろう。

@node if & or, insert or, insert-buffer body, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection @code{or} の代わりに @code{if} を使った @code{insert-buffer}

やるべき仕事は @code{buffer} の値がバッファそのものであり、バッファ名で
はないことを確認することである。もし値が名前であったら、その名前のついた
バッファを持ってこないといけない。

まずあなたが何かのコンファレンスに参加しており、案内係があなた方の名前が
書かれたリストをもってあなたを探している状況を思い浮かべて欲しい。この状
態では案内係はあなた自身ではなく、あなたの名前に「バインド」されている。
しかし、案内係があなたを見つけてあなたの腕を取った時点で、案内係はあなた
自身に「バインド」されたことになる。

Lisp ではこの状況を次のように説明出来る。

@example
@group
(if (not (お客をつかまえている))
    (お客を見つけて腕を取る))
@end group
@end example

我々はこれと同じことをバッファについてやりたいわけである---バッファそのも
のでない場合も、バッファを見つけて取って来たいのだ。

@code{bufferp} という(バッファの名前ではなく)バッファかどうかを判定して
くれる述語を使うと、このコードを次のように書くことが出来る。

@example
@group
(if (not (bufferp buffer))              ; @r{if-part}
    (setq buffer (get-buffer buffer)))  ; @r{then-part}
@end group
@end example

@noindent
コメントにもあるが、上の式で、@code{if} 式の真偽テストの部分は 
@w{@code{(not (bufferp buffer))}} であり、一方 then-part の部分は 
@w{@code{(setq buffer (get-buffer buffer))}} である。

このテストの中では @code{bufferp} 関数は引数がバッファであれば真の値を返
す---しかしバッファの名前であれば偽の値を返す。(@code{bufferp} という関
数の名前の最後は @samp{p} で終わっている。以前見たようにこの @samp{p} は、
この関数が述語、つまり、ある性質を持つか否かを判定する関数であることを示
すための工夫として付けられている。
@ref{Wrong Type of Argument, , 関数に間違った型の引数を与えると}, を参照
のこと。)

@code{(bufferp buffer)} 式の前には関数 @code{not} がある。即ち
真偽テストは次の通りである。

@example
(not (bufferp buffer))
@end example

@noindent
@code{not} は引数が偽であれば真を返し、偽であれば真を返す関数である。従っ
て、もし @code{(bufferp buffer)} が真を返せば、@code{not} 式が偽を返すし、
偽を返せば真を返す。「真でない」というのは偽ということだし、「偽でない」
というのは真だというわけである。

@code{if} は、このテストを使って次のように動作する。変数 @code{buffer} 
の値がバッファの名前ではなく実際にバッファだった場合、真偽テストの結果
は偽である。すると、@code{if} 式は then-part を評価しない。これはまとも
な動作である。というのは、もし変数 @code{buffer} が本当にバッファであれ
ば、これに対して特に何もする必要はないからである。

一方で、@code{buffer} の値がもしバッファそのものではなくバッファの名前で
あったとすると、真偽テストでは真が返り、結果として then-part が評価される。
今の場合、then-part は @code{(setq buffer (get-buffer buffer))} である。
このＳ式は、その名前のついた実際のバッファを得るために @code{get-buffer} 
関数を使っている。そして、@code{setq} で、変数 @code{buffer} の値をバッ
ファの名前から実際のバッファそのものに置き換えている。

@node insert or, insert let, if & or, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection 本体部分の @code{or}

@code{insert-buffer} 関数で @code{or} 式を使う目的は引数 @code{buffer} 
がバッファの名前ではなくバッファそのものにバインドされているかどうかを確
認することにある。前節で、どのようにして @code{if} を使ってこの作業をす
るかを見た。しかし、@code{insert-buffer} 関数では実際は @code{or} を使っ
ている。この理由を理解するには、@code{or} 関数の働きを理解しなければなら
ない。

@findex or
関数 @code{or} はいくらでも引数を持つことが出来る。この関数は各引数を順に
評価していき、@code{nil} でなかった最初の引数の値を返す。また、これが 
@code{or} の重要な特徴なのだが、この関数は引数で @code{nil} 以外の値を返
すものがあった場合、その後の引数はもはや評価しない。

今の場合の @code{or} 式は次の通りである。

@example
@group
(or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
@end group
@end example

@noindent
@code{or} の最初の引数は Ｓ式 @code{(bufferp buffer)} である。この式は、
もし buffer がバッファそのものでありバッファの名前ではない場合は、真を返
す。@code{or} 式では、この場合、@code{or} 式の値として真を返し、その後の
引数は評価されない---我々にはこの方が都合が良い。というのもこの場合には 
つまり @code{buffer} が真のバッファである場合には、この値について何もす
る必要がないからである。

一方で、もし @code{(bufferp buffer)} が @code{nil} であれば、それは 
@code{buffer} の値がバッファの名前であるということである。この場合、Lisp 
インタプリタは @code{or} 式の次の引数も評価する。これは @code{(setq
buffer (get-buffer buffer))} という式である。この式は値 @code{nil} を返
す。これが変数 @code{buffer} にセットされた値である---そしてこの値はバッ
ファそのものであり、バッファの名前ではない。

以上のことから、シンボル @code{buffer} は常に、あるバッファの名前ではな
くバッファそのものにバインドされることになる。また、以上の手続きは全てが
必要なことである。というのも、次の行の @code{set-buffer} 関数はバッファ
に対してしか働かないからである。

@need 1250
ついでだが、@code{or} を使った場合、案内係というのは次のように書ける。

@example
(or (お客をつかまえている) (お客を見つけて腕を取る))
@end example

@node insert let,  , insert or, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection @code{insert-buffer} の中の @code{let} 式

@code{insert-buffer} 関数では、変数 @code{buffer} がバッファの名前ではな
くバッファそのものを表わすことを確認した後には、 @code{let} 式が続く。
ここでは三つの変数 @code{start}, @code{end}, @code{newmark} を指定してい
る。これらの変数は @code{let} 式の内部でのみ使われ、@code{let} 式の評価
が終わるまでの間は、一次的に Emacs 内の同じ名前の他の変数は隠されている。

@code{let} 式の本体は二つの @code{save-excursion} を使っている。まずは、
内側にある方の @code{save-excursion} 式を細かく見ていこう。この式は次の
通りである。

@example
@group
(save-excursion
  (set-buffer buffer)
  (setq start (point-min) end (point-max)))
@end group
@end example

@noindent
Ｓ式 @code{(set-buffer buffer)} は、Emacs が注目するバッファをテキストが
コピー元のバッファに切り替える。このバッファの中で、@code{point-min} コ
マンド及び、@code{point-max} コマンドを使って変数 @code{start} と 変数 
@code{end} に各々バッファの始まりと終わりの位置を設定する。@code{setq} 
を使って、一つのＳ式で二つの変数を同時に設定する方法についてはもう既に説
明したのだった。@code{setq} の最初の引数は二番目の値に、三番目の引数は四
番目の引数の値にセットされる。

@need 1250
外側の @code{save-excursion} 式は次の通りである。

@example
@group
(save-excursion
  (@var{内側の}@code{save-excursion}@var{式}
     (@var{新しいバッファに移動し}@code{start}@var{と}@code{end}@var{をセット})
  (insert-buffer-substring buffer start end)
  (setq newmark (point)))
@end group
@end example

@noindent
関数 @code{insert-buffer-substring} は @code{buffer} @emph{から}、その中
の@code{start} と @code{end} で指定されたリージョン内のテキストを、カレ
ントバッファの@emph{中に}コピーする。今の場合、コピー元のバッファ全体が 
@code{start} と @code{end} の間にあるために、そのバッファ全体が現在編集
中のバッファにコピーされることになる。次に、この時点で挿入されたテキスト
の最後にあるポイントの値が、変数 @code{newmark} に記録される。

外側の @code{save-excursion} の本体が評価された後、ポイントとマークの位
置は元の位置に戻される。

しかしながら、ポイントとマークの位置は新しく挿入されたテキストの最初と最
後にある方が、何かと都合が良い。@code{newmark} 変数は挿入されたテキスト
の最後の位置を記録する。@code{let} 式の最後の行で @code{(push-mark
newmark)} というＳ式でマークをこの位置に設定している。(以前のマークの位
置に移動することも可能である。この値はマークリングに保存されていて、
@kbd{C-u C-@key{SPC}} で遡ることが出来る。) 一方、ポイントの方は初めから
挿入されたテキストの最初の位置にある。これは @code{insert} 関数を呼び出
す前のポイントの位置がここだからである。

@need 1250
完全な @code{let} 式は次の通りである。

@example
@group
(let (start end newmark)
  (save-excursion
    (save-excursion
      (set-buffer buffer)
      (setq start (point-min) end (point-max)))
    (insert-buffer-substring buffer start end)
    (setq newmark (point)))
  (push-mark newmark))
@end group
@end example

@code{append-to-buffer} 関数の時と同じように、@code{insert-buffer} 関数
も @code{let}, @code{save-excursion}, そして @code{set-buffer} を使って
いる。それに加えて、この関数は @code{or} の使い方の一つも教えてくれてい
る。これらの関数は皆大切な部品であり、これから何度でも出てくることだろう。

@node beginning-of-buffer, Second Buffer Related Review, insert-buffer, More Complex  
@comment  node-name,  next,  previous,  up
@section @code{beginning-of-buffer} の完全な定義
@findex beginning-of-buffer

@code{beginning-of-buffer} 関数の基本的な構造については、既に議論したこ
とがあるのだった。(@ref{simplified-beginning-of-buffer, , 簡略版
@code{beginning-of-buffer} の定義}.) このセクションではこの定義の複雑な
部分を説明することにする。

以前説明した通り、引数無しで @code{beginning-of-buffer} を呼び出すと、そ
の時点でのポイントの位置にマークを設定して、カーソルがバッファの先頭に移
動する。しかしながら、もしこのコマンドが1から10までの数と一緒に呼び出さ
れた場合、この関数はバッファ全体を10としてこの数の割合の分を計算し、バッ
ファの先頭からその割合の分だけ進んだ位置にカーソルを移動させる。というわ
けで、@kbd{M-<} でこのコマンドを呼び出せば、カーソルはバッファの先頭に移
動するし、もし例えば @kbd{C-u 7 M-<} として呼び出せば、カーソルはバッファ
全体の70%分の位置にポイントを移動する。もし引数が10より大きかった場合は
バッファの最後に位置に移動する。

@code{beginning-of-buffer} 関数は、引数無しで呼び出すことが出来る。つま
り、引数は省略可能である。

@menu
* Optional Arguments::          
* beginning-of-buffer opt arg:: 省略可能引数の例
* beginning-of-buffer complete:: 完全版
@end menu

@node Optional Arguments, beginning-of-buffer opt arg, beginning-of-buffer, beginning-of-buffer
@subsection 省略可能な引数

特にそうでないと言われない限り、Lisp は、関数定義で引数が指定された関数
はその引数のための値とともに呼ばれるものと思っている。もし、そうでなかっ
た場合、エラーが出され、@samp{Wrong number of arguments} というメッセー
ジを受け取ることになる。

@cindex Optional arguments
@cindex Keyword
@findex optional
しかしながら、Lisp の特徴として省略可能引数というものがある。ある 
@dfn{キーワード} (@dfn{keyword}) を使うと Lisp インタプリタにその引数が
省略可能だと伝えることが出来るのだ。そのキーワードとは @code{&optional} で
ある。(@samp{optional} の前の @samp{&} もこのキーワードの一部分である。)
関数定義の中でこのキーワード @code{&optional} の後に続く引数は、関数が呼
ばれる際に必ずしも値を渡される必要はない。

というわけで、@code{beginning-of-buffer} の関数定義の最初の行は次のように
なる。

@example
(defun beginning-of-buffer (&optional arg)
@end example

@need 1250
また、関数定義全体のアウトラインは次のようになっている。

@example
@group
(defun beginning-of-buffer (&optional arg)
  "@var{説明文字列}@dots{}"
  (interactive "P")
  (push-mark)
  (goto-char 
    (@var{もし引数があれば}
        @var{どこへ行けばよいか調べる}
      @var{そうでなければ次の場所に}
      (point-min))))
@end group
@end example

この関数は @code{simplified-beginning-of-buffer} と似ている。違うのは、
@code{interactive} 式に @code{"P"} が引数として使われていることと、
引数が指定されている場合にカーソルを何処に移動するかを判断する 
@code{goto-char} 関数に続いて if-then-else 式が来ていることである。

@code{interactive} 式の中の @code{"P"} は、Emacs に、関数に前置
引数を渡すように伝えるものである。前置引数というのは 
@kbd{META} キーに続いて数をタイプするか、@kbd{C-u} に押してから数をタイ
プすることで作ることが出来る。(もし @kbd{C-u} に続いて数を入力しない場合
には、デフォルトとして4が渡される。)

@code{if} 式の真偽テストの部分は単純である。単に @code{arg} だけだ。もし、
@code{arg} が @code{nil} 以外の値を持てば、即ち
@code{beginning-of-buffer} が引数付きで呼ばれた場合は、真偽テストでは
真が返り、@code{if} 式の then-part が評価される。一方、もし 
@code{beginning-of-buffer} が引数とともに呼ばれなかったなら、@code{arg} 
の値は @code{nil} になり、@code{if} 式の else-part の方が評価される。
else-part は単に @code{point-min} であり、この場合には 
@code{goto-char} 式の全体は @code{(goto-char (point-min))} になる。
これは、以前の短縮版 @code{beginning-of-buffer} 関数で見た通りである。

@node beginning-of-buffer opt arg, beginning-of-buffer complete, Optional Arguments, beginning-of-buffer
@subsection 引数付きで呼び出された場合の @code{beginning-of-buffer} 

@code{beginning-of-buffer} が引数付きで呼び出された場合は、
@code{goto-char} に渡す値を計算する、あるＳ式が評価される。このＳ式は、
ちょっと見にはかなり複雑に見える。内部に @code{if} 式を含んでいるし、算
数を沢山使っている。実際のコードは次の通りである。

@example
@group
(if (> (buffer-size) 10000)
    ;; @r{バッファサイズが大きい場合のオーバーフローを避ける！}
    (* (prefix-numeric-value arg) (/ (buffer-size) 10))
  (/
   (+ 10
      (*
       (buffer-size) (prefix-numeric-value arg))) 10))
@end group
@end example

しかし、他の複雑そうなＳ式と同様に、これもテンプレートに当てはめてみれば
理解しやすくなる。この場合は、if-then-else 式のテンプレートに当てはめる。
骨組みは次のようになる。

@example
@group
(if (@var{バッファが大きいなら}
    @var{バッファのサイズを10で割り引数を掛ける}
  @var{そうでなければ別の計算をする}
@end group
@end example

この中の @code{if} 式の真偽テストはバッファのサイズをチェックしている。
その理由は、Emacs Lisp の version 18 は約8,000,000以下の数値しか扱わない
のだが(そんなに大きな数は必要ない)、この計算に従うと、大きなバッファの場
合は Emacs は大き過ぎる数を扱うことになってしまうからだ。コードのコメン
トの中に出てくる「オーバーフロー」とは数が大き過ぎることを意味している。

ということで、バッファが大きい場合と、そうでない場合の二つに分けている。

@menu
* large-case::                  大きなバッファでの割り算と掛け算
* small-case::                  括弧の中に何があるか
@end menu

@node large-case, small-case, beginning-of-buffer opt arg, beginning-of-buffer opt arg
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec 大きなバッファの場合

@code{beginning-of-buffer} の中で内側にある方の @code{if} 式はバッファの
サイズが10,000文字を越えているかどうかをテストしている。そのために、
@code{>} と @code{buffer-size} という関数を使っている。
その行は次の通りである。

@example
(if (> (buffer-size) 10000)
@end example

@noindent
もしバッファが大きい場合は、@code{if} 式の then-part が評価される。この
部分を読みやすいよう書き直すと次のようになる。

@example
@group
(* 
  (prefix-numeric-value arg) 
  (/ (buffer-size) 10))
@end group
@end example

@noindent
このＳ式は乗法であり、二つの引数を関数 @code{*} に渡している。

最初の引数は @code{(prefix-numeric-value arg)} である。
@code{interactive} 宣言で @code{"P"} が指定されている場合、引数は関数に
「未処理の前置引数」(raw prefix argument) として渡され、数値としては渡さ
れない。(リストの中では数値である。) 算数で使えるようにするには変換する
必要があり、その仕事を @code{prefix-numeric-value} がやっているのである。

@findex / @r{(division)}
@cindex Division

二番目の引数は @code{(/ (buffer-size) 10)} である。この式は数値としての
バッファの値を10で割る。これはバッファサイズの一割にどれだけの文字数が含
まれているかを計算するものだ。(Lisp では @code{/} は除法に使われる。
@code{*} が乗法に使われるのと同様である。)

乗法の式全体としては、この値に前置引数の値を掛けることになる---こんな感
じだ。

@c @example
@c @group
@c (* @var{numeric-value-of-prefix-arg}
@c    @var{number-of-characters-in-one-tenth-of-the-buffer})
@c @end group
@c @end example
@example
@group
(* @var{数値としての前置引数}
   @var{バッファの10分の1の文字数})
@end group
@end example

@noindent
(訳註：ここでの文字数とは勿論 ASCIIコードでの話で、日本語等の多バイト文
字が入ると話はまた違ってくる。)

@noindent
例えば、仮に前置引数が @samp{7} だったとするなら、この10分の1の数に7を掛
けることで、バッファの中の70%の位置が得られることになる。

結局、バッファが大きい場合の @code{goto-char} 式全体は次のようになる。

@example
@group
(goto-char (* (prefix-numeric-value arg)
              (/ (buffer-size) 10)))
@end group
@end example

これでカーソルは望む場所に移動してくれる。

@node small-case,  , large-case, beginning-of-buffer opt arg
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec 小さなバッファの場合

バッファが10,000文字よりも小さかった場合は、ちょっと違った計算方法が取ら
れる。さっきの方法でも出来るのだから、こんなことをする必要はないと思うか
もしれない。しかし、バッファが小さい場合、初めの方法ではカーソルを望む場
所にきちんと移動してくれない。次に説明する二番目の方法の方がちゃんとした
仕事をしてくれる。

コードは次の通りである。

@c Keep this on one line.  Put into smallexample if necessary.
@example
(/ (+ 10 (* (buffer-size) (prefix-numeric-value arg))) 10))
@end example

@noindent
このコードの中で何をしているかは、括弧の中にどのように関数が埋め込まれて
いるかを見れば分る。各々の式をそれを含む括弧より深くインデントしてやれば、
より見やすくなる。

@example
@group
  (/
   (+ 10
      (*
       (buffer-size)
       (prefix-numeric-value arg)))
   10))
@end group
@end example

@noindent
これらの括弧を見ると、もっとも内側にある関数は 
@code{(prefix-numeric-value arg)} であることが分る。これは未処理の
前置引数を数値に変換するものである。この数値は次の式によってバッファサイズと
掛け合わされる。

@example
(* (buffer-size) (prefix-numeric-value arg)
@end example

@noindent
この掛け算では、バッファのサイズの値よりも大きな数が生ずる---例えば引数
が7なら7倍大きな数になる。これに10が加えられ、最後にこの大きな数が10で割
られる。こうして得られる値は、バッファのサイズ中の目的とする割合よりも一
文字分だけ大きな数である。

これら一連の操作の結果で得られた数が @code{goto-char} に渡され、カーソル
がその位置に移動する。

@node beginning-of-buffer complete,  , beginning-of-buffer opt arg, beginning-of-buffer
@comment  node-name,  next,  previous,  up
@subsection 完全版 @code{beginning-of-buffer}

ここで、@code{beginning-of-buffer} の完全なコードを挙げておく。

@example
@group
(defun beginning-of-buffer (&optional arg)
  "Move point to the beginning of the buffer; 
leave mark at previous position.
With arg N, put point N/10 of the way 
from the true beginning.
Don't use this in Lisp programs!
¥(goto-char (point-min)) is faster 
and does not set the mark."
  (interactive "P")
  (push-mark)
@end group
@group
  (goto-char 
   (if arg
       (if (> (buffer-size) 10000)
           ;; @r{大きなバッファサイズの場合のオーバーフローを避ける！}
           (* (prefix-numeric-value arg)
              (/ (buffer-size) 10))
@end group
@group
         (/ (+ 10 (* (buffer-size) 
                     (prefix-numeric-value arg))) 
            10))
     (point-min)))
  (if arg (forward-line 1)))
@end group
@end example

@noindent
二つの細かな点を除けば、これまでの議論でこの関数がどう動くかが分るだろう。
細かな点の一つ目は、説明文字列についてであり、二つ目は、この関数の最後の
行に関するものである。

で、一点目だが、説明文字列の中に、あるＳ式についてのリファレンスがある。

@example
¥(goto-char (point-min))  
@end example

@noindent 
この式の最初の括弧の前に @samp{¥} が使われている。この @samp{¥} は Lisp 
インタプリタに対し、このＳ式は説明として表示されるもので
あって、Ｓ式として評価されるものではないことを示すものである。

次に二点目だが、@code{beginning-of-buffer} コマンドの最後の行は、この関
数が引数とともに呼ばれた場合に、ポイントを次の行の最初に持ってくためのも
のである。

@example
(if arg (forward-line 1)))
@end example

@noindent
これによって、カーソルはバッファの中の適当な割合の位置の次の行の先頭に移
動する。これが最良の位置であろう。カーソルは@emph{少くとも}要求された割
合よりかは常に大きい位置に移動するからだ。この動作はちょっと几帳面過ぎる
かもしれないが、かと言ってそうしなければ、必ず文句を言う人がいるだろう。

@node Second Buffer Related Review, &optional Exercise , beginning-of-buffer, More Complex
@comment  node-name,  next,  previous,  up
@section 復習

ここで、この章の幾つかのトピックを手短にまとめておく。

@table @code
@item or
引数を順に評価していき、@code{nil} でない最初の値を返す。ただし、もしど
の引数も @code{nil} を返した場合は @code{nil} を返す。一言で言うと、引数
の中で真である最初の値を返す。つまり、ある引数が真であるか@emph{または}
(or) その他の引数のどれかが真であれば真の値を返す。

@item and
引数を順に評価していき、どれか一つでも @code{nil} があれば、@code{nil} 
を返し、どれも @code{nil} で無ければ最後の引数の値を返す。一言で言うと、
全ての引数が真である場合のみ真である値を返す。つまり、ある引数が真であり、
@emph{かつ} (and) その他の引数も全て真である場合に真の引数を返す。

@item &optional
関数定義での引数が省略可能であることを示すために使うキーワード。これが
あると、その引数がなくともその関数を評価することが出来る。

@item forward-line
ポイントを次の行の先頭に移動する。1より大きい引数が与えられた場合はその
数の行だけ進む。進めない場合は行けるところまで進み、行くはずではあったが
進めなかった分の行数を値として返す。

@item erase-buffer
カレントバッファの内容を全て削除する。

@item bufferp
引数がバッファの場合、@code{t} を返す。そうでない場合は @code{nil} を返す。
@end table

@node &optional Exercise ,  , Second Buffer Related Review, More Complex
@section @code{&optional} 引数の練習問題

省略可能な引数を持ち、その引数の数が @code{fill-column} の値よりも大きい
か小さいかをテストして結果を教えてくれるようなインタラクティブな関数を書
きなさい。ただし、引数なしの場合は56をデフォルトとして使うようにしなさい。

@node Narrowing & Widening, car cdr & cons, More Complex, Top
@comment  node-name,  next,  previous,  up
@chapter ナローイングとワイドニング
@cindex Focusing attention (narrowing)
@cindex Narrowing
@cindex Widening

ナローイングはバッファの特定部分にのみ注目し、その他の部分を間違って変更
したりすることなく作業するための Emacs の機能である。ナローイングは普通
は使えないようになっている。これは初心者を混乱させないためである。
@menu
* narrowing advantages::        ナローイングの利点
* save-restriction::            特殊形式 @code{save-restriction}
* what-line::                   ポイントは今何行目にあるか
* narrow Exercise::             ナローイングの練習問題
@end menu

@node narrowing advantages, save-restriction, Narrowing & Widening, Narrowing & Widening
@ifinfo
@heading ナローイングの利点
@end ifinfo

ナローイングを使うと、バッファのその他の部分はあたかも存在しないかのよう
に見えなくなる。これは、例えばバッファのある部分でのみ単語を置き換えたい
場合なんかに有効である。つまり特定の部分にナローイングしてそこで置換を実
行すると、その部分のみ置換が実行されて残りの部分は無視される。検索につい
ても同様で、ナローイングされた部分でのみ検索を行い、外の部分は探さない。
というわけで、文書のある部分のみ修正したい場合など、そのリージョンにナロー
イングをかけることで、間違って修正不要な箇所まで見てしまうのを防ぐことが
出来るのである。

しかしながら、ナローイングするとバッファの残りの部分が見えなくなるので、
意図せずナローイングしてしまった場合、ファイルのその部分を削除してしまっ 
たのではないかと不安に思う人も出てくるかもしれない。更に、@code{undo} コ
マンド (これは大抵 @kbd{C-x u} にバインドされている) でもナローイングは
解除されない(それに、そうすべきではない)。従って、もし @code{widen} コマ
ンドでまた見えるように出来るということを知らなかった場合、パニックに陥い
るかもしれない。(Emacs version 18 では、@code{widen} のキーバインディン
グは @code{C-x w} だった。version 19 では @kbd{C-x n w} になっている。)

ナローイングは、人間だけではなく Lisp インタプリタにとっても便利なように
なっている。 Emacs Lisp の関数はしばしば、バッファのある限定された部分に
対してのみ働くように設計されている。逆に言うと、Emacs Lisp 関数はナロー
イングされたバッファ全体に対して働くようになっているとも言える。例えば 
@code{what-line} 関数は、もしバッファにナローイングがかかっていればそれ
を解除し、仕事が終わるとまたナローイングを元に戻す。一方、
@code{what-line} 関数の中から呼び出される @code{count-lines} 関数は、ま
ずナローイングを用いてバッファの目的とする部分に限定して仕事を行い、その
後ナローイングを解除して元の状態に戻す。

@node save-restriction, what-line, narrowing advantages, Narrowing & Widening
@comment  node-name,  next,  previous,  up
@section 特殊形式 @code{save-restriction}
@findex save-restriction

Emacs Lisp では、@code{save-restriction} という特殊形式を使うことで、
ナローイングのかかった状態を保持することが出来るようになっている。Lisp 
インタプリタが @code{save-restriction} 式に出逢った場合、まず 
@code{save-restriction} 式の本体部分を評価し、次にそのコードを実行するこ
とでナローイングの状況が変わった場合にそれを元に戻す。例えば、バッファが
ナローイングされていて、@code{save-restriction} の本体で、ナローイングが
解除された場合、実行後に@code{save-restriction} はバッファにナローイング
されたリージョンを返してくれる。@code{what-line} コマンドでは、バッファ
にどんなナローイングが設定されていても @code{save-restriction} に続く 
@code{widen} コマンドで解除してしまう。元のナローイングはこの関数が終了
する直前に元に戻されるわけである。

@need 1250
@code{save-restriction} 式のテンプレートは単純である。

@example
@group
(save-restriction
  @var{本体}@dots{} )
@end group
@end example

@noindent
@code{save-restriction} の本体は一つないしは複数のＳ式であり、それらは 
Lisp インタプリタによって順に評価される。

最後に注意しておくことがある。それは @code{save-excursion} と 
@code{save-restriction} の両方を、片方のすぐ後にもう片方を続けて使う場合、
@code{save-excursion} の方を外側にすることだ。これを逆にすると、
@code{save-excursion} を呼び出してからナローイングが設定されたバッファに
移動した場合にそのナローイングの状況を記録しそこねることがあるのだ。とい
うことで、もし @code{save-excursion} と @code{save-restriction} を両方一
緒に使うなら、次のように使うことになる。

@example
@group
(save-excursion
  (save-restriction
    @var{本体}@dots{}))
@end group
@end example

@node what-line, narrow Exercise, save-restriction, Narrowing & Widening
@comment  node-name,  next,  previous,  up
@section @code{what-line}
@findex what-line
@cindex Widening, example of

@code{what-line} コマンドは現在カーソルがある場所までの行数を教えてくれ
るものである。この関数を見ることで、@code{save-restriction} と 
@code{save-excursion} の使い方を知ることが出来る。以下がこの関数の完全な
コードである。

@example
@group
(defun what-line ()
  "Print the current line number (in the buffer) of point."
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (beginning-of-line)
      (message "Line %d"
               (1+ (count-lines 1 (point)))))))
@end group
@end example

この関数は一行の説明文字列を持ち、あなたが予想した通
り、インタラクティブな関数である。次の二つの行では 
@code{save-restriction} と @code{widen} を使っている。

特殊形式 @code{save-restriction} は、カレントバッファにどのようなナロー
イングがかかっていようと、それを記録して本体のコードが評価し終わった後に
その状態に戻してくれる。

特殊形式 @code{save-restriction} の後には @code{widen} が続いている。
この関数は、@code{what-line} が呼ばれた時にカレントバッファのナローイン
グを解除する。(ここでのナローイングは、@code{save-restriction} が憶えて
いるナローイングである。) これによって行数を数えるコマンドは、バッファの
最初からの行数を数えることが出来るのである。そうしない場合は、現在アクセ
ス可能なリージョンの範囲内でしか行数をカウントしない。元のナローイングは
特殊形式 @code{save-restriction} によってこの関数が終了する直前に元の状
態に戻される。

@code{widen} の呼び出しに続いて @code{save-excursion} が使われている。こ
れはカーソルの位置、(即ち、point の位置) とマークの位置を保存し、本体部
分のコードの中の @code{beginning-of-line} 関数によって動かされたポイント
の位置を元に戻す、という働きをしている。

(@code{(widen)} 式が @code{save-restriction} と @code{save-excursion} の
間にあることに注意しよう。これら二つの @code{save- @dots{}} 式を続けて使
う場合は @code{save-excursion} を外側に書かないといけないのであった。)

@code{what-line} 関数の最後の二つの行は、バッファ内の行数を数え、それを
エコー領域に表示するものである。

@example
@group
(message "Line %d"
         (1+ (count-lines 1 (point)))))))
@end group
@end example

@code{message} 関数は Emacs の画面の最下行に一行メッセージを表示する関数
である。最初の引数は二重引用符に挟まれていて、これは文字文字列を表示する
ものである。ただし、@samp{%d}, @samp{%s}, @samp{%c} も入れることが出来て、
これらはこの文字列の後に続く引数を表示する。@samp{%d} は引数を10進数とし
て表示するので、メッセージは例えば @samp{Line 243} と言った感じになる。

@samp{%d} の場所に表示される数字は、この関数の最後の行で計算される。

@example
(1+ (count-lines 1 (point)))
@end example

@noindent
これがやっていることは1で示された位置、つまりバッファの最初の位置から 
@code{(point)} までの行数を数え、それに1を加えることである。(@code{1+} 
という関数は引数に 1 を加える関数である。)1を加えるのは、例えば二行目は
その前に一行しかないからである。@code{count-lines} はカレント行の
@emph{前の}行までしか数えないので、こうしないと一行ずれてしまうのだ。

@code{count-lines} が仕事を終えてメッセージがエコー領域に表示された後は 
@code{save-excursion} によってポイントとマークの位置が元の状態に戻される。
そして、@code{save-restriction} がナローイングの状態を元に戻す。

@node narrow Exercise,  , what-line, Narrowing & Widening
@section ナローイングの練習問題

カレントバッファの最初の60文字を表示するような関数を書きなさい。その際、
例えばナローイングにより後半部分しかアクセス不能であり、最初の行が見えな
い状態であってもきちんと表示するようなものにしなさい。また、ポイント、マー
ク、及びナローイングを復元するようにすること。この練習問題のためには、
@code{save-restriction}、@code{widen}、@code{goto-char}、
@code{point-min}、@code{buffer-substring}、@code{message} 及び他の関数を
うまく組み合わせて使う必要がある。

@node car cdr & cons, Cutting & Storing Text, Narrowing & Widening, Top
@comment  node-name,  next,  previous,  up
@chapter @code{car}, @code{cdr}, @code{cons}：基本関数
@findex car, @r{introduced}
@findex cdr, @r{introduced}

Lisp では @code{car}、@code{cdr}、そして @code{cons} が基本的な関数であ
る。@code{cons} 関数はリストを作るのに使われ、@code{car} 関数と 
@code{cdr} 関数はそれらを分解するのに使われる。

@code{copy-region-as-kill} 関数を ``walk-through'' する時に、@code{cons} 
と共に @code{cdr} の二つの変種である @code{setcdr} と @code{nthcdr} につ
いても見るつもりだ。(@ref{copy-region-as-kill}).

@menu
* Strange Names::               寄り道: 何故こんな名前がついているか
* car & cdr::                   リストの一部を取り出すための関数
* cons::                        リストの構成
* nthcdr::                      @code{cdr} を何回もよびだす
* setcar::                      リストの最初の要素の変更
* setcdr::                      リストの残りの要素の変更
* cons Exercise::               cons についての練習問題
@end menu

@node Strange Names, car & cdr, car cdr & cons, car cdr & cons
@ifinfo
@heading 奇妙な名前の由来
@end ifinfo

@code{cons} 関数の名前は特に非合理的なものではない。この名前は 
`construct' という単語を略したものである。一方、@code{car} と @code{cdr} 
の名前の由来は難解である。@code{car} は `Contents of the Address part of
the Register' というフレーズの頭文字から来ており、@code{cdr} (`could-er' 
と発音する) は `Contents of the Decrement part of the Register' というフ
レーズから来ている。これらのフレーズは、Lisp が開発された頃の極めて初期
のハードウェアの特定の部分に基づくものであるが、単に時代遅れであるという
だけでなく、実に25年以上もの間、Lisp に関わる人々にとって全く見当はずれ
のものであった。だがしかし、これらの関数をもっと合理的な名前で呼ぼうとし
た学者も何人かいたにも関わらず、現在でもこの古い用語が使われている。特に 
Emacs Lisp のソースコードでもこの用語が使われているので、この入門書でも
これらを使うことにしよう。

@node car & cdr, cons, Strange Names, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{car} と @code{cdr}

リストの @code{car} とは、単にそのリストの最初の要素のことである。従って、
リスト @code{(rose violet daisy buttercup)} の @code{car} は @code{rose} 
である。

もし、この文章を GNU Emacs の Info で読んでいるなら、次を評価してみるこ
とでこのことを確認出来る。

@example
(car '(rose violet daisy buttercup))
@end example

@noindent
このＳ式を評価すると、エコー領域に @code{rose} と表示されたはずだ。

明らかに @code{car} には @code{first} という名前の方がふさわしいし、
よくそのように提案されてもいる。

@code{car} は最初の要素を除いたりはしない。ただ単にそれが何かを伝えるだ
けである。あるリストに @code{car} を施した後も、そのリストは元のままであ
る。専門用語では、@code{car} は「非破壊的 (non-destructive)」であると言っ
たりする。この特徴は、後で重要であることが分るだろう。

List の @code{cdr} はリストの残りの部分である。つまり、@code{cdr} 関数は
リストの最初の要素を除いた部分を返す。従って、@code{'(rose violet daisy 
buttercup)} というリストの @code{car} が @code{rose} であるように、この
リストの残りの部分、つまり @code{cdr} を施して返される値は @code{(violet 
daisy buttercup)} である。

@need 1250
このことも、次をいつも通り評価してみることで確かめられる。

@example
(cdr '(rose violet daisy buttercup))
@end example

@noindent
これを評価すると、エコー領域に @code{(violet daisy buttercup)} と表示さ
れたはずだ。

@code{car} と同様、@code{cdr} もリストから要素を取り除いたりしない---た
だ単に二番目以降の要素のリストを返すだけである。

ついでに言っておくと、上の例では花のリストに引用符が付いている。もしこれ
が付いていなければ Lisp インタプリタは @code{rose} を関数として呼び出し
て評価しようとするだろう。この例では、そういうことをしたいのではなかった。

明らかに @code{cdr} には @code{rest} という名前の方が、ふさわしい。

(ここでちょっと教訓。あなたが新しい関数に名前をつける場合、それについて
極めて注意深く考えないといけない。というのも、あなたは多分、あなたが思う
よりずっと長い間、その名前につきまとわれることになるからだ。この文章でこ
れらの名前を使っているのは、Emacs Lisp のソースコードでこれらを使ってい
るからであり、そうしないとコードを読むのがつらいだろうからである。しかし、
どうかあなた自身はなるべくこういった言葉使いを避けて欲しい。そうすれば後
からやってきた人々から感謝されるだろう。)

@code{car} や @code{cdr} を @code{(pine fir oak maple)} といったシンボル
からなるリストに施した時、@code{car} によって返される要素はシンボル 
@code{pine} であり、括弧は付いてはいない。@code{pine} はこのリストの最初
の要素である。しかしながら、リストの @code{cdr} は 
@code{(fir oak maple)} というリストである。それは、次の式をいつものよう
に評価してみればすぐに分る。

@example
@group
(car '(pine fir oak maple))

(cdr '(pine fir oak maple))
@end group
@end example

一方、リストのリストでは、そのリストの最初の要素がそれ自身リストである。
この場合、@code{car} は最初のリストとしての要素を返す。例えば次のリストは
三つのサブリストを含んでいる。各々、肉食動物、草食動物、海洋哺乳類の
リストである。

@example
@group
(car '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end example

@noindent
この場合、最初の要素、つまり全体のリストの @code{car} は肉食動物のリスト 
@code{(lion tiger cheetah)} である。そしてリストの残りは@code{((gazelle
antelope zebra) (whale dolphin seal))} である。

@example
@group
(cdr '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end example

ここでもう一度、@code{car} と @code{cdr} が非破壊的であると言っておいた
ほうがいいだろう。これらの関数はリストを変化させないのだ。このことはこれ
らの関数を使うにあたって極めて重要になる。

また最初の章でアトムについて議論した時に、Lisp では「ある種のアトム、
例えば配列 (array)、は複数の部分に分解出来る。しかし、そのメカニズムはリ
ストを分解する時のメカニズムとは違う。リストの操作に関する限り、リストの
アトムは分解不可能である。」と書いた。(@ref{Lisp Atoms}). @code{car} 関
数と @code{cdr} 関数はリストを分解するのに使われ、Lisp の基本と考えられ
ている。しかし、これらの関数は配列を分解したり、部分を取り出したりするの
には使えない。従って、配列はリストではなくアトムであると考えられるわけであ
る。また、もう一つの基本的な関数である @code{cons} も、リストを構築するこ
とは出来るが、配列を作ることは出来ない。(配列は、配列を扱う特殊な関数を
使って操作する。詳しくは @ref{Arrays, , Arrays, elisp, The GNU Emacs Lisp
Reference Manual}, を参照のこと。)

@node cons, nthcdr, car & cdr, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{cons}
@findex cons, @r{introduced}

@code{cons} は、リストを作る関数である。@code{car} や @code{cdr} とは逆
の働きをするものだと言える。例えば、@code{cons} は三つの要素を持つリスト 
@code{(fir oak maple)} から四つの要素を持つリストを作ることが出来る。つ
まり、

@example
(cons 'pine '(fir oak maple))
@end example

@noindent
を評価すると、

@example
(pine fir oak maple)
@end example

@noindent
というリストがエコー領域に表示される。このように、@code{cons} はリストの
先頭に新しい一つの要素を付け加える。リストに要素を追加するわけである。

@code{cons} には、まず要素を付け加えるべきリストが必要になる。
@footnote{実際は、アトムに要素を @code{cons} してドット対を作ることも出
来る。が、ドット対のことはここでは説明しない。これについては次を参照せよ。
@ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU Emacs
Lisp Reference Manual}.} 何も無いところからスタートすることは出来ないの
である。もし、リストを作りたいならば、少くともまず初めに空リストを用意す
る必要がある。次に挙げるのは、@code{cons} を連続して使って花のリストを作
るものである。もし、この文章を Emacs の Info で読んでいるのなら、各々の
Ｓ式をいつものように評価することが出来る。表示される値が @samp{@result{}} 
の後に書かれている。これを「次のように評価される」と置き換えて読んで欲し
い。

@example
@group
(cons 'buttercup ())
     @result{} (buttercup)
@end group

@group
(cons 'daisy '(buttercup))
     @result{} (daisy buttercup)
@end group

@group
(cons 'violet '(daisy buttercup))
     @result{} (violet daisy buttercup)
@end group

@group
(cons 'rose '(violet daisy buttercup))
     @result{} (rose violet daisy buttercup)
@end group
@end example

@noindent
最初の例では、空リストが @code{()} という形で出ている。そして、
@code{buttercup} とこの空リストから新しいリストが作られる。見ればわかる
と思うが、空リストは作成されたリストの要素としては出て来ない。
@code{(buttercup)} というリストが見えるだけである。空リストは要素として
は数えられない。というのも、空リストには要素が一つもないからである。一般
的にいうと、空リストは見えないのである。

二番目の例では @code{(cons 'daisy '(buttercup))} を評価することで
@code{daisy} を @code{buttercup} の前に付け加えて、二つの要素を持つリス
トを作っている。三番目の例では @code{daisy} と @code{buttercup} の前に 
@code{violet} を加えて三つの要素を持つリストを作っている。

@menu
* length::                      リストの長さを知る
@end menu

@node length,  , cons, cons
@comment  node-name,  next,  previous,  up
@subsection リストの長さを調べる: @code{length}
@findex length

あるリストがどれだけ多くの要素を持つかを見るには、@code{length} という 
Lisp の関数を使えばよい。次のように感じである。

@example
@group
(length '(buttercup))
     @result{} 1
@end group

@group
(length '(daisy buttercup))
     @result{} 2
@end group

@group
(length (cons 'violet '(daisy buttercup)))
     @result{} 3
@end group
@end example

@noindent
三番目の例では、三つの要素を持つリストを作るために @code{cons} 関数が使
われ、その結果出来たリストが @code{length} 関数に引数として渡されている。

@code{length} 関数を使って、空リストの中の要素の数を数えることも出来る。

@example
@group
(length ())
     @result{} 0
@end group
@end example

@noindent
予想した通りだと思うが、空リストの中の要素の数は零個と数えられる。

リストが無い場合にその長さを求めさせてみるのも面白い実験である。つまり、
引数として空リストすら渡さずに @code{length} を呼び出すのである。

@example
(length )
@end example

@noindent
やってみれば分るが、これを評価すると、エラーメッセージが表示される。

@example
Wrong number of arguments: #<subr length>, 0
@end example

@noindent
これは引数の数が間違っているという意味のメッセージである。今の場合なら、
本当は一つの引数が渡されなければならない。例えば引数がリストなら、そのリ
ストの長さをこの関数が測ることになるはずだったのである。(リストが沢山の
要素を持っていたとしても、@emph{一つ}のリストは@emph{一つ}の引数であるこ
とに注意。)

(訳註：因みに @code{length} の引数は必ずしもリストでなくともよい。例えば 
@code{length} に文字列を渡すと、その文字列の長さが返る。)

エラーメッセージの中の @samp{#<subr length>} という部分は、関数の名前で
ある。これは、特殊な表記法で書かれている。@samp{#<subr} は @code{length} 
が Emacs Lisp ではなく C で書かれたプリミティブな関数であることを表して
いる。(@samp{subr} は `subroutine' の略である。) @ref{What Is a
Function, ,What Is a Function?, elisp , The GNU Emacs Lisp Reference
Manual}, にこの辺りのことについてのより詳しい情報がある。

@node nthcdr, setcar, cons, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{nthcdr}
@findex nthcdr

@code{nthcdr} 関数は、@code{cdr} 関数に関連した関数である。これは、リス
トの @code{cdr} を繰り返し取るものである。

@code{(pine fir oak maple)} の @code{cdr} を取ると、@code{(fir oak
maple)} が返される。もしこの返された値にもう一度同じ操作をすると、
@code{(oak maple)} が返される。(勿論、リストに何回 @code{cdr} を施しても、
元のリストは変化しない。@code{cdr} は対象リストを変化させはしないからで
ある。従って、@code{cdr} の @code{cdr} を評価する必要がある。) これを続
ければ、結果として空リストが返る。この場合、@code{()} ではなく 
@code{nil} が表示される。

復習のために、以下に @code{cdr} の繰り返しの例を書いておく。
@samp{@result{}} の後に表示される結果が書いてある。

@example
@group
(cdr '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
(cdr '(fir oak maple))
     @result{} (oak maple)
@end group

@group
(cdr '(oak maple))
     @result{} (maple)
@end group

@group
(cdr '(maple))
     @result{} nil
@end group

@group
(cdr 'nil)
     @result{} nil
@end group

@group
(cdr ())
     @result{} nil
@end group
@end example

複数の @code{cdr} を、間に表示される値を挟まずに続けて書くことも出来る。 


@example
@group
(cdr (cdr '(pine fir oak maple)))
     @result{} (oak maple)
@end group
@end example

@noindent
この場合は、Lisp インタプリタは最も内側のリストを先に評価する。最も内側
にあるリストには引用符が付いているので、それはそのままリストとして返され、
内側の方の @code{cdr} に渡される。この内側の @code{cdr} はこのリストの二
番目以降の要素からなるリストを返し、外側の @code{cdr} に渡す。これは、元
のリストの三番目以降の要素からなるリストを返すというわけである。この例の
ように、@code{cdr} 関数を二回続けて使うと、元のリストの最初の二つの要素
を除いたリストが返されることになる。

@code{nthcdr} 関数は、@code{cdr} 関数を繰り返して使うのと同じことをして
くれる。次の例では引数2がリストと一緒に @code{nthcdr} 関数に渡され、その
結果最初の二つの要素を除いたリストが返されている。これはまさに 
@code{cdr} を二回繰り返してリストに施したのと同じ結果である。

@example
@group
(nthcdr 2 '(pine fir oak maple))
     @result{} (oak maple)
@end group
@end example

元の4つの要素を持ったリストを使って、0、1、5などを含むいろいろな引数を 
@code{nthcdr} に与えた場合に何が起こるかを見てみよう。

@example
@group
;; @r{リストはそのまま。}
(nthcdr 0 '(pine fir oak maple))    
     @result{} (pine fir oak maple)
@end group

@group
;; @r{最初の要素を除いた残りのコピーを返す。}
(nthcdr 1 '(pine fir oak maple))    
     @result{} (fir oak maple)
@end group

@group
;; @r{三つの要素を除いた残りのコピーを返す。}
(nthcdr 3 '(pine fir oak maple))    
     @result{} (maple)                
@end group

@group
;; @r{四つ全部を除いた残りを返す。}
(nthcdr 4 '(pine fir oak maple))    
     @result{} nil             
@end group

@group
;; @r{これも全部を除いた残りを返す。}
(nthcdr 5 '(pine fir oak maple))    
     @result{} nil                   
@end group
@end example

@code{nthcdr} も @code{cdr} と同様に元のリストを変化させないことに一言触
れておくほうがいいだろう。この関数もまた非破壊的なのである。これは 
@code{setcar} 関数や @code{setcdr} 関数とはっきり違っているところである。

@node setcar, setcdr, nthcdr, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{setcar}
@findex setcar

この二つの名前から連想されるように、@code{setcar} と @code{setcdr} とい
う関数は、リストの @code{car} や @code{cdr} に新しい値を持たせる。これら
は @code{car} や @code{cdr} が値を変化させないのとは異なり、実際に元のリ
ストの値を変化させてしまう。これがどういうことなのかを見る一つの方法は、
実験してみることだろう。まずは @code{setcar} 関数から始めてみよう。

最初にリストを作り、@code{setq} を使ってある変数の値にそのリストをセット
する。動物のリストでやってみよう。

@example
(setq animals '(giraffe antelope tiger lion))
@end example

@noindent
GNU Emacs の Info でこの文章を読んでいるなら、このＳ式をいつものように評
価してみよう。カーソルをＳ式の後に持っていき、@kbd{C-x C-e} とタイプする
のである。(私はこう書く時には実際にこの操作を試している。これは計算機環
境にインタプリタが組み込まれていることの利点の一つである。)

変数 @code{animals} を評価してみれば、この変数が @code{(giraffe antelope
tiger lion)} というリストにバインドされていることが確かめられる。

@example
@group
animals
     @result{} (giraffe antelope tiger lion)
@end group
@end example

@noindent
別の言い方をすれば、変数 @code{animals} はリスト @code{(giraffe antelope
tiger lion)} を指しているとも言える。

次に、関数 @code{setcar} に変数 @code{animals} と引用符付きのシンボル 
@code{hippopotamus} の二つ引数を渡して評価してみよう。これは三つの要素を
持つ @code{(setcar animals 'hippopotamus)} というリストを書いて、これを
いつものように評価することで行うことが出来る。

@example
(setcar animals 'hippopotamus)
@end example

@noindent 
このＳ式を評価した後で、変数 @code{animals} をもう一度評価してみよう。す
ると、動物のリストが変化していることが分る。

@example
@group
animals
     @result{} (hippopotamus antelope tiger lion)
@end group
@end example

@noindent
リストの最初の要素 @code{giraffe} が @code{hippopotamus} に変わっている。

以上のことから分るように、@code{setcar} は @code{cons} のように新しい要
素を付け加えるのではなく、@code{giraffe} を @code{hippopotamus} に置き換
えている。即ち、この関数はリストの最初の要素を@emph{変更する}ものなのだ。


@node setcdr, cons Exercise, setcar, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{setcdr}
@findex setcdr

@code{setcdr} 関数も、@code{setcar} 関数と似ているのだが、こちらはリスト
の最初の要素ではなく、二番目以降の要素を置き換えるものである。

実際どのように働くかを見るために、まず次のＳ式を評価して、変数の値を家畜
のリストにセットしておく。

@example
(setq domesticated-animals '(horse cow sheep goat))
@end example

@noindent
この時点でこの変数を評価したなら、リスト @code{(horse cow sheep goat)} 
が返されるはずだ。

@example
@group
domesticated-animals
     @result{} (horse cow sheep goat)
@end group
@end example

次に、@code{setcdr} に、このリストを値に持つ変数名とそのリストの 
@code{cdr} の部分を置き換えるリストの二つの引数を与えて、評価してみる。

@example
(setcdr domesticated-animals '(cat dog))
@end example

@noindent
このＳ式を評価すると、リスト @code{(cat dog)} がエコー領域に表示される。
これがこの関数によって返される値である。我々にとって興味があるのは副作用
の方であるが、こちらは変数 @code{domesticated-animal} を評価してみれば
どんなものか理解出来る。

@example
@group
domesticated-animals
     @result{} (horse cat dog)
@end group
@end example

@noindent
このリストが @code{(horse cow sheep goat)} から @code{(horse cat dog)} 
に変化しているのが分る。リストの @code{cdr} が @code{(cow sheep goat)} 
から @code{(cat dog)} に置き換わっているのである。

@node cons Exercise,  , setcdr, car cdr & cons
@section 練習問題

四種類の鳥のリストを幾つかの @code{cons} を使ったＳ式を評価することで
作りなさい。また、あるリストにそれ自身を @code{cons} した時に、何が起き
るかを見なさい。四種類の鳥のリストの最初の要素を魚で置き換えなさい。更に、
そのリストの残りの要素も他の魚で置き換えなさい。

@node Cutting & Storing Text, List Implementation, car cdr & cons, Top
@comment  node-name,  next,  previous,  up
@chapter テキストの切り取りと保存
@cindex Cutting and storing text
@cindex Storing and cutting text
@cindex Killing text
@cindex Clipping text
@cindex Erasing text
@cindex Deleting text

GNU Emacs で `kill' コマンドを使ってバッファからテキストをカットないしは
切り取った (clip した) 場合、常にその情報はリストとして保持されており、
それをヤンク (yank) コマンドで取り出すことが出来る。

(Emacs で特に何らかの実体を破壊@emph{しない}プロセスに対して `kill' とい
う言葉を使うのは、不幸な歴史的出来事である。これには `clip' という単語の
方がずっとふさわしい。これこそ kill コマンドがやっていることに他ならない
からである。このコマンドはバッファからテキストを `clip' し、それをまた取
り出すことが出来るような置場所に移しているのだ。私はしばしば Emacs のソー
スの中に出てくるあらゆる `kill' を `clip' に、あらゆる `killed' を 
`clipped' に置き換えたい衝動にかられる。)

@menu
* Storing Text::                テキストはリストの中に保存される
* zap-to-char::                 テキストをある文字まで削除する
* kill-region::                 リージョンの削除
* delete-region::               脱線: C で書かれた関数について
* defvar::                      変数に初期値を与える
* copy-region-as-kill::         テキストの複写の定義
* cons & search-fwd Review::    cons と search-forward の復習
* search Exercises::            検索についての練習問題
@end menu

@node Storing Text, zap-to-char, Cutting & Storing Text, Cutting & Storing Text
@ifinfo
@heading リストへのテキストの保存
@end ifinfo

テキストがバッファから切り取られた場合、そのテキストはあるリストに保存され
る。次にまたテキストを切り取りると、そのテキストもまたこのリストの中に続けて
保存される。従ってリストは次のようになる。

@example
("a piece of text" "last piece")
@end example

@noindent
関数 @code{cons} を使えば、以下のように、このリストにテキストを加えるこ
とが出来る。

@example
@group
(cons "another piece" 
      '("a piece of text" "last piece"))
@end group
@end example

@noindent
このＳ式を評価すると、次の三つの要素を持つリストがエコー領域に表示される
はずだ。

@example
("another piece" "a piece of text" "last piece")
@end example

関数 @code{car} や @code{nthcdr} を使うと、この中からどの部分でも取り出
すことが出来る。例えば次に挙げるコードでは @code{nthcdr 1 @dots{}} が最
初の要素を除いたリストを返し、@code{car} がその残りのリストの中の最初の
要素---元々のリストでは二番目の要素---を返す。

@example
@group
(car (nthcdr 1 '("another piece"
                 "a piece of text"
                 "last piece")))
     @result{} "a piece of text"
@end group
@end example

勿論、実際に Emacs で使われている関数はこれよりももっと複雑である。テキ
ストをカットしたり取り出したりするためのコードは Emacs があなたが取り出
したいテキストがどれか分るように書かれていなければならない。それが一番目
にあろうと二番目にあろうと三番目にあろうと、あるいはもっと他の場所にあっ
てもである。また、もしリストの最後まで来た場合、そこで終わりとはせずに再
度最初の要素に戻らなくてはなるまい。

テキストの部分を保存しているリストは @dfn{kill リング} (@dfn{kill ring}) 
と呼ばれる。この章では少しずつ kill リングについて話していくことにする。
そのために、まず @code{zap-to-char} 関数がどのように働くかを見ることで、
kill リングの使い方を見ていきたいと思う。山の頂上を目指す前にまず手頃な丘
に登ってみるわけである。

実際にテキストがどのようにバッファから切り取られ、あるいは取り出されるの
かについては、次の章で説明する。@ref{Yanking, , Yanking Text Back}, 参照。

@node zap-to-char, kill-region, Storing Text, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section @code{zap-to-char}
@findex zap-to-char

@code{zap-to-char} 関数は、GNU Emacs の version 18 と version 19 とでは
異なる書き方がされている。version 19 での実装の方が単純で、動作も少々異
なる。まずは version 19 用に書かれた方を見て、その後に version 18 の方を
見ることにしよう。

インタラクティブ関数 @code{zap-to-char} の Emacs version 19 用の実装では、
カーソルの位置 (つまりポイントの位置) から次に指定した文字が現れるまでの、
その文字も含めた領域のテキストを取り去る。@code{zap-to-char} によって取
り除かれたテキストは、kill リングに置かれる。これは @kbd{C-y}
(@code{yank}) とタイプすることで取り出すことが出来る。もし、このコマンド
が引数と共に呼び出されたなら、その回数だけ指定された文字が出てくるまでの
間のテキストを取り去る。従って、もしカーソルが次の文の先頭にあり、特定の
文字が `s' だったとすると、`Thus' が取り去られることになる。

Thus, if the cursor were at the beginning of this sentence and the
character were `s', `Thus' would be removed.

@noindent
(訳註：日本語の文章では @code{zap-to-char} は使えないので、止むなく英文
のままにした。)

またもし引数が2であれば、@samp{Thus, if the curs} が取り去られる。ここで
も最後の @samp{s} が含まれていることに注目しよう。

Emacs version 18 での実装では、指定した文字までの@emph{その文字を含まな
い}領域を取り去るようになっている。従って、先のパラグラフでの例では、
@samp{s} は取り除かれ@emph{ない}。

更に Emacs の version 18 での実装では、もし指定した文字が現れなかった場
合にはバッファの最後までカーソルが移動した。しかし、version 19 の方では
単にエラーを返すだけである。(従って、テキストを取り除いたりもしない。)

どれだけのテキストを取り去るかを決定するために、どちらのバージョンの場合
でも検索関数を使っている。検索はもっぱらテキストを扱うコードの中で使われ
る。そして、削除コマンドだけでなく検索関数にも注目するのは意味のあること
である。

以下が version 19 でのこの関数の完全なコードである。

@c v 19 version
@example
@group
(defun zap-to-char (arg char)  ; version 19 implementation
  "Kill up to and including ARG'th occurrence of CHAR.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "*p¥ncZap to char: ")
  (kill-region (point)
               (progn
                 (search-forward
                  (char-to-string char) nil nil arg)
                 (point))))
@end group
@end example

@menu
* zap-to-char interactive::     三つの部分からなるインタラクティブ式
* zap-to-char body::            ちょっと復習
* search-forward::              文字列検索の仕方
* progn::                       @code{progn} 関数について
* Summing up zap-to-char::      @code{point} と @code{search-forward} を使う
* v-18-zap-to-char::            version 18 での実装
@end menu

@node zap-to-char interactive, zap-to-char body, zap-to-char, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection @code{interactive} 式

@code{zap-to-char} コマンド内のインタラクティブ式は、次の通りである。

@example
(interactive "*p¥ncZap to char: ")
@end example

引用符の中の部分は、@code{"*p¥ncZap to char:@: "} であり、三つのことを指
定している。一番目の部分は単なるアスタリスク @samp{*} で、バッファが 
read-only だったら警告のためにエラーを出すためのものである。つまり、
read-only なバッファで @code{zap-to-char} を使おうとしてもテキストを取り
除くことは出来ず、代わりに ``buffer is read-only'' というメッセージを受
け取ることになることを意味する。端末によってはビープ音もなる。

@code{*p¥ncZap to char:@: "} の二番目の部分は @samp{p} である。この部分
は改行 @samp{¥n} で終っている。@samp{p} はこの関数の最初の引数として、処
理された前置引数の値が渡されることを意味する。前置引数は @kbd{C-u} に続
いてある数を、もしくは @kbd{M-} に続いてある数をタイプすることで渡される。
もし、この関数が前置引数なしで呼び出された場合、1が引数として渡される。

@code{*p¥ncZap to char:@: "} の三番目の部分は、@samp{cZap to char:@: } 
である。この部分の最初の小文字の @samp{c} は @code{interactive} がプロン
プトを出して、文字の入力を要求することを指示するものである。プロンプトは
@samp{c} の後に続くもので、この場合は文字列 @samp{Zap to char:@: } 
である。(コロンの後の空白は、単に見栄えをよくするためのものである。)

結局これがすることは、正しい型の @code{zap-to-char} の引数を用意し、ユー
ザーに対してプロンプトを出すということである。

@node zap-to-char body, search-forward, zap-to-char interactive, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection @code{zap-to-char} の本体部分

@code{zap-to-char} 関数の本体部分は、現在のカーソルの位置から指定した文
字までの間の領域のテキストを削除するコードを含んでいる。その最初の部分は
次の通りである。

@example
(kill-region (point) @dots{}
@end example

@noindent
@code{(point)} は現在のカーソルの位置である。

この後には、@code{progn} を使った式が続いている。@code{progn} の本体部分
では、@code{search-forward} と @code{point} を呼び出している。

まず @code{search-forward} を学んでからの方が @code{progn} の働きを理解
しやすいので、先にこちらを見て、次に @code{progn} について述べることにし
よう。

@node search-forward, progn, zap-to-char body, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection 関数 @code{search-forward}
@findex search-forward

@code{search-forward} 関数は、@code{zap-to-char} の中で、削除する範囲の
端を定める文字 (以下 zapped-to-character と書く) の位置を定めるのに使わ
れている。もし検索が成功すると、@code{search-forward} は目的の文字列の最
後の文字のすぐ後にポイントを移動する。(今の場合、目的の文字列はちょうど
一文字である。) もし検索が後方に向かうものであれば、
@code{search-forward} は目的の文字列の最初の一文字のすぐ前にポイントを移
動する。また、@code{search-forward} 自身は値として @code{t} を返す。(従っ
て、ポイントの移動は副作用である。)

@need 1250
@code{zap-to-char} の中で @code{search-forward} は次のように使われている。 

@example
(search-forward (char-to-string char) nil nil arg)
@end example

関数 @code{search-forward} は四つの引数を取る。

@enumerate
@item
最初の引数は、検索しようとするターゲットである。これは @samp{"z"} のよう
に文字列でなければならない。

今回の場合は、たまたま @code{zap-to-char} に渡される引数は単独の文字であ
る。計算機の設計上、Lisp インタプリタは単独の文字を一文字からなる文字列
とは区別して扱う。計算機の中では単独の文字は一文字からなる文字列とは別の
電気的なフォーマットを持っているのである。(単独の文字はたいてい計算機の
中で1バイトで記録されている。(訳註：勿論日本語とかでは事情は別である。) 
しかし、文字列の方は長いものもあれば短いものもあるので、計算機の方でそれ
に備えなければならないのである。) @code{search-forward} は文字列を検索す
るものなので、@code{zap-to-char} 関数に引数として渡された文字を計算機の
内部で別のフォーマットに変換しないといけない。でないと、
@code{search-forward} は検索に失敗してしまう。この変換をするために、
@code{char-to-string} という関数が使われている。

@item
二番目は、検索の範囲を指定するためのものである。これはバッファ内の
位置として指定される。今の場合、検索はバッファの最後まで行うので、範囲を
制限したりはしない。従って、二番目の引数は @code{nil} である。

@item
三番目は、この関数に検索が失敗し場合にどうするか---警告してエラー
を表示するか、単に @code{nil} を返すか---を伝えるものである。 三番目の引
数として @code{nil} が指定されていると、検索に失敗した場合にはエラーを出
して警告する。

@item
@code{search-forward} の四番目の引数は、繰り返しの回数---つまり検索対象
の文字列が何回現れるのを調べるか---を指定するものである。この引数は省略
可能であり、もしこの引数なしで関数が呼び出された場合、この引数として1が
渡される。引数が負であれば、検索は後方に向かってなされる。
@end enumerate

テンプレートで書くと、@code{search-forward} 式は次のようになる。

@example
@group
(search-forward "@var{目的とする文字列}"
                @var{検索の範囲の限界}
                @var{検索に失敗した時の動作}
                @var{繰り返しの階数})
@end group
@end example

次に @code{progn} を見ることにしよう。

@node progn, Summing up zap-to-char, search-forward, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection 関数 @code{progn}
@findex progn

@code{progn} は引数を各々順番に評価していき、最後の式の値を返すよう
な関数である。それ以前のＳ式はその副作用のためだけに評価され、これらが返
す値は無視される。

@code{progn} 式のテンプレートは極めて単純である。

@example
@group
(progn
  @var{本体}@dots{})
@end group
@end example

@code{zap-to-char} の中では、@code{progn} 式は二つのことを行う。まず、ポ
イントをちょうど正しい位置に置くこと。次に、ポイントの位置を返して、
@code{kill-region} がどこまでテキストを削除すればよいかを教えることである。

@code{progn} の最初の引数は @code{search-forward} である。
@code{search-forward} は検索する文字列を見つけた場合、その文字列
の最後の文字のすぐ後にポイントを移す。(今の場合、検索文字列は一文字
である。) ただし、もし検索が後方方向なら最初の一文字の直前の位置にポイン
トを移す。ポイントの移動は副作用である。

二番目の、そして最後の @code{progn} の引数は @code{(point)} である。この
Ｓ式はポイントの位置を返す。今の場合なら、これは @code{search-forward} 
によって移動されたポイントの位置である。この値が @code{progn} 式の値とし
て返され、@code{kill-region} に @code{kill-region} の二番目の引数として
渡される。

@node Summing up zap-to-char, v-18-zap-to-char, progn, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection @code{zap-to-char} についての総括

さて、以上で @code{search-forward} と @code{progn} の働きを見てきた。こ
こで @code{zap-to-char} 全体がどのように動作するかを見ることにしよう。

@code{zap-to-char} コマンドが与えられた時の @code{kill-region} の最初の
引数はカーソルの位置---その時点でのポイントの値---である。また 
@code{progn} の中で検索コマンドによってポイントが zapped-to-character の
すぐ後に移され、@code{point} によってその位置の値が返される。
@code{kill-region} 関数はこれら二つの値の最初の値をリージョンの始まりに、
二番目の値をリージョンの終わりに指定して、そのリージョンを削除する。

@code{progn} 関数が必要なのは、@code{kill-region} 関数の引数が二つである
からである。仮に @code{search-forward} 式と @code{point} 式が続けて二つ
の引数として書かれていたとしたら、うまく動作してはくれない。@code{progn} 
は @code{kill-region} にとって一つの引数であり、@code{kill-region} が第
二引数として必要な一つの値を返すのである。

@node v-18-zap-to-char,  , Summing up zap-to-char, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection Version 18 での実装

@code{zap-to-char} の version 18 での実装は version 19 での実装とはちょっ
とばかり違っている。こちらも zapped-to-character までのテキストを削除す
るのだが、それには zapped-to-character 自身は含めない。また、指定された
文字列が見つからない場合にはバッファの最後まで削除してしまう。

違いは @code{kill-region} の第二引数にある。Version 19 での実装では次の
ようになっていた。

@example
@group
(progn
  (search-forward (char-to-string char) nil nil arg)
  (point))
@end group
@end example

@need 1250
@noindent
しかし version 18 では次のようになっている。

@example
@group
(if (search-forward (char-to-string char) nil t arg)
    (progn (goto-char
            (if (> arg 0) (1- (point)) (1+ (point))))
           (point))
  (if (> arg 0)
      (point-max)
    (point-min)))
@end group
@end example

これはかなり複雑に見える。しかし、各々の部分は容易に理解することが出
来る。

最初の部分はこうだ。

@example
(if (search-forward (char-to-string char) nil t arg)
@end example

@noindent
これは次の仕事をするような @code{if} 式のテンプレートにきちん当てはまっ
ている。

@example
@group
(if @var{zapped-to-character まで移動出来たらその位置にポイントを移動し}
    @var{ポイントを正確な位置に移動し直してその位置を返す}
   @var{そうでなければバッファの最後まで行き、その位置を返す})
@end group
@end example

@noindent
@code{if} 式を評価することで、@code{kill-region} の二番目の引数が指定さ
れる。最初の引数としてはポイントの位置が与えられるので、これらから、
@code{kill-region} はポイントから zap する位置までのテキストを削除出来る。 

@code{search-forward} が副作用としてどのようにポイントを移動するかについ
ては、既に説明したのだった。@code{search-forward} はもし検索に成功したな
ら @code{t} を返す。失敗した場合に @code{nil} を返すか、エラーメッセージ
を出すかは @code{search-forward} の三番目の引数による。今の場合三番目の
引数は @code{t} なので、検索に失敗すると @code{nil} が返る。後で見るよう
に、@code{nil} が返される場合のコードの扱いは簡単である。

@code{zap-to-char} の version 18 での実装では、検索は @code{if} 式の真偽
テストの部分で検索のためのＳ式が評価されることによって起動される。もし検
索に成功すれば Emacs は @code{if} 式の then-part を評価する。一方、もし
検索に失敗すれば、Emacs は else-part の方を評価する。

@code{if} 式の中で検索が成功すれば、@code{progn} 式が実行される---つまり
プログラムとして走らされる。

前にも言ったように、@code{progn} は引数を順に評価していき、その最後のＳ
式の値を返す関数である。それ以前のＳ式は単に副作用だけのために評価され、
それらが返す値は捨てられる。

上で説明したように、このバージョンの @code{zap-to-char} では 
@code{progn} 式は @code{search-forward} 関数が検索する文字を見つけた場合
に実行される。@code{progn} 式は二つのことを実行しなければならない。一つ
はポイントを正しい位置に移動することであり、もう一つはその位置を返すこと
により @code{kill-region} にどこまで削除すればよいかを伝えることである。

@code{progn} が使われる理由は @code{search-forward} が検索文字列を見
つけた場合に、目的の文字列の最後の文字の直後までポイントを移動してし
まうことにある。(今の場合は目標となる文字列は一つの文字である。) ま
た、検索が後方方向の場合は、@code{search-forward} はポイントを目的の
文字列の最初の文字の直前に置いてしまう。

しかし、このバージョンの @code{zap-to-char} は検索した文字自身は削除しな
いようになっている。例えば @code{zap-to-char} が @samp{z} という文字まで
のテキストを削除する場合、このバージョンのものでは @samp{z} という文字は
削除してはいけない。そこで、ポイントをその文字を削除しないような所まで移
動しなければならないというわけである。

@menu
* progn body::                  @code{progn} 式の本体部分
@end menu

@node progn body,  , v-18-zap-to-char, v-18-zap-to-char
@unnumberedsubsubsec @code{progn} 式の本体

@code{progn} 式の本体は二つのＳ式からなっている。異なる部分間の区切を明
確にするために間を空けて、更にコメントを加えると、@code{progn} 式は次の
ようになる。

@example
@group
(progn 

  (goto-char                ; @r{@code{progn} の最初の式。}
        (if (> arg 0)       ; @r{もし @code{arg} が正なら、}
            (1- (point))    ; @r{  一文字分戻り、}
          (1+ (point))))    ; @r{  そうでなければ一文字分進む。}

  (point))                  ; @r{@code{progn} の二番目の式。}
                            ; @r{  ポイントの位置を返す。}
@end group
@end example

@noindent
この @code{progn} 式がやることは次の通りである。もし検索が前方ならば、
(つまり @code{arg} が正の数なら) Emacs は検索した文字の直後にポイントを
移動している。そこで一文字分前に戻ることで、その文字を対象範囲から除く。
この場合、@code{progn} 式の中のＳ式は次のように読める。@code{(goto-char
(1- (point)))}。これはポイントの位置を一文字分だけ戻す。(@code{1-} とい
う関数は引数から1を引く関数である。同様に @code{1+} は引数に1を足す。)一
方、もし @code{zap-to-char} の引数が負ならば、検索は後方に向かって行われ
る。@code{if} がこれを検知し、この場合は @code{(goto-char (1+ (point)))} 
というＳ式が実行されることになる。(繰り返しになるが、@code{1+} は引数に1
を加える関数である。)

@code{progn} の二番目の、そして最後の引数は、@code{(point)} というＳ式で
ある。このＳ式は @code{progn} の最初の引数によって移動したポイントの位置を
返す。この値はこのＳ式を含む @code{if} 式によって返され、
@code{kill-region} の第二引数として渡される。

手短にまとめると、この関数の働きは以下の通りである。@code{kill-region} 
の最初の引数は @code{zap-to-char} コマンドが与えられた時のカーソルの位置
---つまりその時点でのポイントの位置---である。検索に成功すれば検索を行う
関数がそこまでポイントを移動する。そして @code{progn} 式によって、指定し
た文字が削除する領域に入らないようにポイントの位置をずらしてから、その位
置を返す。そして、@code{kill-region} 関数がそのリージョンを削除するとい
うわけである。

最後に、@code{if} 式の else-part で、指定した文字が見つからなかった場合
の対処をしている。@code{zap-to-char} 関数の引数が正である場合 (もしくは
引数が与えられていなかった場合)、指定した文字が見つからなければ、その時
のカーソルの位置から先のアクセス可能な範囲の全てのテキスト (もしナローイ
ングがかかっていなければバッファの最後まで) が削除される。@code{arg} が
負の場合は、指定した文字が見つからなければ上の操作がその時にアクセス可能
な範囲の始めの方に向って行われる。この部分のコードは単純な @code{if} 式
である。

@example
(if (> arg 0) (point-max) (point-min))
@end example

これは、もし @code{arg} が正の数なら、@code{point-max} そうでなければ 
@code{point-min} の値を返すことを表している。

復習のために、コメント付きで @code{kill-region} を含むコードを挙げておこ
う。

@example
@group
(kill-region
 (point)                    ; @r{リージョンの始まり}
 (if (search-forward
      (char-to-string char) ; @r{検索対象}
      nil                   ; @r{検索の限界: 無し}
      t                     ; @r{失敗したら @code{nil} を返す。}
      arg)                  ; @r{繰り返しの回数}
@end group
@group
     (progn                 ; @r{then-part}
       (goto-char     
        (if (> arg 0)
            (1- (point))
          (1+ (point))))
       (point))
   
   (if (> arg 0)            ; @r{else-part}
       (point-max)
     (point-min))))
@end group
@end example

これを見ればわかるように、version 19 での実装は、version 18 での実装より
もやることがちょっと少ないが、その分コードはずっと単純になっていたのであ
る。

@node kill-region, delete-region, zap-to-char, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section @code{kill-region}
@findex kill-region

@code{zap-to-char} は @code{kill-region} 関数を使っている。これはとても
単純な関数で、説明文字列の一部を省略すると、次のよう
に書かれている。

@example
@group
(defun kill-region (beg end)
  "Kill between point and mark.
The text is deleted but saved in the kill ring."
  (interactive "*r")
  (copy-region-as-kill beg end)
  (delete-region beg end))
@end group
@end example

主に注目すべき点は @code{delete-region} と @code{copy-region-as-kill} を
使っているところである。これらの関数については以降のセクションで説明する。

@node delete-region, defvar, kill-region, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section @code{delete-region}: ちょっと脱線して C の話を
@findex delete-region
@cindex C, a digression into
@cindex Digression into C

@code{zap-to-char} コマンドは @code{kill-region} 関数を使っている。そし
て、これはこれでまた別の二つの関数 @code{copy-region-as-kill} 及び 
@code{delete-region} を利用している。@code{copy-region-as-kill} につい
てはこの後のセクションでも説明するが、リージョンを kill-ring にコピーし
てヤンク出来るようにするものである。(@ref{copy-region-as-kill, ,
@code{copy-region-as-kill}}, 参照。)

@code{delete-region} 関数は、リージョンの中身を消去してしまうもので、こ
の場合、それを取り戻すことは出来ない。

これまでに議論してきたコードとは異なり、@code{delete-region} は Emacs
Lisp では書かれていない。これは C で書かれており、GNU Emacs system のプ
リミティブの一つである。これは大変単純なものなので、ちょっとの間 Lisp か
ら脱線して、これについて説明することにしよう。
@c
@c 以下の部分はあまりよく分らずに訳しているので、間違いがある可能性が大
@c きいです。「インスタンス」は instance なのだが、これは単に「例」の意
@c 味で使っているのかもしれない。原文は以下の通り
@c Like many of the other Emacs primitives, @code{delete-region} is written
@c as an instance of a C macro, a macro being a template for code.  The
@c first section of the macro looks like this:

他の多くの Emacs のプリミティブと同様、@code{delete-region} も C のマク
ロのインスタンス、つまりコードのテンプレートとしてのマクロとして書かれて
いる。このマクロの最初の部分は次のようである。

@smallexample
@group
DEFUN ("delete-region", Fdelete_region, Sdelete_region, 2, 2, "r",
  "Delete the text between point and mark.¥n¥
When called from a program, expects two arguments,¥n¥
character numbers specifying the stretch to be deleted.")
@end group
@end smallexample

マクロの記述の細かい点に立ち入ることはしないが、このマクロが 
@code{DEFUN} という単語から始まっていることを指摘しておく。ここで 
@code{DEFUN} という単語を選んだのは、このコードが Lisp における 
@code{defun} と同じ目的を持っているためである。単語 @code{DEFUN} の後に
続く括弧の中に7つの部分がある。

@itemize @bullet
@item
最初の部分は、この関数に Lisp の中で与えられる関数の名前である。この場合
は @code{delete-region} である。

@item
二番目は、この関数の C での名前 @code{Fdelete_region} である。便宜上、
@samp{F} から始まっている。C では名前にハイフンを使わないので、代わりに
下線 (underscore) が使われている。

@item
三番目は、内部でこの関数の情報を記録しておくための C の constant な
構造体の名前である。これは、C での関数名であるが、@samp{F} ではなく 
@samp{S} で始まっている。

@item
四番目と五番目は、この関数が引数として取れる最小の数と最大の数を指定して
いる。今の場合はちょうど2つの引数を取る。

@item
六番目は Lisp の関数定義のインタラクティブ宣言に続く引数と同じようなもの
である。文字と、大抵はそれに続くプロンプトが書かれる。今の場合、その文字
は @code{"r"} である。これは、この関数の引数がそのバッファのリージョンの
最初と最後の位置であることを示している。この場合はプロンプトはない。

@item
七番目は、説明文字列である。これも Emacs Lisp の関数
定義の場合とほぼ同じであるが、全ての改行が明示的に @samp{¥n} に続いてバッ
クスラッシュと復帰コードを書くことで示されている。
@end itemize

次に形式的なそのオブジェクトの種類の宣言と一緒にパラメータが来て、そして、
このマクロの本体部分と呼ばれる部分が来る。@code{delete-region} の場合は、
本体は次の三行からなる。

@example
@group
validate_region (&b, &e);
del_range (XINT (b), XINT (e));
return Qnil;
@end group
@end example

最初の関数 @code{validate_region} は、リージョンの始まりと終わりとして渡
された値が正しい型で、適切な範囲かどうかをチェックしている。二番目の関数、
@code{del_range} は、実際にテキストを削除する関数である。もしこの関数が
エラーを起こさず仕事を終えたら、三行目がそのことを示すために @code{Qnil} 
を返す。

@code{del_range} は複雑な関数なので、立ち入らないことにする。これはバッ
ファを更新するなどの働きをする。しかしながら、@code{del_range} に渡され
る二つの引数には注目しておいた方がいいだろう。@w{@code{XINT(b)}} と 
@w{@code{XINT(e)}} の二つである。C 言語として見る限り、@code{b} と 
@code{e} は削除するリージョンの始まりと終わりを表わす二つの32ビットの整
数である。しかしながら、他の Emacs Lisp の数と同様、本来の数として使用さ
れるのは32ビット中の最初の24ビットだけである。残りの8ビットは情報の種類
を保持したりするなど、他の目的のために使われる。(ある種の機械では、最初
のほんの6ビットしか使わなかったりもする。) 今の場合は、この8ビットはこれ
らの数がバッファ内での位置を表すためのものであることを示すために用いられ
る。このような目的のために使われる数は、@dfn{tag} と呼ばれる。このように
32ビット整数の中に8ビットのタグを埋め込むことで、そうしないよりも Emacs 
がずっと速く動作するようにすることが出来る。一方で、数を24ビットに制限し
てしまうために、Emacs のバッファは約8メガバイトに制限されてしまう。(バッ
ファの最大サイズは、コンパイルする前に @file{emacs/src/config.h} の中で 
@code{VALBITS} と @code{GCTYPEBITS} を定義することでぐっと増やすことが出
来る。Emacs の配布に含まれる @file{emacs/etc/FAQ} を参照のこと。)

@samp{XINT} は、32ビットの Lisp オブジェクトから 24ビットの数を取り出す 
C のマクロである。他の目的に使われる8ビットの部分は破棄される。かくして
けで、@w{@code{del_range (XINT (b), XINT (e))}} は、開始位置 @code{b} か
ら 終了位置 @code{e} までの間を消去することになる。Lisp を書く人の立場か
ら見れば、Emacs はおしなべて大変単純な構造をしている。しかし、そのような
動作をさせるために、裏では極めて複雑な処理をやっているというわけである。


@node defvar, copy-region-as-kill, delete-region, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section @code{defvar} を用いた変数の初期化
@findex defvar
@cindex Initializing a variable
@cindex Variable initialization

@code{delete-region} 関数と違って、@code{copy-region-as-kill} 関数は 
Emacs Lisp で書かれている。これはバッファのリージョンを複写して 
@code{kill-ring} と呼ばれる変数に保存するものである。このセクションでは
この変数がどのようにして生成され初期化されるのかを説明する。

(ここでも、@code{kill-ring} という言葉は誤用と言えるだろう。バッファから
切り取られたテキストは取り戻すことが出来るのである。これは、死体の輪なんか
ではなく、復活出来るテキストの輪なのだ。)

Emacs Lisp では、@code{kill-ring} のような変数は @code{defvar} という特
殊形式によって生成され、初期値を与えられる。この名前は ``define
variable'' から来ている。

@code{defvar} という特殊形式は、変数に値を設定する点で @code{setq} 
と似ている。@code{setq} と違う点は二つある。一つ目は、その変数がまだ値を
持っていない場合にのみ値を設定するということである。既に値がある場合には、
@code{defvar} はその値を上書きしたりはしない。二つ目は @code{defvar} に
は説明文字列があるということである。

現在の変数の値は、どんな値であれ、@code{describe-variable} 関数を使って
見ることが出来る。これは普通は @kbd{C-h v} をタイプすることで呼び出せる。
@kbd{C-h v} とタイプして、プロンプトが出た所で @code{kill-ring} (と改行) 
を入力すると、現在の kill リングの中身がどうなっているか見ることが出来る。
これは、滅茶苦茶多いこともある！ 逆に、もし今回 Emacs を起動してからこの
文書を読むだけで他には何もしていなければ、中には何もないはずだ。

また、@file{*Help*} バッファの最後に @code{kill-ring} の説明がなされてい
ることも見てとれる。

@example
@group
Documentation:
List of killed text sequences.
@end group
@end example

この kill リングは @code{defvar} を使って次のように定義されている。

@example
@group
(defvar kill-ring nil
  "List of killed text sequences.")
@end group
@end example

@noindent
この変数定義の中では、この変数は初期値 @code{nil} を与えられている。これ
はもっともなことである。何もセーブしないうちから、ヤンク (yank) コマンド
で何かを取り出したいとは思わないだろう。説明文字列は @code{defun} の
説明文字列と同じように書かれている。
@code{defun} のものと同様、最初の行はそれだけで完全な文になっているべき
だ。何故なら @code{apropos} のような幾つかのコマンドは、最初の一行しか
表示しないからである。また、その後に続く行はインデントすべきではない。そ
うしないと @code{C-h v} (@code{describe-variable}) を使って見た場合に見
栄えがよくない。

@findex edit-options, @r{introduced}
@cindex Options introduced
大抵の変数は Emacs の内部のものである。が、幾つか @code{edit-options} コ
マンドを使って簡単に設定出来るようになっているものもある。(ただし、ここ
での設定はその時のセッション限りのものである。その設定を永続的に使用した
い場合は、@file{.emacs} ファイルを使う。詳しくは @ref{Emacs
Initialization, , Your @file{.emacs} File}, を参照のこと。)

簡単に設定出来る変数は、Emacs の中で、説明文字列の一
桁目にアスタリスク @samp{*} を付けることで他の変数と区別されている。

例えば、

@example
@group
(defvar line-number-mode nil
  "*Non-nil means display line number in mode line.")
@end group
@end example

@noindent
これは @code{edit-options} コマンドを使って @code{line-number-mode} の値
を変化させることが出来ることを示している。

勿論、@code{setq} 式を使って @code{line-number-mode} の値を変化させるこ
とも出来る。例えば次のようにすればよい。

@example
(setq line-number-mode t)
@end example

@noindent
@ref{Using setq, ,  Using @code{setq}}, 参照。

@node copy-region-as-kill, cons & search-fwd Review, defvar, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section @code{copy-region-as-kill}
@findex copy-region-as-kill
@findex nthcdr

@code{copy-region-as-kill} 関数はバッファからリージョンのテキストを複写
して、@code{kill-ring} と呼ばれる変数の中に保存する。

もし、@code{kill-region} コマンドを前回の @code{kill-region} コマンドの
直後に呼び出したとすると、Emacs は新しく複写したテキストを以前複写したテ
キストに付加 (append) する。これは、もしそのテキストをヤンクした場合、以
前複写した分と今回複写した分を合わせた全体を戻すことになるということを意
味する。一方、もし @code{copy-region-as-kill} に先立って他のコマンドを使
用した場合には、複写したテキストは kill リングの新しい別の部分に、それま
でに複写したものと区別されて保存される。

以下が version 18 での @code{copy-region-as-kill} の完全な定義である。た
だし、見やすいように幾つかのコメントを加えて整形してある。

@example
@group
(defun copy-region-as-kill (beg end)
  "Save the region as if killed, but don't kill it."
  (interactive "r")
@end group

@group
  (if (eq last-command 'kill-region)

      ;; @r{then-part: 新しくコピーされたテキストを}
      ;; @r{  前回コピーされたものと結合}
      (kill-append (buffer-substring beg end) (< end beg))
@end group

@group
    ;; @r{else-part: 新しくコピーされたテキストを新たな要素として}
    ;; @r{  kill リングに追加し、必要なら kill リングを短くする。}
    (setq kill-ring
          (cons (buffer-substring beg end) kill-ring))
    (if (> (length kill-ring) kill-ring-max) 
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group

@group
  (setq this-command 'kill-region)
  (setq kill-ring-yank-pointer kill-ring))
@end group
@end example

これまで同様、この関数もまとまりのある幾つかの部分に分けることが出来る。

@example
@group
(defun copy-region-as-kill (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  (interactive "r")
  @var{本体}@dots{})
@end group
@end example

引数は @code{beg} と @code{end} であり、@code{"r"} によってインタラクティ
ブ宣言がなされている。つまり、二つの引数は各々リージョンの始まりと終わり
を示すものである。もしこの文書をきちんと最初から読んできたなら、この部分
を理解するのは殆どルーティーンワークにすぎないだろう。

この関数の本体は、@code{if} 式で始まっている。この式でやっているのは二つ
の状況を区別することである。つまり、このコマンドが@code{kill-region} コ
マンドが呼び出された直後に実行されたかどうかの判断である。もし直後に実行
されたなら、新しく複写されるリージョンは以前複写された部分に付加される。
そうでない場合は、kill リングの先頭に、以前複写されたものとは区別されて
保存される。

この関数定義の最後の二行は、二つの @code{setq} 式である。一つは変数 
@code{this-command} を @code{kill-region} に、もう一つは変数 
@code{kill-ring-yank-pointer} を kill リングに設定する。

この @code{copy-region-as-kill} の本体部分は詳しく見る価値がある。

@menu
* copy-region-as-kill body::    @code{copy-region-as-kill} の本体部分
@end menu

@node copy-region-as-kill body,  , copy-region-as-kill, copy-region-as-kill
@comment  node-name,  next,  previous,  up
@subsection @code{copy-region-as-kill} の本体部分

@code{copy-region-as-kill} 関数は、二行以上の kill を一つの項目につなげ
るように書かれている。もし、それらを kill リングからヤンクして取り出すと、
一箇所にまとめて取り出される。更に、現在のカーソルの位置から前方 (つまり
テキストの終わりの方) に向かって kill すると、その部分は以前 kill したテ
キストの後に付け加えられ、後方 (つまりテキストの始まりの方) に向かって 
kill すると、以前 kill したテキストの前に付け加えられる。こうしてテキス
トの部分は正しい順序に保たれることになる。

この関数は、現在、及びその一つ前に Emacs が実行したコマンドを憶えておく
ために二つの変数 @code{this-command} と @code{last-command} を使っている。

通常、Emacs はどんな関数を実行している場合でも @code{this-command} の値
を現在実行中のコマンドの値 (今の場合なら @code{copy-region-as-kill}) に
セットしている。しかしながら、@code{copy-region-as-kill} の場合は違う。
この関数は @code{this-command} の値を @code{kill-region} にセットする。
これは @code{copy-region-as-kill} を呼び出している関数の名前である。

@code{copy-region-as-kill} の本体部分の最初のパートでは、@code{if} 式で 
@code{last-command} が @code{kill-region} かどうかを判定している。もしそ
うであれば、@code{kill-append} 関数を使って今回複写したテキストを kill
リングの最初の要素 (つまり @sc{car}) のテキストと結合する。一方、もしも 
@code{last-command} の値が @code{kill-region} で無ければ 
@code{copy-region-as-kill} 関数は kill リングに新しい要素を付け加えること
になる。

@need 1250
@code{if} 式は次の通りである。これは @code{eq} を使っているが、この関数
はここで初めて出てきたものである。

@example
@group
(if (eq last-command 'kill-region)
    ;; @r{then-part}
    (kill-append (buffer-substring beg end) (< end beg))
@end group
@end example

@findex eq @r{(example of use)}
@noindent
@code{eq} 関数は、最初の引数が二番目の引数と同じ Lisp オブジェクトかどう
かを判定するものである。@code{eq} 関数は @code{equal} 関数と、等しいかど
うかの判定をするという点では似ているが、異なる名前を持つものが、計算機の
内部で実際に同じオブジェクトかどうかを判定するのかそうでないか、という点
で異なっている。@code{eq} の方は同じオブジェクトの場合でないと真を返さな
いが、@code{equal} 関数の方は二つの式が同じ構造でありかつ同じ内容であり
さえすれば真を返す。

@noindent
(訳註：ここはちょっと分り難いかもしれない。詳しくは @ref{Equality
Predicates, , Equality Predicates, elisp, The GNU Emacs Lisp Reference
Manual}, を参照。なお、
@ref{List Implementation, , リストはどのように実装されているか}, も参考
になる。)

@menu
* kill-append function::        @code{kill-append} 関数
* copy-region-as-kill else-part::  @code{copy-region-as-kill} の else-part 
@end menu

@node kill-append function, copy-region-as-kill else-part, copy-region-as-kill body, copy-region-as-kill body
@unnumberedsubsubsec 関数 @code{kill-append}
@findex kill-append

@code{kill-append} 関数は次のようなものである。

@example
@group
(defun kill-append (string before-p)
  (setcar kill-ring
          (if before-p
              (concat string (car kill-ring))
              (concat (car kill-ring) string))))
@end group
@end example

この関数をパートごとに見ていこう。@code{setcar} 関数は @code{concat} を
使って新しいテキストを kill リングの @sc{car} と結合している。新しい方の
テキストを前に持ってくるか、後に持ってくるかは @code{if} 式の結果による。

@example
@group
(if before-p                            ; @r{if-part}
    (concat string (car kill-ring))     ; @r{then-part}
  (concat (car kill-ring) string))      ; @r{else-part}
@end group
@end example

@noindent 
もし、今回切り取ったリージョンが直前のコマンドで切り取ったテキストよりも
前にあれば、今回切り取ったものは以前保存したものの前につなげるべきである
し、逆に、今回切り取ったテキストが以前切り取ったテキストの後に続くものな
ら、以前保存したものの後につなげるべきである。@code{if} 式は今回保存する
テキストを以前保存しておいたテキストの前につけるか後につけるかを
@code{before-p} という述語で判断している。

シンボル @code{before-p} は @code{kill-append} の引数の名前の一つである。
@code{kill-append} 関数が評価されると、これは実際の引数を評価して返され
た値にバインドされる。今の場合であれば、@code{(< end beg)} の値がバイン
ドされる。このＳ式は、今回のコマンドで切り取られたテキストが直前のコマン
ドで切り取られたテキストの前に属しているか、それとも後に属しているかを、
直接判定しているわけではない。この式がやっているのは変数 @code{end} の値
が変数 @code{beg} の値よりも小さいかどうかの判定だけである。もし小さけれ
ば、それはユーザがおそらくはバッファの先頭に向かっているということを意味
する。というわけで、この場合は以前のテキストの前に今回のテキストを追加す
るようになっている。一方、もし @code{end} の値の方が @code{beg} の値より
も大きかった場合、今回のテキストは以前のテキストの後尾に追加される。

新しく保存したテキストが以前保存したテキストの前に追加される場合は、その
新しいテキストを前にして古いテキストと結合される。

@example
(concat string (car kill-ring))
@end example

@noindent
逆に、テキストが後に追加される場合は、新しいテキストを古いテキストの後に
して結合する。

@example
(concat (car kill-ring) string))
@end example

この関数の動作を理解するためには、@code{concat} 関数の復習から始めなけれ
ばならないだろう。@code{concat} 関数は二つのテキスト文字列を一つにつ
なげるものである。結果も文字列になる。例えば次のような感じである。

@example
@group
(concat "abc" "def")
     @result{} "abcdef"
@end group

@group
(concat "new " 
        (car '("first element" "second element")))
     @result{} "new first element"

(concat (car 
        '("first element" "second element")) " modified")
     @result{} "first element modified"
@end group
@end example

以上で @code{kill-append} 関数が理解出来るようになる。これは、kill リン
グの中身を修正するものである。kill リングはリストであり、各々の要素は保
存されたテキストである。@code{setcar} 関数が実際にこのリストの最初の要素
を置き換える役目を果たしている。そのために、まず @code{concat} で kill リ
ングの最初の要素 (kill リングの @sc{car}) と新しいテキストを結合し、元の
要素をその新しく出来た要素で置き換えている。新しく保存するテキストを元々
のテキストの前に結合するか後に結合するかは、それが古いテキストを切り取っ
た場所の前にあるか後にあるかによる。結合された結果が kill リングの新しい
最初の要素となる。

ついでながら、私の現在の kill リングの最初の方を挙げておこう。

@example
("concatenating together" "saved text" "element" @dots{}
@end example

@node copy-region-as-kill else-part,  , kill-append function, copy-region-as-kill body
@unnumberedsubsubsec @code{copy-region-as-kill} の else-part

さて、@code{copy-region-as-kill} の説明に戻ろう。

@need 1500
もし直前のコマンドが @code{kill-region} でなかったとすると、この場合は 
@code{kill-append} ではなく、次のＳ式の else-part が呼ばれることになる。

@example
@group
(if @var{真偽テスト}
    @var{テストが真だった時の動作}
  ;; @r{else-part}
  (setq kill-ring
        (cons (buffer-substring beg end) kill-ring))
  (if (> (length kill-ring) kill-ring-max)
      (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@end example

else-part の @code{setq} の行では、kill リングの新しい値として、古い 
kill リングの値に新しく削除した文字列を加えた結果をセットしている。

これがどういうことをやっているかを簡単な例で見てみることにしよう。

@example
(setq example-list '("here is a clause" "another clause"))
@end example

このＳ式を @kbd{C-x C-e} で評価すると、@code{example-list} が評価出来る
ようになる。その結果は次の通り。

@example
@group
example-list
     @result{} ("here is a clause" "another clause")
@end group
@end example

@noindent
さて、次のＳ式を評価することで、このリストに新しい要素を付け加えてみよう。

@example
(setq example-list (cons "a third clause" example-list))
@end example

@noindent
そうして再度評価すると、次の値が返されるのが分る。

@smallexample
@group
example-list
     @result{} ("a third clause" "here is a clause" "another clause")
@end group
@end smallexample

@noindent
かくして、三番目の要素が @code{cons} によってリストに加えられた。

この関数での @code{setq} や @code{cons} も上と同じことをやっているのであ
る。違うのは、リージョンのテキストを取り出して @code{cons} に渡すために、
@code{buffer-substring} を使っていることである。その行をもう一度抜き出し
ておく。

@example
(setq kill-ring (cons (buffer-substring beg end) kill-ring))
@end example

@code{copy-region-as-kill} の else-part の次の部分は、もう一つの if 式で
ある。この @code{if} 式は kill リングが長くなりすぎるのを防ぐものである。
この部分は以下のようになっている。

@example
@group
(if (> (length kill-ring) kill-ring-max)
    (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@end example

このコードはまず kill リングの長さが最大許容範囲にを越えていないかどうか
チェックしている。最大許容範囲とは @code{kill-ring-max} の値 (デフォルト
では 30) のことである。もしこの長さがそれより長ければ、このコードは kill 
リングの最後の要素を @code{nil} にセットする。そのために二つの関数 
@code{nthcdr} と @code{setcdr} を利用している。

先に @code{setcdr} の方を見ることにする。(@ref{setcdr, , @code{setcdr}}, 
参照。) これはリストの @sc{cdr} を設定するものである。@code{setcar} が
リストの @sc{car} を設定するのと同様だ。しかしながら、この場合 
@code{setcdr} は kill リング全体の @code{cdr} を設定するのではない。

@code{nthcdr} 関数は繰り返しリストの @sc{cdr} を取ることで動作する。つま
り、@sc{cdr} の @sc{cdr} を取り、そのまた @sc{cdr} を取り @dots{} という
操作を N 回繰り返して、その値を返すのである。

もし四つの要素のリストがあって、それを(最初の)三つの要素のリストにしたい
場合、二回 @sc{cdr} を取って出来たリストの @sc{cdr} を @code{nil} に設定
すればよい。このようにして、リストを短く出来るのである。

以上のことは、下の三つのＳ式を順に評価していくことで理解出来る。まずは 
@code{trees} の値を @code{(maple oak pine birch)} にセットし、次にその二
番目の @sc{cdr} の @sc{cdr} を @code{nil} にセットする。そして 
@code{trees} の値を見てみるのである。

@example
@group
(setq trees '(maple oak pine birch))
     @result{} (maple oak pine birch)
@end group

@group
(setcdr (nthcdr 2 trees) nil)
     @result{} nil

trees
     @result{} (maple oak pine)
@end group
@end example

@noindent
(@code{setcdr} 式そのものの値は @code{nil} になる。これは、@sc{cdr} 
を @code{nil} にセットしたからである。)

繰り返しのために @code{nthcdr} 関数を使って、@code{copy-region-as-kill} 
に対し kill リングの最大許容範囲よりも1少ない回数だけ @sc{cdr} を取り、
最後に返された @sc{cdr} の値(これは kill リングの最後の要素である)を 
@code{nil} にセットする。こうして kill リングが長くなり過ぎることを防い
でいるのである。

@code{copy-region-as-kill} 関数の次の行は

@example
@code{(setq this-command 'kill-region)}
@end example

@noindent
である。この行は内側のＳ式にも外側の @code{if} 式にも属していない。従っ
て、@code{copy-region-as-kill} が呼ばれるたびに毎回評価される。ここの部
分で @code{this-command} が @code{kill-region} に設定されていることが分
るだろう。前に見たように、次のコマンドが与えられると、この値は 
@code{last-command} の値になる。

@need 1250
最後に @code{copy-region-as-kill} の最後の行を見てみよう。

@example
(setq kill-ring-yank-pointer kill-ring)
@end example

@code{kill-ring-yank-pointer} は @code{kill-ring} に設定されるグローバ
ル変数である。

@code{kill-ring-yank-pointer} はポインタ (@samp{pointer}) とは呼ばれてい
るけれども、実際は kill-ring と同じような変数である。ただし、このような
名前がついているのは、この変数の使われ方がよく分るようにするためである。
この変数は @code{yank} や @code{yank-pop} などの関数で使用される。
(@ref{Yanking, , テキストのヤンク}, 参照。)

この辺りの話をするにはやはり、バッファから切り取ったテキストを取り戻すた
めのコマンド---ヤンクコマンドについて話さなければなるまい。が、その話をす
る前に、リストが計算機の内部でどのように扱われるかを説明しておいた方が良
いだろう。そうすることで、「ポインタ」といったミステリアスな言葉を明確に
理解出来るようになるだろう。

@node cons & search-fwd Review, search Exercises, copy-region-as-kill, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section 復習

この辺りで導入した関数についての簡単なまとめを載せておく。

@table @code
@item car
@itemx cdr
@code{car} はリストの最初の要素を返す。@code{cdr} はリストの二番目以降の
要素からなるリストを返す。

@need 1250
例）

@example
@group
(car '(1 2 3 4 5 6 7))
     @result{} 1
(cdr '(1 2 3 4 5 6 7))
     @result{} (2 3 4 5 6 7)
@end group
@end example

@item cons
@code{cons} は最初の引数を二番目の引数の前に加えることで新たなリストを作
成する。

@need 1250
例）

@example
@group
(cons 1 '(2 3 4))
     @result{} (1 2 3 4)
@end group
@end example

@item nthcdr
リストに対して `n' 回 @code{cdr} を取った結果を返す。言わば `残り' の
`残り' である。

@need 1250
例）

@example
@group
(nthcdr 3 '(1 2 3 4 5 6 7))
     @result{} (4 5 6 7)
@end group
@end example

@item setcar
@itemx setcdr
@code{setcar} はリストの最初の要素を置き換える。@code{setcdr} はリストの
二番目以降の要素を置き換える。

@need 1250
例）

@example
@group
(setq triple '(1 2 3))

(setcar triple '37)

triple
     @result{} (37 2 3)

(setcdr triple '("foo" "bar"))

triple
     @result{} (37 "foo" "bar")
@end group
@end example

@item progn
引数を順に評価していき、最後の値を返す。

@need 1250
例）

@example
@group
(progn 1 2 3 4)
     @result{} 4
@end group
@end example

@item save-restriction
カレントバッファのナローイングの情報をどんな状態であれ保存し、引数を評価
し終った後、その状態を復元する。

@item search-forward
文字列を検索し、もし文字列が見つかれば、そこにポイントを移動する。

@noindent
引数は次の四つ

@enumerate
@item
検索文字列。

@item
(省略可能) 検索範囲。

@item
(省略可能) 検索に失敗した時に @code{nil} を返すかエラーメッセージを出すか
を指定。

@item
(省略可能) 検索を何回実行するかを指定。負数の場合は後方検索になる。
@end enumerate

@item kill-region
@item delete-region
@item copy-region-as-kill

@code{kill-region} はバッファのポイントとマークの間のテキストを切り取って
それを kill リングに保存する。このテキストはヤンクによって取り出すことが
出来る。

@code{delete-region} はポイントとマークの間のテキストをバッファから削除
して捨ててしまう。復活させることは出来ない。

@code{copy-region-as-kill} はポイントとマークの間のテキストを kill リング
に複写する。これはヤンクによって取り出すことが出来る。この関数はバッファ
からテキストを切り取ったり削除したりはしない。
@end table

@need 1500
@node search Exercises,  , cons & search-fwd Review, Cutting & Storing Text
@section 検索についての練習問題

@itemize @bullet
@item
文字列を検索するインタラクティブな関数を書きなさい。もし文字列の
検索に成功すればその直後にポイントを移動し、「見つけた！」というメッセー
ジを表示するようにしなさい。(この関数の名前に @code{search-forward} とい
う名前を使ってはいけない。そうしてしまうと、元の Emacs で定義された現在
の @code{search-forward} を上書きしてしまう。例えば @code{test-search} 
という名前を使いなさい。

@item
現在の kill リングの三番目の内容をエコー領域に表示するような関数を書きな
さい。その際、もし kill リングに三番目の要素が無い場合にも適切なメッセー
ジを表示するようにしなさい。

@item
version 19.29 では @code{copy-region-as-kill} はもはや 
@code{this-command} に値をセットしない。この変更で、どのような影響が出る
か？ また、何故このような変更が行われたと思うか。
@end itemize

@node List Implementation, Yanking, Cutting & Storing Text, Top
@comment  node-name,  next,  previous,  up
@chapter リストはどのように実装されているか
@cindex Lists in a computer

Lisp では、アトムは直接的な方法で記録される。たとえ現実の実装方法が直接
的ではなかったとしても、理論上は直接的である。例えば @samp{rose} という
アトムは四つの隣接する文字 @samp{r}, @samp{o}, @samp{s}, @samp{e} として
記録される。一方、リストはもっと異なる方法で記録される。メカニズムとして
は同じくらい単純なのだが、そのアイディアに慣れるのにはちょっと時間がかか
るかもしれない。リストは、ポインタのペアの列として記録される。この列の中
で、各々のペアの一番目のポインタは、あるアトムか、もしくは他のリストを指
している。そして、二番目のポインタは次のペアか、シンボル @code{nil} を指
している。@code{nil} の場合はリストの終わりということである。

ポインタそれ自身は、指されている対象の極めて単純な電気的な住所だと言える。
従って、リストも電気的な住所の列として記録されていると言える。例えば、
@code{(rose violet buttercup)} というリストは @samp{rose},
@samp{violet}, @samp{buttercup} という三つの要素を持っている。計算機の中
では、@samp{rose} の電気的な住所は、ある計算機のメモリのセグメントに 
@samp{violet} というアトムの電気的な住所を示すアドレスに並んで記されてい
る。そしてこっちの住所 (@samp{violet} の場所を示すもの) は 
@samp{buttercup} というアトムの電気的な住所を示すアドレスに並んで記され
ている。

このように書くと何やら複雑に思えるかもしれないが、図に書いてみれば簡単に
理解出来るだろう。

@c clear print-postscript-figures
@c !!! cons-cell-diagram #1
@ifinfo
@example
@group
@c ascii diagram
    ___ ___      ___ ___      ___ ___ 
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |      
     |            |            |
      --> rose     --> violet   --> buttercup
@c    ┌─┬─┐   ┌─┬─┐   ┌─┬─┐
@c    │  │  ├─>│  │  ├─>│  │  ├─> nil
@c    └┬┴─┘   └┬┴─┘   └┬┴─┘
@c      │           │           │
@c      └─> rose   └─> violet └─> buttercup
@c ascii diagram end
@end group
@end example
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@example
@group
    ___ ___      ___ ___      ___ ___ 
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |      
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end example
@end iftex
@end ifclear

@noindent
上の図の中で、各々の箱は Lisp オブジェクトを保持する計算機のメモリのワー
ドを表現している。これは普通はメモリアドレスの形をしている。これらの箱、
即ち住所は、ペアになっている。各々の矢印は、そのアドレスを持つ住所を指し
ている。その場所には、アトムか他のアドレスのペアがある。最初の箱は 
@samp{rose} の電気的な住所であり、矢印は @samp{rose} を指している。二番
目の箱は次の箱のペアを指しており、こっちのペアの一番目の箱は 
@samp{violet} の住所、そして二番目の箱はまた次のペアのアドレス、という具
合になっている。そして最後の箱は、シンボル @code{nil} を指している。これ
は、リストの最後を示している。

@code{setq} などの関数によってある変数がこのリストにセットされた場合、こ
のリストの先頭の箱のアドレスがこの変数にセットされる。従って、

@example
(setq bouquet '(rose violet buttercup))
@end example

@need 1250
@noindent
というＳ式を評価すると、以下のような状況になる。

@c cons-cell-diagram #2
@ifinfo
@example
@group
@c ascii diagram
bouquet
     |
     |     ___ ___      ___ ___      ___ ___ 
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |      
            |            |            |
             --> rose     --> violet   --> buttercup
@c bouquet
@c    │
@c    │   ┌─┬─┐   ┌─┬─┐   ┌─┬─┐
@c    └─>│  │  ├─>│  │  ├─>│  │  ├─> nil
@c         └┬┴─┘   └┬┴─┘   └┬┴─┘
@c           │           │           │
@c           └─> rose   └─> violet └─> buttercup
@c ascii diagram end
@end group
@end example
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@example
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___ 
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |      
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end example
@end iftex
@end ifclear

@noindent
この場合、シンボル @code{bouquet} が最初のペアのアドレスを持つことになる。
実際、シンボル @code{bouquet} は幾つかのアドレスボックスから出来ている。
一つは表示される単語の @samp{bouquet} の住所であり、二つ目はこのシンボル
に定義されている関数のアドレスであり、三つ目はリスト @code{(rose violet
buttercup)} というリストの最初のアドレスボックスのペアのアドレスであり、
というふうである。

同じリストをちょっと箱の書き方を変えた別のイラストで描いてみると、次のよ
うになる。

@c cons-cell-diagram #2a
@ifinfo
@smallexample
@group
@c ascii diagram
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@c bouquet
@c  │
@c  │   ┌───┬──┐   ┌───┬──┐   ┌─────┬──┐
@c  │   │car   │cdr │   │car   │cdr │   │car       │cdr │
@c  └─>│rose  │  ・──>│violet│  ・──>│buttercup │ nil│
@c       └───┴──┘   └───┴──┘   └─────┴──┘
@c ascii diagram end
@end group
@end smallexample
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2a}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end iftex
@end ifclear

最初の方のセクションでは、シンボルを引き出しが幾つかある整理棚だと見倣す
と良いと書いた。関数定義がある引き出しに入っており、値は他の引き出しに入っ
ている、という説明だ。値がある引き出しの中身は他の引き出しの中身に影響を
与えずに変えることが出来るし、その逆も可能だとも書いた。実際には、各々の
引き出しに入っているのは値や関数定義のアドレスである。これは、屋根裏部屋
で古い棚を見つけて、その引き出しの一つを空けてみると宝が埋まっている場所
が描かれた地図が見つかった、ということに例えられよう。

(名前だけではなく、シンボルの定義や変数の値、また、その他の情報を取り出
すための @dfn{属性リスト} (@dfn{property list}) の「引き出し」というもの
もある。属性リストについてはここでは説明はしない。@ref{Property Lists, ,
Property Lists, elisp, The GNU Emacs Lisp Reference Manual}, を参照のこ
と。)

@need 1500
次は空想上の整理棚の絵である。

@c chest-of-drawers diagram
@ifinfo
@sp 1
@smallexample
@group
@c ascii diagram
           Chest of Drawers             Contents of Drawers

         ---------------------
        |                     |
        |    symbol name      |             bouquet
        |                     |
         ---------------------
        |                     |
        |  symbol definition  |             [none]
        |                     |
         ---------------------
        |                     |
        |   variable value    |             (rose violet buttercup)
        |                     |
         ---------------------
        |                     |
        |   property list     |             [not described here]
        |                     |
         ---------------------
        |/                   ¥|
@c            Chest of Drawers              Contents of Drawers
@c 
@c        ┌──────────┐ 
@c        │                    │
@c        │   symbol name      │              bouquet
@c        │                    │
@c        ├──────────┤
@c        │                    │
@c        │ symbol definition  │              [none]
@c        │                    │
@c        ├──────────┤
@c        │                    │
@c        │  variable value    │              (rose violet buttercup)
@c        │                    │
@c        ├──────────┤
@c        │                    │
@c        │  property list     │              [not described here]
@c        │                    │
@c        └──────────┘ 
@c         |／                ＼|
@c ascii diagram end
@end group
@end smallexample
@sp 1
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{drawers}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
           Chest of Drawers             Contents of Drawers

         ---------------------
        |                     |
        |    symbol name      |             bouquet
        |                     |
         ---------------------
        |                     |
        |  symbol definition  |             [none]
        |                     |
         ---------------------
        |                     |
        |   variable value    |             (rose violet buttercup)
        |                     |
         ---------------------
        |                     |
        |   property list     |             [not described here]
        |                     |
         ---------------------
        |/                   ¥|
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

もし、シンボルがあるリストの @sc{cdr} にセットされたなら、そのリスト自身
は変化しない。そのシンボルは単にそのリストのアドレスを持つようになるだけ
である。(専門用語では、@sc{car} や @sc{cdr} は
「非破壊的 (non-destructive)」 であると言う。) 従って、次のＳ式を評価す
ると、

@example
(setq flowers (cdr bouquet))
@end example

@noindent
以下のような状況が生ずる。

@c cons-cell-diagram #3
@ifinfo
@sp 1
@example
@group
@c ascii diagram
bouquet        flowers
  |              |        
  |     ___ ___  |     ___ ___      ___ ___ 
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |      
         |              |            |
          --> rose       --> violet   --> buttercup
@c bouquet        flowers
@c   │             │
@c   │   ┌─┬─┐│   ┌─┬─┐   ┌─┬─┐
@c   └─>│  │  │└─>│  │  │   │  │  │
@c        │  │  ├──>│  │  ├─>│  │  ├─> nil
@c        └┬┴─┘     └┬┴─┘   └┬┴─┘
@c          │             │           │
@c          └─> rose     └─> violet └─> buttercup
@c ascii diagram end
@end group
@end example
@sp 1
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@example
@group
bouquet        flowers
  |              |        
  |     ___ ___  |     ___ ___      ___ ___ 
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |      
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end example
@sp 1
@end iftex
@end ifclear

@noindent
@code{flowers} の値は @code{(violet buttercup)} であるが、これはシンボル 
@code{flowers} がアドレスボックスのペアのアドレスを持ったということである。
このペアの最初の箱には @code{violet} のアドレスがあり、二番目の箱には 
@code{buttercup} のアドレスが入っている。

アドレスボックスのペアは@dfn{コンスセル} (@dfn{cons cell}) もしくは
@dfn{ドット対} (@dfn{dotted pair}) と呼ばれる。@ref{Cons Cell Type, ,
Cons Cell and List Type , elisp, The GNU Emacs Lisp Reference Manual}, 
及び @ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU
Emacs Lisp Reference Manual}, にコンスセルとドット対についてのより詳しい
情報がある。

関数 @code{cons} は、上に述べたようなアドレスの列の先頭に新しいアドレス
ペアを付け加える。例えば、

@example
(setq bouquet (cons 'lily bouquet))
@end example

@noindent
を評価すると

@c cons-cell-diagram #4
@ifinfo
@sp 1
@example
@group
@c ascii diagram
bouquet                       flowers        
  |                             |                 
  |     ___ ___        ___ ___  |     ___ ___       ___ ___        
   --> |   |   |      |   |   |  --> |   |   |     |   |   |       
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |             
         |              |              |             |             
          --> lily       --> rose       --> violet    --> buttercup
@c bouquet                     flowers
@c   │                          │
@c   │   ┌─┬─┐   ┌─┬─┐│   ┌─┬─┐   ┌─┬─┐
@c   └─>│  │  │   │  │  │└─>│  │  │   │  │  │
@c        │  │  ├─>│  │  ├──>│  │  ├─>│  │  ├─> nil
@c        └┬┴─┘   └┬┴─┘     └┬┴─┘   └┬┴─┘
@c          │           │             │           │
@c          └─> lily   └─> rose     └─> violet └─> buttercup
@c ascii diagram end
@end group
@end example
@sp 1
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-4}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet                       flowers        
  |                             |                 
  |     ___ ___        ___ ___  |     ___ ___       ___ ___        
   --> |   |   |      |   |   |  --> |   |   |     |   |   |       
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |             
         |              |              |             |             
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@noindent
という状況になる。この操作ではシンボル @code{flowers} の値を変更している
わけではない。これは次を評価することで確かめられる。

@example
(eq (cdr (cdr bouquet)) flowers)
@end example

@noindent
これは、@code{t} を返すはずだ。再設定されない限り、@code{flowers} はずっ
と @code{(violet buttercup)} という値を持ったままである。つまり、最初の
アドレスが @code{violet} であるコンスセルのアドレスを持っているというこ
とだ。また上の操作は、既に存在しているコンスセルを変えたりはしない。そ
れらは全てそのままである。

従って、Lisp でリストの @sc{cdr} を得るには、単にその列の隣りのコンスセ
ルのアドレスを得ればよく、また @sc{car} を得るには、単にそのリストの最初
の要素のアドレスを得ればよい。更に、リストに新しい要素を @code{cons} す
るには、リストの先頭に新しいコンスセルを加えればよい。以上がこの話題に
関する全てである。Lisp の裏側は驚くほど明解で単純のなのだ。

では、コンスセルの列の最後のアドレスはどこに関連づけられているのか？ こ
れは @code{nil}, 即ち、空リストである。

まとめると、Lisp の変数にある値にセットされる時は、その変数には、その変
数が見にいくリストのアドレスが与えられるというわけである。

@menu
* List Exercise::               List についての練習問題
@end menu

@node List Exercise,  , List Implementation, List Implementation
@section 練習問題

@code{flowers} に @code{violet} と @code{buttercup} をセットしなさい。ま
た、このリストに更に二つの花を consし、新しく出来たリストを 
@code{more-flowers} にセットしなさい。@code{flowers} の @sc{car} に魚の
名前をセットしなさい。この時、@code{more-flowers} のリストの中身はどうな
るか。

@node Yanking, Loops & Recursion, List Implementation, Top
@comment  node-name,  next,  previous,  up
@chapter テキストのヤンク
@findex yank
@findex rotate-yank-pointer
@cindex Text retrieval
@cindex Retrieving text
@cindex Pasting text

GNU Emacs で `kill' コマンドでバッファからテキストを切り取った場合、その
テキストは常に、ヤンク (yank) コマンドで取り戻すことが出来る。バッファか
ら切り取られたテキストは kill リングに置かれており、ヤンクコマンドは、こ
の kill リングの中から該当する内容を取り出してバッファに挿入する (これは、
元のバッファとは限らない)。

単なる @kbd{C-y} (@code{yank}) コマンドは、kill リングの最初の要素をカレ
ントバッファに挿入する。もし、@kbd{C-y} コマンドのすぐ後に続けて 
@kbd{M-y} とタイプすると、その最初の要素が二番目の要素と取り換えられる。
続けて何回も @kbd{M-y} をタイプすると、その回数だけ最初の要素を入れ替え
ていき、一回りするとまた最初に戻ってそれを繰り返す。(そういうわけで kill
リングは「リスト」ではなく「リング」と呼ばれるのである。しかし、実際にテ
キストを保存しているデータの型はリストに他ならない。リストをリングとして
扱う方法についてのより詳しい話は @ref{Kill Ring, , kill リングの扱い}, 
を参照。)

@menu
* Kill Ring Overview::          kill リングはリストである
* kill-ring-yank-pointer::      @code{kill-ring-yank-pointer} 変数について
* yank nthcdr Exercises::       ヤンクと nthcdr についての練習問題
@end menu

@node Kill Ring Overview, kill-ring-yank-pointer, Yanking, Yanking
@comment  node-name,  next,  previous,  up
@section Kill リングについての概観
@cindex Kill ring overview

kill リングはテキスト形式の文字列のリストである。例えば次のような形を
している。

@example
("some text" "a different piece of text" "yet more text")
@end example

もし私の kill リングが上のものだったとして、ここで私が @kbd{C-y} と押す
と、@samp{some text} という文字列が私が現在いるバッファのカーソルの位置
に挿入される。

@code{yank} コマンドはまた、テキストを複写するのにも使われる。コピーされ
るテキストはバッファから切り取られるのではなく、一旦 kill リングに置かれ、
その後ヤンクされることで挿入されることになる。

kill リングのテキストを取り出すには三つの関数が使われる。通常 @kbd{C-y} 
にバインドされている @code{yank}, 同じく通常 @kbd{M-y} にバインドされて
いる @code{yank-pop}、そして、この二つの関数によって使われる 
@code{rotate-yank-pointer} である。

@example
(insert (car kill-ring-yank-pointer))
@end example

@code{yank} や @code{yank-pop} の働きを理解するには、まず 
変数 @code{kill-ring-yank-pointer} と、関数 @code{rotate-yank-pointer} 
を理解する必要がある。

@node kill-ring-yank-pointer, yank nthcdr Exercises, Kill Ring Overview, Yanking
@comment  node-name,  next,  previous,  up
@section 変数 @code{kill-ring-yank-pointer}

@code{kill-ring-yank-pointer} は、@code{kill-ring} と同じく変数である。
一般に変数は、あるものの値にバインドされることで、それを指し示す働きをす
る。

@need 1000
従って、もし kill リングの値が

@example
("some text" "a different piece of text" "yet more text")
@end example

@need 1250
@noindent
であり、また @code{kill-ring-yank-pointer} が二番目の位置を指していたとす
ると、@code{kill-ring-yank-pointer} の値は

@example
("a different piece of text" "yet more text")
@end example

@noindent
である。前章で説明したように
(@ref{List Implementation, , リストはどのように実装されているか},)、
計算機は @code{kill-ring} と @code{kill-ring-yank-pointer} とに指された
テキストを各々別々に保持しているわけではない。``a different piece of
text'' と ``yet more text'' の二つの言葉は、二重に複製されているのではな
いのである。その代わり二つの Lisp 変数は同じテキストの集まりを指している。
図に表わすと次の通りである。

@c cons-cell-diagram #5
@ifinfo
@example
@group
@c ascii diagram
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___ 
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |      
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text"
            |
             --> "some text"
@c kill-ring    kill-ring-yank-pointer
@c     │             │
@c     │   ┌─┬─┐│   ┌─┬─┐   ┌─┬─┐
@c     └─>│  │  │└─>│  │  │   │  │  │
@c          │  │  ├──>│  │  ├─>│  │  ├─> nil
@c          └┬┴─┘     └┬┴─┘   └┬┴─┘
@c            │             │           │
@c            │             │           └─> "yet more text"
@c            │             │ 
@c            │             └─> "a different piece of text"
@c            │
@c            └─> "some text"
@c ascii diagram end
@end group
@end example
@sp 1
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-5}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@example
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___ 
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |      
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text"
            |
             --> "some text"
@end group
@end example
@sp 1
@end iftex
@end ifclear

変数 @code{kill-ring} と 変数 @code{kill-ring-yank-pointer} は両方ともポ
インタである。しかし、kill リングそのものは、実際に要素を組み合わせたもの
として説明されることが多い。つまり、@code{kill-ring} はリストの計算機内
での位置を指しているというよりは、リストそのものの意味で使われる。それに対
し、@code{kill-ring-yank-pointer} の方は、リストへのポインタという意味で
使われることが多い。

全く同じことについて、こういうふうに二つの言い方を使うと最初は混乱するよ
うに思えるかもしれない。しかしよく考えてみれば合理的である。kill リング
は一般に、Emacs のバッファから最近切り取られたテキストのデータからなって
いると捉えられている。一方 @code{kill-ring-yank-pointer} の方は、kill リ
ングの中でその最初の要素 (つまり @sc{car}) がこれから挿入するデータであ
るような部分、を指し示すために使われる。

@code{rotate-yank-pointer} 関数は、@code{kill-ring-yank-pointer} が指し
示す要素を交換するものである。より詳しく言うと、ポインタが kill リングの
最後の要素を越えて更に次の要素に移ろうとする際に、自動的にポインタを 
kill リングの最初の要素に移動してくれるのだ。このようにしてリストがあた
かもリングであるように扱えるのである。@code{rotate-yank-pointer} 関数そ
れ自身は単純であるが、その中身には多くの細かい説明が必要である。この関数
及び、これよりずっと単純な @code{yank}, @code{yank-pop} 関数については次
の所で説明する。@ref{Kill Ring, , kill リングの扱い}.

@need 1500
@node yank nthcdr Exercises,  , kill-ring-yank-pointer, Yanking
@section @code{yank} と @code{nthcdr} についての練習問題

@itemize @bullet
@item
@kbd{C-h v} (@code{describe-variable}) を使って、あなたの kill リングの値
を見なさい。幾つか kill リングの要素を増やしてから、もう一度 kill リング
の中身を見なさい。@kbd{M-y} (@code{yank-pop}) を使って kill リングの中を
動き回りなさい。あなたの kill リングの中にはどのくらい多くの要素がありま
すか？ @code{kill-ring-max} の値を見なさい。kill リングはもう一杯ですか？ 
それともまだテキストのブロックを追加出来ますか？

@item
@code{nthcdr} と  @code{car} を使って、各々リストの一番目、二番目、三番目、
及び四番目の要素を返すような四つのＳ式を作りなさい。
@end itemize

@node Loops & Recursion, Regexp Search, Yanking, Top
@comment  node-name,  next,  previous,  up
@chapter ループと再帰
@cindex Loops and recursion
@cindex Recursion and loops
@cindex Repetition (loops)

Emacs Lisp は、一つないしは複数のＳ式を繰り返し評価させるのに、主として
二つの方法を持っている。一つは @code{while} ループを利用するもの、もう一
つは@dfn{再帰} (@dfn{recursion}) を使うものである。

繰り返しは非常に役に立つものである。例えば四つの文の分だけ先に移動したい
場合には、一つの文だけ移動するプログラムを書いて、そのプロセスを四回繰り
返せば良い。計算機には飽きるとか疲れるとかいった感情はないので、このよう
な繰り返しをいくらやらせたところで、人間のように過度の繰り返しをさせてし
まってミスを犯しやすくなるといった弊害は無い。

@menu
* while::                       特定のコードの繰り返し
* Recursion::                   再帰: 自分自身を呼び出す関数
* Looping exercise::            ループについての練習問題
@end menu

@node while, Recursion, Loops & Recursion, Loops & Recursion
@comment  node-name,  next,  previous,  up
@section @code{while}
@cindex Loops
@findex while

特殊形式 @code{while} は、最初の引数を評価して返された値が真か偽かを
テストする。ここまでは @code{if} の時と同じである。しかし、次に Lisp イ
ンタプリタがやることはちょっと違っている。

@code{while} 式においても、返された値が偽の場合は、Lisp インタプリタは残
りのＳ式 (このＳ式の本体部分) をスキップし、それを評価したりはしない。し
かし、返された値が真の場合は、Lisp インタプリタは本体部分を評価した後、
もう一度 @code{while} の最初の引数が真か偽かをテストする。もし、返された
値がまたもや真であったなら、Lisp インタプリタは再度本体部分を実行する。

@code{while} 式のテンプレートは次の通りである。

@example
@group
(while @var{真偽テスト}
  @var{本体}@dots{})
@end group
@end example

@code{while} 式の真偽テストの部分が真を返している限り、本体部分は繰り返
し評価される。このプロセスはループと呼ばれる。これは、Lisp インタプリタ
が何回も同じことを繰り返す様子が、飛行機の宙返りと似ているためである。
真偽テストの結果が偽の場合は、Lisp インタプリタはそこで @code{while} 式
の残りの部分を評価するのを止めて「ループを抜ける」。

当たり前のことだが、もし @code{while} 式の最初の引数が常に真を返すとする
と、その後の本体部分は何回でも無限に評価され続ける。逆にもし真になり得な
いとすると、本体部分の式は決して評価されることはない。@code{while} 式
のループを書く工程とは、本体部分のＳ式の評価を繰り返したい回数だけ真偽テ
ストが真の値を返し、そしてその後、偽を返すような仕掛けを作ることである。

@code{while} 式を評価した場合に返される値は真偽テストが返す値である。従っ
て面白いことに、エラーなく評価された @code{while} ループは、たとえ100回
ループを繰り返した後でも一度もループしなかった場合でも、必ず @code{nil} 
を返す。正しく評価された @code{while} 式は決して真の値を返すことはないわ
けだ！ このことは、@code{while} 式は常に副作用を目的として評価されること
を意味する。即ち、@code{while} ループの中の本体部分のＳ式を評価するため
に評価されるのである。これは理にかなっている。単にループを繰り返すことが
目的なのではなく、ループの中のＳ式を繰り返し評価した時に生じる結果こそが
望むものなのだから。

@menu
* Loop Example::                リストを使った @code{while} ループ
* print-elements-of-list::      @code{while}, @code{car}, @code{cdr} の利用
* Incrementing Loop::           増加するカウンタを使ったループ
* Decrementing Loop::           減少するカウンタを使ったループ
@end menu

@node Loop Example, print-elements-of-list, while, while
@comment  node-name,  next,  previous,  up
@subsection @code{while} ループとリスト

@code{while} ループをコントロールする一般的な方法は、リストが要素を持っ
ているかどうかをテストすることである。もし要素が一つもなければ、それは空
リストであり、結果として空リスト @code{()} が返される。これは、
@code{nil} もしくは偽 (false) の同義語である。一方、要素を持つリストの場
合は、それらの要素そのものが返される。Lisp は @code{nil} 以外のものは全
て真と見倣すので、この場合は @code{while} ループでは真が返されたことにな
る。

例えば、次のＳ式を評価すると、変数 @code{empty-list} の値を @code{nil} 
にセットすることが出来る。

@example
(setq empty-list ())
@end example

@noindent
この @code{setq} 式を評価した後、変数 @code{empty-list} をいつものように
カーソルをこのシンボルのすぐ後に持っていって @code{C-x C-e} とタイプすこ
とで評価してみよう。エコー領域に @code{nil} が表示されるはずだ。

@example
empty-list
@end example

一方、変数を要素を持つリストにセットした場合は、その変数を評価するとその
リストが表示される。これは次の二つのＳ式を評価することで確かめられる。

@example
@group
(setq animals '(giraffe gazelle lion tiger))

animals
@end group
@end example

ということで、リスト @code{animals} に要素があるかをテストに使用するよう
な @code{while} ループを作るには、ループの最初の部分を次のように書けばよ
い。

@example
@group
(while animals
       @dots{}
@end group
@end example

@noindent
@code{while} が最初の引数をテストすると、変数 @code{animals} が評価され
る。これはリストを返す。このリストが要素を持っている限り、@code{while} 
はテストの結果が真だと判断する。しかし、リストが空になると、結果は偽だと
判断される。

@code{while} ループが無限に続くことを避けるためには、最終的にリストが空
になるような何らかの仕掛けが必要である。よく使われるテクニックは、
@code{while} 式の本体部分の形式の一つでそのリストの値をそのリストの 
@code{cdr} で置き換えるようにしておくことである。@code{cdr} 関数が評価さ
れるごとにそのリストは短くなっていき、ついには空リストが残されるというわ
けである。そうなると @code{while} ループのテストは偽を返し、@code{while} 
の引数はもはや評価されず、ループが終了する。

例えば、動物のリストが変数 @code{animals} にバインドされていた時は、次
のＳ式を使ってその変数を元のリストの @sc{cdr} にセットすることが出来る。

@example
(setq animals (cdr animals))
@end example

@noindent
もし一つ前のＳ式を評価してあったなら、このＳ式を評価するとエコー領域に 
@code{(gazelle lion tiger)} が表示されるはずだ。もう一度このＳ式を評価す
ると、今度は @code{(lion tiger)} が表示される。更に評価すると、
@code{(tiger)} が表示され、そこでまた評価すると、やっと空リストになって、
@code{nil} が表示される。

@code{cdr} 関数を繰り返し使うことで最終的に真偽テストで偽を返す 
@code{while} ループのテンプレートは次のようになる。

@example
@group
(while @var{リストが空かどうかのテスト}
  @var{本体}@dots{}
  @var{リストに自分自身の cdr をセット})
@end group
@end example

このテストと @code{cdr} の利用を組み合わせて、リストの各要素を各々一行ご
とに表示するような関数を作ることが出来る。これを次に説明することにしよう。

@node print-elements-of-list, Incrementing Loop, Loop Example, while
@subsection リストを使ったループの例: @code{print-elements-of-list}
@findex print-elements-of-list

リストを使った @code{while} ループのことを理解するには 
@code{print-elements-of-list} 関数を見ると良い。

@cindex @file{*scratch*} buffer
この関数は、出力を表示するために幾つかの行を必要とする。エコー領域は一行
しかないので、今まで説明して来たように Info の中で評価するようなやり方で
はその動作をうまく描写出来ない。代わりに必要なＳ式を @file{*scratch*} バッ
ファにコピーして、そこでそれらを評価する必要がある。コピーするには、まず
対象となるリージョンの最初を @kbd{C-@key{SPC}} (@code{set-mark-command}) 
でマークしてからカーソルをリージョンの最後に移動し、@kbd{M-w}
(@code{copy-region-as-kill}) でそのリージョンをコピーする。そして 
@file{*scratch*} バッファで @kbd{C-y} (@code{yank}) することで、そのＳ式
を取り出せばよい。

@file{*scratch*} バッファにそのＳ式をコピーしたら、今度はそのＳ式を評価
するのだが、最後の @code{(print-elements-of-list animal)} は @kbd{C-u
C-x C-e} とタイプして評価する必要がある。つまり @code{eval-last-sexp} に
前置引数を与えるのである。すると、評価した結果はエコー領域ではなく 
@code{*scratch*} バッファに表示される。(単に @kbd{C-x C-e} とするだけだ 
と、返された値はエコー領域に @code{^Jgiraffe^J^Jlion^J^Jtiger^Jnil} のよ
うに表示されてしまう。ここで出て来る @samp{^J} は改行を表している。従っ
て @code{*scratch*} バッファでは各々の単語は一行ごとに表示されることにな
るわけである。このことは、今 Info バッファで次のＳ式を評価してみても確か
められる。)

@example
@group
(setq animals '(giraffe gazelle lion tiger))

(defun print-elements-of-list (list)
  "Print each element of LIST on a line of its own."
  (while list
    (print (car list))
    (setq list (cdr list))))

(print-elements-of-list animals)
@end group
@end example

@noindent
これらの三つのＳ式を順に @file{*scratch*} バッファで評価していくと、その
バッファの中で次のように表示されるはずだ。

@example
@group
giraffe

gazelle

lion

tiger
nil
@end group
@end example

リストの各要素が各々一行ごとに表示され (これは @code{print} の仕事である)、
そして最後にこの関数自体が返した値が表示される。この関数の中の最後のＳ式
は @code{while} ループであり、@code{while} ループは常に @code{nil} を返
すので、@code{nil} がリストの最後の要素の後に表示される。

@node Incrementing Loop, Decrementing Loop, print-elements-of-list, while
@comment  node-name,  next,  previous,  up
@subsection 増加するカウンタを使ったループ

ループは止まるべき時に止まってくれないことには役に立たない。リストを使っ
たループの制御以外の一般的な方法としては、最初の引数として、正しい回数だ
け繰り返すと偽を返すテストを書くという方法がある。これは、ループがカウン
タ---つまりループを繰り返した回数を数えるＳ式---を持つということである。

真偽テストとしては、@code{(< count desired-number)} といったＳ式が使える。
これは @code{count} の値が期待する繰り返しの数 @code{desired-number} よ
りも小さければ、@code{t} という真の値を返し、@code{desired-number} 以上
であれば、偽の値 @code{nil} を返す。カウンタを増加させるＳ式は 
@code{(setq count (1+ count))} といったごく簡単な @code{setq} 式でよい。
ここで @code{1+} は Emacs Lisp の組み込み関数で、引数に1を加えるものであ
る。(@code{(1+ count)} は @code{(+ count 1)} としても同じだが、この方が
人間にとって読みやすいであろう。)

ということで、増加するカウンタを使った @code{while} ループのテンプレート
は次のようになる。

@example
@group
@var{カウンタを初期値に戻す}
(while (< count desired-number)         ; @r{真偽テスト}
  @var{本体}@dots{}
  (setq count (1+ count)))              ; @r{インクリメンタ}
@end group
@end example

@noindent
この場合 @code{count} の初期値を定めなければならないことに注意しよう。通
常は1にセットする。

@menu
* Incrementing Example::        三角形に並んだ小石の数を数えてみる
* Inc Example parts::           関数定義はどんな部分からなるか
* Inc Example altogether::      関数を一つにまとめる
@end menu

@node Incrementing Example, Inc Example parts, Incrementing Loop, Incrementing Loop
@unnumberedsubsubsec  増加カウンタの例

あなたは浜辺で遊んでおり、小石で三角形を作ろうと思ったとしよう。まず、一
行目に1つの小石を置き、二行目に 2 つ置き、三行目に 3 つ置き..., という具
合に続けていくのだ。図で描くと次のようになる。

@sp 1
@c pebble diagram
@ifinfo
@example
@group
                ・
               ・・
              ・・・
             ・・・・
@end group
@end example
@end ifinfo
@iftex
@example
@group
               @bullet{}
              @bullet{} @bullet{}
             @bullet{} @bullet{} @bullet{}
            @bullet{} @bullet{} @bullet{} @bullet{}
@end group
@end example
@end iftex
@sp 1

@noindent 
(約2500年前、ピタゴラス一派はこのような問題を考えて数論の初歩を発展させ
ていった。)

ここで、七行の三角形を作るにはいくつの小石が必要かを知りたいと思ったとする。

当然、ここであなたがしなければならないのは1から7までの数を加えることであ
る。これを行うには二通りの方法がある。小さい数から始めて1、2、3、4、... 
という数列を加えて行くか、大きい方から始めて7、6、5、4、... という数列の
和を取るかである。どちらの場合にも @code{while} ループを書く時の共通の方
法を説明してくれるので、この下から登るのと、上から降りるのと両方の例を作っ
てみようと思う。最初の例として1に2、3、4を加えていくものから始めよう。

和を取る数のリストが短い場合は、一度に全部足してしまうのがもっとも簡単な
方法である。しかしながら、もし前もって数のリストがどれくらいの長さになる
か分らなかったり、あるいは極めて長いリストの場合にも対処したい場合には、
複雑なプロセスを一度にやるのではなく、単純なプロセスを沢山繰り返して和を
求めるような方法を考える必要がある。

例えば、小石を一度に全部加える代わりに、まず最初の行の小石の数1に二行目
の小石の数2を加え、次にその合計に三行目の小石の数3を加え、今度はその和に
四行目の数4を加え、という操作を続けるのである。

このプロセスで大切な特徴は、繰り返し行う操作は単純ですむということである。
今の場合、各々のステップでやっていることは、二つの数を加えるということだ
けである。その時点での行の小石の数と、それまでの合計は既に分っている。こ
の二数の和を取るプロセスは、最後の行の数をそれまでの合計に加えるまで何回
でも繰り返される。もっと複雑なループでは、繰り返し行う操作はそれ程単純で
はない。しかしそれでも全てを一度にやるよりはずっと簡単なのである。

@node Inc Example parts, Inc Example altogether, Incrementing Example, Incrementing Loop
@unnumberedsubsubsec 関数定義の各部分

前節での分析は、我々の関数定義の骨組みを与えてくれる。まず、小石の全体の
数を表わす変数が要る。これは @code{total} としていいだろう。これがこの関
数の返す値である。

次に、この関数には三角形の全行数を表わす引数が要る。これは 
@code{number-of-rows} として良いだろう。

最後に、カウンタとして使う変数が必要である。これは @code{counter} として
も構わないのだが、それよりも @code{row-number} とする方が良い。何故なら、
このカウンタがやることは行を数えることであり、プログラムは出来るだけ分り
やすく書くべきものだからである。

Lisp インタプリタがこの関数内のＳ式の評価を開始すると、まず @code{total} 
の値が零にセットされる。これはまだ何も加えていないからである。次に、最初
の行の小石の数が足される。そして二行目の数を加え、三行目の数を加え、とい
うふうに続き、最後の行の小石を加えたところで終了する。

@code{total} も @code{row-number} も共にこの関数内部でしか使われない。従っ
て、@code{let} を使って局所変数として宣言し、初期値を与えればよい。明ら
かに @code{total} の初期値は0であり、また @code{row-number} の初期値は1
である。ということで、@code{let} 式は次のようになる。

@example
@group
  (let ((total 0)
        (row-number 1))
    @var{本体}@dots{})
@end group
@end example

内部変数が宣言されて初期値にバインドされたなら、@code{while} ループを開
始する。テストの部分のＳ式は @code{row-number} が @code{number-of-rows} 
以下である場合その時のみ @code{t} を返すようなものでなければならない。
(@code{row-number} と @code{number-of-rows} が一致する場合も含めないと最
後の行の小石の数が加えられないことに注意。)

@findex <= @r{(less than or equal)}
Lisp には @code{<=} という、最初の引数が二番目の引数以下の場合に真を返し、
そうでない場合は偽を返す関数がある。これを使うと、@code{while} 式のテス
ト部分のＳ式は次のように書ける。

@example
(<= row-number number-of-rows)
@end example

全体の小石の数は、各々の行の小石の数をそれまでの合計に繰り返し加えていく
ことで計算される。ある行の小石の数はその行の番号と一致するので、全体の数
は行の番号を加えていくことで求まることになる。(言うまでもないが、状況が
複雑な場合には、ある行の小石の数とその行の番号とはもっと複雑な関係で結ば
れている。そういう場合は行番号は他の適当なＳ式で置き換えることになる。)

@example
(setq total (+ total row-number))
@end example

@noindent
このＳ式では @code{total} の新しい値としてそれまでの合計に現在の行の小石
の数を加えたものをセットしている。

@code{total} の値をセットしたら、次のループに移る場合のために条件を整え
ておかなければならない。それには、カウンタ用の変数 @code{row-number} の
値に1を加えれば良い。@code{row-number} の値が1増やされると、次のループの 
@code{while} 式の先頭の真偽テストで、この新しい値が @code{number-of-row} 
の値以下であるかが判定される。もしそうであれば、変数 @code{row-number} 
の新しい値が前回のループでの @code{total} の値に加えられる。

Emacs Lisp の組み込み関数 @code{1+} は数に1を加えてくれる。従って、
@code{row-number} 変数は次のＳ式で1増加させることが出来る。

@example
(setq row-number (1+ row-number))
@end example

@node Inc Example altogether,  , Inc Example parts, Incrementing Loop
@unnumberedsubsubsec 各部分の総合

これまでで関数定義の各々の部分を書いたので、ここでそれらを一つにまとめる
ことにしよう。

まず @code{while} 式の中身は次の通り。

@example
@group
(while (<= row-number number-of-rows)   ; @r{真偽テスト}
  (setq total (+ total row-number))
  (setq row-number (1+ row-number)))    ; @r{インクリメンタ}
@end group
@end example

これに @code{let} 式の変数リストを加えればほぼ関数定義の本体部分は完成す
るが、最後にほんの少しだけ加えるべき要素がある。

それは変数 @code{total} それ自身を @code{while} 式の後に書くことである。
そうしないと関数全体が返す値は @code{let} 式の本体部分の最後のＳ式が返す
値、即ち @code{while} 式が返す値になるので、常に @code{nil} が返されてし
まうからである。

このことはぱっと見ただけでは気がつかないかもしれない。値を1増加させる式
が最後だから良いように思えるかもしれないが、これはあくまで @code{while} 
式の一部なのである。シンボル @code{while} から始まるリストの最後の要素な
のだ。更に @code{while} ループ全体は @code{let} 式の本体部分の中のリスト
なのである。

@need 1250
大ざっぱに書くと関数は次のような形をしている。

@example
@group
(defun @var{関数名} (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  (let (@var{変数リスト})
    (while (@var{真偽テスト})
      @var{while の本体}@dots{} )
      @dots{} )                     ; @r{ここに最後の式が来る。}
@end group
@end example

このように定義された関数が返す値は @code{let} 式が返す値になる。というの
も @code{let} は @code{defun} 以外の他のどのリストにも含まれてはいないか
らである。だから、もし @code{while} が @code{let} 式の本体の最後のＳ式で
あれば、この関数は常に @code{nil} を返してしまうことになる。これは我々が
望む結果ではない！ これを回避するには、単にシンボル @code{total} を 
@code{let} で始まるリストの最後に置けば良い。この式はこのリストの他のＳ
式が評価された後に評価される。これによって、全体として正しい値が返される
ことになる。

@code{let} で始まるリスト全体を一行で表示してみると、理解しやすいだろう。
こう書くと変数リスト @var{varlist} と @code{while} 式が @code{let} 式の
二番目と三番目の要素であることがよく分る。そして最後の要素が 
@code{total} になるわけである。

@example
@group
(let (@var{変数リスト}) (while (@var{真偽テスト}) @var{while の本体}@dots{} ) total)
@end group
@end example

以上を一つにまとめると、@code{triangle} 関数の定義は次のようになる。

@example
@group
(defun triangle (number-of-rows)    ; @r{インクリメンタを使った}
                                    ; @r{  バージョン。}
  "Add up the number of pebbles in a triangle.
The first row has one pebble, the second row two pebbles,
the third row three pebbles, and so on.
The argument is NUMBER-OF-ROWS."
@end group
@group
  (let ((total 0)
        (row-number 1))
    (while (<= row-number number-of-rows)
      (setq total (+ total row-number))
      (setq row-number (1+ row-number)))
    total))
@end group
@end example

これを評価して @code{triangle} をインストールした後、実際に試してみよう。
二つの例を挙げる。

@example
@group
(triangle 4)

(triangle 7)
@end group
@end example

@noindent
最初の4つの数の和は10になり、最初の7つの数の和は28になる。

@node Decrementing Loop,  , Incrementing Loop, while
@comment  node-name,  next,  previous,  up
@subsection 減少するカウンタを使ったループ

@code{while} ループのテスト部分のもう一つの一般的な書き方としては、カウ
ンタが零を越えるかどうかを判定するというものがある。カウンタが零より大き
い間はループを繰り返すが、零以下になると止まるというわけである。このように
動作させるためにはカウンタは零以上の数から始めて繰り返しの部分が評価され
るごとに小さくなるようにしなければならない。

テスト部分は @code{(> counter 0)} のようになる。これは @code{counter} の
値が零よりも大きければ真として @code{t} を返し、零以下なら偽として 
@code{nil} を返すというものである。数を次第に小さくしていくには、
@code{(setq counter (1- counter))} という単純な @code{setq} 式を使う。こ
こで、@code{1-} は引数を1減らす Emacs Lisp の組み込み関数である。

@need 1250
ということで、@code{while} ループのテンプレートは次のようになる。

@example
@group
(while (> counter 0)                    ; @r{真偽テスト}
  @var{本体}@dots{}
  (setq counter (1- counter)))          ; @r{デクリメンタ}
@end group
@end example

@menu
* Decrementing Example::        またまた浜辺の小石を数えてみる
* Dec Example parts::           関数定義はどんな部分からなるか
* Dec Example altogether::      関数を一つにまとめる
@end menu

@node Decrementing Example, Dec Example parts, Decrementing Loop, Decrementing Loop
@unnumberedsubsubsec 減少するカウンタを使った例

減少するカウンタを使ったループを説明するために、@code{triangle} 関数を、
このようなカウンタを使って書き直してみることにする。

数え方は、この関数の前回のバージョンの逆である。今回は、例えば三行からな
る三角形の小石の数を求めるために、まず三行目の3つの小石を加え、次にその
前の二行目の2個の小石の数を加え、更にその合計に1行目の小石の数1を加える
という操作をすることになる。

同様にして、七行からなる三角形の小石の数を求めるには、七行目の小石の数7
にその前の行の小石の数6を加え、次にその合計に その前の行に小石の数5を加
え、とやっていくことになる。前回の例と同じく、各々の足し算ではそれまでの
合計と現在の行の小石の数の二つの数を加えているだけである。このプロセスは、
足す小石の数がなくなるまで繰り返される。

最初に加える小石の数も分る。最後の行の小石の数は全体の行の数に等しいから
である。三角形が七行からなっていれば、最終行の小石の数は7である。同様に、
次々と足していく小石の数も分る。それは、前回足した数から1を引いたもので
ある。

@node Dec Example parts, Dec Example altogether, Decrementing Example, Decrementing Loop
@unnumberedsubsubsec 関数定義の各部分

まず三つの変数が必要である。三角形の行の総数、各々の行の小石の数、そして、
小石の総数だ。この最後の数が今回求めようとしている数である。これら三つの
変数を各々 @code{number-of-rows}, @code{number-of-pebbles-in-row}, 
@code{total} と名付ることにする。

@code{total} も @code{number-of-pebbles-in-row} もこの関数の内部でしか使
われないので、@code{let} を用いて宣言される。@code{total} の初期値は勿論
零である。一方、@code{number-of-pebbles-in-row} の初期値は三角形の行の数
に等しくなるべきである。これは、もっとも長い行から小石の数を数えていくた
めである。

@need 1250
従って @code{let} 式の始めの部分は次のようになる。

@example
@group
(let ((total 0)
      (number-of-pebbles-in-row number-of-rows))
  @var{本体}@dots{})
@end group
@end example

小石全体の数は、各々の行の小石の数を順番に数えていくことで求められる。
つまり、繰り返し次のＳ式を評価していけばよい。

@example
(setq total (+ total number-of-pebbles-in-row))
@end example

@noindent
@code{number-of-pebbles-in-row} は @code{total} に加えられた後、次のルー
プに備えて一つだけ値を減らさなければならない。というのも次に加えられる行
は一段上の行であり、現在の長さよりも一つ分短いからである。これは次のＳ式
を評価することでなされる。

@example
@group
(setq number-of-pebbles-in-row
      (1- number-of-pebbles-in-row))
@end group
@end example

最後に、小石が無くなった時点で @code{while} ループを抜けなければならない
が、そのための条件部は次のような簡単なものでよい。

@example
(while (> number-of-pebbles-in-row 0)
@end example

@node Dec Example altogether,  , Dec Example parts, Decrementing Loop
@unnumberedsubsubsec 各部分の総合

以上のＳ式をひとまとめにすると、関数定義は次のようになる。

@example
@group
;;; @r{デクリメンタを使った最初のバージョン。}
(defun triangle (number-of-rows)        
  "Add up the number of pebbles in a triangle."
  (let ((total 0)
        (number-of-pebbles-in-row number-of-rows))
    (while (> number-of-pebbles-in-row 0)
      (setq total (+ total number-of-pebbles-in-row))
      (setq number-of-pebbles-in-row
            (1- number-of-pebbles-in-row)))
    total))
@end group
@end example

これはこれで、うまく動作する。

しかしながら、実は変数 @code{number-of-pebbles-in-row} は必要でない！

@cindex Argument as local variable
@code{triangle} 関数が評価されると、シンボル @code{number-of-rows} は初期
値を与えられて、ある数にバインドされる。この数は関数の本体の中であたかも
局所変数であるかのごとく変化させることが可能で、この関数の外でのこの変数
の値には何の影響も与える心配はない。これは Lisp の大変便利な特徴であるが、
このことから関数内の @code{number-of-pebbles-in-row} を全て変数 
@code{number-of-rows} で置き換えても良いことが分る。

ということで、以下に、この関数の少し整理したバージョンを挙げる。

@example
@group
(defun triangle (number)                ; @r{二番目のバージョン。}
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1- number)))
    total))
@end group
@end example

まとめてみよう。きちんと書かれた @code{while} ループは以下の三つの部分か
らなる。

@enumerate
@item
ループを正しい回数繰り返した後、偽を返すテスト

@item
繰り返し評価された後、最後に望む値を返すようなＳ式

@item
正しい回数だけループを繰り返した後にテストが偽を返すよう、真偽テストに渡
される値を変化させるＳ式
@end enumerate

@node Recursion, Looping exercise, while, Loops & Recursion
@comment  node-name,  next,  previous,  up
@section 再帰
@cindex Recursion

再帰関数とは、自分自身を評価するようなコードを含んでいるものである。関数
が自分自身を評価した場合、それはまた自分自身を評価するコードに出くわす。
結果としてその関数はまた自分自身を評価し @dots{} となってこれがずっと続
く。再帰関数は自分自身止める条件を与えられない限り、永久に自分自身を繰り
返し呼び出し続けることになる。

再帰関数は、典型的には次のような三つの部分からなる条件分岐部を含んでいる。 

@enumerate
@item
この関数がもう一度呼び出されるかどうかを決定する真偽テスト。ここでは 
@dfn{do-again-test} と呼ぶ。

@item
この関数の名前

@item
条件分岐部が正しい回数だけ繰り返しを行った後に偽を返すようにするためのＳ
式。ここでは @dfn{next-step-expression} と呼ぶ。
@end enumerate

再帰関数は、他の種類の関数に比べて最も簡単な形に書ける。実際、再帰関数を
使い始めると、しばしば奇妙な程単純な形になってしまい、不可解な感じがする
ことが多いようである。再帰関数の定義を読むためには、ある種のコツが必要で、
最初は難しく思えても、慣れると単純であることが分ってくる。初めて自転車に
乗るときと同じである。

再帰関数のテンプレートは次のようになる。

@example
@group
(defun @var{再帰関数名} (@var{変数リスト})
  "@var{説明文字列}@dots{}"
  @var{本体}@dots{}
  (if @var{do-again-test}
    (@var{再帰関数名} 
         @var{next-step-expression})))
@end group
@end example

@noindent
再帰関数が評価されるごとに、ある引数が next-step-expression の値にバイン
ドされ、そしてその値が do-again-test で使われる。next-step-expression は 
関数をもう繰り返す必要がなくなった場合に do-again-test が偽を返すように
設計されている。

do-again-test は @dfn{停止条件} (@dfn{stop-condition}) と呼ばれることも
ある。これはテストが偽の場合に繰り返しが止まるからである。

@menu
* Recursion with list::         再帰のテストにリストを使う
* Recursive triangle function::  @code{while} ループを再帰で置き換える
* Recursion with cond::         別の条件分岐を用いた再帰の例
@end menu

@node Recursion with list, Recursive triangle function, Recursion, Recursion
@comment  node-name,  next,  previous,  up
@subsection List を使った再帰

先に挙げた、 @code{while} ループを使ったリストの要素を表示する関数の例は、
再帰的に書くことも可能である。次に、変数 @code{animals} の値をあるリスト
にセットするＳ式も含めて、そのコードを書いてみることにしよう。

この例は @file{*scratch*} バッファにコピーして、各々のＳ式をそのバッファ
で評価してやらなければならない。そして @code{(print-elements-recursively
animals)} を評価する際は @kbd{C-u C-x C-e} を使う必要がある。でないと、
Lisp インタプリタは結果をエコー領域に一行分だけしか表示してくれない。

また、カーソルを @code{print-elements-recursively} 関数の最後の閉じ括弧
の直後の、コメントの手前の位置に持っていって評価しないといけない。そうし
ないと、Lisp インタプリタはコメントまで評価しようとしてしまう。

@findex print-elements-recursively
@example
@group
(setq animals '(giraffe gazelle lion tiger))

(defun print-elements-recursively (list)
  "Print each element of LIST on a line of its own.
Uses recursion."
  (print (car list))                  ; @r{本体}
  (if list                            ; @r{do-again-test}
      (print-elements-recursively     ; @r{再帰呼び出し}
       (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end example

@code{print-elements-recursively} 関数は最初にリストの一番目の引数、即ち、
リストの @sc{car} を表示する。そしてもしリストが空でなければ、この関数内
で自分自身を呼び出す。ただし引数としては、全体のリストではなく二番目以降
の要素からなるリスト、即ち、そのリストの @sc{cdr} を渡す。

この時の評価では、この関数は引数として受け取ったリストの最初の要素 (これ
は元々のリストでは二番目の要素であたる) を表示する。そして @code{if} 式
が評価され、それが真であれば、この関数は自分自身を今回受け取った引数の 
@sc{cdr} (これは、元々のリストの @sc{cdr} の @sc{cdr} である) を引数とし
て再度自分自身を呼び出す。

関数が自分自身を呼び出す度に、引数として渡されるリストは元々のリストに比べ
て短くなっていき、結果として最後には空リストとともに呼び出すことになる。
@code{print} 関数は空リストを @code{nil} として表示する。そして次に条件
分岐の部分が @code{list} の値をテストする。@code{list} は @code{nil} な
ので、@code{if} 式は偽を返し、もはや then-part は実行しない。関数全体と
しては @code{nil} が返されるので、この関数を評価すると最後に二回 
@code{nil} が現れる。

@code{(print-elements-recursively animals)} を @file{*scratch*} バッファ
で評価すると、次のような結果が表示されるはずだ。

@example
@group
giraffe

gazelle

lion

tiger

nil
nil
@end group
@end example

(最初の @code{nil} は空リストの値が表示されたものであり、二番目の 
@code{nil} は関数全体の値である。)

@node Recursive triangle function, Recursion with cond, Recursion with list, Recursion
@comment  node-name,  next,  previous,  up
@subsection カウンタの代わりに再帰を使う
@findex triangle-recursively

前節で説明した @code{triangle} 関数もまた再帰的に書ける。これは次のよう
になる。

@example
@group
(defun triangle-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{再帰呼び出し}
        (1- number)))))               ; @r{next-step-expression}

(triangle-recursively 7)
@end group
@end example

@noindent
これを評価することでこの関数をインストールし、試しに 
@code{(triangle-recursively 7)} を評価してみよう。(カーソルを関数定義の
直後の、コメントの手前の位置に持っていって評価することを忘れずに。)

この関数がどのように動作するかを確かめるため、この関数に1、2、3、4等の様々
な引数を与えた場合に何が起きるかを考えてみよう。

まず引数の値が1だとどうなるか？

この関数では説明文字列の後に @code{if} 式がくる。これは @code{number} の
値が1かどうかテストするものである。もし1であれば、Emacs は @code{if} 式
の then-part を評価する。この場合は関数の値として1が返される。(一行から
なる三角形の中には小石は1つしかない。)

では引数の値が2であればどうだろう。この場合は Emacs は @code{if} 式の 
else-part を評価する。

今の場合、else-part は足し算と @code{triangle-recursively} の
再帰呼び出し、そしてデクリメントからなっている。具体的には次の通り。

@example
(+ number (triangle-recursively (1- number)))
@end example

Emacs がこのＳ式を評価する時は、まず最も内側のＳ式から評価していき、順に
他の部分を評価していく。詳しく書くと次のようなステップを踏むことになる。

@table @i
@item Step 1 @w{  } 最も内側のＳ式の評価。

今の場合、最も内側のＳ式は @code{(1- number)} なので、Emacs は 
@code{number} を2から1に減らす。

@item Step 2 @w{  } @code{triangle-recursively} 関数の評価。

この関数が自分自身の内部に含まれていることとは関係なく、Emacs は Step 1 
の結果をこの関数の引数として渡す。

今の場合、Emacs は @code{triangle-recursively} を引数1とともに評価する。
さっき見たように、この場合この関数は1を返す。

@item Step 3 @w{  } @code{number} の値の評価。

ここでいう変数 @code{number} は @code{+} で始まるリストの二番目の要素。
その値は2である。

@item Step 4 @w{  } @code{+} 式の評価。

@code{+} 式は二つの引数を受け取る。一つ目は @code{number} を評価して返さ
れた値 (Step 3) であり、二つ目は @code{triangle-recursively} を評価して
返された値 (Step 2) である。

足し算の結果は2と1の和であり、3が返される。これは正しい結果である。
二行からなる三角形の中には小石は3個含まれる。
@end table

@menu
* Recursive Example arg of 3::  引数が3の場合の再帰関数の動作
@end menu

@node Recursive Example arg of 3,  , Recursive triangle function, Recursive triangle function
@unnumberedsubsubsec 引数3の場合

@code{triangle-recursively} が引数3とともに呼び出されたとする。

@table @i
@item Step 1 @w{  } do-again-test の評価。

まずは @code{if} 式が評価される。これは do-again-test であり、偽が返され
る。従って、@code{if} 式の else-part が評価される。(この例では、テストの
結果が真の時ではなく偽の時に自分自身を再帰呼び出しすることに注意しよう。)

@item Step 2 @w{  } else-part のもっとも内側のＳ式の評価。

else-part の最も内側のＳ式が評価され、3が2にデクリメントされる。これ
が next-step-expression である。

@item Step 3 @w{  } @code{triangle-recursively} 関数の評価。

数値2が @code{triangle-recursively} 関数に渡される。

前節で説明した通り、@code{triangle-recursively} は引数2とともに評価さ
れると3を返すのであった。

@item Step 4 @w{  } 足し算の評価。

足し算の式では3がこの時の @code{number} の値3に加えられる。
@end table

@noindent
全体として、この関数が返す値は6になる。

以上で @code{triangle-recursively} に引数3を与えるとどうなるかが分った。
もはや引数が4の場合に何が起きるかは明らかであろう。次のような感じだ。

@quotation
再帰呼び出しで

@example
(triangle-recursively (1- 4))
@end example

@noindent
が評価され、結果として

@example
(triangle-recursively 3)
@end example

@noindent
の値を返す。これは6であり、この値に三行目の足し算で4が加えられる。
@end quotation

@noindent
全体としてこの関数が返す値は10になる。

@code{triangle-recursively} が評価されるごとに、より小さい引数とともに自
分自身を評価し、その状況が、引数がもはや再帰呼び出しを起こさない程小さく
なるまで続けられるというわけである。

@node Recursion with cond,  , Recursive triangle function, Recursion
@comment  node-name,  next,  previous,  up
@subsection @code{cond} を使った再帰の例
@findex cond

以前説明したバージョンの @code{triangle-recursively} は特殊形式 
@code{if} を用いて書かれていた。これは @code{cond} と呼ばれる特殊形式を
用いても書くことが出来る。特殊形式 @code{cond} の名前は 
@code{conditional} という単語の短縮形から来ている。

特殊形式 @code{cond} は Emacs Lisp では @code{if} ほど頻繁に使われている
とは言えないが、ここで説明する価値がある程度には使われている。

@code{cond} 式のテンプレートは次の通りである。

@example
@group
(cond
 @var{本体}@dots{})
@end group
@end example

@noindent
ここで @var{本体} はリストの列である。

本体の中身をもっと詳しく書くと次のような感じになる。

@example
@group
(cond
 ((@var{最初の真偽テスト} @var{最初の結果部})
  (@var{二番目の} @var{二番目の結果部})
  (@var{三番目の} @var{三番目の結果部})
  @dots{})
@end group
@end example

Lisp インタプリタが @code{cond} 式を評価する時は、まず @code{cond} の本
体のＳ式の列の最初のＳ式の最初の要素 (@sc{car} つまり真偽テストの部分) 
から評価する。

もし、真偽テストが @code{nil} を返したなら、その式の残りの部分 (これを結
果部 (consequent) と呼ぼう) はスキップされて、次のＳ式の真偽テストが評価
される。こうして、もしあるＳ式で真偽テストが @code{nil} 以外の値を返した
なら、そのＳ式の結果部が評価される。結果部は一つでも複数でも構わない。複
数の場合は各々の式が順に評価されていき、最後の値が返される。もしそのＳ式
が結果部を持たなければ、真偽テストの結果が返される。(訳註：そして、真偽
テストが真であったＳ式以降は無視される。)

どのＳ式の真偽テストも偽を返した場合は @code{cond} 式は @code{nil} を返
す。

@need 1250
@code{cond} を使って書くと、@code{triangle} 関数は次のようになる。

@example
@group
(defun triangle-using-cond (number)
  (cond ((<= number 0) 0)
        ((= number 1) 1)
        ((> number 1)
         (+ number (triangle-using-cond (1- number))))))
@end group
@end example

@noindent
この例では、@code{cond} は number が0以下の場合は0を返し、1の場合は1を返
し、1より大きい場合は @code{(+ number (triangle-using-cond (1-
number)))} が評価される。

@need 1500
@node Looping exercise,  , Recursion, Loops & Recursion
@section ループについての練習問題

@itemize @bullet
@item
各々の行の値が行番号の自乗であるような場合に、@code{triangle} 関数と同様
な関数を書きなさい。ただし、@code{while} ループを使うこと。

@item
@code{triangle} 関数と同様だが、各々の行の値を足すのでは無く、掛けていく
ような関数を書きなさい。

@item
上の二つの関数を再帰的な関数に書き直しなさい。また、@code{cond} を使って
書き直しなさい。

@c comma in printed title causes problem in Info cross reference
@item
Texinfo モードのために、パラグラフの中に含まれる全ての @samp{@@dfn} に対
する索引の項目をそのパラグラフの最初に作成するような関数を書きなさい。
(Texinfo ファイルでは、@samp{@@dfn} が定義の印になっている。詳しくは
@ifinfo
@ref{Indicating, , Indicating Definitions, texinfo}, 参照。)
@end ifinfo
@iftex
``Indicating Definitions, Commands, etc.'' in @cite{Texinfo, The GNU
Documentation Format}, 参照。)
@end iftex
@end itemize

@node Regexp Search, Counting Words, Loops & Recursion, Top
@comment  node-name,  next,  previous,  up
@chapter 正規表現の検索
@cindex Searches, illustrating
@cindex Regular expression searches
@cindex Patterns, searching for
@cindex Motion by sentence and paragraph
@cindex Sentences, movement by
@cindex Paragraphs, movement by

GNU Emacs の中では、正規表現の検索が徹底的に活用されている。例えば、
@code{forward-sentence} とか @code{forward-paragraph} といった関数を調
べてみれば、こういった検索についてよく理解出来るだろう。

正規表現の検索は @ref{Regexp Search, , Regular Expression Search, emacs,
The GNU Emacs Manual}, の中や @ref{Regular Expressions, , , elisp, The
GNU Emacs Lisp Reference Manual}, の中で説明されている。この章を書く際に
も、私は読者が少なくともこれらをある程度は知っていることを想定している。
大事な点は、正規表現を使うことで具体的な文字列そのものだけではなく、パター
ンをも検索出来るということである。例えば @code{forward-sentence} のコー
ドは文 (sentence) の終わりを示すパターンを検索し、その場所にポイントを移
動する。

実際に @code{forward-sentence} 関数のコードを見る前に、文の終わりを示すパ
ターンがどんなものであるべきかを考えておいた方が良いだろう。このパターン
については次のセクションで議論することにする。その次に、正規表現の検索を
行う関数である @code{re-search-forward} の説明をする。
@code{forward-sentence} 関数の説明はその後である。この章の最後の節では、
@code{forward-paragraph} 関数の説明をする。@code{forward-paragraph} は複雑
な関数なので、幾つか新しい特徴を紹介することになる。

@menu
* sentence-end::                @code{sentence-end} の正規表現
* re-search-forward::           @code{search-forward} とほぼ同じ
* forward-sentence::            正規表現検索の単純な例
* forward-paragraph::           もうちょっと複雑な例
* etags::                       @file{TAGS} テーブルの作り方
* Regexp Review::               正規表現の復習
* re-search Exercises::         正規表現の練習問題
@end menu

@node sentence-end, re-search-forward, Regexp Search, Regexp Search
@comment  node-name,  next,  previous,  up
@section @code{sentence-end} の正規表現
@findex sentence-end

シンボル @code{sentence-end} は文末 (訳註：ここでは勿論英語の文章を想定
している。) を示すあるパターンにバインドされている。この正規表現はどうあ
るべきだろうか？ 

明らかに、文末には終止符か疑問符、もしくは感嘆符が来る。実際、この三つの
文字の中の一つで終了する文節だけが文末と見倣されるべきである。これはパター
ンの中に次の文字集合が含まれるということだ。

@example
[.?!]
@end example

しかしながら、@code{forward-sentence} が単に終止符や疑問符、感嘆符に移動
するというだけではまずい。というのも、これらの文字は文中にも使われること
があるからである。例えば終止符は略語の後にも使われる。従って、他の情報も
必要になる。

慣習的に、普通文末には二つの空白を打つが、文中の終止符、疑問符、感嘆符の
の後には一つの空白しか打たない。従って、終止符、疑問符、感嘆符に続いて二
つの空白というのが文末の良い目印になるだろう。ただし、ファイルの中では二
つの空白はタブや行末であっても良い。つまり、正規表現の中には、これら三つ
のどれかというものが含まれる。この部分は次のように書ける。

@example
@group
¥¥($¥¥| ¥¥|  ¥¥)
       ^   ^^
      TAB  SPC
@end group
@end example

@noindent
ここで @samp{$} は行末を表わす。それと、タブと二つの空白がこの表現の中に
入っていることを指摘しておく。両方とも、この表現の中に実際の文字が挿入さ
れている。

括弧や縦棒の前には二つのバックスラッシュ @samp{¥¥} が必要になる。最初の
バックスラッシュは、Emacs の中でその後に続くバックスラッシュを quote 
するためのものであり、二番目のバックスラッシュは、その後に続く括弧や縦棒
が特殊文字であることを示すものである。

また、文の後には次のように一つ以上の復帰コードが続くこともある。

@example
@group
[
]*
@end group
@end example

@noindent
タブや空白と同様、復帰コードも実際のコードを埋め込むことで正規表現の中に
挿入される。末尾のアスタリスクは、@key{RET} が零回以上繰り返すことを示す。

ただ、文末が必ずしも終止符や疑問符、ないしは感嘆符に続いて空白で終ってい
るとは限らない。閉引用符や何らかの閉括弧が空白の前に来るかもしれない。実
際の所、このような記号が空白の前に二つ以上続くこともある。これらのために、
次のような表現が必要になる。 

@example
[]¥"')@}]*
@end example

この表現の中で、最初の @samp{]} が最初に来ていることに注意しよう。(訳註：
@samp{[} と @samp{]} で狭んで定める文字集合の中に @samp{]} を含めるには、
このように文字集合の最初に @samp{]} を記述する。) また、二番目の文字は 
@samp{"} である。前の @samp{¥} は Emacs にこれが特殊文字ではなく文字列の
一部だと伝えるためのものである。残りの三文字は、@samp{'}、@samp{)}、
@samp{@}} そのものを表わす。これらの文字が零回以上現れるということになる。

これら全てを合せたものが、あるべき文末の正規表現を形成している。そして、
実際に @code{sentence-end} を評価してみると、次のような値が返される。
(訳註：Mule や Nemacs では、これに加えて日本語のための拡張がなされている
ので、更に複雑になっている。)

@example
@group
sentence-end
     @result{} "[.?!][]¥"')@}]*¥¥($¥¥|     ¥¥|  ¥¥)[       
]*"
@end group
@end example

@ignore

@noindent
(ここで、@kbd{TAB}、二つの空白、そして @kbd{RET} は表現の中に文字そのも
のが埋め込まれている。)

この正規表現は次のように解読出来る。

@table @code
@item [.?!]
表現の最初の部分は角括弧の中の終止符、疑問符、感嘆符の三つの文字である。
パターンはこれらの三つの文字の内、いずれかで始まっていなければならない。

@item []¥"')@}]*
表現の二番目は、閉括弧や閉引用符のグループである。これらは零回以上続いて
良い。また、これらは終止符や疑問符、感嘆符の後に来る。正規表現の中では、
バックスラッシュ @samp{¥} に続く二重引用符 @samp{"} は文字列引用文字のク
ラスを表わす。普通、このクラスに属するのは二重引用符だけである。アスタリ
スク @samp{*} は直前のグループ (角括弧 @samp{[]} で囲まれたグループ) が
零回以上続くことを示す。

@item ¥¥($¥¥|   ¥¥|  ¥¥)
三番目のパターンは、行末か、タブか、二つの空白かのいずれかであるという意
味になる。二重のバックスラッシュは、Emacs にこの括弧や縦棒が検索パターン
の一部ではないことを伝えるためのものである。括弧はグループを作るためのも
ので、縦棒はそれによって区切られたどのパターンであっても良いことを示す。
ドルマークは行末を表し、タブと二つの空白はそのものが挿入されている。

@item [@key{RET}]*
最後に、一番後のパターンは行末や終止符、疑問符、感嘆符に続く空白の後に復
帰コードが来てもよいことを示している。実際のパターンの中では本当の復帰コー
ドが挿入されているのだが、ここでは @kbd{RET} として表示している。
@end table

@end ignore

@node re-search-forward, forward-sentence, sentence-end, Regexp Search
@comment  node-name,  next,  previous,  up
@section 関数 @code{re-search-forward}
@findex re-search-forward

@code{re-search-forward} 関数は、@code{search-forward} 関数と非常によく
似ている。(後者については、@ref{search-forward, , 関数 
@code{search-forward}}, 参照。)

@code{re-search-forward} は正規表現を検索するためのものである。もし検索
が成功すれば、ただちに目的とする文字の後にポイントを移動する。後方検索の
場合は目的の文字の直後に移動する。検索成功時には 
@code{re-search-forward} は @code{t} を返す。(訳註：Emacs version 19 で
はポイントの位置を返す。) (従って、ポイントの移動は「副作用」である。)

@code{search-forward} と同じく @code{re-search-forward} 関数も四つの引数
を持つ。

@enumerate
@item
最初の引数は、検索する正規表現である。正規表現は引用符に囲まれた文字列で
なければならない。

@item
二番目の引数は省略可能であり、関数が検索する範囲を制限するために用いる。
これはバッファの中の位置として指定される。

@item
三番目の引数も省略可能で、検索に失敗した場合の挙動を決めるためのものであ
る。もし引数が @code{nil} なら失敗時にはエラーが返され、メッセージが表示
される。他の値の場合は失敗時には @code{nil} が返り、成功時には @code{t} 
が返される。(訳註：Emacs version 19 ではポイントの位置が返される。)

@item
四番目の引数は繰り返しの回数である。負の引数を与えると、後方検索になる。
@end enumerate

@code{re-search-forward} のテンプレートは次の通りである。

@example
@group
(re-search-forward "@var{正規表現}"
                @var{検索範囲の限界}
                @var{検索失敗時の動作}
                @var{繰り返しの回数})
@end group
@end example

二番目から四番目までの引数は省略可能である。しかし、最後の二つの片方ない
しは両方に値を渡したい場合は、それ以前の全ての引数を与えなければならない。
そうしないと Lisp インタプリタはどの引数を何処へ渡すかを間違えてしまう。

@code{forward-sentence} 関数では、正規表現は変数 @code{sentence-end} の
値である。つまり、次の通りである。

@example
@group
"[.?!][]¥"')@}]*¥¥($¥¥|  ¥¥|  ¥¥)[       
]*"
@end group
@end example

@noindent
検索の限界はパラグラフの終わりまでである (文がパラグラフを越えて続くこと
はないので)。検索に失敗した場合は @code{nil} が返される。また、繰り返し
の回数は @code{forward-sentence} の引数として与えられる。

@node forward-sentence, forward-paragraph, re-search-forward, Regexp Search
@comment  node-name,  next,  previous,  up
@section @code{forward-sentence}
@findex forward-sentence

カーソルを文の前方に移動するコマンドは、Emacs Lisp での正規表現検索の使
い方をストレートに説明してくれる。この関数は、実際以上に長くて複雑そうに
見えるが、それは、前方に検索するだけではなく後方にも検索出来るようになっ
ていたり、オプションとして複数の文を移動することが出来るようになっている
ためである。この関数は通常は @kbd{M-e} というキーにバインドされている。

@need 1250
以下が @code{forward-sentence} のコードである。

@smallexample
@group
(defun forward-sentence (&optional arg)
  "Move forward to next sentence-end.  With argument, repeat.
With negative argument, move backward repeatedly to sentence-beginning.
Sentence ends are identified by the value of sentence-end
treated as a regular expression.  Also, every paragraph boundary
terminates sentences as well."
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (while (< arg 0)
    (let ((par-beg
           (save-excursion (start-of-paragraph-text) (point))))
      (if (re-search-backward
           (concat sentence-end "[^ ¥t¥n]") par-beg t)
          (goto-char (1- (match-end 0)))
        (goto-char par-beg)))
    (setq arg (1+ arg)))
  (while (> arg 0)
    (let ((par-end
           (save-excursion (end-of-paragraph-text) (point))))
      (if (re-search-forward sentence-end par-end t)
          (skip-chars-backward " ¥t¥n")
        (goto-char par-end)))
    (setq arg (1- arg))))
@end group
@end smallexample

ぱっと見ただけだと、この関数は長く感じてしまう。まずは骨組みを見て、それ
から肉の部分を見ていくのが賢明だろう。骨組みを見るには、桁が左にあるもの
から見て行けば良い。

@example
@group
(defun forward-sentence (&optional arg)
  "@var{説明文字列}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (while (< arg 0)
    @var{while ループの本体}
  (while (> arg 0)
    @var{while ループの本体}
@end group
@end example

こう書き直すとぐっと解りやすくなる。この関数定義は説明文字列と 
@code{interactive} 式、そして @code{or} 式と @code{while} ループからなっ
ているのである。

では順に各々の部分を見ていくことにしよう。

まず、説明文字列が過不足なくかつ理解しやすく書かれていることに注意しよう。

この関数は @code{interactive "p"} 宣言を持っている。これは、(もし与えら
れたなら) 処理された前置引数が引数としてこの関数に渡されることを意味する。
(これは数値である。) もしこの関数が引数を渡されなければ (引数は省略可能
である) その場合、引数 @code{arg} は1にバインドされる。また、
@code{forward-sentence} が非インタラクティブに引数無しで呼ばれた場合には、
@code{arg} は @code{nil} にバインドされる。

前置引数を扱うのは @code{or} 式である。この式では、@code{arg} の値がある
値にバインドされている場合はそのままにしておき、もし @code{nil} にバイン
ドされていた場合は1にセットしている。

@menu
* fwd-sentence while loops::    二つの @code{while} ループ
* fwd-sentence re-search::      正規表現検索
@end menu

@node fwd-sentence while loops, fwd-sentence re-search, forward-sentence, forward-sentence
@unnumberedsubsubsec @code{while} ループ

@code{or} 式の後には、二つの @code{while} ループが続く。最初の 
@code{while} ループには、前置引数が負の値ならば真を返すような真偽テスト
が含まれている。これは後方検索のためのものである。このループの本体は二番
目の @code{while} ループの本体とそっくりであるが全く同じではない。取り敢
えずこちらの方はとばして、二番目のループの方に集中することにしよう。

@need 1500
二番目の @code{while} ループはポイントを前方に移動するものである。骨組み
は次の通りである。

@example
@group
(while (> arg 0)            ; @r{真偽テスト}
  (let @var{変数リスト}
    (if (@var{真偽テスト})
        @var{then-part}
      @var{else-part}
  (setq arg (1- arg))))     ; @code{while} @r{ループのデクリメンタ}
@end group
@end example

この @code{while} ループはデクリメントタイプの物である 
(@ref{Decrementing Loop, , 減少カウンタを使ったループ}, 参照)。
この中にはカウンタ (今の場合は変数 @code{arg}) が零よりも大きい間は真を
返すような真偽テストが含まれている。そして、ループを繰り返すごとにカウン
タの値を1減らすようなデクリメンタが含まれている。

もし @code{forward-sentence} に前置引数が与えられなかったなら、といって
もこれが普通の使い方だが、その場合 @code{while} ループは一度だけ繰り返す。
これは @code{arg} の値が1だからである。

@code{while} ループの本体は @code{let} 式からなる。これは局所変数を作成
する。また、その本体として @code{if} 式を持っている。

@need 1250
@code{while} ループの本体は次のようである。

@example
@group
(let ((par-end
       (save-excursion (end-of-paragraph-text) (point))))
  (if (re-search-forward sentence-end par-end t)
      (skip-chars-backward " ¥t¥n")
    (goto-char par-end)))
@end group
@end example

ここで @code{let} 式は局所変数 @code{par-end} を生成、バインドしている。
この後見るように、この局所変数は正規表現検索に限界ないしは制限を与えるた
めに用いられている。もしこの検索でパラグラフ内に適切な文末が見つからなけ
ればパラグラフの終端で検索をやめる。

が、その前にまずどうやって @code{par-end} がパラグラフの終端の値にバイン
ドされるかを見てみよう。ここでは @code{let} 式を使って、次のＳ式を Lisp 
インタプリタが評価した際に返される値に @code{par-end} の値をセットしてい
る。

@example
@group
(save-excursion (end-of-paragraph-text) (point))
@end group
@end example

@noindent
この式では @code{(end-of-paragraph-text)} によってポイントがパラグラフ終
端に移動し、@code{(point)} によってそのポイントの値が返される。そして、
@code{save-excursion} によって元の位置にポイントが戻されるというわけであ
る。このようにして @code{let} は @code{par-end} に @code{save-excursion} 
式が返す値、つまりパラグラフの終端の位置をバインドする。
(@code{end-of-paragraph-text} 関数は @code{forward-paragraph} を使ってい
る。これについては後で簡単に触れる。)

Emacs は次に @code{let} 式の本体を評価する。これは次のような 
@code{if} 式である。

@example
@group
(if (re-search-forward sentence-end par-end t) ; @r{if-part}
    (skip-chars-backward " ¥t¥n")              ; @r{then-part}
  (goto-char par-end)))                        ; @r{else-part}
@end group
@end example

@code{if} は最初の引数が真かどうかテストし、もし真なら then-part を評価
し、そうでなければ else-part を評価する。今の場合 @code{if} の真偽テスト
は正規表現検索である。

@code{forward-sentence} のような関数の実際の動作は奇妙に感じられるかもし
れない。しかし Lisp ではこのような操作が行われるのは、ごく一般的なことで
ある。
@c 何か変かなあ。原文は以下の通り
@c It may seem odd to have what looks like the `real work' of
@c the @code{forward-sentence} function buried here, but this is a common
@c way this kind of operation is carried out in Lisp.

@node fwd-sentence re-search,  , fwd-sentence while loops, forward-sentence
@unnumberedsubsubsec 正規表現の検索

@code{re-search-forward} 関数は文末、つまり正規表現 @code{sentence-end} 
で定義されたパターンを検索する。もしパターンが見つかったなら---即ち文末
が見つかったなら---その時は @code{re-search-forward} 関数は二つのことを
行う。

@enumerate
@item
@code{re-search-forward} 関数は副作用を実行する。即ち、ポイントを見つけ
た文末まで移動する。

@item
@code{re-search-forward} 関数は真の値を返す。これは @code{if} によって返
される値であり、検索が成功したことを意味する。
@end enumerate

@noindent
副作用としてのポイントの移動は @code{if} 関数が検索成功の結果として値を
返すよりも前の時点に行われる。

@code{if} 関数が検索に成功した @code{re-search-forward} から呼び出されて
真の値を返す際には @code{if} は then-part、即ち@ 
@code{(skip-chars-backward "¥t¥n")} の評価も行う。このＳ式はタブや改行
などを含む全ての種類の空白文字を越えて、表示される文字 (printed
character) の所まで前に戻り、その文字の直後にポイントを置く。ポイントは
既に文末のパターンの所まで移動しているので、この動作で文が目に見える文字
で終わっている部分の直後に来ることになる。通常はピリオドだろう。

一方、もし @code{re-search-forward} 関数が文末パターンを見つけられなかっ
た場合には、関数は偽を返す。この場合は @code{if} は三番目の引数を評価す
る。これは @code{(goto-char par-end)} である。これはパラグラフの終わりに
までポイントを移動する関数である。

正規表現検索は極めて便利なものであり、@code{forward-sentence}---その中
では検索は @code{if} 式のテストになっている---で説明されたパターンは手軽
に使えるものである。あなたもこのパターンを取り入れたコードを見たり書いた
りするであろう。

@node forward-paragraph, etags, forward-sentence, Regexp Search
@comment  node-name,  next,  previous,  up
@section @code{forward-paragraph}：関数の金脈
@findex forward-paragraph

@code{forward-paragraph} 関数はポイントをパラグラフの終わりまで移動する。
これは通常 @kbd{M-@}} にバインドされており、例えば @code{let*}、
@code{match-beginning}、@code{looking-at} のようなそれ自身も重要であるよ
うな他の幾つかの関数を利用している。

@code{forward-paragraph} 関数の定義は @code{forward-sentence} 関数の定義
に比べてかなり長い。これは各々の行が fill-prefix (行詰め接頭辞) で始まる
ようなパラグラフも相手にしなければならないためである。

Fill prefix は 各々の行の先頭に繰り返し現れる文字列からなる。例えば 
Lisp コードでは便宜上パラグラフの各々の行が @samp{;;; } から始まる。また
テキストモードでは四つの空白文字インデントされたパラグラフの fill prefix 
としてよく使われる。(Fill prefix についてのより詳しい情報は @ref{Fill
Prefix, , , emacs, The GNU Emacs Manual}, を参照せよ。)

Fill prefix があるということは、@code{forward-paragraph} 関数は、中の行
が左端から始まっているようなパラグラフの終わりを見つけるだけではなく、そ
のバッファの全て、ないしは多くの行がある fill prefix で始まっているよう
場合にもパラグラフの終わりを見つけなければならないということを意味する。

更に、時には fill prefix があっても無視した方が良い場合だってある。特に
空行でパラグラフが区切られているような場合などがそうだ。これにより、更に
複雑さが増す。

ここでは @code{forward-paragraph} 関数を全て書き出すのはやめて、その中の
一部だけを見ることにする。準備なしに読もうとすると、ちょっと臆してしまう
かもしれない。

この関数のアウトラインは次のようである。

@example
@group
(defun forward-paragraph (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let*
      @var{変数リスト}
    (while (< arg 0)        ; @r{後方に戻る場合のコード}
      @dots{}
      (setq arg (1+ arg)))
    (while (> arg 0)        ; @r{前方に進む場合のコード}
      @dots{}
      (setq arg (1- arg)))))
@end group
@end example

関数の最初の部分はいつもの通りである。引数のリストには一つ省略可能な引数
があるだけである。次に説明文字列が続く。

インタラクティブ宣言の中の小文字の @samp{p} はもし前置引数があれば、それ
を処理してから関数に渡すことを意味する。これは数値であり、いくつ分のパラ
グラフを移動するかを表わす。次の行の @code{or} 式は関数に一つも引数が与
えられなかった場合を扱うための物である。これはこの関数がインタラクティブ
ではなく他のコードから呼び出された場合に起きる。これについては以前説明し
た。(@ref{forward-sentence, 関数 @code{forward-sentence}}, 参照。) ここ
までは、今まで慣れ親しんできた部分である。

@menu
* fwd-para let::                @code{let*} 式について
* fwd-para while::              前方に向かう場合の @code{while} ループ
* fwd-para between paragraphs::  パラグラフとパラグラフの間での動作
* fwd-para within paragraph::   パラグラフの内部での動作
* fwd-para no fill prefix::     fill prefix が無い場合
* fwd-para with fill prefix::   fill prefix が有る場合
* fwd-para summary::            @code{forward-paragraph} のまとめ
@end menu

@node fwd-para let, fwd-para while, forward-paragraph, forward-paragraph
@unnumberedsubsubsec @code{let*} 式

@code{forward-paragraph} の次の行は @code{let*} 式で始まる。これは以前に
出てた式とは異なる。このシンボルは @code{let*} であって @code{let} では
ない。

特殊形式 @code{let*} は基本的に @code{let} と同じなのだが、Emacs が変数
を順にセットしていくため、変数リストの中で後に出てくる変数がそれ以前に出
てきた変数の値を参照することが出来る、という点のみが異なっている。

この関数の @code{let*} 式の中では Emacs は二つの変数 
@code{fill-prefix-regexp} と @code{paragraph-separate} をバインドしてい
るのだが、@code{paragraph-separate} がバインドされる値は 
@code{fill-prefix-regexp} の値に依存しているのである。

各々を順に見ていこう。シンボル @code{fill-prefix-regexp} は次のリストを
評価した値にセットされる。

@example
@group
(and fill-prefix 
     (not (equal fill-prefix ""))
     (not paragraph-ignore-fill-prefix)
     (regexp-quote fill-prefix))
@end group
@end example

@noindent 
これは最初の要素が関数 @code{and} であるようなＳ式である。

関数 @code{and} は各々の引数をそのどれかが @code{nil} を返すまで評価して
いく。どれかが @code{nil} を返した場合は @code{and} は @code{nil} を返す。
しかし、もしどの引数も @code{nil} を返さなければ、最後の引数を評価して返
された値を返す。(この場合、その値は nil ではないので、Lisp では真と見な
される。) 別の言い方をすれば、@code{and} は引数全てが真である場合にのみ
真を返すわけである。
@findex and

今の場合なら、@code{fill-prefix-regexp} は後に続く四つのＳ式を評価して全
て真 (即ち、非 @code{nil}) が返された場合にのみ、非@code{nil} の値を返す。
そうでない場合は @code{fill-prefix-regexp} は @code{nil} にバインドされる。

@table @code
@item fill-prefix
この変数を評価すると、もしあれば fill prefix の値が返される。fill prefix 
が無い場合は @code{nil} が返る。

@item (not (equal fill-prefix "")
このＳ式は fill prefix があった場合にそれが空文字列、つまり文字を一つも
含まない文字列かどうかを判定する。空文字列は fill prefix としての役には
立たない。

@item (not paragraph-ignore-fill-prefix)
このＳ式は、もし変数 @code{paragraph-ignore-fill-prefix} が @code{t} 等
の真の値にセットされている場合に @code{nil} を返す。

@item (regexp-quote fill-prefix)
これは @code{and} 関数の最後の引数になる。もし @code{and} の全ての引数が
真であれば、@code{and} の値としてはこのＳ式を評価して返された値が返され
ることになる。そしてそれが fill-prefix-regexp の値になる。
@end table

@findex regexp-quote
@noindent
この @code{and} 式を評価して真が返された場合、@code{fill-prefix-regexp} 
は @code{regexp-quote} によって修正された @code{fill-prefix} の値にバイ
ンドされる。@code{regexp-quote} は、文字列を読み取り、それのみにマッチし、
その他の文字列にはマッチしないような正規表現を返す。結局、fill prefix が
存在する場合、@code{fill-prefix-regexp} はその fill prefix の値にちょう
どマッチする値にセットされ、そうでなければ @code{nil} にセットされる。

@code{let*} 式の二番目の局所変数は @code{paragraph-separate} である。こ
れは次のＳ式を評価して返された値にバインドされる。

@example
@group
(if fill-prefix-regexp
    (concat paragraph-separate 
            "¥¥|^" fill-prefix-regexp "[ ¥t]*$")
  paragraph-separate)))
@end group
@end example

このＳ式を見れば何故 @code{let} ではなく @code{let*} 式を使ったかが分る。
@code{if} 式の真偽テストは、変数 @code{fill-prefix} の値が @code{nil} か
その他の値かということに依存しているのである。

もし @code{fill-prefix-regexp} が値を持たなかったなら、(訳註: つまり 
@code{nil} であれば) Emacs は @code{if} 式の else-part を評価し、
@code{paragraph-separate} を現在の局所的な値にバインドする。
(@code{paragraph-separate} はパラグラフの区切りにマッチする正規表現であ
る。) 

しかし、もし @code{fill-prefix-regexp} が値を持てば、(訳註: 真の値を持て
ば) Emacs は @code{if} 式の then-part を評価し、
@code{paragraph-separate} の値を @code{fill-prefix-regexp} をパターンの
一部として含むような正規表現にバインドする。

より詳しく言うと @code{paragraph-separate} は、元々の 
@code{paragraph-separate} の値を @code{fill-prefix-regexp} に空行を加え
た表現を連結した値にセットされることになる。@samp{^} は 
@code{fill-prefix-regexp} が行頭に来なければならないことを意味し、その後
に空白が来ても良いことが、@w{@code{"[ ¥t]*$"}} で定義されている。
@samp{¥¥|} は、この正規表現か元の @code{paragraph-separate} かどちらかが
マッチしなければならないことを示すものである。

では @code{let*} 式の本体部分に入ろう。本体の最初の部分では、この関数に
負の引数が与えらた場合、即ち後方に戻る場合を扱っている。この部分は省略す
ることにする。

@node fwd-para while, fwd-para between paragraphs, fwd-para let, forward-paragraph
@unnumberedsubsubsec 前方に移動する場合の @code{while} ループ

@code{let*} 式の本体の二番目の部分は前方に進む場合を扱っている。これは 
@code{arg} が零よりも大きい間は繰り返すような @code{while} ループである。
この関数を使う場合、大抵この引数は1である。従って @code{while} ループの
本体はちょうど一度だけ実行され、それによりカーソルはパラグラフ一つ分だけ
移動する。

この @code{while} ループは次のような形をしている。

@example
@group
(while (> arg 0)
  (beginning-of-line)

  ;; @r{パラグラフとパラグラフの間に居る場合}
  (while (prog1 (and (not (eobp))
                     (looking-at paragraph-separate))
           (forward-line 1)))
@end group

@group
  ;; @r{パラグラフ内で、fill prefix がある場合}
  (if fill-prefix-regexp
      ;; @r{fill prefix があるので、paragraph-start は関係無し。}
      (while (and (not (eobp))
                  (not (looking-at paragraph-separate))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group

@group
    ;; @r{パラグラフ内で、fill prefix がない場合}
    (if (re-search-forward paragraph-start nil t)
        (goto-char (match-beginning 0))
      (goto-char (point-max))))

  (setq arg (1- arg)))
@end group
@end example

まず直ちに分ることは、これは減少カウンタの @code{while} ループであり、デ
クリメンタとして @code{(setq (1- arg))} というＳ式を使っているということ
である。このループの本体は次の三つのＳ式からなる。

@example
@group
;; @r{パラグラフの間に居る場合} 
(beginning-of-line)       
(while 
    @var{while ループの本体})
@end group

@group
;; @r{パラグラフ内で、fill prefix がある場合}
(if @var{真偽テスト}    
    @var{then-part}             
@end group

@group
;; @r{パラグラフ内で、fill prefix がない場合}
  @var{else-part}               
@end group
@end example

@noindent 
Emacs Lisp のインタプリタが @code{while} ループの本体を評価する場合、ま
ず最初に @code{(beginning-of-line)} という式を評価して行頭に移動する。次
に内部の @code{while} ループに入る。この @code{while} ループは、カーソル
がパラグラフとパラグラフの間の空白にあった場合、その外に移動させるための
ものである。最後に、実際にパラグラフの終りにポイントを移動する @code{if} 
式が来る。

@node fwd-para between paragraphs, fwd-para within paragraph, fwd-para while, forward-paragraph
@unnumberedsubsubsec パラグラフとパラグラフの間での動作

まずは内部の @code{while} ループを見ることにしよう。このループはポイント
がパラグラフとパラグラフの間にあった場合を扱うためのものである。ここでは
三つの新しい関数が登場する。@code{prog1}、@code{eobp}、そして 
@code{looking-at} である。
@findex prog1
@findex eobp
@findex looking-at

@itemize @bullet
@item
@code{prog1} 関数は @code{progn} とよく似ているのだが、引数を順に評価し
ていった後、最初の引数が返した値をこの関数全体の値として返す、という点が
異なっている。(@code{progn} 関数は最後の引数が返した値を返すのだった。) 
@code{prog1} の二番目以降の引数は副作用だけのために評価されるわけである。

@item
@code{eobp} は @samp{End Of Buffer P} の略であり、ポイントがバッファの最
後にある場合に真を返す関数である。

@item
@code{looking-at} は、ポイントの後に続くテキストが @code{looking-at} の
引数として与えられた正規表現にマッチする場合に真を返す関数である。
@end itemize

@code{while} ループは次の通りである。

@example
@group
(while (prog1 (and (not (eobp))
                   (looking-at paragraph-separate))
              (forward-line 1)))
@end group
@end example

@noindent
この @code{while} ループは本体部分を持たない！ 真偽テストは次のＳ式であ
る。

@example
@group
(prog1 (and (not (eobp))
            (looking-at paragraph-separate))
       (forward-line 1)))
@end group
@end example

@noindent
@code{prog1} の最初の引数は @code{and} 式である。この中には、ポイントが
バッファの最後にあるかどうか、そしてポイントの直後にパラグラフの区切りを
示す正規表現にマッチするパターンがあるかどうかのテストが含まれている。

もしカーソルがバッファの最後ではなく、またカーソルの後にパラグラフの区切
りを示す文字があれば、@code{and} 式は真になる。Lisp インタプリタは 
@code{and} 式を評価した後、@code{prog1} の二番目の引数である 
@code{forward-line} を評価する。これはポイントを一行だけ前に移動する。た
だし、@code{prog1} が返す値は最初の引数の値である。従って、@code{while} 
ループはポイントがバッファの最後にはなく、またパラグラフとパラグラフの間
にある間だけ繰り返される。最終的にポイントがあるパラグラフに移動したなら、
@code{and} 式は偽を返す。いずれにしろ @code{forward-line} コマンドは実行
されることに注意しよう。これはポイントがパラグラフとパラグラフの間から移
動した場合、ポイントはパラグラフの二行目の先頭に置かれることになることを
意味している。

@node fwd-para within paragraph, fwd-para no fill prefix, fwd-para between paragraphs, forward-paragraph
@unnumberedsubsubsec パラグラフの内部での動作

外側の @code{while} ループでの次のＳ式は @code{if} 式である。
Lisp インタプリタは @code{fill-prefix-regexp} 変数が @code{nil} 以外の値
を持っている場合には @code{if} 式の then-part を評価し、@code{nil} の場
合、つまり fill prefix が無い場合は else-part を評価する。

@node fwd-para no fill prefix, fwd-para with fill prefix, fwd-para within paragraph, forward-paragraph
@unnumberedsubsubsec Fill prefix が無い場合

まず最初に fill prefix が無い場合のコードを見るのが単純で良いだろう。こ
のコードは次のようにまた別の @code{if} 式からなっている。

@example
@group
(if (re-search-forward paragraph-start nil t)
    (goto-char (match-beginning 0))
  (goto-char (point-max)))
@end group
@end example

@noindent
このＳ式は、大抵の人が @code{forward-paragraph} コマンドの主目的と考える
であろう仕事を実際に行う。つまり、まず次のパラグラフの始まりを前方に向かっ 
て検索するような正規表現の検索を行い、もし見つかれば、ポイントをその位置
に移動する。別のパラグラフの始まりが見つからない場合は、現在のバッファで
アクセス可能な最後の位置まで移動する。

この中で、これまでで慣れ親しんでいない部分は @code{match-beginning} の使
い方だけである。この関数自体も初めて出てくるものだ。
@code{match-beginning} 関数は、最後に行った正規表現検索でマッチしたテキ
ストの始まりの位置を表わす数値を返す関数である。

ここで @code{match-beginning} 関数が使われているのは前方検索の性質のため
である。つまり、前方検索が成功した場合、通常の検索か正規表現の検索かどう
かにかかわらず、ポイントを見つけたテキストの位置にまで移動してしまう。今
の場合なら、検索に成功した場合はポイントは @code{paragraph-start} のパター
ンの終わりにまで移動するのだが、これは現在のパラグラフの終わりではなく、
次のパラグラフの始まりである。

しかしながら、我々の目的はポイントを次のパラグラフの先頭ではなく現在のパ
ラグラフの終わりにまで移動することである。この二つの位置は、パラグラフと
パラグラフの間に幾つかの空行がある場合などでは、当然異なる。

@findex match-beginning
引数0で呼ばれた場合、 @code{match-beginning} は最も最近、正規表現の検索
に成功した位置を返す。今の場合、最も最近の正規表現の検索は 
@code{paragraph-start} を探すものなので、@code{match-beginning} はそのパ
ターンの開始位置を返す。(終了位置ではない。) この開始位置は現在のパラグ
ラフの最後である。

(ついでにいうと、引数として正の数が渡された場合、
@code{match-beginning} 関数は最後の正規表現の中の括弧でくくられた部分の表
現の開始位置を返す。これは便利な機能である。)

@node fwd-para with fill prefix, fwd-para summary, fwd-para no fill prefix, forward-paragraph
@unnumberedsubsubsec Fill prefix がある場合

さっき議論した、内部の方の @code{if} 式は、それを含む fill prefix がある
かどうかをテストする @code{if} 式の else-part になっていたのであった。
fill prefix がある場合は、then-part の方が評価される。この部分は次の通り
である。

@example
@group
(while (and (not (eobp))
            (not (looking-at paragraph-separate))
            (looking-at fill-prefix-regexp))
  (forward-line 1))
@end group
@end example

@noindent
このＳ式がやることは、次の三つの条件が真である間だけ、ポイントを一行ずつ
前方に移動することである。

@enumerate
@item
ポイントはバッファの最後ではない。

@item
ポイントに続くテキストはパラグラフの区切りではない。

@item
ポイントに続くパターンは fill prefix を表わす正規表現である。
@end enumerate

最後の条件はちょっと戸惑うかもしれないが、ポイントが 
@code{forward-paragraph} 関数によって既に行頭に移動していることを思い出
せば納得出来るだろう。つまり、テキストに fill prefix があれば、
@code{looking-at} 関数がそれを見ることになるのである。

@node fwd-para summary,  , fwd-para with fill prefix, forward-paragraph
@unnumberedsubsubsec まとめ

以上をまとめてみよう。前方に移動する場合の @code{forward-paragraph} 関数
は次のことを行う。

@itemize @bullet
@item
ポイントを行頭に移動する。

@item
パラグラフとパラグラフの間から抜け出す。

@item
fill prefix があるかどうかチェックする。もしあれば、

@itemize ---

@item
その行がパラグラフの区切りの行でない間だけ、一行ずつ前に進む。
@end itemize

@item
もし fill prefix がなければ、

@itemize ---

@item
次のパラグラフの開始パターンを検索する。

@item
そのパラグラフの開始パターンの始まりの位置に移動する。これは、その前のパ
ラグラフの終了位置である。

@item
そのパターンが見つからない場合は、そのバッファのアクセス可能な最大位置
まで移動する。
@end itemize
@end itemize

復習のために、これまで議論してきたコードを見やすいよう整形して挙げておく。

@example
@group
(interactive "p")
(or arg (setq arg 1))
(let* (
       (fill-prefix-regexp
        (and fill-prefix (not (equal fill-prefix ""))
             (not paragraph-ignore-fill-prefix)
             (regexp-quote fill-prefix)))
@end group

@group
       (paragraph-separate
        (if fill-prefix-regexp
            (concat paragraph-separate
                    "¥¥|^"
                    fill-prefix-regexp
                    "[ ¥t]*$")
          paragraph-separate)))

  @var{backward-moving-code (omitted)} @dots{}
@end group

@group
  (while (> arg 0)                ; @r{前方に進む場合のコード}
    (beginning-of-line)

    (while (prog1 (and (not (eobp))
                       (looking-at paragraph-separate))
             (forward-line 1)))
@end group

@group
    (if fill-prefix-regexp
        (while (and (not (eobp))  ; @r{then-part}
                    (not (looking-at paragraph-separate))
                    (looking-at fill-prefix-regexp))
          (forward-line 1))
@end group
@group
                                  ; @r{else-part: 内部の if}
      (if (re-search-forward paragraph-start nil t)
          (goto-char (match-beginning 0))
        (goto-char (point-max))))

    (setq arg (1- arg)))))        ; @r{デクリメンタ}
@end group
@end example

@code{forward-paragraph} 関数の完全な定義は、上に挙げた前方に進むコード
だけでなく、後方に戻るコードも含んでいる。

もし、この文書を GNU Emacs の中で読んでいるなら、この関数全体のコードを
見たい場合には @code{M-.} (@code{find-tag}) とタイプし、プロンプトが出た
ら関数名をタイプすれば良い。@code{find-tag} 関数がまず @file{TAGS} テー
ブルの名前を聞いてきた場合は、あなたの @file{emacs/src} ディレクトリの中
の @file{TAGS} ファイルの名前を答える。これは 
@file{/usr/local/lib/emacs/19.23/src/TAGS}. のようなパス名である。(正確
な @file{emacs/src} ディレクトリのパス名はあなたの Emacs がどのようにイ
ンストールされているかに依る。もしパス名が分らなければ、@kbd{C-h i} とし
て Info に入り、@kbd{C-x C-f} とタイプして @code{emacs/info} ディレクト
リのパス名を知ることが出来る。@file{TAGS} ファイルのパスは対応する 
@file{emacs/src} パスであることが多い。(訳註：無いことも多い。) もっとも 
Info ファイルが他の場所にあることも多いが。

あるいは、@file{TAGS} ファイルがないディレクトリに、自分自身の@ 
@file{TAGS} ファイルを作成することも出来る。
@ifinfo
@ref{etags, , 自分自身の @file{TAGS} ファイルの作成}, を参照。
@end ifinfo

@node etags, Regexp Review, forward-paragraph, Regexp Search
@section 自分自身の @file{TAGS} ファイルの作成
@findex etags
@cindex @file{TAGS} file, create own

簡単にソースの場所までジャンプ出来るように、あなた自身の @file{TAGS} ファ
イルを作成することが出来る。例えば、もしあなたの @file{‾/emacs} ディレク
トリに沢山のファイルがあったとすると---何を隠そう、私もこの場所に137個の 
@file{.el} ファイルがあり、その内17個をロードしているのだが---そのディレ
クトリに @file{TAGS} ファイルを作ることで、@code{grep} やその他の道具で
関数名を検索するよりはずっと簡単に、特定の関数の位置にジャンプすることが
出来るようになる。

@code{TAGS} ファイルは、Emacs の配布に含まれる @code{etags} プログラムを
使って作成出来る。普通、@code{etags} は Emacs が構築された時に一緒にコン
パイルされインストールされる。(ただし、@code{etags} は Emacs Lisp 関数や 
Emacs の一部分ではない。これは C のプログラムである。)

@file{TAGS} ファイルを作成するには、まずこのファイルを作成したいディレク
トリに移動する。Emacs の中だと、@kbd{M-x cd} コマンドを使うか、そのディ
レクトリにあるファイルをビジットするか、あるいは @kbd{C-x d}
(@code{dired}) を使うことで移動することが出来る。そして

@example
M-! etags *.el
@end example

@noindent
とタイプしてやれば良い。@code{etags} プログラムは普通のシェルで使える全
てのワイルドカードを理解出来る。例えば、もし二つのディレクトリに対して一
つの @file{TAGS} ファイルを作りたい場合は、二番目のディレクトリを 
@file{../elisp/} だとして、次のようにタイプすればよい。

@example
M-! etags  *.el ../elisp/*.el
@end example

@need 1250
また、@code{etags} が受け付けるオプションのリストを見たい場合には

@example
M-! etags --help
@end example

@noindent
とタイプする。

@code{etags} プログラムは Emacs Lisp, Common Lisp, Scheme, C, Fortran,
Pascal, LaTeX, そして大抵のアセンブラを扱うことが出来る。このプログラム
には言語を特定するためのスィッチはない。その代わりにファイル名や中身から
そのファイルの言語を認識するのである。

また @file{etags} は、自分自身でコードを書いたり、既に書いた関数を後から
参照したりするのにも大変便利である。新しい関数を書いたら、ときおり 
@code{etags} プログラムを走らせよう。そうすることでそれらの関数が 
@file{TAGS} ファイルに付け加わる。

@node Regexp Review, re-search Exercises, etags, Regexp Search
@comment  node-name,  next,  previous,  up
@section 復習

ここでは最近導入した関数の簡単なまとめを載せておく。

@table @code
@item while
本体部分のＳ式を、本体の最初の要素が真を返す間だけ繰り返し評価する。最後
は @code{nil} を返す。(つまり、この式は副作用のためだけに評価される。)

@need 1250
例）

@example
@group
(let ((foo 2))
  (while (> foo 0)
    (insert (format "foo is %d.¥n" foo))
    (setq foo (1- foo))))

     @result{}      foo is 2.
             foo is 1.
             nil
@end group
@end example
@noindent
(@code{insert} 関数は引数をポイントに挿入する。また @code{format} 関数
は引数を @code{message} 関数が整形するのと同様に整形して出来たストリン
グを返す。@code{¥n} は改行である。

@item re-search-forward
パターンを検索し、発見した場合はその直後にポイントを移動する。

@noindent
@code{search-forward} と同様、四つの引数を取る。

@enumerate
@item
検索パターンを表わす正規表現。

@item
省略可能。検索の限界。

@item
省略可能。検索が失敗した場合にどうするか。@code{nil} を返すかエラーメッ
セージを出すか。

@item
省略可能。検索を何回繰り返すか。負の数の場合は後方に検索する。
@end enumerate

@item let*
幾つかの変数を特定の値に局所的にバインドし、残りの引数を評価する。値
としては最後の引数の値を返す。局所変数をバインドする際、より先にバイン
ドした変数があれば、その値を利用出来る。

@need 1250
例）

@example
@group
(let* ((foo 7)
      (bar (* 3 foo)))
  (message "`bar' is %d." bar))
     @result{} `bar' is 21.
@end group
@end example

@item match-beginning
最後の正規表現で見つかったテキストの始まりの位置を返す。

@item looking-at
ポイントに続くテキストが引数の正規表現にマッチした場合に真として 
@code{t} を返す。

@item eobp
ポイントがそのバッファのアクセス可能な最大位置にある場合に真として 
@code{t} を返す。アクセス可能な範囲というのは、もしナローイングがかかっ
ていない場合はバッファの最後の位置であり、ナローイングがかかっている場合
は、その部分の最後である。

@item prog1
引数を順に評価していき、@emph{最初}の引数の値を返す。

@need 1250
例）

@example
@group
(prog1 1 2 3 4)
     @result{} 1
@end group
@end example
@end table

@need 1500
@node re-search Exercises,  , Regexp Review, Regexp Search
@section @code{re-search-forward} についての練習問題

@itemize @bullet
@item
二行以上続く空行にマッチする正規表現を検索する関数を書きなさい。

@item
`the the' のように二度続く単語を検索する関数を書きなさい。二つの同じ部分
からなる文字列にマッチする regexp (regular expression = 正規表現) の書き
方については @ref{Regexps, , Syntax of Regular Expression, emacs, The
GNU Emacs Manual}, を参考にしなさい。regexp の書き方はいく通りもある。そ
の内の幾つかは残りのものよりも良い。私が利用している関数は、幾つかの正規
表現と一緒に次の所に記されている。@ref{the-the, , 関数 @code{the-the}}.
@end itemize

@node Counting Words, Words in a defun, Regexp Search, Top
@chapter カウント：繰り返しと正規表現
@cindex Repetition for word counting
@cindex Regular expressions for word counting

繰り返しと正規表現の検索は、Emacs Lisp でコードを書く際によく使われる大
変強力な道具である。この章では、正規表現の検索の利用の仕方を、
@code{while} ループないしは再帰を利用した単語を数えるコマンドの作成を通
して説明していくことにする。

@menu
* Why Count Words::             Emacs には単語を数えるコマンドが欠けている
* count-words-region::          正規表現を使う。でも問題が...
* recursive-count-words::       リージョンに単語が一つも無い場合には
* Counting Exercise::           カウントに関する練習問題
@end menu

@node Why Count Words, count-words-region, Counting Words, Counting Words
@ifinfo
@heading 単語のカウント
@end ifinfo

標準的な Emacs の配布にはリージョン内の行数を数える関数が含まれている。
しかし同じことを単語について行う関数はない。

文章の種類によっては単語の数を数えなければならないようなことがある。エッ
セイを書く場合は800単語以内に制限した方がよいであろうし、小説を書く場合
など、一日1000単語は書くぞと決心することもあるだろう。個人的には Emacs 
に単語を数えるコマンドがないのは変だと思う。多分 Emacs を使う人は大抵コー
ドとかドキュメントを書いていて、単語の数を数える必要などないのだろう。あ
るいは Operating system 附属の単語数を数えるコマンドである @code{wc} し
か使わなかったりするのかもしれない。はたまた編集者の都合に合わせて、文書
の中の単語の数を文字数を5で割ったものとして数えている人もいるかもしれな
い。何はともあれ、以下で単語数を数えるコマンドを紹介することにする。

@node count-words-region, recursive-count-words, Why Count Words, Counting Words
@comment  node-name,  next,  previous,  up
@section 関数 @code{count-words-region}
@findex count-words-region

単語数を数えるコマンドとしては、行、パラグラフ、あるいはリージョンやバッ
ファなどの中に含まれる単語の数を数えるものが考えられる。コマンドとしては
どんなことまで出来ればよいだろうか。コマンドをバッファ全体の単語を数える
ように設計することも出来るが、Emacs の伝統からいって、もっと柔軟性を持た
せた方がよいだろう。例えばバッファ全体ではなく、あるセクションの中の単語
の数を教えるようなコマンドが欲しい場合も出てくるかもしれない。従って、リー
ジョンの中の単語数を数えるように設計した方が合理的だろう。一度、このよう
な @code{count-words-region} というコマンドを作ってしまえば、@kbd{C-x h}
(@code{mark-whole-buffer}) を使ってバッファ全体をマークすることで、バッ
ファ全体の単語を数えることだって出来る。

単語を数えることは、明らかに繰り返しを伴う動作だ。リージョンの始まりから
スタートして最初の単語を数え、次に二番目に行き、三番目に行き、というふう
にしてリージョンの最後に来るまで続けるわけである。これは単語を数えるとい
う行為が、もともと再帰や @code{while} ループに適しているということを意味
する。

まずは、@code{while} ループを使って、次に再帰を使って、単語を数えるコマ
ンドを実際に作ってみることにする。これらのコマンドは勿論インタラクティブ
であるべきである。

これまでにも何度も見たように、インタラクティブな関数の定義のテンプレート
は次のようになっている。

@example
@group
(defun @var{関数名} (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  (@var{インタラクティブ式}@dots{})
  @var{本体}@dots{})
@end group
@end example

このスロットを埋めればよい。

関数の名前はそれ自体で意味が通じ、かつ既にある
関数 @code{count-lines-region} の名前と似たものであるべきである。これは
名前を覚えやすくするためだ。@code{count-words-region} なんかが良いだろう。

この関数はリージョン内の単語の数を数える。従って引数リストには、リージョ
ンの始まりと終わりの二つの位置各々にバインドされるシンボルが含まれていな
ければならない。これらの二つの位置は @samp{beginning} と @samp{end} と呼
べばいいだろう。説明文字列の最初の行は一つの文であるべきである。というの
は @code{apropos} のようなコマンドで表示される部分は一行目が全てであるか
らである。インタラクティブ式は @samp{(interactive "r")} という形になる。
こうすることで、リージョンの始まりと終わりの位置をこの関数の引数リストに
渡すことが出来る。ここまではルーティーンワークである。

関数の本体は、三つの仕事をするように書かれなければならない。一番目は 
@code{while} ループが単語を数える時の条件を設定すること、二番目は 
@code{while} ループを走らせること、そして三番目はユーザにメッセージを送
ることである。

ユーザが @code{count-words-region} を呼び出した時点では、ポイントはリー
ジョンの始まり、もしくは終わりにある。しかし、カウントは常にリージョンの
始まりの位置から開始しなければならない。従って、そうでない場合はまずその
位置までポイントを移動しておいて欲しい。@code{(goto-char beginning)} を
実行することで、このことが保証される。勿論、関数が仕事を終えたらポイント
の位置は元の位置に戻っていて欲しい。このために、本体部分は 
@code{save-excursion} 式で囲む必要がある。

本体の中心部分は、あるＳ式で次の単語に一つずつジャンプし、もう一つのＳ式
でジャンプの回数を数える @code{while} ループからなる。@code{while} ルー
プの真偽テストはポイントがもう先へは進めなくなるまでは真を返し、リージョ
ンの最後まできたら偽を返すようなものでなければならない。

ポイントを単語ごとに移動するＳ式としては @code{(forward-word 1)} を使っ
てもよい。しかし、正規表現の検索を使うなら、Emacs が何を単語と見倣すかを
見る方が簡単である。

単語のパターンを検索する正規表現の検索では、ポイントはマッチしたパターン
の最後の文字の位置に移動する。従って、続けて検索が成功している間はポイン
トは単語を一つずつ移動していくことになる。

現実問題として、正規表現の検索では、単語だけではなく単語間の空白や句読点
をジャンプするようになっていて欲しい。実際、単語間の空白を越えて進まない
ような正規表現では二単語以上先には進めなくなってしまう。つまり、正規表現
の中には単語だけでなく、その後に続く空白や句読点等も含まれていなければな
らないわけである。(単語はバッファの最後に来るかもしれないので、後に必ずし
も空白がくるとは限らない。従って、空白等の部分の正規表現はオプションに
なる。)

というわけで、我々が求めている正規表現は、まず幾つかの単語構成文字が続き、
オプションとして単語の構成要素以外の文字が一つ以上の続くようなパターンで
ある。このような正規表現は次のように書ける。

@example
¥w+¥W*
@end example

@noindent
どの文字が単語構成文字であり、どの文字がそうでないかは、そのバッファのシ
ンタックステーブルによる。
(詳しくは @ref{Syntax, , 単語やシンボルは何から構成されているか}, あるいは 
@ref{Syntax, Syntax, The Syntax Table, emacs, The GNU Emacs Manual}, や 
@ref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp Reference
Manual}, を参照。)

検索のためのＳ式は次の通りである。

@example
(re-search-forward "¥¥w+¥¥W*")
@end example

@noindent
(@samp{w} や @samp{W} の前にはバックスラッシュが二つずつ組になっているこ
とに注意しよう。単独のバックスラッシュは Emacs インタプリタにとって特殊
な意味を持っている。つまり、後に続く文字が普通とは異なる意味に解釈される
のである。例えば、@samp{¥n} という二つの文字は、バックスラッシュに続く 
@samp{n} ではなく、改行コードを表わす。バックスラッシュが二つ続いて初め
て通常の「特殊でない」バックスラッシュを表わすのである。)

(訳註：つまり、バックスラッシュが二つ要るのは、それが一度 Emacs の Lisp 
リーダによって一つのバックスラッシュに解釈された後の結果が正規表現として
解釈されるためである。ここは混乱しやすいので注意しよう。)

いくつ単語があったかを数えるためのカウンタも必要である。この変数は最初は0
にセットされ、while ループを一つ繰り返す度に一つずつ増えていく。この一つ
増やすためのＳ式は単に

@example
(setq count (1+ count))
@end example

@noindent
だけでよい。さて、最後にユーザに対してリージョンにいくつ単語があったかを
知らせたい。このようにユーザに情報を表示する目的には、@code{message} 関
数が用意されている。今の場合、メッセージは単語の数がいくつあった場合でも
きちんとした文章になっていなければならない。例えば、``there are 1 words
in the region'' というふうになっては困る。単語が一つなのに複数形が使われ
るのは文法的に正しくないからである。この問題は、条件分岐式を用いて単語数
によってメッセージを変えるようにすれば回避出来る。可能性は三つある。一つ
はリージョン内には全く単語が無い場合、もう一つは一個だけある場合、そして、
複数の単語がある場合である。このような場合には @code{cond} を使うとよい
のであった。

@need 1500
以上を総合すると、次のような関数定義になる。

@example
@group
;;; @r{最初のバージョン: バグあり！}
(defun count-words-region (beginning end)  
  "Print number of words in the region.
Words are defined as at least one word-constituent
character followed by at least one character that
is not a word-constituent.  The buffer's syntax
table determines which characters these are."
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. 適切な状況の設定。}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. } while @r{loop を走らせる。} 
      (while (< (point) end)
        (re-search-forward "¥¥w+¥¥W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. ユーザにメッセージを送る。}
      (cond ((zerop count)
             (message 
              "The region does NOT have any words."))
            ((= 1 count) 
             (message 
              "The region has 1 word."))
            (t 
             (message 
              "The region has %d words." count))))))
@end group
@end example

@noindent
が、以下に書かれている通り、この関数は全ての状況できちんと動作するわけでは
ない。

@menu
* Whitespace Bug::              @code{count-words-region} の空白についてのバグ
@end menu

@node Whitespace Bug,  , count-words-region, count-words-region
@comment  node-name,  next,  previous,  up
@subsection @code{count-words-region} の空白文字に関するバグ

前節で説明した @code{count-words-region} コマンドには、二つのバグ、とい
うか二つの現れ方をする一つのバグがある。まず、たとえリージョンがある文章
の途中にある空白文字しか含まない場合でも、@code{count-words-region} は単
語が一つあると言ってくる。また、バッファないしはアクセス可能な部分の最後
にある空白文字しか含まない場合は、

@example
Search failed: "¥¥w+¥¥W*"
@end example

@noindent
というエラーメッセージが返ってしまう。この文を GNU Emacs の Info で読ん
でいるなら、このバグを実際に自分で確かめることが出来る。

まずはこの関数をいつも通り評価してインストールしよう。
@ifinfo
ここに定義のコピーを書いておく。最後の閉じ括弧の直後にカーソルを持っていっ
て @kbd{C-x C-e} とタイプすればインストールされる。

@example
@group
;; @r{最初のバージョン; バグあり！}
(defun count-words-region (beginning end)  
  "Print number of words in the region.
Words are defined as at least one word-constituent character followed
by at least one character that is not a word-constituent.  The buffer's
syntax table determines which characters these are."
@end group
@group
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. 適切な状況の設定。}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. } while @r{loop を走らせる。}
      (while (< (point) end)
        (re-search-forward "¥¥w+¥¥W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. ユーザにメッセージを送る。}
      (cond ((zerop count)
             (message "The region does NOT have any words."))
            ((= 1 count) (message "The region has 1 word."))
            (t (message "The region has %d words." count))))))
@end group
@end example
@end ifinfo

お望みなら、次の式を評価することでこのコマンドのためのキーバインディン
グもインストール出来る。

@example
(global-set-key "¥C-c=" 'count-words-region)
@end example

最初のテストをするために、次の行の最初と最後にマークとポイントを設定して 
@kbd{C-c =} (あるいは @kbd{C-c =} というキーバインディングをインストール
していなければ @kbd{M-x count-words-region}) とタイプしよう。

@example
    one   two  three        
@end example

@noindent
Emacs はリージョンには三つの単語があると正しく答えるはずだ。

次に、マークを行頭にセットして、ポイントをちょうど @samp{one} という単語
の@emph{前}に置いて同じテストをしてみよう。@kbd{C-c =} (あるいは 
@kbd{M-x count-words-region}) とタイプした場合、Emacs はリージョンには一
つも単語がないと答えるべきである。リージョンには行頭の空白文字だけしか含
まれないからだ。しかし実際は Emacs はリージョンには一つの単語があると答
えてくる！

三番目に、サンプルの行を @file{*scratch*} バッファの最後にコピーして行の
終わりに幾つか空白文字をタイプしてから、マークを @samp{three} の直後に、
ポイントを行末に設定する。(即ち、行末をバッファの最後にする。) ここでさっ
きと同じく @kbd{C-c =} (あるいは @kbd{M-x count-words-region}) とタイプ
しよう。空白文字しかないのだから、今回も Emacs は単語は一つもないと答え
るべきである。しかし、Emacs は @samp{Search failed} というエラーメッセー
ジを表示する。

この二つのバグは共通する問題から生じたものだ。

最初のバグを考えてみよう。コマンドを実行すると、空白だけしかないはずの行
頭部分に一つの単語が含まれていると言ってきたのであった。これは何故だろう
か？ @code{M-x count-words-region} コマンドは、まずポイントをリージョン
の最初に移動させる。@code{while} テストは @code{point} の値が @code{end} 
の値よりも小さいかどうかテストする。これは正しいので、結果として最初の単
語を見つける正規表現の検索が実行され、最初の単語が見つかる。ポイントは単
語の後ろに移され、@code{count} は1にセットされる。@code{while} ループは
もう一度実行されるが、今度はポイントの値が @code{end} の値よりも大きくな
るので、ループはそこで終了する。そしてこの関数は、リージョン内の単語は一
つだと言うメッセージを表示するというわけである。手短にいうと、正規表現の
検索では、単語がリージョンの外にあるにも関わらず、単語を発見してしまうの
である。

二番目のバグの場合、リージョン内にはバッファの最後の空白文字だけしかなかっ
た。Emacs は @samp{Search failed} と言う。これは何故か？ まず最初の 
@code{while} ループでは真偽テストは真になるので、検索が実行される。しか
し、バッファの最後には単語は一つもないので、検索は失敗するというわけである。

どちらの現象も、検索がリージョンを越えて実行される所に問題があった。

解決法は、検索をリージョンに制限することである---これはかなり単純な動作
に思えるが、実際に考えてみると、思った程簡単にはいかないことが分る。

今まで見てきたように、@code{re-search-forward} 関数は最初の引数を検索
パターンとする。しかし、この最初の必須の引数の他に、三つの省略可能な引
き数を取ることが出来る。省略可能である二番目の引数は検索の限界である。
オプションである三番目の引数は、もし @code{t} なら検索に失敗した場合に
エラーを出さずに @code{nil} を返す。オプションである四番目の引数には繰
り返しの回数を指定する。(Emacs では、関数定義の説明文字列を見るには 
@kbd{C-h f} に続けて関数名をタイプして @kbd{RET} キーを押せばよい。)

@code{count-words-region} の定義内では、変数 @code{end} にリージョンの
最後の値がこの関数の引数として渡され保持される。そこで、正規表現の検索の 
引数として、この @code{end} の値を与えてみよう。

@example
(re-search-forward "¥¥w+¥¥W*" end)
@end example

しかし、もし @code{count-words-region} の値にこの変更だけしか加えずに、
新しいバージョンの関数を、空白だけの場所でテストすると、@samp{Search
failed} というメッセージが返される。

これはどうしてかというと、リージョン内には単語を構成する文字が無いために、
検索をそこに制限すると、検索が失敗してしまうためである。そのためにエラー
メッセージが返される。しかし、この場合にエラーメッセージは受け取りたくな
い。期待されるのは "The region does NOT have any words." というメッセー
ジである。

この問題を回避するには @code{re-search-forward} に三番目の引数として 
@code{t} を与えれば良い。すると関数はエラーメッセージの代わりに 
@code{nil} を返す。

しかし、この変更を加えてからもう一度テストしてみると、
``Counting words in region ... '' というメッセージが表示された後いくら待っ 
ても何も表示されない。結局 @kbd{C-g} (@code{keyboard-quit}) とタイプする
までずっとこのメッセージを見続けることになる。

どうしてこうなるかだが、検索はリージョンに制限されているのでさっきと同じ
ように失敗する。これはリージョンには単語を構成する文字が含まれないのだか
ら期待通りである。結果として @code{re-search-forward} 式は @code{nil} を
返す。そして他のことは何もしない。特に、ポイントを動したりもしない。これ
は検索に成功した場合の副作用だからだ。@code{re-search-forward} が 
@code{nil} を返した後、@code{while} ループの次のＳ式が評価される。これは 
カウンタを一つ増やす。そして、次のループに移る。@code{re-search-forward} 
式でポイントが移動しないために、ポイントの値は @code{end} の値よりも小さ
いままであり、真偽テストは真になる。そしてループが繰り返される。これがずっ
と続く @dots{}

検索が失敗した場合は @code{while} ループの真偽テストが偽を返すようにする
ために、またもや @code{count-words-region} の定義に変更を加える必要があ
る。即ち、カウンタを一つ増やす前に行う真偽テストでは二つの条件が満たされ
なければならないのだ。一つはポイントがリージョン内にあること、もう一つは
検索によって単語が見つかることである。

最初の条件も二番目の条件も同時に真にならなければいけないので、次のように
リージョンテストを行うＳ式と検索を行うＳ式の二つのＳ式を @code{and} 関数
で連結して @code{while} ループの真偽テストに埋め込むことにしよう。

@example
(and (< (point) end) (re-search-forward "¥¥w+¥¥W*" end t))
@end example

@c colon in printed section title causes problem in Info cross reference
@c also trouble with an overfull hbox
@iftex
@noindent
(@code{and} 関数についての詳細は、@ref{forward-paragraph, ,
@code{forward-paragraph}：関数の金脈}, を参照。)
@end iftex
@ifinfo
@noindent
(@code{and} についての詳細は @ref{forward-paragraph}, を参照。)
@end ifinfo

@code{re-search-forward} 式は、もし検索が成功した場合は真を返し、副作用
としてポイントを移動する。結果として、単語が見つかった場合にはポイントは
リージョンを越えてしまうことがある。検索が失敗した場合やポイントがリージョ
ンの終わりに来てしまった場合は、真偽テストは偽を返し、@code{while} ルー
プが終了して、メッセージが表示される。

これらの最終的な変更を加えると、@code{count-words-region} は (少なくとも
私が見た範囲では！) バグ無しに動作するようになる。コードは次の通りである。 

@example
@group
;;; @r{最終バージョン:} @code{while}
(defun count-words-region (beginning end)  
  "Print number of words in the region."
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. 適切な状況の設定}
  (save-excursion
    (let ((count 0))
      (goto-char beginning)
@end group

@group
;;; @r{2. } while @r{loop を走らせる。}
      (while (and (< (point) end)
                  (re-search-forward "¥¥w+¥¥W*" end t))
        (setq count (1+ count)))
@end group

@group
;;; @r{3. ユーザにメッセージを送る}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end example

@node recursive-count-words, Counting Exercise, count-words-region, Counting Words
@comment  node-name,  next,  previous,  up
@section 再帰を使った単語数のカウント
@cindex Count words recursively
@cindex Recursively counting words 
@cindex Words, counted recursively

単語を数える関数は @code{while} ループではなく再帰を使っても書くことが出
来る。実際にどのようになるかを見てみよう。

まず、@code{count-words-region} 関数は三つの仕事をするということをはっき
り認識しておこう。初めに、カウントを行う際の適当な条件を整え、次にリージョ
ン内の単語を数え、最後に単語の数を知らせるメッセージをユーザに対し表示す
るというわけである。

これらの仕事を全て一つの再帰関数でやらせようとすると、全ての再帰呼び出し
でメッセージを受け取ってしまうことになる。例えばリージョンに13の単語があっ
た場合、13個のメッセージが並んでしまうのだ。これでは困る。そこで、これら
の仕事を二つの関数に分けてやらせることにする。一つを再帰関数にして、それ
をもう一方で呼び出すのである。片方は条件を整え、メッセージを表示するもの
であり、もう片方は、単語を数えるものである。

まずはメッセージを表示する方の関数から始めよう。今回も関数の名前は 
@code{count-words-region} を使うことにする。

こちらはユーザが呼び出す方の関数であり、インタラクティブなものになる。実
の所、これはこの関数の前回のバージョンにそっくりである。ただし、リージョ
ン内の単語を数えるために、途中で @code{recursive-count-words} を呼び出し
ている所だけが違う。

前回の関数を参考にすれば、簡単にこの関数のテンプレートを作ることが出来る。

@example
@group
;; @r{再帰バージョン; 正規表現検索を利用}
(defun count-words-region (beginning end)  
  "@var{説明文字列}@dots{}"
  (@var{インタラクティブ式}@dots{})
@end group
@group

;;; @r{1. 適切な状況の設定}
  (@var{状況説明のメーセージ})
  (@var{初期設定のための関数}@dots{}
@end group
@group

;;; @r{2. 単語数のカウント}
    @var{再帰呼び出し}
@end group
@group

;;; @r{3. ユーザにメッセージを送る。}
    @var{単語数を伝えるメッセージ}))
@end group
@end example

この定義は非常に素直に書かれているが、再帰呼び出しで返されたカウントを単
語の数を表示するメッセージに渡す所が、幾分ややこしいかもしれない。これは、 
ちょっと考えれば、@code{let} 関数を使えばよいと気付く。つまり、
@code{let} 式の変数リストの変数に、再帰関数から返されたリージョン内の単
語数をバインドすればよいのである。その後、@code{cond} 式を利用してその値
をユーザに表示する。

@code{let} 式の中での変数のバインドというと、何か関数の二義的な仕事に思
われることも多い。しかし、今の場合には、関数の主な仕事だと思われる単語を
数えるということが、@code{let} 式の中で行われることになる。

@need 1250
@code{let} を使うと、関数定義は次のようになる。

@example
@group
(defun count-words-region (beginning end)  
  "Print number of words in the region."
  (interactive "r")
@end group

@group
;;; @r{1. 適切な状況の設定}
  (message "Counting words in region ... ")
  (save-excursion
    (goto-char beginning)
@end group

@group
;;; @r{2. 単語数のカウント}
    (let ((count (recursive-count-words end)))    
@end group

@group
;;; @r{3. ユーザに対しメッセージを送る}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end example

次に、再帰関数の方に移ろう。

再帰関数は少なくとも三つの部分を持たねばならない。`do-again-test'、
`next-step-expression'、そして、再帰呼び出しである。

do-again-test は関数が自分自身をもう一度呼ぶかどうかを決定するものである。
ここではリージョン内の単語を数え、その中の単語の分だけ前に移動するのであ
るから、do-again-test ではポイントがまだリージョンの内部にあるかどうかを
チェックすれば良い。つまり、ポイントの値を調べて、それがリージョンの終わ
りの値よりも小さいか大きいかを比べるわけである。ポイントの値を調べるには 
@code{point} 関数を使えばよい。リージョンの終わりの値は、勿論、この再帰
関数の引数として渡す必要がある。

更に do-again-test では検索で単語が見つかったかどうかもテストしなければ
ならない。無かった場合は再帰呼び出しをすべきではない。

next-step-expression は再帰関数が自分自身の呼び出しを止めるべき時に止め
るように値を変化させるものである。より正確に言うと、next-step-expression 
は適切な時に do-again-test が再帰呼び出しを繰り返すのを止めるように、値
を変化させていく。今の場合なら、next-step-expression はポイントを単語ご
とに移動させていくＳ式になる。

再帰関数の三つ目の部分は、再帰呼び出しである。

また、どこかにこの関数の実際の「仕事」をする部分、つまり単語数を数える部
分を書く必要がある。これが一番重要な部分だ！

@need 1250
が、ともかく、再帰関数のアウトラインは出来た。

@example
@group
(defun recursive-count-words (region-end)
  "@var{説明文字列}@dots{}"
   @var{do-again-test}
   @var{next-step-expression}
   @var{再帰呼び出し})
@end group
@end example

このスロットを埋めていけばよい。まずは、一番単純な場合から始めよう。もし
ポイントがリージョンの終わりもしくはそれ以降の位置にあった場合は、リージョ
ン内には単語はない。従って、関数は0を返すべきである。同様に検索が失敗
した場合も単語はないので、0を返すべきである。

一方、もしポイントがリージョンの中にあって検索が成功した場合には、関数は
自分自身を再度呼び出すべきである。

というわけで、do-again-test は次のようになる。

@example
@group
(and (< (point) region-end)
     (re-search-forward "¥¥w+¥¥W*" region-end t))
@end group
@end example

検索をするＳ式も do-again-test の一部であることに注意しよう。この関数は
検索が成功すれば @code{t} を返し、失敗すれば @code{nil} を返す。
(@ref{Whitespace Bug, , @code{count-words-region} の空白文字に関するバグ}, 
を見れば、@code{re-search-forward} がどのように動作するかが分る。)

do-again-test は @code{if} 式の真偽テストである。明らかに、もし真偽テス
トが真だった場合には、@code{if} 式はこの関数を再度呼び出さなければならない。
が、もし偽だった場合には、else-part によって零が返されるべきである。何故
なら、単語が見つからなかったということは、ポイントがリージョンの外だった
り検索に失敗したということだからだ。

しかし、再帰呼び出しについて考える前に、next-step-expression について考
える必要があるのだった。これは今の場合何か？ 興味深いことに、これは 
do-again-test の検索部分なのである。

do-again-test で @code{t} や @code{nil} を返すことに加えて、
@code{re-search-forward} は検索成功時には副作用としてポイントを前方に移
動する。これこそが、ポイントがリージョン内を移動しきった場合に、再帰関数
が自分自身を呼び出すのを止めるようにポイントの値を変化させていく動作なの
である。というわけで、@code{re-search-forward} 式が next-step-expression 
になっているのである。

従って @code{recursive-count-words} のアウトラインは次のようになる。

@example
@group
(if @var{do-again-test 兼 next-step-expression}
    ;; @r{then}
    @var{再帰呼び出しをしてカウントを返す}
  ;; @r{else}
  @var{ゼロを返す})
@end group
@end example

これにカウントを数えさせるような機構を組み込むには、どうしたらよいだろう
か。next-step-expression では一単語ごとに前方に進み、従って再帰呼び出し
は一つ単語を進むごとに行われるわけだから、カウントの仕組は 
@code{recursive-count-words} が呼ばれるごとに数を一つ増やすようなもので
なければならない。

幾つかの場合を考えてみよう。

@itemize @bullet
@item
リージョン内に二つの単語があった場合、この関数は、最初の単語を数える時に
返した値にリージョンの残りの単語数、今の場合なら1、を足した数に1を加えた
値を返さなければならない。

@item
リージョン内に一つだけ単語があった場合、この関数は、最初の単語を数える時
に返した値にリージョンの残りの単語数、今の場合なら0、を足した数に1を加え
た値を返さなければならない。

@item
リージョン内に一つも単語がなければ、この関数は0を返すべきである。
@end itemize

以上のことから、@code{if} 式の else-part では、単語が一つもなかった場合
のために0を返せばよいことが分る。これは、@code{if} 式の then-part では残
りの単語の合計の値に1加えた値を返すべきだということを意味する。

実際のＳ式は次のようになる。ここで、@code{1+} は引数に1加える関数である。

@example
(1+ (recursive-count-words region-end))
@end example

以上から @code{recursive-count-words} 関数全体は次のようになる。

@example
@group
(defun recursive-count-words (region-end)
  "@var{説明文字列}@dots{}"

;;; @r{1. do-again-test}
  (if (and (< (point) region-end)          
           (re-search-forward "¥¥w+¥¥W*" region-end t))
@end group

@group
;;; @r{2. then-part: 再帰呼び出し}
      (1+ (recursive-count-words region-end))  

;;; @r{3. else-part}
    0))             
@end group
@end example

@need 1250
実際にどのような動作をするかを見てみよう。

もし、リージョンに単語が一つもなければ、@code{if} 式の else-part が評価
され、結果としてこの関数は0を返す。

もし、リージョンに単語が一つあれば、ポイントの値は @code{region-end} の
値よりも小さく、検索は成功する。この場合、@code{if} 式の真偽テストは真を
返し、then-part が評価され、カウント式が評価される。この式が返す値が関数
全体の返す値になるのだが、これは、再帰呼び出しで返された値に1加えた値で
ある。

ところで、この時同時に next-step-expression によってポイントがリージョン
内の最初の単語 (といっても今はこの一個だけだが) を越えて移動する。つまり、
@code{(recursive-count-words region-end)} が二回目に評価された時には、ポ
イントの位置はリージョンの終わり以降の位置にあることになる。従って、今度
は @code{recursive-count-words} は0を返す。これにさっきの1が加えられ、結
果として元の @code{recursive-count-words} は0足す1、つまり、1を返すこと
になる。これは正しい数である。

ここまでくれば後はもうお分りだと思うが、リージョンの中に単語が二つある場
合には、最初に呼び出された @code{recursive-count-words} は次に残りの単語
を含むリージョンで呼び出された @code{recursive-count-words} の値に1加え
た値、つまり、1 + 1 = 2 という値を返す。これも正しい数である。

同様にして、もしリージョンの中に単語が三つある場合も、最初に呼び出された 
@code{recursive-count-words} は残りのリージョンで呼び出された 
@code{recursive-count-words} の値に1加えた値を返す。このような感じで、単
語が沢山ある場合も正しい数を返してくれる。

@need 1250
説明文字列も完全につけると、二つの関数は次のようになる。

@need 1250
@noindent
再帰関数:

@findex recursive-count-words
@example
@group
(defun recursive-count-words (region-end)
  "Number of words between point and REGION-END."
@end group

@group
;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "¥¥w+¥¥W*" region-end t))
@end group

@group
;;; @r{2. then-part: 再帰呼び出し}
      (1+ (recursive-count-words region-end)) 

;;; @r{3. else-part}
    0))             
@end group
@end example

@noindent
外側の関数 (wrapper):

@example
@group
;;; @r{再帰バージョン}
(defun count-words-region (beginning end) 
  "Print number of words in the region.
@end group

@group
Words are defined as at least one word-constituent
character followed by at least one character that is
not a word-constituent.  The buffer's syntax table
determines which characters these are."
@end group
@group
  (interactive "r")
  (message "Counting words in region ... ")
  (save-excursion
    (goto-char beginning)
    (let ((count (recursive-count-words end)))
@end group
@group
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
@end group
@group
            ((= 1 count)
             (message "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end example

@node Counting Exercise,  , recursive-count-words, Counting Words
@section 練習問題：句読点のカウント

@code{while} ループを使って、リージョン内の句読点---終止符、カンマ、セ
ミコロン、コロン、感嘆符、疑問符---の数を数える関数を書きなさい。同じ関
数を再帰関数を使って書きなさい。

@node Words in a defun, Readying a Graph, Counting Words, Top
@chapter @code{defun} 内の単語のカウント
@cindex Counting words in a @code{defun}
@cindex Word counting in a @code{defun}

次の計画の目標は、関数定義の中の単語の数を数えることである。当たり前のこ
とだが、これは @code{count-words-region} の使い方をちょっと工夫すれば出
来てしまう。@ref{Counting Words, , カウント：繰り返しと正規表現}, を参照
のこと。例えば、ある一つの定義の中の単語数を数えたければ、@kbd{C-M-h}
(@code{mark-defun}) コマンドを使って定義部分をマークしてから 
@code{count-words-region} を呼び出せばよい。

しかしながら、ここではもっと大きなことをやってみたいと思う。Emacs のソー
スの中の全ての定義の中の単語とシンボルの数を数えて、そこにどれだけの関数
があり、各々がどのくらいの長さかをグラフにして出力するとか、40個から49個
までの単語とシンボルを関数がどれだけあるか、50個から59個までではどうか、
といったことを調べるのである。私はしばしば典型的な関数というのがどのくら
いの長さかを知りたくなる。これは、そういったことを教えてくれるものである。

@menu
* Divide and Conquer::          遠大な計画は分割しよう
* Words and Symbols::           何を数えればよいか？
* Syntax::                      単語やシンボルは何から構成されているか
* count-words-in-defun::        @code{count-words} とほぼ同じ
* Several defuns::              一つのファイルにある複数の defun を数える
* Find a File::                 ファイルを見つける
* lengths-list-file::           沢山の定義の長さのリスト
* Several files::               異なるファイルの中の定義を数える
* Several files recursively::   異なるファイルの定義を再帰を使って数える
* Prepare the data::            データをグラフに表示するための準備
@end menu

@node Divide and Conquer, Words and Symbols, Words in a defun, Words in a defun
@ifinfo
@heading 分割による困難の克服
@end ifinfo

はっきり言って、このヒストグラムを書く計画は人をひるませる類のものである。
しかし、これをいくつもの細かいステップに分けて、各々を一つずつ見ていくこ
とにすれば、それほど恐れるほどのものではない。そこで、どんなステップに分
けるべきかを書いてみることにする。

@itemize @bullet
@item
まず最初に、一つの定義の中に単語がどれだけあるかを数える関数を書く。ここ
では、単語と同じくシンボルをどう扱うかが問題になる。

@item
二番目に各々の関数の中の単語数をリストにする関数を書く。この関数では 
@code{count-words-in-defun} を使うことが出来る。

@item
三番目に、各ファイルの中の各関数の中の単語数をリストにする関数を書く。こ
れをやろうとすると、必然的に、自動的に様々なファイルを見つけてそれらに移
り、それに含まれる関数定義の中の単語数を数えるということをしなければなら
なくなる。

@item
四番目に、三番目のステップで作成した数のリストをグラフとして出力するのに
適した形に変換する関数を書く。

@item
五番目に結果をグラフとして表示する関数を書く。
@end itemize

これはかなりの大計画である。しかし、各々のステップをゆっくりと進んでいけ
ば、それ程困難なものではない。

@node Words and Symbols, Syntax, Divide and Conquer, Words in a defun
@section 何を数えればよいか？
@cindex Words and symbols in defun

関数定義の中の単語数を数えるにはどうしたらよいか、を最初に考え始めた時に、 
まず疑問に思うこと (あるいは、考えるべきこと) は、我々は何を数えればよい
かということである。Lisp の関数定義に関して単語のことを話す場合、実際に
は大抵シンボルのことを言っている。例えば、次の @code{multiply-by-seven} 
関数は、@code{defun}、@code{multiply-by-seven}、@code{number}、@code{*}、
そして@code{7}という5個のシンボルを含んでいる。これに加えて説明文字列の
中に @samp{Multiply}、@samp{NUMBER}、@samp{by}、そして @samp{seven} とい
う単語が含まれている。@samp{number} は繰り返して使われているので、関数定
義の中には合計10個の単語とシンボルが含まれていることになる。

@example
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end example

@noindent
ところが、もし @code{multiply-by-seven} の定義を @kbd{C-M-h}
(@code{mark-defun}) でマークして、そこで @code{count-words-region} を呼
び出してみると、10個ではなく11個の単語があるという答えが帰ってくる。何かが
おかしい！

実は、問題は二重になっている。@code{count-words-region} は @samp{*} を単
語とは数えないが、逆に、一つのシンボル @code{multiply-by-seven} を三つの
単語だと数えてしまうのである。これはハイフンが一つの単語内でのつながりを
示すものとしてではなく、単語間の間の空白と同じように扱われるためのである。
従って、@samp{multiply-by-seven} は @samp{multiply by seven} と書かれて
いるように扱われることになる。このような混乱の原因は、
@code{count-words-region} の定義内で一つの単語ずつ移動する際に使っている
正規表現にある。標準的な @code{count-words-region} のバージョンで使われ
ている正規表現は

@example
"¥¥w+¥¥W*"
@end example

@noindent
である。この正規表現は一つ以上単語構成文字が続いた後に0個以上の非単語構
成文字が続くというパターンである。「単語構成文字」によって何が意味される
かという問題は、構文 (syntax) の問題になる。これには一つのセクションを割
当てて論じる価値がある。

@node Syntax, count-words-in-defun, Words and Symbols, Words in a defun
@section 単語やシンボルは何から構成されているか
@cindex Syntax categories and tables

Emacs では、各々の文字はある@dfn{構文カテゴリ} (@dfn{syntax categories}) 
に属するものとして扱われる。例えば正規表現 @samp{¥¥w+} は一つ以上の「単
語構成文字」(@emph{word constituent}) が続くパターンを表している。単語構
成文字というのは、ある一つの構文カテゴリーの要素のことである。他の構文カ
テゴリーの要素は、例えば終止符やカンマ等の句読点文字のクラス、スペースや
タブ等の空白文字のクラスを含んでいる。(より詳しいことについては 
@ref{Syntax, Syntax, The Syntax Table, emacs, The GNU Emacs Manual}, 及
び @ref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp
Reference Manual},を参照のこと。)

構文テーブルとはどの文字がどのカテゴリーに属するかを定めるものである。普
通、ハイフンは「単語構成文字」には分類されない。そうではなく「シンボルの
名前ではあるが、単語ではないものの一部をなす文字のクラス」に分類される。
これは @code{count-words-region} 関数がハイフンを単語間の空白文字と同じ
扱いをすることを意味する。これが @code{count-words-region} が 
@samp{multiply-by-seven} を三つの単語だと数える理由である。

Emacs に @code{multiply-by-seven} を一つの単語だと数えさせるには二つの方
法がある。一つは構文テーブルを書き換える方法、もう一つは正規表現を書き直
す方法である。

Emacs が各々のモードに対して持つ構文テーブルを書き換えることで、ハイフン
を単語構成文字だと再定義することが出来る。この動作は我々の目的に殆ど合う
のだが、ハイフンだけが単語の中には現れずシンボルの中には出てくる文字とい
うわけではない。似たような文字は他にもある。

代わりに、@code{count-words} の定義中の正規表現の方を書き直してシンボル
を含むようにすることも出来る。こちらの方法の方がより簡明である。ただし、
実際にやることは少々トリッキーだ。

最初の部分は十分に単純である。パターンとしては「少なくとも一つ以上続く、
単語ないしはシンボルの構成要素」にマッチするもの、つまり、

@example
¥¥(¥¥w¥¥|¥¥s_¥¥)+
@end example

@noindent
になる。@samp{¥¥(} は @samp{¥¥w} と @samp{¥¥s_} のいずれかを表わす正規表
現のグループの開始を示す部分である。対象となる二つの部分は @samp{¥¥|} で
区切られている。@samp{¥¥w} は任意の単語構成文字にマッチし、@samp{¥¥s_} 
はシンボル名の一部になり得るが、単語構成文字ではないような任意の文字にマッ
チする。後に続く @samp{+} は、このグループに属する文字、即ち単語かシンボ
ルの構成文字が少くとも一回はマッチしなければならないことを意味する。

しかしながら、正規表現の二番目の部分はもっと難しい。欲しいものは、一番目
の正規表現に続けて「単語の一部にもシンボルの一部にもならない文字が一つ以
上続いてもかまわない」ことを表わす表現である。まず思い浮んだのは次のよう
なものである。

@example
¥¥(¥¥W¥¥|¥¥S_¥¥)*"
@end example

@noindent
上の大文字の @samp{W} と @samp{S} は各々単語、あるいはシンボルの構成文字
では@emph{ない}ような文字にマッチする。しかし、この表現では、単語構成文
字ではないか、もしくはシンボル構成文字ではない文字に一致してしまう。これ
ではどんな文字にもマッチしてしまう。

次に私は、テストしているリージョン内の全ての単語やシンボルの後には空白文
字 (スペース、タブ、もしくは改行) があることに気がついた。そこで、単語か
シンボルの構成文字が一つ以上続くというパターンの後に、一つ以上の空白文字
が続くというパターンを置いてみた。しかし、これも失敗した。通常は単語やシ
ンボルは空白で終わるのだが、実際のコードでは、シンボルの後に括弧が来たり、
単語の後に句読点が来たりすることだってある。というわけで、結局、単語かシ
ンボルの構成文字の後に0個以上の空白文字以外の文字が続き、その後に0個以上
の空白文字が来る、というパターンにすることにした。

次がその正規表現である。

@example
"¥¥(¥¥w¥¥|¥¥s_¥¥)+[^ ¥t¥n]*[ ¥t¥n]*"
@end example

@node count-words-in-defun, Several defuns, Syntax, Words in a defun
@section 関数 @code{count-words-in-defun}
@cindex Counting words in a @code{defun}

以前見たように、@code{count-words-region} 関数を書く方法は幾つかあった。
が、今回 @code{count-words-in-defun} を書く際には、この内の一つの方法だ
けを採用することにする。

方法としては @code{while} ループを使う方法が理解しやすいだろうから、こち
らを採用することにする。@code{count-words-in-defun} は、より複雑なプログ
ラムの一部になるので、インタラクティブである必要も、メッセージを出す必要
もなく、ただカウントを返しさえすればよい。これらのことを考慮すると、定義
は少し単純になる。

一方、@code{count-words-in-defun} は関数定義を含むバッファの中で使われる。
従って、現在ポイントが関数定義内にあるか判定し、もしそうであればその定義
内の単語を数えるというふうにするのが合理的であろう。こうすると、ちょっと
コードが複雑にはなるが、関数に引数を与える手間は省ける。

@need 1250
以上のことを考慮すると、テンプレートは次のようになる。

@example
@group
(defun count-words-in-defun ()
  "@var{説明文字列}@dots{}"
  (@var{初期設定}@dots{}
     (@var{while ループ}@dots{})
   @var{カウントを返す})
@end group
@end example

@noindent
いつも通り、やるべきことはこの中の空きスロットを埋めていくことである。

まずは初期設定から。

この関数は、関数定義が含まれるバッファの中で呼び出されることを想定されて
いる。現在のポイントは関数定義の中にあるか、外にあるかどちらかである。
@code{count-words-in-defun} が動作してくれるためには、ポイントが関数定義
の先頭に移動し、カウンタがゼロから始まり、ポイントが関数定義の最後に来た
らループが終了するようになっていてくれなければならない。

@code{beginning-of-defun} 関数は後方に向かって行頭の @samp{(} などの開き
括弧を検索し、そこにポイントを移動するか、検索の限界まで移動する。実際に
は、@code{beginning-of-defun} はポイントを現在ポイントが含まれている関数
定義もしくはポイント以前のポイントに最も近い関数定義の開始位置、あるいは
バッファの先頭まで移動することになる。従って、@code{beginning-of-defun} 
を使うことで望みの位置までポイントを移動することが出来る。

@code{while} ループでは、数えた単語やシンボルの数を保持しておくカウンタ
が必要である。@code{let} 式によって、この目的のための変数を作り、その値
をゼロに初期化することが出来る。

@code{end-of-defun} 関数は @code{beginning-of-defun} と同じような働きを
するのだが、ポイントを関数定義の終了位置に移動する点だけが異なっている。
@code{end-of-defun} は関数定義の終了位置を決定するＳ式の一部として使う
ことが出来る。

ということで、@code{count-words-in-defun} の初期設定部分はあっさり書けて
しまう。まずは、関数定義の最初にポイントを移動し、次にカウンタのための局
所変数を用意し、最後に @code{while} ループが止まるべき所で止まれるように
関数定義の終了位置を記録しておくのである。

@need 1250
コードは次の通りである。

@example
@group
(beginning-of-defun)
(let ((count 0)
      (end (save-excursion (end-of-defun) (point))))
@end group
@end example

@noindent
このコードは単純である。ちょっとややこしいのは @code{end} に関するところ
だろう。これには、関数定義の終了位置がバインドされる。その際、
@code{save-excursion} 式の中で一時的に @code{end-of-defun} で関数定義の
終了位置に移動した後にポイントの位置を返すという方法を用いている。

さて、@code{count-words-in-defun} の初期設定に続く二番目の部分は 
@code{while} ループである。

このループでは、ポイントを単語やシンボルごとに移動するＳ式、及びジャンプ
の回数を数えるＳ式が必要である。また、@code{while} ループの真偽テストで
は、ポイントがまだジャンプすべきなら真を返し、定義の終了位置まで到達した
なら偽を返すようなものであるべきである。目的のための正規表現は既に再定義
してしまっているので、(@ref{Syntax, , 単語やシンボルは何から構成されてい
るか}, 参照) ループは簡単に書ける。

@example
@group
(while (and (< (point) end)
            (re-search-forward 
             "¥¥(¥¥w¥¥|¥¥s_¥¥)+[^ ¥t¥n]*[ ¥t¥n]*" end t)
  (setq count (1+ count)))
@end group
@end example

関数定義の三番目の部分は単語やシンボルの数を返す部分である。この部分は 
@code{let} 式の本体部分の最後の部分だが、極めて単純に局所変数 
@code{count} を書いておくだけでよい。これを評価すると数が返るわけである。

以上をまとめると、@code{count-words-in-defun} は次のようになる。

@findex count-words-in-defun
@example
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group
@group
    (while
        (and (< (point) end)
             (re-search-forward 
              "¥¥(¥¥w¥¥|¥¥s_¥¥)+[^ ¥t¥n]*[ ¥t¥n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end example

これをテストするにはどうしたらよいだろうか。この関数はインタラクティブで
はないが、ちょっとＳ式をかぶせることで簡単にインタラクティブにすることが
出来る。これには @code{count-words-region} の再帰関数版とほぼ同じコード
が使える。

@example
@group
;;; @r{インタラクティブバージョン}
(defun count-words-defun ()     
  "Number of words and symbols in a function definition."
  (interactive)
  (message
   "Counting words and symbols in function definition ... ")
@end group
@group
  (let ((count (count-words-in-defun)))
    (cond
     ((zerop count)
      (message
       "The definition does NOT have any words or symbols."))
@end group
@group
     ((= 1 count)
      (message
       "The definition has 1 word or symbol."))
     (t
      (message
       "The definition has %d words or symbols." count)))))
@end group
@end example

@noindent
便宜上 @kbd{C-c =} というキーバインディングをもう一度使うことにしよう。

@example
(global-set-key "¥C-c=" 'count-words-defun)
@end example

以上で、@code{count-words-defun} をテストするための準備が整った。まずは、
@code{count-words-in-defun} 及び @code{count-words-defun} を両方ともインス
トールして、キーバインディングの設定もしてしまおう。そして、カーソルを次
の定義の中に移動して実験してみる。
@ifinfo
(訳註：原文とは異なり、インデントはしていない。@code{(defun} が行頭から
始まっていないと @code{beginning-of-defun} 等がうまく働かないからである。)
@end ifinfo

@format
@group
@t{(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
     @result{} The definition has 10 words or symbols.}
@end group
@end format

@noindent
成功だ！ この定義の中には確かに10個の単語とシンボルがある。

次の問題は、一つのファイルの中の幾つかの定義にある単語とシンボルの数を
数えることである。

@node Several defuns, Find a File, count-words-in-defun, Words in a defun
@section 一つのファイルにある複数の defun を数える

@file{simple.el} のようなファイルの中には80以上の関数定義が含まれていた
りする。我々の最終的な目標は沢山のファイルについての統計を取ることである
が、その最初のステップとして、まずは一つのファイルについての統計を取るこ
とを目標にしよう。

情報は数の列の形で与えられ、各々の数は関数定義の長さになる。これらの数は
リストの中に保持しておくことが出来る。

一つのファイルについての情報は最終的には多くのファイルについての情報の形
に統合されることになる。従って、ここで作成する一つのファイル内の関数定義
の長さを数える関数は単に「長さ」のリストを返すだけでよく、特にメッセージ
とかを表示する必要はない。

単語を数えるコマンドには、単語ごとにポイントを前方に進めるＳ式とジャンプ
の回数を数えるＳ式が含まれていた。定義の長さを測る関数も、同じように設計
することが出来る。この場合は定義ごとにポイントを進めるＳ式と長さのリスト
を作成するようなＳ式が含まれることになる。

問題をこのように言い替えてしまえば、関数定義を書くのは簡単なことである。
明らかに、カウントはファイルの先頭から始めなければならない。従って、最初
のコマンドは @code{(goto-char (point-min))} である。次に @code{while} ルー
プに入る。ここでは、ループの真偽テストは次の関数定義を探す正規表現に取れ
る---検索が成功している間はポイントを進め、本体を評価するわけである。本
体内には長さのリストを作成するＳ式が必要である。これには @code{cons} と
いうリストを構成するコマンドが使える。やるべきことの殆どは、以上で終わっ
ている。

部分的にコードを書くと次のようになる。

@example
@group
(goto-char (point-min))
(while (re-search-forward "^(defun" nil t)
  (setq lengths-list
        (cons (count-words-in-defun) lengths-list)))
@end group
@end example

この他にやることは、関数定義を含むファイルを見つけることである。

今までの例では、この Info file を使うか、@file{*scratch*} バッファなどの
他のバッファに一旦戻って、また帰ってくるということしかしていなかった。

ファイルを見つける (find) ことは、この文書では初めて出てくるプロセスであ
る。

@node Find a File, lengths-list-file, Several defuns, Words in a defun
@comment  node-name,  next,  previous,  up
@section ファイルを見つける
@cindex Find a File

まずは、@code{find-file} のソースを見てみよう。(関数のソースは 
@code{find-tag} を使うと見つけることが出来る。)

@example
@group
(defun find-file (filename)
  "Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists."
  (interactive "FFind file: ")
  (switch-to-buffer (find-file-noselect filename)))
@end group
@end example

定義には、簡潔な説明文字列が付いており、インタラクティブ式では対話的に用
いた時のプロンプトが指定されている。で、定義の本体を見ると、
@code{find-file-noselect} 及び @code{switch-to-buffer} という二つの関
数が使われている。

@kbd{C-h f} (@code{describe-function} コマンド) で表示される説明によると、
@code{find-file-noselect} は指定されたファイルをバッファに読み込み、その
バッファを返す。しかしながらバッファは選択されない、つまり Emacs は注意
をそのバッファには向けない。(あるいは @code{find-file-noselect} を名前の
ついたバッファに対し使った場合は、あなたの注意も引かない。) この仕事は 
@code{switch-to-buffer} がやってくれる。この関数は、Emacs が注目するバッ
ファを指定するものである。更にこの関数は、ウィンドウに表示されているバッ
ファを新しいバッファに切り替える。バッファの切り替えについては、また別の
場所で議論することにしよう。(@ref{Switching Buffers, , バッファ間の移動}, 
参照。)

今やろうとしているヒストグラム計画では、定義の長さを調べる際にいちいち一
つ一つのファイルをスクリーンに表示する必要はない。というわけで
@code{switch-to-buffer} ではなく @code{set-buffer} を使うことにしよう。
これも Emacs が注目するバッファを切り替えるのだが、スクリーンに表示する
バッファはそのままである。従って、我々の目的のためには @code{find-file} 
は使えず、そのためのコードを書くことになる。

といっても、やることは簡単だ。単に @code{find-file-noselect} と 
@code{set-buffer} を使えばよいのである。

@node lengths-list-file, Several files, Find a File, Words in a defun
@section @code{lengths-list-file} についての詳細

@code{lengths-list-file} 関数の核心部分は、defun から defun へ移動してい
く関数を含む @code{while} ループと、各々の defun の中に含まれる単語やシ
ンボルの数を数える関数である。そしてその周辺に、例えば、ファイルを見つけ
たり、ポイントが必ずファイルの先頭部分からスタートするようにしたりする、
といった他の様々な仕事をする関数が来る。結局、定義は次のようになる。

@example
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group
@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)   
      (goto-char (point-min))
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end example

@noindent
この関数は一つの引数を取る。これは作業対象となるファイルの名前である。
説明文字列は四行あるが、インタラクティブ宣言はされていない。本体の一行目
では、使った人が計算機が壊れたのではないかと心配しないように、最初に何を
やっているかを表示するようにしている。

次の行で @code{save-excursion} が使われているので、Emacs は仕事が終わっ
た後、ちゃんと元のバッファに注意を戻してくれる。こうすると、この関数を他
の関数の中に埋め込んでいる場合などにも、ポイントを元の位置に戻してくれる
ので便利である。

@code{let} 式の変数リストの所で、Emacs はファイルを見つけて局所変数 
@code{buffer} をそのファイルを中身とするバッファにバインドする。同時に 
Emacs は @code{lengths-list} を局所変数として生成する。

次に Emacs は注意をそのバッファに向ける。

次の行では Emacs はバッファを書き込み不可にしている。理論上は、この行は
不要である。関数定義内の単語やシンボルの数を数える関数の中で、バッファを
書き換えたりするようなものはないし、たとえそのバッファが変更されたとして
も保存されたりはしない。こういう警戒をするのは、これらの関数が Emacs の
ソース上で作業するために、万が一にでもファイルを修正してしまったりすると
非常に不都合であるという理由のためである。言うまでもないが、私自身は実験
が失敗して私の Emacs のソースファイルが修正されるなんていう事態に会わな
い限り、この行が必要だと思うことはないだろう。

次に、バッファがナローイングされている場合には、それを広げるということを
やっている。これは普通は必要ない---Emacs はそのファイルに対応するバッファ
が無い場合は新規にバッファを開くからだ。しかし、既にある場合には Emacs 
はそのバッファを返す。この場合、もしそのバッファがナローイングされていた
なら、それを解除する必要がある。真にユーザーフレンドリーな関数にしたい場
合には、ナローイングやポイントの位置なんかを保存しておくべきだろうが、こ
こでは何もしないことにする。

@code{(goto-char (point-min))} 式でポイントをバッファの先頭に移動する。

そして @code{while} ループが来る。ここで、この関数の仕事が実行されること
になる。このループでは、Emacs は各々の定義の長さを調べ、その長さのリスト
を作っていく。

あるバッファでの作業が終わると Emacs はそのバッファを kill する。これは、
Emacs 内部でのスペースの節約のためである。私が使っている Emacs 19 のバー
ジョンには300以上ものソースファイルが含まれており、これらに 
@code{lengths-list-file} が適用される。もし Emacs がこれら全てを読み込ん
で一つも kill しなかったら、私の計算機は仮想記憶を使い切ってしまうだろう。

終りまで来ると、@code{let} 式の中の最後のＳ式である @code{lengths-list} 
という変数が評価される。この値が関数全体の値となる。

この関数をいつも通りインストールして試してみることが出来る。インストール
が終わったら、カーソルを次のＳ式の直後に持っていってから @kbd{C-x C-e}
(@code{eval-last-sexp}) とタイプして、評価してみよう。

@example
(lengths-list-file "../lisp/debug.el")
@end example

@c (lengths-list-file "/usr/local/emacs/lisp/debug.el")

@noindent
(多分、ファイルのパス名を変更する必要があるだろう。上に挙げたものは、こ
の Info ファイルのあるディレクトリと Emacs のソースがあるディレクトリが
@code{/usr/local/emacs/info} と @code{/usr/local/emacs/lisp} の
ように隣同士にある場合だけである。変更する場合は、このＳ式を一旦
@file{*scratch*} バッファにコピーしてから、それを修正して評価する。)

@need 1500
私が使っているバージョンの Emacs では、@file{debug.el} に対する長さのリ
ストを生成するのに7秒かかり、結果は次のようになった。

@example
(75 41 80 62 20 45 44 68 45 12 34 235)
@end example

ファイルの中の最後の定義の長さは、リストの最初に現れることに注意しよう。

@node Several files, Several files recursively, lengths-list-file, Words in a defun
@section 異なるファイルの中の定義を数える

前節では、各ファイルの中に含まれる各関数の長さのリストを返すような関数を
作成したのだった。今度は、ファイルのリストが与えられた時に、それらのファ
イルの中の関数の長さのマスターリストを返すような関数を定義してみたい。

リストの中の各ファイルに対する作業は繰り返しの動作なので、@code{while} 
ループや再帰を使って行うことが出来る。

@code{while} ループを使った方法はルーティーンワークである。関数に渡す引
き数はファイルのリストになる。以前見たように
(@ref{Loop Example, , ループの例}, 参照)、
このリストが要素を含んでいる時のみループの本体を実行し、要素が無くなった
ら抜けるようにすることが出来るのであった。これがうまく動作するためには、
本体部分で、本体が一回評価されるごとにこのリストを短くしていき、結果とし
て最後にはリストが空になるように、Ｓ式を書いておく必要がある。このために
は、本体が評価されるごとに、リストにそのリストの @sc{cdr} の値をセットす
るという技法を用いるのが普通である。

テンプレートは次のようになる。

@example
@group
(while @var{リストが空かどうかのテスト}
  @var{本体}@dots{}
  @var{リストを自分自身の cdr にセット})
@end group
@end example

さて、@code{while} ループは常に (真偽テストの結果として) @code{nil} を返
し、本体内のＳ式の値を返したりすることはないのだった。(従って、ループの
本体のＳ式は副作用として評価される。)  しかしながら、長さのリストをセッ
トするＳ式は本体の一部である---にもかかわらず、その関数全体の値として返
して欲しいのもこの値である。そこで、@code{while} ループを @code{let} 式
で包んで、@code{let} 式の最後の要素が長さのリストの値を含むようにする。
(@ref{Incrementing Example, , 増加するカウンタを使ったループの例}, を参
照。)

@findex lengths-list-many-files
@need 1250
以上のことを考えれば、目的の関数が殆ど書けてしまう。

@example
@group
;;; @r{@code{while} ループ を使う。}
(defun lengths-list-many-files (list-of-files) 
  "Return list of lengths of defuns in LIST-OF-FILES."
@end group
@group
  (let (lengths-list)

;;; @r{真偽テスト}
    (while list-of-files        
      (setq lengths-list
            (append
             lengths-list

;;; @r{長さのリストの生成}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
@end group

@group
;;; @r{ファイルのリストを短くする。}
      (setq list-of-files (cdr list-of-files))) 

;;; @r{リストの長さの最終的な値を返す。}
    lengths-list))              
@end group
@end example

@code{expand-file-name} は組み込み関数であり、ファイル名を絶対パスも含
めた省略無しの形に戻すものである。従って、例えば

@example
debug.el
@end example

@noindent
は

@example
/usr/local/emacs/lisp/debug.el
@end example

@noindent
と展開される。

その他の、上の関数内に出てくる新しい要素は @code{append} だけである。こ
れには一つのセクションを割当てた方が良いだろう。

@menu
* append::                      あるリストを別のリストに追加する
@end menu

@node append,  , Several files, Several files
@subsection 関数 @code{append}

@code{append} 関数は、あるリストを、もう一つのリストに追加するものである。
例えば、


@example
(append '(1 2 3 4) '(5 6 7 8))
@end example

@noindent
の結果は次のようになる。

@example
(1 2 3 4 5 6 7 8)
@end example

@noindent
@code{lengths-list-file} によって作成された二つの長さのリストを一つにま
とめる際は、このような形になって欲しいのだった。@code{cons} を使った場合
と比較してみよう。

@example
(cons '(1 2 3 4) '(5 6 7 8))
@end example

@noindent
こっちだと、@code{cons} の最初の引数が出来たリストの最初の要素になって
しまう。

@example
((1 2 3 4) 5 6 7 8)
@end example

@node Several files recursively, Prepare the data, Several files, Words in a defun
@section 異なるファイルの定義を再帰を使って数える

@code{while} ループではなく再帰を使っても各々のファイルのリストに対して
作業することが出来る。再帰を使った @code{lengths-list-many-files} は短く
て単純な形をしている。

再帰関数は、普通は `do-again-test'、`next-step-expression'、そして再帰呼
び出しの部分からなっている。`do-again-test' では、この関数が自分自身をも
う一度呼び出すかどうかを決定する。今の場合は @code{list-of-files} がまだ
残りの要素を持っているかどうかを調べることになる。`next-step-expression' 
では、@code{list-of-files} をそれ自身の @sc{cdr} で置き換える。結果とし
て最後にはリストは空になる。実際の完全なコードは、この説明よりも短い！
@findex recursive-lengths-list-many-files

@example
@group
(defun recursive-lengths-list-many-files (list-of-files) 
  "Return list of lengths of each defun in LIST-OF-FILES."
  (if list-of-files                     ; @r{do-again-test}
      (append
       (lengths-list-file
        (expand-file-name (car list-of-files)))
       (recursive-lengths-list-many-files
        (cdr list-of-files)))))
@end group
@end example

@noindent
一言で言うと、この関数は @code{list-of-files} の最初のファイルについての
長さのリストを、@code{list-of-files} の残りを引数に自分自身を呼び出した
結果に追加している。

実際に、各ファイルに対して @code{lengths-list-file} を走らせながら 
@code{recursive-lengths-list-many-files} をテストしてみるには、次のよう
にする。

まず、まだやっていなければ @code{recursive-lengths-list-many-files} と 
@code{lengths-list-files} をインストールし (訳註：
@code{count-words-in-defun} もインストールする必要がある)、その後、次に
挙げるＳ式を評価する。ただし、ファイルのパス名は変更する必要があるかもし
れない。以下の式では、Info ファイルと Emacs のソースファイルが通常の位置
に置いてある場合に有効である。これを変更したい場合は、これらの
式を @file{*scratch*} バッファにコピーして、それらを編集した後、評価すれ
ばよい。

結果は @samp{@result{}} の後に示されている。(これらの結果は Emacs
version 18.57 についてのものである。他のバージョンの Emacs については、
また別の結果が出ることだろう。)

@example
@group
(lengths-list-file 
 "../lisp/macros.el")
     @result{} (176 154 86)
@end group

@group
(lengths-list-file
 "../lisp/mailalias.el")
     @result{} (116 122 265)
@end group

@group
(lengths-list-file
 "../lisp/makesum.el")
     @result{} (85 179)
@end group

@group
(recursive-lengths-list-many-files
 '("../lisp/macros.el"
   "../lisp/mailalias.el"
   "../lisp/makesum.el"))
       @result{} (176 154 86 116 122 265 85 179)
@end group
@end example

このように @code{recursive-lengths-list-many-files} は期待した結果を返し
てくれるはずだ。

次のステップは、結果をグラフに表示するためのデータのリストを準備すること
である。

@node Prepare the data,  , Several files recursively, Words in a defun
@section データをグラフに表示するための準備

@code{recursive-lengths-list-many-files} 関数は、数のリストを返す。各々
の数は関数定義の長さの記録である。我々がこれからやらねばならないのは、こ
のデータをグラフの表示に適した形の数値のデータに変換することである。新し
く出来るリストからは、10より少ない単語やシンボルしか含まない関数定義がど
れだけあるかとか、10から19や、20から29までではどうか等ということが分るよ
うになる。

手短に言うと、@code{recursive-lengths-list-many-files} 関数が生成したリ
ストを見ていって、各々の範囲に入る関数がどれだけあるかを数えて、それらの
数のリストを作ろうというのである。

これまでの経験から、長さのリストを `@sc{cdr}' しつつ各々の値を見ていき、
それがどの範囲に入るのかを調べてその範囲についてのカウンタを増やす関数を
書くことは、特に難しくはないものと察しがつくだろう。

しかしながら、実際に関数を書き下す前に、長さのリストをまずソートして、少
ない方から大きい方に並べることによって得られるメリットについて考えるべき
である。まず、ソートすることで、各々の範囲に属する関数の数を数えるのが楽
になる。これは隣同士の数は同じ範囲に属するか隣同士の範囲に属するかどちら
かになるからである。また、リストをソートしてしまえば最大の数と最小の数を
簡単に見つけることが出来る。またそこから、後で必要となる最大と最小の差も
決定出来ることになる。

@menu
* Sorting::                     リストをソートする
* Files List::                  ファイルのリストを作る
@end menu

@node Sorting, Files List, Prepare the data, Prepare the data
@subsection リストのソート
@findex sort

Emacs は  @code{sort} と呼ばれるリストをソートするための関数を持っている。
@code{sort} 関数は二つの引数を持つ。ソートされるべきリストと、二つの要
素の大小を比較する際の述語 (predicate) である。

以前説明したように (@ref{Wrong Type of Argument, , 関数に間違ったタイプ
の引数を与えると}, 参照)、述語とは、ある性質が真か偽かを判断する関数のこ
とである。@code{sort} 関数は、リストの要素を述語が使用する性質に従って並
べ換える。これは、数値以外のリストも、数値以外の基準で---例えばアルファ
ベットの順番で--- @code{sort} を利用して並べ換えることが出来ることを示し
ている。

@need 1250
数値で比較する際には @code{<} 関数が使われる。例えば、

@example
(sort '(4 8 21 17 33 7 21 7) '<)
@end example

@noindent
の結果は次のようになる。

@example
(4 7 7 8 17 21 21 33)
@end example

@noindent
(この例では、引数が @code{sort} に渡される際に評価されないように、どち
らのシンボルにも引用符が付いていることに注意しよう。)

@code{recursive-lengths-list-many-files} 関数によって返されたリストをソー
トするのは簡単である。

@example
@group
(sort
 (recursive-lengths-list-many-files
  '("../lisp/macros.el"
    "../lisp/mailalias.el"
    "../lisp/makesum.el"))
 '<)
@end group
@end example

@noindent
とするだけだ。結果は次のようになる。

@example
(85 86 116 122 154 176 179 265)
@end example

@noindent
(この例では @code{sort} の最初の引数には引用符がついていない。これは、
@code{sort} に渡される前にこのＳ式を評価して、リストを生成する必要がある
からである。)

@node Files List,  , Sorting, Prepare the data
@subsection ファイルのリストの作成

@code{recursive-lengths-list-many-files} 関数は引数としてファイルのリ
ストを必要とする。これまで実験した例では、これらのリストは手で作っていた。
しかし、Emacs Lisp のソースディレクトリは大変大きいので、これらを一々手
で書いているわけにはいかない。そこで、代わりに @code{directory-files} 関数
を作って、このようなリストを作成する必要がある。
@findex directory-files

@code{directory-files} 関数は、三つの引数を取る。最初の引数はディレクト
リの名前であり、文字列である。二番目の引数が non-@code{nil} なら、この関
数はファイルの絶対パス名を返す。三番目の引数には @code{nil} か正規表現を
指定する。正規表現を指定した場合、それにマッチするパス名を持つものだけが
返されることになる。

(訳註：Version 19 からは引数の数は四つになった。四番目の引数が 
non-@code{nil} なら結果は sort されない。)

@need 1250
従って、例えば私のシステムで

@example
@group
(length
 (directory-files "../lisp" t "¥¥.el$"))
@end group
@end example

@noindent
とやると、私の version 19.25 の Lisp のソースディレクトリには307の 
@samp{.el} ファイルがあることが分る。
@code{recursive-lengths-list-many-files} が返すリストをソートするための
Ｓ式は次のようになる。

@example
@group
(sort
 (recursive-lengths-list-many-files
  (directory-files "../lisp" t "¥¥.el$"))
 '<)
@end group
@end example

@ignore

(defun test ()
  "Test how long it takes to find lengths of all elisp defuns."
  (insert "¥n" (current-time-string) "¥n")
  (sit-for 0)
  (sort 
   (recursive-lengths-list-many-files
    '("../lisp/macros.el"
      "../lisp/mailalias.el"
      "../lisp/makesum.el"))
   '<)
  (insert (format "%s" (current-time-string))))

@end ignore

我々の取り敢えずの目標は、10未満の単語やシンボルしか含まない関数定義の数
はどれだけか、10以上、20未満ではどうか、20以上、30未満ではどうか、といっ
たことを調べることである。ソートされた数のリストを使うと、これは簡単であ
る。まずは、10未満の要素がどれだけあるかを数え、ついで、その次の要素から 
20 未満の要素がどれだけか数え、また次の数から 30未満の要素がどれだけか数
える、というふうに続けていく。10、20、30、40等の数は、その範囲の数の最大
よりも大きい数になる。これらの数からなるリストは、@code{top-of-ranges} 
リストと呼べばよいだろう。

しようと思えば、このようなリストを自動的に生成することも可能である。が、
今回は手で書いた方が早いだろう。次のような感じである。

@vindex top-of-ranges

@example
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
 "List specifying ranges for `defuns-per-range'.")
@end group
@end example

範囲を変更するには、このリストを編集すればよい。

次に、この各々の範囲に属する定義の数のリストを作る関数を書く必要がある。
明らかに、この関数は引数として @code{sorted-lengths} と 
@code{top-of-ranges} リストを取ることになる。

@code{defuns-per-range} 関数は、二つの作業を何回も繰り返すことになる。一
つは現在の top-of-range の値によって特定される範囲の定義の数を数えること、
もう一つはその範囲の数を数え終わったら次に大きな @code{top-of-ranges} の
値に移ることである。これらの動作は繰り返しなので、@code{while} ループを
使うことが出来る。片方のループで現在の top-of-range の値で決まる範囲の定
義の数をカウントし、もう片方のループでは順に top-of-range の値を選択して
いく。

各々の範囲について、@code{sorted-lengths} リストの中の幾つかのエントリ
がカウントされる。従って、@code{sorted-lengths} リストについてのループは 
@code{top-of-ranges} リストのループの中に置かれることになる。大きなギヤの
なかの小さなギヤみたいな感じだ。

内部のループでは、該当する範囲の定義の数がカウントされる。これは、今まで
に何回も見たような単純なループである。
(@ref{Incrementing Loop, , 増加するカウンタを使ったループ}, を参照。) ルー
プの真偽テストは @code{sorted-lengths} リストの中の数が現在の 
top-of-range の値よりも小さいかどうかを見ることになる。もしそうなら、カ
ウンタを一つ増やして、次の @code{sorted-lengths} のエントリに移動する。

@need 1250
結局、内部のループは次のようになる。

@example
@group
(while @var{長さの要素が top-of-range より小さい}
  (setq number-within-range (1+ number-within-range))     
  (setq sorted-lengths (cdr sorted-lengths)))
@end group
@end example

外部のループは @code{top-of-ranges} リストの最小値から始まって、順に大き
な値に移っていくことになる。そのためには、次のようにすればよい。

@example
@group
(while top-of-ranges
  @var{ループの本体}@dots{}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end example

これらを合わせると、二つのループは次のようになる。

@example
@group
(while top-of-ranges

  ;; @r{現在の範囲にある要素の数のカウント}
  (while @var{長さの要素が top-of-range より小さい}
    (setq number-within-range (1+ number-within-range))     
    (setq sorted-lengths (cdr sorted-lengths)))

  ;; @r{次の範囲に移動}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end example

更に、一回の外部ループごとに、Emacs にその範囲に属する定義の数を記録させ
る必要がある。(リストの中の @code{number-within-range} の値である。この
目的には、@code{cons} が使える。(@ref{cons, , @code{cons}}, を参照。)

@code{cons} 関数はほぼうまく動作するのだが、一つ難点がある。出来るリスト
では最初に大きい方の範囲に入る定義の数がきて、最後に小さい方の範囲の数が
きてしまうのだ。これは、@code{cons} が新しい要素をリストの先頭に加えてい
くことと、上の二つのループは小さい方から大きい方へ長さのリストを作成して
いくために、@code{defuns-per-range-list} が最大の数で終わることからの当
然の帰結である。しかし、グラフを表示する際には小さい値の方を先に表示した
い。この問題を解決するには、@code{defuns-per-range-list} の順序を逆にし
てしまえばよい。これは、@code{nreverse} というリストの順序を逆にする関数
を使うとあっさり解決する。
@findex nreverse

例えば、

@example
(nreverse '(1 2 3 4))
@end example

@noindent
とすると、

@example
(4 3 2 1)
@end example

@noindent
が返る。

注意して欲しいのは、@code{nreverse} は「破壊的」であるということである。
これは、作用させたリストを変更してしまうことを意味している。(訳註：これ
は逆の順のリストに設定されるということではなくて、文字通り破壊されてしま
うということである。) 今の場合、元の @code{defuns-per-range-list} は必要
ないので、これが破壊されても何の問題もない。(一方、@code{reverse} 関数は
元のリストを逆に並べ換えた新しいリストを返す。この場合は元のリストは変化
しない。)
@findex reverse

@need 1250
以上を全て組み合わせると、@code{defuns-per-range} は次のようになる。

@example
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{外部のループ}
    (while top-of-ranges
@end group

@group
      ;; @r{内部のループ}
      (while (and 
              ;; @r{数値引数として数が必要}
              (car sorted-lengths) 
              (< (car sorted-lengths) top-of-range))
@end group

@group
        ;; @r{現在の範囲に入る関数の数を数える}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))

      ;; @r{内部のループは抜けるが、外部のループには入ったまま}
@end group

@group
      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{カウンタを 0 にリセット}
@end group

@group
      ;; @r{次の範囲に移動}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{次の範囲のトップを特定}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{外部のループを抜けて最も大きいの範囲に属する関数定義の数}
    ;; @r{を数える}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))
@end group

@group
    ;; @r{昇順で並ぶ関数定義の長さのリストを返す。}
    (nreverse defuns-per-range-list)))
@end group
@end example

@noindent
この関数は次のちょっとした点を除いては、非常に単純である。内部のループの真
偽テストは、

@example
@group
(and (car sorted-lengths) 
     (< (car sorted-lengths) top-of-range))
@end group
@end example

@noindent
であって、

@example
(< (car sorted-lengths) top-of-range)
@end example

ではない。このテストの目的は @code{sorted-lengths} リストの最初の要素が
その時点での top-of-range の値よりも小さいかどうかを決定することである。

後に挙げた単純な方のテストでも @code{sorted-lengths} リストが @code{nil} 
になるまではうまく動作する。しかし、@code{nil} になると、@code{(car
sorted-lengths)} 式は @code{nil} を返す。@code{<} 関数は数値と 
@code{nil}、即ち空リストとを比較できないため、Emacs はここでエラーを出し、
関数はそこで実行を止めてしまう。

@code{sorted-lengths} リストはカウンタがリストの最後まで辿りつけば常に 
@code{nil} になる。従って、この @code{defuns-per-range} 関数の真偽テスト
の単純なバージョンの方は常に失敗することになる。

  この問題は、@code{(car sorted-lengths)} 式と @code{and} 式を組み合わせ
ることで解決することが出来る。@code{(car sorted-lengths)} 式はリストが最
低一つでも要素を持てば、non-@code{nil} を返す。そしてリストが空になった
時だけ @code{nil} を返す。@code{and} 式は最初に @code{(car
sorted-lengths)} 式を評価し、もしそれが @code{nil} なら @code{<} 式を評
価する前に偽を返す。しかし、もし @code{(car sorted-lengths)} 式が 
non-@code{nil} な値を返せば、@code{<} 式も評価し、その値を @code{and} 式
全体の値を返す。

@c colon in printed section title causes problem in Info cross reference
こうしてエラーが回避出来ることになる。
@iftex
@code{and} についての詳細は、@ref{forward-paragraph, ,
@code{forward-paragraph}：関数の金脈}, を参照のこと。
@end iftex
@ifinfo
@code{and} についての詳細は、@ref{forward-paragraph}, を参照のこと。
@end ifinfo

次に @code{defuns-per-range} についての簡単なテストを載せておく。最初に 
(短縮した) リストを @code{top-of-ranges} にバインドするＳ式を評価し、次
に @code{sorted-lengths} リストをバインドするＳ式を評価し、最後に 
@code{defuns-per-range} 関数を評価してみよう。

@example
@group
;; @r{(後で使うものよりかは短いリスト)}
(setq top-of-ranges        
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)
@end group
@end example

@noindent
次のようなリストが返されるはずである。

@example
(2 2 2 0 0 1 0 2 0 0 4)
@end example

@noindent
実際、@code{sorted-lengths} リストには、110未満の二つの要素が二つ、110か
ら119までの要素も二つ、120から129までも二つ、といった感じになっている。
また、200以上の値の要素は四つある。

@c The next step is to turn this numbers' list into a graph.

@node Readying a Graph, Emacs Initialization, Words in a defun, Top
@chapter グラフを描く準備
@cindex Readying a graph
@cindex Graph prototype
@cindex Prototype graph
@cindex Body of graph

我々の目標は、Emacs のソースの中の様々な長さの関数定義の数をグラフにして
表示することであった。

実際には、グラフを生成するには @code{gnuplot} のようなプログラムを使って
いることだと思う。(@code{gnuplot} は GNU Emacs と相性がよい。)しかしなが
ら、今回は一からプログラムを書いていくことにする。そしてその過程で、今ま
で学んできた事柄を再度確認しつつ、新しいことも学んでいくことにしよう。

この章では、まずグラフを表示する単純な関数を書いてみる。最初の定義は
@dfn{雛型} (@dfn{prototype}) であり、グラフを作成するという未知の領域を
偵察するために取り敢えず書いてみるといった類のものである。我々はドラゴン
を発見するかもしれないし、あるいはそれが単なる神話であることが分るかもし
れない。ともかく地理感覚が掴めてしまえば、自信もつくし、関数を拡張して軸
に自動的にラベルをつけることも出来るようになるだろう。

@menu
* Columns of a graph::          縦のグラフはどうやって表示すればよいか
* graph-body-print::            グラフ本体の表示
* recursive-graph-body-print::  グラフ本体の表示を再帰的に行う
* Printed Axes::                軸の表示
* Line Graph Exercise::         棒グラフについての練習問題
@end menu

@node Columns of a graph, graph-body-print, Readying a Graph, Readying a Graph
@ifinfo
@heading 棒グラフの表示
@end ifinfo

Emacs はどんな種類のターミナルでも動作するよう柔軟に設計されている。その
中にはキャラクターだけしか表示出来ないターミナルも含まれているので、グラ
フは「タイプライタ」の文字から出来ている必要がある。取り敢えずはアスタリ
スクを使うのがよいだろう。後から関数を拡張して、この文字をユーザーが選択
出来るようにすることも可能だ。

この関数を、@code{graph-body-print} と呼ぶことにしよう。これは引数として 
@code{numbers-list} を取る。現段階ではグラフのラベルは出力せず、本体部分
だけを表示することにする。

@code{graph-body-print} 関数は、@code{numbers-list} の各々の値に対して、
アスタリスクを垂直に並べて表示する。それぞれの高さは、
@code{numbers-list} の各要素の値によって決まる。

アスタリスクを垂直に並べる動作は繰り返しである。従って、@code{while} ルー
プか再帰を使って書くことが出来る。

最初の困難は、如何にしてアスタリスクを縦に並べたものを表示するかである。
普通、Emacs 上でタイプすると、文字はスクリーン上に水平に、行ごとに表示さ
れていく。解決への道は二通りある。一つは自分で垂直に挿入するような関数を
書くこと、もう一つは元々 Emacs にそのような関数がないか探すことである。

Emacs に特定の機能を持ったものがないか探す場合には、@kbd{M-x apropos} コ
マンドを使うことが出来る。このコマンドは、@kbd{C-h a} (command-apropos) 
コマンドとほぼ同様なのだが、command-apropos の方はコマンドだけしか検索し
ない。@kbd{M-x apropos} の方は、インタラクティブでないものも含めて正規表
現にマッチするものは全てリストしてくれる。我々が探しているものは縦の文字
列 (column) を表示 (print) したり挿入 (insert) したりするコマンドである。
可能性としては、そのような関数は `print' とか `insert' とか `column' と
いった文字列を含んでいそうである。そこで、単純に @kbd{M-x apropos RET
print¥|insert¥|column RET} として、結果を見てみる。私のシステムでは、こ
のコマンドの実行には暫く時間がかかり、結局79個の関数及び変数のリストが表
示された。このリストを探してみると、我々の仕事に役立ちそうなのは、
@code{insert-rectangle} だけである。実際、これが我々の求めていた関数であ
る。説明を読んでみよう。

@smallexample
@group
insert-rectangle:
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE's first line is inserted at point,
its second line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
@end group
@end smallexample
@smallexample
@group
(日本語訳)
RECTANGLE のテキストを左上がポイントに来るような位置に挿入する。 
つまり RECTANGLE の最初の行がポイントの位置に挿入され、
二行目はポイントの真下の位置に挿入され、というふうになる。
RECTANGLE は文字列のリストでなければならない。
@end group
@end smallexample

簡単なテストを行って、これが本当に求めるものかを確かめてみよう。

以下が、@code{insert-rectangle} 式の直後にカーソルを持っていって、
@kbd{C-u C-x C-e} (@code{eval-last-sexp}) とタイプしてみた結果である。
この関数は、@samp{"first"}, @samp{"second"} そして @samp{third"} をポイ
ントの下に表示する。関数全体としては、@code{nil} が返る。

@example
@group
(insert-rectangle '("first" "second" "third"))first
                                              second
                                              thirdnil
@end group
@end example

@noindent
(訳註：広く配布されている Mule 2.3 (Emacs version 19.28) では、この関数
にバグがある。これは、@file{lisp/rect.el} の最後の方にある 
@code{move-to-column-strictly} の関数定義の中で、四行目の @code{clm} を 
@code{(progn (if force (indent-to column)) column)} で置換えることで修正
出来る。)

@noindent
勿論、我々は @code{insert-rectangle} 式そのものをグラフを描くバッファに
挿入したいのではない。そうではなく、我々のプログラムからこの関数を呼び出
したいのである。ただその際、ポイントがバッファの中で、ちゃんと 
@code{insert-rectangle} 関数で縦の文字列を挿入すべき位置にあるかどうかを
確かめなければならない。

もしこの文章を Info の中で読んでいるなら、まず @file{*scratch*} などの別
バッファに移り、ポイントをバッファのどこかに置きつつ typing @kbd{M-:}と
タイプしよう。(訳註：1998 年現在、日本でまだ使用が多いと思われる Emacs
19.28 ベースの Mule では @kbd{M-@key{ESC}} である。同様に多い Emacs
19.34 べースのものでは @kbd{M-:} で良い。@kbd{M-@key{ESC}} はプレフィク
スキーとして使われるようになった。) 続けてミニバッファで 
@code{insert-rectangle} 式をタイプしてやれば、このような動作が可能である
ことが分る。ここでは、Ｓ式を評価するのはミニバッファの中だったのだが、そ
の際のポイントの値としては、@file{*scratch*} バッファの中のポイントの値
が使われたのであった。(@kbd{M-:} は @code{eval-expression} のキーバイン
ディングである。)

実際にやってみると、ポイントが直前に入力した行の最後にある状態で終わるこ
と---つまり、この関数は副作用として、ポイントを移動することが分る。この
コマンドを続けて実行すると、次の挿入は前回の位置から下方及び右方向に移動
した所から行われる。これでは困る。棒グラフを作成するには、縦の列が隣同士
に並ばなければならない。

というわけで、棒グラフを挿入する @code{while} ループの各々のサイクルで、
ポイントの位置を適切な位置に再配置する必要があることが分った。また、その
位置は縦の列の一番上であって底ではない。更に、このグラフを表示する際に、
個々の縦の列の長さが全て揃うことはまずない。つまり、各々の縦棒のてっぺん
の高さは、前のものと異なるのが普通である。従って、単に前と同じ行にポイン
トを移動していくだけでは駄目である。そうではなくて@dots{}

我々はグラフをアスタリスクで表示しようとしていたのであった。アスタリスク
の数は @code{numbers-list} の現在の要素で指定される。このアスタリスクを
要素とするリストを、@code{insert-rectangle} を呼び出すたびに作成する必要
がある。もし、このリストが単に必要な数のアスタリスクだけからなっていたと
すると、ポイントの位置をグラフの基準線から正しい行数だけ上の位置におかな
ければならない。しかし、これは難しい。

その代わり、もし @code{insert-rectangle} に対して常に一定の長さのリスト
を渡すことが出来れば、ポイントも常に同じ行の一つ右の桁に移動すればよくな
る。しかし、この場合には @code{insert-rectangle} に渡されるリストのいく
つかの要素はアスタリスクではなく空白になる。例えば、もしグラフの最大の高
さが5であり、現在の高さが3であったとすると、@code{insert-rectangle} は、
次のような引数を必要とする。

@example
(" " " " "*" "*" "*")
@end example

この最後の方法は、縦の列の高さを決定出来さえすれば、それほど難しくはない。
縦の列の高さを特定するには二つの方法がある。一つは我々が綺麗に表示される
ような高さを勝手に指定してしまうというもの、もう一つは、数のリストを検索
して、最大のものをグラフの最大の高さとして使うというものである。後者の方
法が難しい場合は、前者を採用するのが楽である。が、Emacs には、初めから引
数の中で最大のものを決定する関数が組み込まれている。この関数を使おう。関
数の名前は @code{max} で、全ての引数の中で最大のものを返す。引数は数でな
ければならない。従って、例えば、

@example
(max  3 4 6 5 7 3)
@end example

@noindent
は7を返す。(これに対して @code{min} という関数は、引数の中で最小のもの
を返す。)
@findex max
@findex min

しかしながら、単に @code{numbers-list} の上で @code{max} を呼び出すこと
は出来ない。@code{max} は数のリストではなく、数を引数として要求するから
だ。従って、

@example
(max  '(3 4 6 5 7 3))
@end example

@noindent
とやると、次のようなエラーメッセージが返される。

@example
Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)
@end example

@findex apply
従って、リストの中身を引数として関数に渡すような関数が必要になる。
@code{apply} と呼ばれる関数がこの役目を果してくれる。この関数はその最初
の引数である関数に、残りの引数を適用 (apply) する。この時、最後の引数は
リストでなければならない。

@need 1250
例えば

@example
(apply 'max 3 4 7 3 '(4 8 5))
@end example

@noindent
は8を返す。

(ついでにいうと、私はこの関数をこの文書のようなものを使わずに見つけだす
方法を知らない。他の @code{search-forward} や @code{insert-rectangle} と
いった関数ならば、名前の一部分を推測して @code{apropos} を使えばよい。け
れども apply については、名前の元となるメタファ---最初の引数に残りを 
`apply' する---は明らかであるにしても、初心者が @code{apropos} や他の助
けを借りてこのような特定な単語に辿り着けるとは思わない。勿論、私が間違っ
ているのかもしれない。結局は、関数はそれを作った人によって名付けられるも
のなのである。)

@code{apply} の二番目以降の引数は省略可能である。従って、@code{apply} を
使って、関数にリストの要素を引数として渡して呼び出すことも出来る。例えば、
次は8を返す。

@example
(apply 'max '(4 8 5))
@end example

この最後の例が我々の目的にあっている。
@code{recursive-lengths-list-many-files} 関数は、数のリストを返すが、こ
れを @code{max} に適用することが出来るわけである。(@code{max} にソートさ
れたリストを渡すことも出来るが、この場合はソートされていてもされていなく
ても関係ない。)

というわけで、グラフの最大の高さを求める操作は次の通りである。

@example
(setq max-graph-height (apply 'max numbers-list))
@end example

では、グラフの縦の列を描くための文字列のリストをどうやって作ればよいかと
いう問題に戻ろう。この関数はグラフの最大の高さと個々の縦の列の中のアスタ
リスクの数から、@code{insert-rectangle} コマンドが挿入する文字列のリスト
を返す必要がある。

各々の縦の列は空白とアスタリスクからなる。高さとアスタリスクの数が分れば、
空白の数はその差として求められる。そして空白とアスタリスクの数が分れば、
二つの @code{while} ループを使ってリストを作ることが出来る。

@example
@group
;;; @r{最初のバージョン}
(defun column-of-graph (max-graph-height actual-height) 
  "Return list of strings that is one column of a graph."
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{アスタリスクを詰める}
    (while (> actual-height 0)                
      (setq insert-list (cons "*" insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{空白を詰める}
    (while (> number-of-top-blanks 0) 
      (setq insert-list (cons " " insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))
@end group

@group
    ;; @r{リスト全体を返す}
    insert-list))
@end group
@end example

この関数をインストールしてから次のＳ式を評価すると、求めるリストが得られ
るはずだ。

@example
(column-of-graph 5 3)
@end example

@noindent
を評価すると、

@example
(" " " " "*" "*" "*")
@end example

@noindent
が返されるというわけである。

前にも書いたが、@code{column-of-graph} には大きな欠陥がある。空白とグラ
フ本体の印のために用いられる記号はスペースとアスタリスクに「ハードコード」
されている。これは雛型としてはよい。が、あなたや他のユーザは他の記号を使
いたいと思うことも多いだろう。例えば、グラフ関数をテストしてみる際には、
@code{insert-rectangle} 関数が呼ばれた時にポイントの位置がきちんと移動さ
れているかどうかを見るために、スペースの代わりに終止符を使いたいと思うだ
ろう。また、アスタリスクの代わりに @samp{+} 等の記号を使ったりしたいと思
うこともあるに違いない。更に、グラフの桁数をディスプレイの一桁の幅よりも
広く取りたいと思うこともあるだろう。そういうわけでプログラムはもっと柔軟
であるべきである。そのための方法としては、スペースとアスタリスクを 
@code{graph-blank} と @code{graph-symbol} という二つの変数で置き換えて、
これらの変数を別に定義することが考えられる。

また、説明文字列も解りやすいとは言えない。以上のことを考慮すると、次のよ
うな関数に辿り着く。

@example
@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group
@end example

@noindent
(@code{defvar} の説明については、@ref{defvar, , @code{defvar} を用いた変数の初期化},を参照。)

@example
@group
;;; @r{二番目のバージョン}
(defun column-of-graph (max-graph-height actual-height) 
  "Return list of MAX-GRAPH-HEIGHT strings; 
ACTUAL-HEIGHT are graph-symbols.
@end group
@group
The graph-symbols are contiguous entries at the end 
of the list.
The list will be inserted as one column of a graph.  
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{@code{graph-symbols} を詰める}
    (while (> actual-height 0)                
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{@code{graph-blanks} を詰める}
    (while (> number-of-top-blanks 0) 
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{リスト全体を返す}
    insert-list))
@end group
@end example

もし望むなら、@code{column-of-graph} も書き換えて、オプションとして棒グラ
フだけでなく、線グラフも書けるようにも出来る。これはそんなに難しいことで
はない。線グラフをどう描くかだが、例えば棒グラフにおいて、一番上の点から
下は全て空白にしてしまえば、それはもう棒グラフとは呼べないだろう。線グラ
フのための縦の文字列を作るには、まずは値よりも一つだけ少ない数の空白のリ
ストを作り、ついで @code{cons} を用いてリストにグラフ記号を追加し、最後
に、上の余白部分の数の空白を付け足せばよい。

こういう関数を実際に書くのも簡単だが、今の所は必要ないので、書かないでお
くことにする。が、ともかく書くことは出来るし、またこの関数を一度書いてし
まえば、@code{column-of-graph} で使うことも出来る。ここで大切なことは、
他の部分の書き換えは殆どしなくても良いということである。即ち、拡張しよう
と思えば簡単に出来るわけだ。

さて、やっと、はじめて実際のグラフを書いてみる所まで来た。ここではグラフ
の本体だけを表示し、縦軸や横軸のラベルは表示しない。そこで、この関数を 
@code{graph-body-print} と呼ぶことにする。

@node graph-body-print, recursive-graph-body-print, Columns of a graph, Readying a Graph
@section 関数 @code{graph-body-print}
@findex graph-body-print

前節までの準備の後では、@code{graph-body-print} 関数はあっというまに出来
てしまう。この関数は、数値のリストから各々の縦の列の中のアスタリスクの数
を決定し、一桁おきにアスタリスクを用いたグラフを表示する。これは繰り返し
の動作なので、減少 @code{while} ループか、再帰を使って書くことが出来る。
このセクションでは、@code{while} ループを用いて定義を書いてみよう。

@code{column-of-graph} 関数は、引数としてグラフの高さを必要とする。この
値を定めたなら、局所変数として記録しておくべきである。

これらのことから、このバージョンにおいては次のような @code{while} ループ
のテンプレートが出来る。

@example
@group
(defun graph-body-print (numbers-list)
  "@var{説明文字列}@dots{}"
  (let ((height  @dots{}
         @dots{}))
@end group

@group
    (while numbers-list
      @var{縦の列を挿入し、ポイントを移動}
      (setq numbers-list (cdr numbers-list)))))
@end group
@end example

@noindent
この中の空きスロットを埋めていくことになる。

当然、グラフの高さの決定には @code{(apply 'max numbers-list)} 式を使うこ
とが出来る。

@code{while} ループは @code{numbers-list} の各要素に対して一回ずつ回る。
このリストは @code{(setq numbers-list (cdr numbers-list))} 式によって短
くなっていき、各時点でのリストの @sc{car} が @code{column-of-graph} に引
数として渡される。

この @code{while} ループの各サイクルで、@code{column-of-graph} によって
返されたリストが @code{insert-rectangle} 関数に渡される。
@code{insert-rectangle} 関数はポイントを挿入された矩形の右下のポイントに
移動するので、それを矩形が挿入される前の位置に戻してから、次の位置に水平
方向に移動してやる必要がある。そこで次の @code{insert-rectangle} が呼ば
れるわけである。

単独の空白とアスタリスクを使った場合などのように、もし挿入される棒グラフ
が一桁の幅ならば、移動のためのコマンドは単に @code{(forward-char 1)} と
なる。しかし、この幅はもっと大きくなるかもしれない。従って、
@code{(forward-char symbol-width)} と書く方が良い。@code{symbol-width} 
は @code{graph-blank} の長さであり、@code{(length graph-blank)} という式
で求めることが出来る。@code{symbol-width} という変数をグラフの幅にバイン
ドする一番良い位置は @code{let} 式の変数リストの中である。

@need 1250
以上のことを総合すると次のような関数定義になる。

@example
@group
(defun graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."

  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
@end group

@group
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{各桁ごとのグラフの描写}
      (sit-for 0)               
      (setq numbers-list (cdr numbers-list)))
@end group
@group
    ;; @r{X 軸のラベルのためにポイントを移動}
    (forward-line height)
    (insert "¥n")
))
@end group
@end example

@noindent
この関数では、ひとつ予期していなかったＳ式が出てくる。それは 
@code{while} ループの中の @w{@code{(sit-for 0)}} 式である。この式を使う
ことで、グラフを表示する過程を見るのが楽しくなる。この式は Emacs に 0 時
間待ってから画面を再描画させるものである。これを上の位置に置くと棒グラフ
が一つずつ描かれていくことになる。逆に置かなければ、関数が仕事を全て終了
するまでグラフは描かれない。

次のようにすれば、この @code{graph-body-print} を短いリストに対してテス
トしてみることが出来る。

@enumerate
@item
まず @code{graph-symbol}、@code{graph-blank}、@code{column-of-graph} そ
して @code{graph-body-print} をインストールする。

@item
次のＳ式をコピーする。

@example
(graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
@end example

@item
@file{*scratch*} バッファに移り、グラフを表示させたい位置にカーソルを置
く。

@item
@kbd{M-:} (@code{eval-expression}) とタイプする。(訳註：Emacs 19.28 ベー
スの Mule では、@kbd{M-@key{ESC}}.)

@item
@kbd{C-y} (@code{yank}) を使って @code{graph-body-print} 式をミニバッファ
に yank する。

@item
@kbd{RET} を押して、@code{graph-body-print} 式を評価する。
@end enumerate

Emacs は次のようなグラフを表示するはずである。

@example
@group
                    *    
                *   **   
                *  ****  
               *** ****  
              ********* *
             ************
            *************
@end group
@end example

@node recursive-graph-body-print, Printed Axes, graph-body-print, Readying a Graph
@section 関数 @code{recursive-graph-body-print}
@findex recursive-graph-body-print

@code{graph-body-print} 関数は、再帰を使って書くことも出来る。この場合は、
二つの部分に分けて書くことになる。外側の関数 (wrapper) で @code{let} 式を
使って、グラフの最大の高さのように一度だけ決めればよいような幾つかの変数
の値を設定し、内側の関数で、再帰呼び出しを使ってグラフを表示するわけであ
る。

@need 1250
外側の関数 (wrapper) は特に複雑ではない。

@example
@group
(defun recursive-graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."
  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
    (recursive-graph-body-print-internal
     numbers-list
     height
     symbol-width)))
@end group
@end example

再帰関数の方は、ちょっとばかり難しい。これは `do-again-test'、グラフ表示
コード、再帰呼び出し、そして `next-step-expression' の四つの部分からなる。
`do-again-test' は @code{number-list} にまだ要素が残っているかを判定する@ 
@code{if} 式である。もし残っていれば、一本の棒グラフを書いてからまた自
分自身を呼び出す。関数が自分自身をもう一度呼び出すかどうかは、結局は 
`next-step-expression' が返す値による。これは、短縮版の@ 
@code{number-list} に作用するような呼び出しを行う。

@example
@group
(defun recursive-graph-body-print-internal
  (numbers-list height symbol-width)
  "Print a bar graph.
Used within recursive-graph-body-print function."
@end group

@group
  (if numbers-list
      (progn
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
@end group
@group
        (goto-char from-position)
        (forward-char symbol-width)
        (sit-for 0)     ; @r{各桁ごとのグラフの描写}
        (recursive-graph-body-print-internal
         (cdr numbers-list) height symbol-width))))
@end group
@end example

@need 1250
これをインストールして実際にテストしてみることが出来る。次にサンプルを挙
げる。

@example
(recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end example

これを評価すると、次のようなグラフが描かれる。

@example
@group
                *        
               **   *    
              ****  *    
              **** ***   
            * *********  
            ************ 
            *************
@end group
@end example

@code{graph-body-print} も @code{recursive-graph-body-print} もグラフの
本体部分のみを描く関数である。

@node Printed Axes, Line Graph Exercise, recursive-graph-body-print, Readying a Graph
@section 軸を表示する

グラフには、それが何を表わすかを示すために軸を表示する必要がある。一度だ
けしかグラフを描かないのならば、Emacs の Picture mode を利用して手で軸を
描くのも結構である。しかし、この関数は何度も利用するかもしれない。

というわけで、基本的な @code{print-graph-body} 関数を拡張して、自動的に
横軸と縦軸のラベルを表示するようにしてみた。この関数には特に新しい事柄は
含まれていないので、これについての説明は次の所ですることにする。
@ref{Full Graph, , ラベルと軸が付いたグラフ}.

@node Line Graph Exercise,  , Printed Axes, Readying a Graph
@section 練習問題

上と同様なグラフを表示する関数で、横棒のグラフを描くバージョンを作りなさい。

@node Emacs Initialization, Debugging, Readying a Graph, Top
@chapter @file{.emacs} ファイル
@cindex @file{.emacs} file
@cindex Customizing your @file{.emacs} file
@cindex Initialization file

「Emacs を好きになるために Emacs を好きになる必要はない。」-- この、一見
パラドクスのように聞こえる格言こそが、GNU Emacs の秘密である。ただ箱を開
けて取り出したままの Emacs は一般的な道具でしかない。大抵の人は、それを
自分自身が使いやすいようにカスタマイズする。

GNU Emacs は多くの部分が Emacs Lisp で書かれている。これは、Emacs Lisp 
の式を書くことで、変更したり拡張したり出来るということを意味する。

@menu
* Default Configuration::       Emacs のデフォルトは合理的である
* Site-wide Init::              サイトごとの初期化ファイルもある
* edit-options::                そのセッションでの変数の設定
* Beginning a Init File::       @code{.emacs file} の書き方
* Text and Auto-fill::          自動的に行を折り返す
* Mail Aliases::                Email の短縮アドレス
* Indent Tabs Mode::            @TeX{} ではタブを使わないようにするには
* Keybindings::                 個人的なキーバインディングを設定するには
* Loading Files::               ファイルを自動的にロード(評価)する
* Autoload::                    Autoload: 関数をすぐ使える状態に
* Simple Extension::            関数を定義し、キーにバインドする
* Keymaps::                     キーバインディングについて更に詳しく
* X11 Colors::                  Version 19 の X 上でのカラー表示
* V19 Miscellaneous::           ミニバッファを自動的なリサイズ etc.
* Mode Line::                   モード行のカスタマイズ
@end menu

@node Default Configuration, Site-wide Init, Emacs Initialization, Emacs Initialization
@ifinfo
@heading Emacs のデフォルトの設定
@end ifinfo

Emacs のデフォルトの設定を素直にありがたく使う人達もいる。それでも Emacs 
は C のファイルを編集する際は C mode になるし、Fortran のファイルを編集
する際は Fortran mode になるし、特に設定されていないファイルについては 
Fundamental mode になる。誰が Emacs を使うか分らない状況では、これは合理
的な設定である。人々がどのファイルに対して何をしたいかを把握出来る人など
何処にもいないだろう。Fundamental mode は把握出来ないようなファイルに対
しての正しいデフォルトである。ちょうど C mode が C のコードを編集する際
の正しいデフォルトであるのと同じである。しかし、もし誰が Emacs を使おう
としているかが分る場合---例えば自分自身が使う場合---なら Emacs をカスタ
マイズするのが合理的である。

例えば私は、適当なモードが見つからないようなファイルに対しては 
Fundamental mode にしたいことは殆どない。そういう場合には Text mode を使
うことが多い。そこで Emacs をカスタマイズする。結果として、私にとって使
いやすいものになる。

Emacs をカスタマイズしたり拡張したりするには @file{‾/.emacs} ファイルを
書くことになる。これは個人用の初期化ファイルである。中身は Emacs Lisp で
書かれ、Emacs に何をするかを伝える。

この章では、簡単な @file{.emacs} の説明をする。より多くの情報については、
以下を参照して欲しい。@ref{Init File, , The Init File, emacs, The GNU
Emacs Manual}, @ref{Init File, , The Init File, elisp, The GNU Emacs
Lisp Reference Manual}.

@node Site-wide Init, edit-options, Default Configuration, Emacs Initialization
@section サイトごとの初期化ファイル

@cindex @file{default.el} init file
@cindex @file{site-init.el} init file
@cindex @file{site-load.el} init file

Emacs は個人的な初期化ファイルに加えて、サイト用の初期化ファイルが存在す
れば、それも自動的にロードする。これらは @file{.emacs} と同様な形式で書
かれるが、全員に対してロードされる。

このサイト用の初期化ファイルの中の @file{site-load.el} と 
@file{site-init.el} の二つは、Emacs が dump される際に、ロードされ、かつ
標準的なものとして `dump' される。(Dump することで、Emacs はより速くロー
ド出来る。しかしながら、一旦ファイルがロードされ dump されると、もう一度
自分でロードしたり再 dump したりしない限り、変更は Emacs に反映されない。
これについては @ref{Building Emacs, , Building Emacs, elisp, The GNU
Emacs Lisp Reference Manual}, 及び @file{INSTALL} ファイルを参照のこと。)

これら以外にも三つのサイト用の初期化ファイルがあり、それらは存在すれば
Emacs の起動時に自動的にロードされる。この三つのファイルというのは、
@file{.emacs} の@emph{前に}ロードされる @file{site-start.el}、及び  
@file{.emacs} の@emph{後に}ロードされる @file{default.el} と端末タイプファ
イルである。

@file{.emacs} での設定や定義は、@file{site-start.el} での設定や定義を上
書きする。そして、@file{default.el} や端末タイプファイルが更にその設定や
定義を上書きすることになる。(端末タイプファイルによる上書きを防ぐには、
@code{term-file-prefix} を @code{nil} にする。@ref{Simple Extension, , 
ちょっとした拡張}, を参照。)

配布の中に含まれる @file{INSTALL} ファイルには、@file{site-init.el} と 
@file{site-load.el} についての説明がある。

@file{loadup.el}、@file{startup.el}、そして @file{loaddefs.el} ファイル
がロードをコントロールしている。これらのファイルは Emacs の配布の中の 
@file{lisp} ディレクトリの中にあるので、読んでみると良い。

@file{loaddefs.el} ファイルには、何を個人的な @file{.emacs} ファイルの中
に書き、何をサイト用の初期化ファイルに書くべきなのかということについて多
くの有益な示唆が書かれている。

@node edit-options, Beginning a Init File, Site-wide Init, Emacs Initialization
@section あるセッションでの変数の設定
@findex edit-options
@findex list-options
@cindex Options, easily settable

私の使用している Emacs version 19.23 には、@code{edit-options} コマンド
を利用して設定出来る392のオプションがある。これらの「オプション」という
のは以前説明したように、@code{defvar} を使って定義された変数に過ぎない。

Emacs では、これらの変数が「容易に設定出来るように意図されたものか」とい
うことを、説明文字列の最初の一文字で判別している。つまり、もし最初の文字
が @samp{*} だったら、その変数はユーザが設定出来るオプションである。
(@ref{defvar, , @code{defvar} を用いた変数の初期化}, を参照。)

@code{edit-options} コマンドは Emacs Lisp のライブラリを書いた人々が簡単
に設定出来るようにするべきだと考えた Emacs の変数を全て列挙してくれる。
そして、変数を簡単に再設定出来るようなインターフェースを与えてくれる。

一方で、@code{edit-options} で設定されたオプションは現在の編集セッション
の間にしか効力を持たない。新しく設定した値は次のセッションには保存されな
い。Emacs は起動される度に新しくソースコードから @code{defvar} されたオ
リジナルの値を読み取るわけである。次のセッションでもその変数の設定を使い
たい場合には、@file{.emacs} 等の起動の度にロードされるファイルで 
@code{setq} 式を使って値を上書きする必要がある。

私にとっての @code{edit-options} コマンドの主な使い道というのは、自分の 
@file{.emacs} ファイルで設定したくなるような変数を示唆してもらうというも
のである。このコマンドが出すリストを見てみることを強く薦めておく。

@ref{Edit Options, , Editing Variable Values, emacs, The GNU
Emacs Manual}, を見れば、より詳しいことが書かれている。

@node Beginning a Init File, Text and Auto-fill, edit-options, Emacs Initialization
@section @file{.emacs} の書き方
@cindex @file{.emacs} file, beginning of

Emacs を起動すると、コマンドラインに @samp{-q} を指定して読み込まないよ
うにした場合を除き、@file{.emacs} ファイルがロードされる。
(@code{emacs -q} コマンドでは、素のままの Emacs が起動される。)

@file{.emacs} ファイルは Lisp 式を含んでいる。大抵は値を設定するだけだが、
時には関数定義が書かれていることもある。

初期化ファイルの簡単な説明については、次を参照。@ref{Init File, , The
Init File @file{‾/.emacs}, emacs, The GNU Emacs Manual}.

この章でも同じようなことを説明するのだが、その際、私が長く使ってきた私
自身の @file{.emacs} を素材にすることにする。

ファイルの最初の部分はコメントからなる。これは個人的なメモとして利用して
いる。勿論、今はその内容を把握しているが、最初はそうではなかった。

@example
@group
;;;; Bob's .emacs file
; Robert J. Chassell
; 26 September 1985 
@end group
@end example

@noindent
日付を見てみよう！ このファイルを使い初めたのは随分と昔だ。それ以来、
内容を追加してきたわけである。

@example
@group
; Each section in this file is introduced by a
; line beginning with four semicolons; and each
; entry is introduced by a line beginning with
; three semicolons.
@end group
@end example

@example
@group
(日本語訳)
; このファイルの各セクションは行頭がセミコロンであるような
; 行から始まる。また、各項目は行頭が三つのセミコロンである
; ような行から始まる。
@end group
@end example

@noindent
ここでは Emacs Lisp のコメントの通常の便宜上の慣習を説明している。セミ
コロンで始まる行は全てコメントである。二つ、三つ、ないしは四つのセミコロ
ンがセクションやサブセクションのために使われる。(コメントについての説明
は次を参照。@ref{Comments, ,, elisp, The GNU Emacs Lisp Reference
Manual}.)

@example
@group
;;;; The Help Key
; Control-h is the help key; 
; after typing control-h, type a letter to
; indicate the subject about which you want help.
; For an explanation of the help facility, 
; type control-h three times in a row.
@end group
@end example

@example
@group
(日本語訳)
;;;; ヘルプキーについて
; Control-h がヘルプキーである。
; control-h をタイプした後、見たいヘルプの内容を示す
; 文字をタイプする。ヘルプ自体の簡単な説明を見るには
; control-h を三回タイプすればよい。
@end group
@end example

@noindent
ここでは特に @kbd{C-h} を三回タイプすることでヘルプが表示されることを注
意しておく。(訳註：これは訳者の Mule-2.3 (Emacs version 19.28) では二回
押すだけで表示された。仕様が変わったのだと思う。) 

@example
@group
; To find out about any mode, type control-h m
; while in that mode.  For example, to find out
; about mail mode, enter mail mode and then type
; control-h m.
@end group
@end example

@example
@group
(日本語訳)
; あるモードがどんなものか知りたい場合は、そのモードで
; control-h m とタイプする。例えば、mail mode について
; 知りたい場合は mail mode に入ってから control-h m と
; タイプする。
@end group
@end example

@noindent
私はこれを「モードヘルプ (mode help)」と読んでいるのだが、大変便利である。
普通はこれを読むだけで必要なことが殆ど分ってしまう。

勿論、このようなコメントは @file{.emacs} ファイルに含める必要はない。私
がこれらを含めたのは、よくモードヘルプのことやコメントの書き方を忘れたた
めだ。で、これを見れば思い起こすことが出来たわけである。

@node Text and Auto-fill, Mail Aliases, Beginning a Init File, Emacs Initialization
@section Text モードと Auto Fill モード

さて、Text mode や Auto Fill mode をオンにする箇所まで来た。

@example
@group
;;; Text mode and Auto Fill mode
; The next two lines put Emacs into Text mode
; and Auto Fill mode, and are for writers who
; want to start writing prose rather than code.
@end group
@end example

@example
@group
(日本語訳)
;;; Text mode と Auto Fill mode
; 次の二つの行は、Emacs を Text mode や Auto Fill mode 
; にするためのものである。コードを書くよりは普通の文章
; を書くことが多い人向けの設定である。
 
(setq default-major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end group
@end example

これが、この @file{.emacs} の中で、どこかの忘れっぽい人間のための備忘録
以外のちゃんとした役目を果たす最初の部分である。

この括弧で挟まれた二行の内の最初の一行は、ファイルを読み込む際に、そのファ
イルに C mode のような特定のモードが設定されて@emph{いない}場合には Text 
mode に入るようにするものである。

@cindex Per-buffer, local variables list
@cindex Local variables list, per-buffer, 
@cindex Automatic mode selection
@cindex Mode selection, automatic 
Emacs は、ファイルを読む際にその拡張子を見る。(拡張子というのは @samp{.}
の後に続く部分である。もしファイルが @samp{.c} や @samp{.h} という拡張子
で終わっていれば、Emacs は C mode になる。また、Emacs はファイルの最初の
空行でない行も見る。例えば最初の行に @w{@samp{-*- C -*-}} と書かれていれ
ば、Emacs は C mode になる。Emacs は自動判別のための拡張子とモード指定の
リストを持っている。更に Emacs は、そのバッファの最後のページ付近に 
``local variable list'' があれば、それも見る。

@ifinfo
@ref{Choosing Modes, , How Major Modes are Chosen, emacs, The GNU Emacs
Manual}.

@ref{File Variables, , Local Variables in Files, emacs, The GNU
Emacs Manual}.
@end ifinfo
@iftex
これについては、@cite{The GNU Emacs Manual} の ``How Major Modes are
Chosen'' や ``Local Variables in Files'' 等のセクションを参照のこと。
@end iftex

さて、@file{.emacs} ファイルに戻ろう。

もう一度、さっきの行を書いておく。これは何をするのものだろう？

@cindex Text Mode turned on
@example
(setq default-major-mode 'text-mode)
@end example

@noindent
この行は、短いながらも完全な Emacs Lisp の式である。

我々は既に @code{setq} には慣れ親しんでいる。これは、後に続く変数 
@code{default-major-mode} をその後の @code{text-mode} という値にセットす
るものだ。@code{text-mode} の先頭の引用符は、Emacs に 
@code{text-mode} がシンボルとして何を表しているかを見るのではなく、文字
通りそのまま扱うよう指示するものである。@code{setq} のより詳しい説明につ
いては次を参照。@ref{set & setq, , 変数の値の設定}.
大切なポイントは、@file{.emacs} で値をセットする手続きは、Emacs の他
の場所での手続きと全く違いはないということである。

次は二行目である。

@cindex Auto Fill mode turned on
@findex add-hook
@example
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end example

@noindent
この行では、@code{add-hook} コマンドで @code{turn-on-auto-fill} を 
@code{text-mode-hook} という変数に加えている。@code{turn-on-auto-fill} 
はプログラムの名前であり、名前から推察される通りのことを行う。Auto Fill
mode をオンにするのである。

Emacs は Text mode に入るたびに、Text mode にフック (hook) されたコマン
ドを実行する。従って、Emacs が Text mode になるごとに Auto Fill mode も
オンになるわけである。

まとめると、最初の行は、特に拡張子や最初の空でない行や局所変数からどのモー
ドにしてよいか分らない場合には Text mode になるよう設定するものである。

Text mode では、物書きには便利な構文テーブルが設定されたりする。例えば、
アポストロフィ @samp{'} は普通の文字ように単語の一部だと解釈するが、終止
符や空白は単語の一部だとは考えない。従って @kbd{M-f} では @samp{it's} 全
体を飛び越えて進む。一方、C mode では、@samp{it's} のちょうど @samp{t} 
の直後の位置で止まる。

また二行目は、Text mode に入る際に同時に Auto Fill mode もオンにするため
のものである。Auto Fill mode では、Emacs は自動的に長い行を次の行に折り
返してくれる。その際は、単語を寸断したりせずちゃんと単語と単語の間を折り
返すようになっている。

Auto Fill mode がオフになっている場合は、行はあなたがタイプしていくとそ
のまま右に伸びていく。行が右端まで到達した場合、@code{truncate-lines} の
値をどう設定しているかによって、右の部分が見えなくなったり、あるいは汚い
形で表示されたりする。

@node Mail Aliases, Indent Tabs Mode, Text and Auto-fill, Emacs Initialization
@section メールのエイリアス

以下が mail aliases 等を使えるようにする @code{setq} 式、及びそれについ
ての備忘録である。

@example
@group
;;; Mail mode
; To enter mail mode, type `C-x m'
; To enter RMAIL (for reading mail), 
; type `M-x rmail'
@end group
@end example

@example
@group
(日本語訳)
;;; Mail mode
; Mail mode に入るには、`C-x m' とタイプする。
; (mail を読むために) RMAIL にはいるには、
; `M-x rmail' とタイプする。

(setq mail-aliases t)
@end group
@end example

@cindex Mail aliases
@noindent
この @code{setq} コマンドは、変数 @code{mail-aliases} の値を @code{t} に
セットする。@code{t} は真を意味するので、この行は「どうぞ、mail aliases 
を使って下さい」という意味になる。

Mail aliases というのは、長い電子メールアドレスや電子メールアドレスのリ
ストに対する便宜上の短い名前のことである。あなたの `aliases' を保存して
おくファイルは @file{‾/.mailrc} である。alias は次のような形式で書けばよ
い。

@example
alias geo george@@foobar.wiz.edu
@end example

@noindent
George にメッセージを書く場合は、アドレスに @samp{geo} と書くだけでよい。
するとメイラーは自動的に @samp{geo} をフルアドレスに展開してくれる。

@node Indent Tabs Mode, Keybindings, Mail Aliases, Emacs Initialization
@section Indent Tabs モード
@cindex Tabs, preventing
@findex indent-tabs-mode

Emacs はデフォルトでは、リージョンを整形する際に沢山の空白の連続にはタブ
を挿入する。(例えばあなたは、沢山の行を一度にインデントするために 
@code{indent-region} を使ったりすることだろう。) タブは端末や普通の印刷
では綺麗に見える。しかし @TeX{} ではタブは無視されるために、@TeX{} や 
Texinfo を使う際には出力が汚くなってしまう。

@need 1250
次のようにすれば、Indent Tabs mode をオフに出来る。

@example
@group
;;; Prevent Extraneous Tabs
(setq-default indent-tabs-mode nil)
@end group
@end example

この行では、今まで使ってきた @code{setq} ではなく @code{setq-default} を
使っていることに注意しよう。@code{setq-default} コマンドは、その変数に対
するバッファローカルな値がない場合に限り、その値をセットする。

@ifinfo
@ref{Just Spaces, , Tabs vs. Spaces, emacs, The GNU Emacs Manual}.

@ref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
@cite{The GNU Emacs Manual} の中の ``Tabs vs.@: Spaces'' や ``Local
Variables in Files'' を参照。
@end iftex

@node Keybindings, Loading Files, Indent Tabs Mode, Emacs Initialization
@section 幾つかのキーバインディング

次は、幾つかの個人的なキーバインディングの設定である。

@example
@group
;;; Compare windows
(global-set-key "¥C-cw" 'compare-windows)
@end group
@end example

@findex compare-windows
@code{compare-windows} は、現在のウィンドウと次のウィンドウの中のテキス
トを比較してくれるという、洒落たコマンドである。これは、各々のウィンドウ
の中のポイントの位置から比較を開始して、両方が同じである所まで進む。私は
このコマンドをいつも利用している。

また、これを見れば、全てのモードに対する大域的なキーバインディングを設定
する方法が分る。

@cindex Setting a key globally
@cindex Global set key
@cindex Key setting globally
@findex global-set-key
コマンドは @code{global-set-key} だ。この後にキーバインディングが続く。
@file{.emacs} ファイルではキーバインディングは上に示した通りの方法で書か
れる。@code{¥C-c} は `control-c', つまり、「control キーと @kbd{c} を同
時に押す」ことを表わす。また、@code{w} は「@kbd{w} を押す」ことを表わす。
説明の中では、@kbd{C-c w} のように書かれる。(@key{CTL} キーではなく 
@kbd{M-c} のような @key{META} キーを使ったバインドをしたい場合は、
@code{¥M-c} のように書く。詳しくは次を参照。@ref{Init Rebinding, ,
Rebinding Keys in Your Init File, emacs, The GNU Emacs Manual}.)

このキーで呼び出されるコマンドは @code{compare-windows} である。この時、
@code{compare-windows} の先頭に引用符を付けることに注意しよう。そうしな
いと、Emacs は最初にこのシンボルの値を評価しようとしてしまう。

二重引用符と、@samp{C} の前のバックスラッシュ、及び単独の引用符の三つは
キーバインディングには必須であるにもかかわらず、私はよく忘れてしまう。幸
いなことに、これらは @file{.emacs} を見れば思い出すことが出来る。

@kbd{C-c w} というキーバインディングそのものについても書いておく。これは、
@kbd{C-c} という前置キーと一文字---今の場合は @kbd{w}---からなっている。
このような @kbd{C-c} に続けて一文字というキー設定は、特に個人的な用途に
残されている。もしあなたが Emacs を拡張したい場合、これらのキーを公の
用途に使わないで欲しい。その代わり、@kbd{C-c C-w} のようなキーを使うべき
である。そうでないと個人用にバインドするキーがなくなってしまう。

@need 1250
以下にコメント付きで他のキーバインディングを書いておく。

@example
@group
;;; Keybinding for `occur'
; I use occur a lot, so let's bind it to a key:
; (私は occur をよく使うので、キーにバインドしておく。)
(global-set-key "¥C-co" 'occur)
@end group
@end example

@findex occur
@code{occur} コマンドは、現在のバッファの中で正規表現にマッチする部分を
含む行を全て表示してくれるコマンドである。マッチした行は、@file{*Occur*} 
というバッファに表示される。このバッファはその位置に簡単に飛ぶためにも使
われる。

@findex global-unset-key
@cindex Unbinding key
@cindex Key unbinding
@need 1250
次に、キーバインディングの解除の仕方を示す。特定のキーバインディングを使
えなくするわけである。

@example
@group
;;; Unbind `C-x f'
(global-unset-key "¥C-xf")
@end group
@end example

このキーバインディングを解除するのには理由がある。私は、自分がよく 
@kbd{C-x C-f} とタイプしようとして、間違って @w{@kbd{C-x f}} とタイプし
てしまうことに気が付いた。ファイルを読み込もうとして、偶然行詰めの幅を設
定してしまうわけである。結果的に大抵は変な幅が設定されてしまう。私はこの
幅を変更することは殆どないので、単にキーバインディングを解除することにし
たのだ。

@findex list-buffers, @r{rebound}
@findex buffer-menu, @r{bound to key}
@need 1250
次は現在のキーをバインドし直すものである。

@example
@group
;;; Rebind `C-x C-b' for `buffer-menu'
(global-set-key "¥C-x¥C-b" 'buffer-menu)
@end group
@end example

デフォルトでは、@kbd{C-x C-b} は @code{list-buffer} コマンドを起動するも
のである。このコマンドは現在のバッファのリストを@emph{別の}ウィンドウに
表示する。私は大抵はそのウィンドウで何かをしたいことが多いので 
@code{buffer-menu} コマンドの方が好きである。これは単にバッファのリスト
を表示するだけでなく、ポイントをそのウィンドウに移動してくれる。

@node Loading Files, Autoload, Keybindings, Emacs Initialization
@section ファイルのロード
@cindex Loading files
@c findex load

GNU Emacs のコミュニティの沢山の人々が Emacs の拡張を行ってきた。時が経
つにつれ、これらの拡張が新しいリリースに含まれることも多くなった。例えば 
カレンダーや日記のパッケージは今や Emacs version 19 の配布の一部になって
いる。これらは標準の Emacs version 18 の配布には含まれていなかったものだ。

(私は Calc も Emacs の大切な一部だと考えている。パッケージが大きいために
別配布の形を取ってはいるものの、これも標準の配布の一部と言えるだろう。)

@code{load} コマンドを使うと、ファイルの中身全てを評価することが出来る。
従って、そのファイルの関数や変数を全て Emacs にインストールすることが可
能だ。例えば、

@example
(load "‾/emacs/kfill")
@end example

というＳ式は、ホームディレクトリの @file{emacs} というサブディレクトリの
下の @file{kfill.el} ファイルを評価、即ちロードする。(もしバイトコンパイ
ルされた @file{kfill.elc} があれば、そちらがロードされる。こっちの方が速
くロード、実行出来る。)

(@file{kfill.el} は、Kyle E.@: Jones の @file{filladapt.el} パッケージを 
Bob Weinere が改造したもので、「すっきりとして、こうるさいくない折り返し
及びパラグラフの行詰めを提供し、ニュースやメール、それに Lisp, C++, 
Postscript やシェルコマンドなんかを含めてインデントしてくれる」パッケー
ジである。私はこれをよく利用するので、標準の配布の中に含めてくれることを
願っている。)

@vindex load-path
沢山の拡張パッケージをロードしたい場合は、上のようにそのファイルの位置を
正確に指定するのではなく、あるディレクトリを Emacs の @code{load-path} 
に指定するとよい。私はそうしている。この場合には、Emacs はファイルをロー
ドする際にデフォルトのディレクトリのリストに加えてそのディレクトリも検索
してくれるようになる。(デフォルトのディレクトリは Emacs を作成する際に 
@file{paths.h} で指定される。)

@need 1250
次のコマンドで、@file{‾/emacs} ディレクトリを現在のロードパスに含めるこ
とが出来る。

@example
@group
;;; Emacs Load Path
(setq load-path (cons "‾/emacs" load-path))
@end group
@end example

ついでに言っておくと、@code{load-library} は関数をロードする際のインタラ
クティブなインターフェースも提供してくれる。この関数の完全なコードは次の
ようになっている。

@findex load-library
@example
@group
(defun load-library (library)
  "Load the library named LIBRARY.
This is an interface to the function `load'."
  (interactive "sLoad library: ")
  (load library))
@end group
@end example

@code{load-library} という関数の名前では `library' という言葉を便宜的に 
`file' の同意語として見ている。@code{load-library} コマンドのソースは 
@file{files.el} ライブラリにある。

これと若干違う動作をするインタラクティブなコマンドとして、
@code{load-file} がある。これが @code{load-library} とどう違うかについて
のより詳しい情報は次を参照。@ref{Lisp Libraries, , Libraries of Lisp
Code for Emacs, emacs, The GNU Emacs Manual}.

@node Autoload, Simple Extension, Loading Files, Emacs Initialization
@section オートロード
@findex autoload

その関数を含むファイルをロードしたり、関数定義を直接評価したりしてインス
トールする代わりに、その関数が実際に最初に使われるまではインストールはし
ないが、いつでも呼び出せる状態にはしておくということも出来る。これは
@dfn{オートロード} (@dfn{autoloading}) と呼ばれる。

オートロードされた関数を実行すると、Emacs は自動的にその定義を含むファイ
ルを評価して、その関数を呼び出す。

オートロード関数を使うと Emacs をより速く起動出来る。というのも起動時に
はそのライブラリはロードされないからだ。その代わり、最初にオートロードさ
れた関数を使う際には、それを含むファイルを評価する間ちょっと待たされるこ
とになる。

めったに使われない関数はしばしばオートロードされる。@file{loaddefs.el} 
ライブラリには @code{bookmark-set} から @code{wordstar-mode} まで何百も
のオートロードされる関数が含まれている。勿論、個人的にこれらの「めったに
使わない」関数を頻繁に使うことになることもあるかもしれない。この場合は、
その関数のファイルを @code{load} 式を使って @code{.emacs} ファイルの中で
ロードしておくべきだろう。

私の Emacs version 19.23 用の @file{.emacs} ファイルでは、元々オートロー
ドされるような関数を含む17のライブラリがロードされている。(実際には、こ
れらの関数を「dump」した Emacs を作るべきなのだが、忘れていたのだ。dump 
についての詳しい情報は、@ref{Building Emacs, , Building Emacs, elisp,
The GNU Emacs Lisp Reference Manual}, や @file{INSTALL} を見て欲しい。)

あるいはまた @file{.emacs} ファイルにオートロード式を書きたいこともある
だろう。@code{autoload} は五つの引数を取る組み込み関数であり、最後の三つ
の引数は省略可能である。最初の引数はオートロードする関数の名前、二番目の
引数はロードされるファイル名、三番目は関数の説明文、四番目はその関数をイ
ンタラクティブに呼び出せるかどうか、そして最後の五番目の引数は、オブジェ
クトのタイプ---@code{autoload} は関数だけでなく、キーマップやマクロも扱
えるので---である。(デフォルトは関数である。)

以下に典型的な例を挙げる。

@example
@group
(autoload 'html-helper-mode
  "html-helper-mode" "Edit HTML documents" t)
@end group
@end example

@noindent
この式は、@code{html-helper-mode} 関数をオートロードするものである。これ
は、@file{html-helper-mode.el} ファイルの中でロードされる。(あるいは、も
し @file{html-helper-mode.elc} があれば、そちらから読み込まれる。) この
ファイルは @code{load-path} で指定されたディレクトリに置かれていなければ
ならない。説明文を読むと、これは HyperText Markup Language で書かれた文
書を編集するためのモードであることが分る。このモードは @kbd{M-x
html-helper-mode} とタイプすることでインタラクティブに呼び出すことが出来
る。(この場合、オートロード式の説明文には正規の説明文をそのまま複写する
必要がある。正規の説明文はまだロードされていないので、まだ読めないわけで
ある。)
@c @ifset largebook
@c @noindent
@c この式は、@code{html-helper-mode} 関数を、@file{html-helper-mode.el} ファ
@c イルのからロードする。(あるいは、もし @file{html-helper-mode.elc} があれば、
@c そちらから読み込む。) このファイルは @code{load-path} で指定されたディレ
@c クトリに置かれていなければならない。説明文を読むと、これは HyperText
@c Markup Language で書かれた文書を編集するためのモードであることが分る。こ
@c のモードは @kbd{M-x html-helper-mode} とタイプすることでインタラクティブ
@c に呼び出すことが出来る。(この場合、オートロード式の説明文には正規の説明
@c 文をそのまま複写する必要がある。正規の説明文はまだロードされていないので、
@c まだ読めないわけである。)
@c @end ifset

詳しくは、次を参照。@ref{Autoload, , Autoload, elisp, The GNU Emacs Lisp
Reference Manual}.

@node Simple Extension, Keymaps, Autoload, Emacs Initialization
@section ちょっとした拡張: @code{line-to-top-of-window}
@findex line-to-top-of-window
@cindex Simple extension in @file{.emacs} file

次に、ポイントのある行をウィンドウの最上段に移動する簡単な Emacs の拡張
を書いておく。これを使うとテキストを簡単に見ることが出来るので、私は普段
よく利用している。

次のコードを別ファイルにして、それを @file{.emacs} でロードしても良いし、
コードを直接 @file{.emacs} の中に含めてしまうことも出来る。

@need 1250
以下が定義である。

@example
@group
;;; Line to top of window;  
;;; replace three keystroke sequence  C-u 0 C-l
(defun line-to-top-of-window ()
  "Move the line point is on to top of window."
  (interactive) 
  (recenter 0))
@end group
@end example

@need 1250
次にキーバインディングである。

大抵の Emacs version 18 用の @file{.emacs} ファイルは、そのまま version
19 でも動くのだが、やはり幾つかの違いがある。(勿論 Emacs 19 での新しい
機能もある。)

Version 19 の Emacs では、ファンクションキーを @samp{[f6]} のように書く
ことが出来る。Version 18 ではファンクションキーを押した時にキーボードか
ら送られるキーストロークを指定しなければならなかった。例えば Zenith 29 
キーボードでは、6番目のファンクションキーを押すと @kbd{ESC P} が送られる
し、Ann Aubor Ambassador キーボードでは @kbd{ESC O F} が送られる。これら
のキーストロークは各々 @samp{¥eP} 及び @samp{¥eOF} のように書かれること
になる。

私は version 18 の @file{.emacs} では @code{line-to-top-of-window} を端
末のタイプに依存するキーにバインドしている。

@example
@group
(defun z29-key-bindings () 
  "Function keybindings for Z29 terminal."
  ;; @dots{}
  (global-set-key "¥eP" 'line-to-top-of-window))
@end group

@group
(defun aaa-key-bindings () 
  "Function keybindings for Ann Arbor Ambassador"
  ;; @dots{}
  (global-set-key "¥eOF" 'line-to-top-of-window))
@end group
@end example

@noindent
(ファンクションキーを押した時にどういうキーストロークが送られるかは、
@kbd{C-h l} (@code{view-lossage}) とタイプすることで知ることが出来る。こ
れは、最後にタイプした100のキーストロークを表示してくれる。)

キーバインディングを指定した後は、端末タイプに従って、そのどちらかのキー
バインディングを選択するＳ式を評価する。が、その前に以前定義されたデフォ
ルトのキーバインディングを削除する。そうしないと、定義がぶつかった場合に 
@file{.emacs} でのキーバインディングが上書きされる。

@example
@group
;;; Turn Off Predefined Terminal Keybindings

; The following turns off the predefined 
; terminal-specific keybindings such as the
; vt100 keybindings in lisp/term/vt100.el.  
; If there are no predefined terminal
; keybindings, or if you like them,
; comment this out.
@end group
@end example

@example
@group
(日本語訳)
;;; 以前定義された端末のキーバインディングを取り消す
; 下の式では、以前定義された端末固有のキーバインディング、
; 例えば lisp/term/vt100.el にある vt100 のキーバインディ
; ングを取り消すものである。
; もしまだ端末固有のキーバインディングが定義されていなかっ
; たり、そのバインディングが好みのものであった場合は、これ
; をコメントアウトしよう。

(setq term-file-prefix nil)
@end group
@end example

@need 1250
以下が選択のためのＳ式である。

@example
@group
(let ((term (getenv "TERM")))
  (cond 
   ((equal term "z29") (z29-key-bindings))
   ((equal term "aaa") (aaa-key-bindings))
   (t (message
       "No binding for terminal type %s."
       term))))
@end group
@end example

Emacs version 19 では、ファンクションキーは (マウスボタンイベントや非
@sc{アスキー}文字と同様) 引用符無しの角括弧でくくって書くことが出来る。
私は次のようにして @code{line-to-top-of-window} をファンクションキー 
@kbd{F6} にバインドしている。

@example
(global-set-key [f6] 'line-to-top-of-window)
@end example

@noindent 
こっちの方がずっと単純だ！

より詳しいことについては、次を見て欲しい。@ref{Init Rebinding, ,
Rebinding Keys in Your Init File, emacs, The GNU Emacs Manual}.

@cindex Conditional 'twixt Emacs 18 and 19
@cindex Version of Emacs, choosing
@cindex Emacs version, choosing
Emacs 18 と Emacs 19 の両方を走らせている場合、次のような条件分岐を使っ
て、どちらのコードを使うかを選択することが出来る。

@example
@group
(if (string=
     (int-to-string 18)
     (substring (emacs-version) 10 12))
    ;; evaluate version 18 code
    (progn
       @dots{} )
  ;; else evaluate version 19 code
  @dots{}
@end group
@end example

@node Keymaps, X11 Colors, Simple Extension, Emacs Initialization
@section キーマップ
@cindex Keymaps
@cindex Rebinding keys

Emacs はどのキーをどのコマンドにバインドするかを @dfn{keymaps} を使って
記録する。C mode や Text mode のような特定のモードは、それ自身のキーマッ
プを持っている。モード独自のキーマップは、全てのバッファで共有される 
global map を上書きする。

@code{global-set-key} 関数は global keymap のキーをバインドしたり再バイ
ンドしたりする。例えば次のＳ式は、キー @kbd{C-c C-l} を関数 
@code{line-to-top-of-window} にバインドする。

@example
(global-set-key "¥C-c¥C-l" 'line-to-top-of-window)
@end example

モード独自のキーマップは @code{define-key} 関数を使ってバインドされる。
これは、キーやコマンドと同時に特定のキーマップも引数に取る。例えば私の 
@file{.emacs} ファイルでは、@code{texinfo-insert-@@group} コマンドを 
@kbd{C-c C-c g} にバインドするために、次のようなＳ式が書かれている。

@example
@group
(define-key texinfo-mode-map "¥C-c¥C-cg"
  'texinfo-insert-@@group)
@end group
@end example

@noindent
@code{texinfo-insert-@@group} 関数そのものは、Texinfo ファイルに 
@samp{@@group} をインサートするためのちょっとした Texinfo mode の拡張であ
る。私はこのコマンドをいつも使うので、六つのキーストローク @kbd{@@ g r o 
u p} よりも三つのキーストロークである @kbd{C-c C-c g} を使う方がずっと便
利なのだ。(@samp{@@group} と対応する @samp{@@end group} は中のテキストを
一つのページに収めるためのコマンドである。この本の中の、沢山の複数行に
渡る例が @samp{@@group @dots{} @@end group} で囲まれている。)

@need 1250
以下が @code{texinfo-insert-@@group} の関数定義である。

@example
@group
(defun texinfo-insert-@@group ()
  "Insert the string @@group in a Texinfo buffer."
  (interactive)
  (beginning-of-line)
  (insert "@@group¥n"))
@end group
@end example

(タイプ数を節約するためには、勿論、単語を挿入する関数を定義したりする代
わりに Abbrev mode を使うことも出来る。しかし、キーストロークが他の 
Texinfo mode のキーバインディングと調和が取れているという意味で、私は上
の方法の方が好みである。)

@file{loaddefs.el} を見れば @file{c-mode.el} や @file{lisp-mode.el} のよ
うな様々なモードライブラリと同時に沢山の @dfn{define-key} 式が書かれてい
るのが分る。

キーマップについての詳細は次を参照のこと。 
@ref{Key Bindings, , Customizing Key Bindings, emacs, The GNU Emacs
Manual}, 及び @ref{Keymaps, , Keymaps, elisp, The GNU Emacs Lisp
Reference Manual}.

@node X11 Colors, V19 Miscellaneous, Keymaps, Emacs Initialization
@section X11 でのカラー表示

X Window System を使うと、Emacs version 19 をカラーで使うことが出来る。
(これまでに挙げた全ての例は、Emacs version 18 でも Emacs version 19 でも
動くはずである。が、ここの例は Emacs version 19 でのみ動作する。)

私はデフォルトのカラーが気に入らないので、自分独自の色を指定している。

私の指定は、大抵の X の初期化ファイルにあるものである。やったことを備忘
録として自分の @file{.emacs} に記述している。

@example
@group
;; I use TWM for window manager;
;; my ‾/.xsession file specifies:
@end group
@end example

@example
@group
(日本語訳)
;; 私はウィンドウマネージャとして TWM を使っている。
;; 私の ‾/.xsession ファイルには次のように記されている。
;    xsetroot -solid navyblue -fg white
@end group
@end example

@need 1250
@noindent
実際は、X Window のルートは Emacs の一部などでは全くない。が、ともかく書
いておくことにした。

@example
@group
;; My ‾/.Xresources file specifies:
;; (私の ‾/.Xresources ファイルには、次のように記されている。)
;     XTerm*Background:    sky blue
;     XTerm*Foreground:    white
;     emacs*geometry:      =80x40+100+0
@end group
@group
;     emacs*background:    blue
;     emacs*foreground:    grey97
;     emacs*cursorColor:   white
;     emacs*pointerColor:  white
@end group
@end example

@need 1250
次からが、@file{.emacs} で値を設定しているＳ式の部分である。

@example
@group
;;; Set highlighting colors for isearch and drag
;;; (isearch とドラッグのためのハイライトカラー)
(set-face-foreground 'highlight "white" )
(set-face-background 'highlight "slate blue")
(set-face-background 'region    "slate blue")
(set-face-background
 'secondary-selection "turquoise")
@end group

@group
;; Set calendar highlighting colors
;; カレンダー用のハイライトカラー
(setq calendar-load-hook
      '(lambda () 
         (set-face-foreground 'diary-face   "skyblue")
         (set-face-background 'holiday-face "slate blue")
         (set-face-foreground 'holiday-face "white")))
@end group
@end example

色々な色合いの青が、スクリーンのちらつきから私の眼を守り、そして癒してく
れる。

@node V19 Miscellaneous, Mode Line, X11 Colors, Emacs Initialization
@section V19 での雑多な事柄

以下は、Emacs version 19 用の細かい設定である。
@sp 1

@itemize @minus
@item
自動的に必要なだけミニバッファの大きさを変更する。

@example
@group
(resize-minibuffer-mode 1)
(setq resize-minibuffer-mode t)
@end group
@end example

@item
検索文字をハイライト表示する。

@example
(setq search-highlight t)
@end example

@item
全てのフレームでメニューバーを表示し、マウスをそのフレーム上に移動したと
きに上に来るようにする。

@example
@group
(setq default-frame-alist
      '((menu-bar-lines . 1)
        (auto-lower . t)
        (auto-raise . t)))
@end group
@end example

@item

マウスカーソルの色と形の設定。
@example
@group
; Cursor shapes are defined in
; `/usr/include/X11/cursorfont.h'; 
; for example, the `target' cursor is number 128;
; the `top_left_arrow' cursor is number 132.
@end group

@group
(日本語訳)
; カーソルの形状は、次の中で定義されている
; `/usr/include/X11/cursorfont.h'.
; 例えば、`target' カーソルは 128 番であり、
; `top_left_arrow' カーソルは 132 番である。
@end group

@group
(let ((mpointer (x-get-resource "*mpointer"
                                "*emacs*mpointer")))
  ;; If you have not set your mouse pointer
  ;;     then sent it, otherwise leave as is:
  ;; (もしまだマウスポインタをセットしていないのなら、
  ;; セットする。既にしてある場合はその状態のままに。)
  (if (eq mpointer nil)
      (setq mpointer "132")) ; top_left_arrow
@end group
@group
  (setq x-pointer-shape (string-to-int mpointer))
  (set-mouse-color "white"))
@end group
@end example
@end itemize

@node Mode Line,  , V19 Miscellaneous, Emacs Initialization
@section モード行の修正
@vindex default-mode-line-format
@cindex Mode line format

最後に、モード行の修正について述べる。これが変更出来るようになっているの
は本当に嬉しい。

私は時々ネットワーク上で仕事をするので、通常モード行の左側に書かれている 
@samp{Emacs: } をシステムの名前で置き換えている---そうしないと、私が現在
どのマシンの上で仕事をしているか忘れてしまうからである。更に、どのディレ
クトリにいたかを忘れないようにデフォルトのディレクトリのリストも書いてい
る。また、@samp{Line} が溢れるために、line point を on にした。以上の設
定をする @file{.emacs} の記述は以下の通りである。

@example
@group
(setq mode-line-system-identification  
  (substring (system-name) 0
             (string-match "¥¥..+" (system-name))))
@end group

@group
(setq default-mode-line-format
      (list ""
            'mode-line-modified
            "<"
            'mode-line-system-identification
            "> "
            "%14b"
            " "
            'default-directory
            " "
            "%[(" 
            'mode-name 
            'minor-mode-alist 
            "%n" 
            'mode-line-process  
            ")%]--" 
             "Line %l--"
            '(-3 . "%P")
            "-%-"))
@end group

@group
;; Start with new default.
(setq mode-line-format default-mode-line-format)
@end group
@end example

@noindent
@emph{default} のモード行のフォーマットは Info のような様々なモードが上
書きすることを許すようにした。リストの中の多くの要素は、名前から役目が推
測出来るようになっている。例えば @code{mode-line-modified} はバッファが
修正された場合、それを教えてくれるようにする変数だし、@code{mode-name} 
はモードの名前を教えてくれる、等々。

@samp{"%14b"} は現在のバッファの名前を (お馴染みの @code{buffer-name} 関
数を使って) 表示する。`14' は表示する文字数の最大の指定である。それより
も文字数が少ない場合は空白文字で埋めてくれる。@samp{%[} と @samp{%]} は
各々の再帰編集レベルに応じて角括弧の組を表示するものである。
@samp{%n} はナローイングをしている時に `Narrow' と表示してくれる。
@samp{%P} はバッファ全体でウィンドウの最下段より上にある部分が何パーセン
トあるか、もしくは `Top' か `Bottom' かを表示してくれる。(小文字の 
@samp{p} にすると、ウィンドウの最上段より上の部分がどのくらいかを表示す
る。) @samp{%-} は行の残りをダッシュ (訳註：`-' のこと) で埋めてくれる。

Emacs version 19.29 以降では、@code{frame-title-format} を使って Emacs 
のフレームにタイトルを表示することが出来る。この変数は 
@code{mode-line-format} と同じ構造をしている。

モード行のフォーマットについては、次に説明がある。@ref{Mode Line Format,
, Mode Line Format, elisp, The GNU Emacs Lisp Reference Manual}.

(訳註：Nemacs や Mule では日本語コードや多国語コードの状態を表示するため
に拡張が加えられている。@code{default-mode-line-format} を一度評価して値
を調べ、それを元に修正するとよいだろう。)

もう一度「Emacs を好きになるために Emacs を好きになる必要はない。」とい
う言葉を思い出して欲しい---あなた自身の Emacs はデフォルトの Emacs とは
異なる色や異なるコマンド、そして異なるキーマップを持つことが出来るのだ。

一方で、もし「箱から取り出したままの」カスタマイズされていない素の Emacs 
を起動したい場合は、次のようにタイプしよう。

@example
emacs -q
@end example

@noindent
こうすると、Emacs はあなたの初期化ファイル @file{‾/.emacs} をロードしな
いで起動する。これが素のままのデフォルトの Emacs である。

@node Debugging, Conclusion, Emacs Initialization, Top
@chapter デバッグ
@cindex debugging

GNU Emacs は二つのデバッガを持っている。@code{debug} と @code{edebug} で
ある。最初のものは、Emacs の内部に組み込まれていて、常に使える状態にある。
二番目のものは拡張機能として与えられているもので、version 19 では標準の
配布の中に含まれている。

これらのデバッガは共に、以下の所に非常に詳しく説明されている。 
@ref{Debugging, , Debugging Lisp Program, elisp, The GNU Emacs Lisp
Reference Manual}. この章では、各々の簡単な例を見ていくことにする。

@menu
* debug::                       組み込みデバッガの使い方
* debug-on-entry::              関数呼び出し時にデバッガを起動する
* debug-on-quit::               @kbd{C-g} を押した時にデバッガを起動する
* edebug::                      ソースレベルのデバッガ Edebug
* Debugging Exercises::         デバッグについての練習問題
@end menu

@node debug, debug-on-entry, Debugging, Debugging
@section @code{debug}
@findex debug

例えばあなたが、1から与えられた数までの和を計算するための関数の定義を書
いたとしよう。(これは以前に説明した @code{triangle} 関数である。次の所で
詳しく議論されている。
@ref{Decrementing Loop, , 減少するカウンタを使ったループ}.)

しかしながら、あなたの関数にはバグがあったとしよう。例えば @samp{1-} と
書くべきところを @samp{1=} と書いてしまったとする。この間違いをしたプロ
グラムは以下の通りである。

@findex triangle-bugged
@example
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1= number)))      ; @r{ここでエラー}
    total))
@end group
@end example

もし、この文章を Info で読んでいるなら、この関数をいつものように評価する
ことが出来る。そうすると、エコー領域には @code{triangle-bugged} と表示さ
れるはずだ。

@need 1250
さて、@code{triangle-bugged} を引数 4 とともに評価してみよう。

@example
(triangle-bugged 4)
@end example

@noindent
@example
@group
@exdent すると、次のようなエラーメッセージを受け取るはずだ。

Symbol's function definition is void:@: 1=
@end group
@end example

実際は、このような単純なバグなら、エラーメッセージだけでどう修正すればよ
いか分るだろう。しかし、分らない場合はどうすればよいか？

@findex debug-on-error
@code{debug-on-error} の値を @code{t} とすることで、デバッグを開始するこ
とが出来る。

@example
(setq debug-on-error t)
@end example

@noindent
こうしておくと、Emacs は次にエラーに遭遇した時にデバッグに入る。

@need 1250
@noindent
逆に @code{debug-on-error} を @code{nil} にすると、デバッグには入らない。 

@example
(setq debug-on-error nil)
@end example

@need 1250
@noindent
では、@code{debug-on-error} を @code{t} にして、次を評価してみよう。

@example
(triangle-bugged 4)
@end example

@need 1250
@noindent
今度は Emacs は @file{*Backtrace*} と呼ばれるバッファを生成したはずだ。
これは以下のようなものだ。

@example
@group
---------- Buffer: *Backtrace* ----------
Signalling: (void-function 1=)
  (1= number))
  (setq number (1= number)))
  (while (> number 0) (setq total (+ total number))
        (setq number (1= number))))
  (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total))
  triangle-bugged(4)
  eval((triangle-bugged 4))
  eval-last-sexp(nil)
* call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end example

@noindent
(上はちょっとばかり修正してある。実際はデバッガは長い行を折り返したりは
しない。)

@cindex @file{*Backtrace*} buffer
@cindex Backtrace buffer for debugging
@file{*Backtrace*} を読む時は、下から上に向かって読んでいく。そうすると、
Emacs がどのようにしてエラーを出すに至ったかが分る。今の場合、Emacs は 
@kbd{C-x C-e} (@code{eval-last-sexp}) をインタラクティブに呼び出し、その
結果として @code{triangle-bugged} 式を評価している。上の各々の行から@ 
Lisp インタプリタが次に何を評価していったかが分る。

@need 1250
上から三行目は

@example
(setq number (1= number))
@end example

@noindent
である。Emacs はこのＳ式を評価しようとした。そのために、内部のＳ式を評価
しようとした。それが上から二行目の式である。

@example
(1= number)
@end example

@need 1250
@noindent
エラーが生じたのは、ここである。一行目にはそう書かれている。

@example
Signalling: (void-function 1=)
@end example

@noindent
そこでエラーを修正し、再び関数定義を評価して、もう一度テストしてみること
になる。

@need 1250
もし、Info でこれを読んでいるなら、ここで下の式を評価して 
@code{debug-on-error} を @code{nil} に戻しておこう。

@example
(setq debug-on-error nil)
@end example

@node debug-on-entry, debug-on-quit, debug, Debugging
@section @code{debug-on-entry}
@findex debug-on-entry

ある関数に対して @code{debug} を実行する二番目の方法は、関数を呼び出す時
にデバッグに入る方法である。それには @code{debug-on-entry} を使う。

@need 1250
@noindent
まず、次のようにタイプしてみよう。

@example
M-x debug-on-entry RET triangle-bugged RET
@end example

@need 1250
@noindent
そして、次を評価する。

@example
(triangle-bugged 5)
@end example

@noindent
Emacs は @file{*Backtrace*} バッファを作成し、@code{triangle-bugged} 関
数の評価の開始を知らせてくる。

@example
@group
---------- Buffer: *Backtrace* ----------
Entering:
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp(nil)
* call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end example

@file{*Backtrace*} バッファの中で、@kbd{d} とタイプしてみよう。すると、
Emacs は @code{triangle-bugged} の最初のＳ式を評価する。このときバッファ
は次のようになる。

@example
@group
---------- Buffer: *Backtrace* ----------
Beginning evaluation of function call form:
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total))
  triangle-bugged(5)
* eval((triangle-bugged 5))
  eval-last-sexp(nil)
* call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end example

@noindent
ここで、ゆっくりと、更に8回 @kbd{d} をタイプしてみよう。@kbd{d} をタイプ
するごとに、Emacs は関数定義の中の別のＳ式を評価していく。結果として、こ
のバッファは次のようになる。

@example
@group
---------- Buffer: *Backtrace* ----------
Beginning evaluation of function call form:
* (setq number (1= number)))
* (while (> number 0) (setq total (+ total number)) 
        (setq number (1= number))))
* (let ((total 0)) (while (> number 0) 
        (setq total ...) (setq number ...)) total))
  triangle-bugged(5)
* eval((triangle-bugged 5))
  eval-last-sexp(nil)
* call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end example

@noindent
最後に、更に 2 回 @kbd{d} をタイプすると Emacs はエラーの箇所まで辿り着
く。その結果 @file{*Backtrace*} の上から二行は次のようになる。

@example
@group
---------- Buffer: *Backtrace* ----------
Signalling: (void-function 1=)
* (1= number))
@dots{}
---------- Buffer: *Backtrace* ----------
@end group
@end example

@kbd{d} をタイプすることで、関数を一つずつ実行していくことが出来る。

@file{*Backtrace*} バッファを抜けるには @kbd{q} をタイプする。こう
するとトレースは抜けるが、@code{debug-on-entry} はキャンセルしない。

@findex cancel-debug-on-entry
@code{debug-on-entry} そのものを無効にするには、
@code{cancel-debug-on-entry} に呼び出して関数名を入力すればよい。次のよ
うな感じだ。

@example
M-x cancel-debug-on-entry RET triangle-bugged RET
@end example

@noindent
(もしこれを Info で読んでいるなら、ここで @code{debug-on-entry} を無効に
しておこう。)

@node debug-on-quit, edebug, debug-on-entry, Debugging
@section @code{debug-on-quit} と @code{(debug)}

@code{debug-on-error} をセットしたり @code{debug-on-entry} を呼び出したり
する以外にも二つ程、@code{debug} を開始する方法がある。

@findex debug-on-quit
一つは変数 @code{debug-on-quit} を @code{t} にセットすることで、こうする
と @kbd{C-g} (@code{keyboard-quit}) をタイプすることで常に @code{debug} 
を開始することが出来る。これは無限ループをデバッグする際に有効である。

@cindex @code{(debug)} in code
もう一つは、コードの中のデバッグを開始したい所に @code{(debug)} を呼び出す
行を挿入する方法である。例えば次のような感じである。

@example
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (debug)                         ; @r{デバッガ起動}
      (setq number (1= number)))      ; @r{ここでエラー}
    total))
@end group
@end example

@code{debug} 関数は次の中で詳しく説明されている。 @ref{Debugger, , The
Lisp Debugger, elisp, The GNU Emacs Lisp Reference Manual}.

@node edebug, Debugging Exercises, debug-on-quit, Debugging
@section ソースレベルのデバッガ @code{edebug}
@cindex Source level debugger
@findex edebug

Edebug は通常デバッグをしているコードのソースを表示してくれる。そして、
現在どの行を実行しているかを左側の矢印で示してくれる。

関数を一行ごとに実行することも出来るし、実行を止める @dfn{breakpoint} 
の所まで一気に走らせることも出来る。

Edebug については次の所に説明がある。@ref{edebug, , Edebug, elisp, The
GNU Emacs Lisp Reference Manual}.

次にバグを含んだ @code{triangle-recursively} の関数定義を挙げておく。こ
れについて復習したい場合には、次を参照。@ref{Recursive triangle
function, , カウンタの代わりに再帰を使う}. この例は、後で説明されている
ように @code{defun} の左のインデント無しで表示されている。

@format
@group
@t{(defun triangle-recursively-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                   
      1                              
    (+ number                        
       (triangle-recursively-bugged   
        (1= number)))))               ; @r{ここでエラー}}
@end group
@end format

@noindent
普通は、この関数定義をインストールするにはカーソルを関数の最後の閉じ括弧
の後で @kbd{C-x C-e} (@code{eval-last-sexp}) とタイプするか、関数定義内
にカーソルを置いて @kbd{C-M-x} (@code{eval-defun}) とタイプする。(デフォ
ルトでは @code{eval-defun} コマンドは Emacs Lisp mode か Lisp
Interaction mode でしか動作しない。)

しかしながら、Edebug を使ってこの関数をデバッグする際には、まず最初に別
の関数を使って、コードの @dfn{膳立て} (@dfn{instrument}) をする必要があ
る。Emacs version 19 では関数定義内で次のようにタイプする。

@example
M-x edebug-defun RET
@end example

@noindent
こうすることで、もし Edebug が Emacs にインストールされていなければ自動
的にインストールし、関数を適切に膳立てする。(Edebug をロードした後は、
Edebug の標準的なキーバインディングが使えるようになる。例えば 
@code{edebug-defun} を @kbd{C-u C-M-x} (@code{eval-defun} の前置引数付き
の実行) で実行出来る。)

Emacs version 18 では自分で Edebug をロードしなければならない。それには 
@file{.emacs} に適切な @code{load} コマンドを書いておけばよい。

もしこれを Info の中で読んでいるなら、ここで上の 
@code{triangle-recursively-bugged} 関数の膳立てをする。その際に
関数定義の @code{defun} の行がインデントされていると、
@code{edebug-defun} が定義の範囲を特定出来なくなってしまうので、上に挙げ
た例では今まで入れていた @code{defun} の左のスペースを除いてある。

関数の膳立てをした後、カーソルを次のＳ式のすぐ後に持っていって 
@kbd{C-x C-e} (@code{eval-last-sexp}) とタイプしよう。

@example
(triangle-recursively-bugged 3)
@end example

@noindent
すると @code{triangle-recursively-bugged} のソースに戻ってカーソルがこの
関数内の @code{if} の行の最初に移動する。また、@samp{=>} という矢印がそ
の行の左側に表示される。この矢印は関数が実行されている場所を指している。

@example
=>@point{}(if (= number 1)
@end example

@noindent
@iftex
例の中で、星印 @samp{@point{}} はポイントを表している (これは Info では 
@samp{-!-} と表示される。)。
@end iftex
@ifinfo
例の中で、@samp{@point{}} はポイントの位置を表している (これは印刷された
本の中では五つの点からなる星印になっている)。
@end ifinfo

さて、ここで @kbd{SPC} を押すと、ポイントは次に実行されるＳ式に移動する。
従って、この行が次のようになる。

@example
=>(if @point{}(= number 1)
@end example

@noindent
続けて @kbd{SPC} を押していくと、ポイントはＳ式からＳ式へと移動していく。
同時にＳ式が値を返すごとにその値がエコー領域に表示される。例えばポイント
が @code{number} の所を通過すると、次のように表示されるはずだ。

@example
Result: 3 = C-c
@end example

@noindent
これは @code{number} の値が3、つまり三番目の @sc{ascii} コードである 
@sc{ascii} @key{CTL-C} であることを意味している。(C はアルファベットの三
番目の文字である。) (訳註：暇な人は @code{(char-to-string 3)} 等を評価し
てみよう。)

こうしてエラーのある行まで移動することが出来る。これを表示する直前には、
この行は次のように表示されている。

@example
=>        @point{}(1= number)))))               ; @r{ここでエラー}
@end example

@need 1250
@noindent
ここでもう一度 @kbd{SPC} を押すと次のようなエラーメッセージが表示される。

@example
Symbol's function definition is void:@: 1=
@end example

@noindent
これがバグである。

Edebug を終了するには @samp{q} を押せばよい。

この関数定義の膳立てを解くには、 単に膳立てしないようなコマンドでその関
数を評価しなおせばよい。例えば、関数定義の最後の閉じ括弧の後で @kbd{C-x
C-e} とタイプするだけでよい。

Edebug は単に関数を一つずつ実行していくだけではなく他にも沢山のことをし
てくれる。自動的に関数を実行していってエラーが起きた所で止まるように設定
することも出来るし、特定の場所で止まるようにすることも可能である。様々な
Ｓ式の値の変化を表示させることも出来るし、ある関数が何回実行されたかも調
べることも出来る。その他にもいろいろなことが出来る。

Edebug については次で説明されている。 @ref{edebug, , Edebug, elisp, The
GNU Emacs Lisp Reference Manual}.

@need 1500
@node Debugging Exercises,  , edebug, Debugging
@section デバッグについての練習問題

@itemize @bullet
@item
@code{count-words-region} 関数をインストールし、それを呼び出した時に内部
デバッガが起動するようにしなさい。二つの単語を含むような region の上でこ
の関数を実行しなさい。@kbd{d} をかなりの回数押す必要があるだろう。あなた
の システムではこのコマンドが終了した時点で何かフックが呼ばれますか？ 
(フックについての情報は次を参照。 @ref{Command Overview, , Command Loop
Overview, elisp, The GNU Emacs Lisp Reference Manual}.)

@item
@code{count-words-region} を @file{*scratch*} バッファにコピーして、必要
なら @code{defun} の先頭のスペースを取り除いてから、この関数を Edebug の
ために膳立てしなさい。そして、この関数を1ステップずつ実行しなさい。この
場合、必ずしも関数にはバグがある必要はない。バグがあった方がよければバグ
を設定してもよい。もしこの関数にバグがなければ、問題なく最後まで実行出来
るはずだ。

@item
Edebug を実行している間に、@kbd{?} とタイプして全ての Edebug のコマンド
のリストを見なさい。(@code{global-edebug-prefix} は普通 @kbd{C-x X}、つ
まり @:@kbd{@key{CTL}-x} に続く大文字の @kbd{X} になっている。Edebug の
デバッグバッファの外でのコマンドにはこの前置キーを使うようにする。)

@item
Edebug のデバッギングバッファで @kbd{p}
(@code{edebug-bounce-point}) コマンドを使ってリージョンの何処で 
@code{count-words-region} が動作しているかを見なさい。

@item
ポイントを関数の下の方に持って行き、@kbd{h}
(@code{edebug-goto-here}) コマンドをタイプすることでその場所にジャンプし
なさい。

@item
@kbd{t} (@code{edebug-trace-mode}) コマンドを使って、Edebug が自分自身で
関数の上を走るようにしなさい。同様に大文字の @kbd{T} を使って 
@code{edebug-Trace-fast-mode} に入りなさい。

@item
ブレークポイントを設定し、その位置まで Edebug を Trace mode で走らせなさ
い。
@end itemize

@node Conclusion, the-the, Debugging, Top
@chapter まとめ

この入門書はこれで終わりである。以上であなたは Emacs Lisp でのプログラミ
ングについて十分学んだので、値をセットしたり、簡単な @file{.emacs} ファ
イルを自分自身や友人のために書いたり、Emacs にちょっとしたカスタマイズや
拡張を施すことが出来るようになっているはずである。

もっとも、これは一つの段階に過ぎない。望むなら、もっと先に進み、自分自身
で学んでいくことが出来る。

ここからは GNU Emacs のソースや
@iftex
@cite{The GNU Emacs Lisp Reference Manual}
@end iftex
@ifinfo
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual},
@end ifinfo
などが参考になるだろう。

Emacs Lisp のソースを見ることは一種の探検である。ソースを読んで見慣れな
い関数やＳ式に出逢った場合には、それが何であるかを解読したり調べたりしな
ければならない。

まずリファレンスマニュアルを開こう。これは徹底して書かれた、完全な、しか
も読みやすい Emacs Lisp の説明書である。これは熟練者のためだけではなく、
あなたが現在知っているような知識しかない人向けにも書かれている。
(@cite{Reference Manual} は標準的な GNU Emacs の配布に含まれている。この 
入門書と同様、これも Texinfo のソースファイルとして配布されている。従っ
て、オンラインでも読めるし、タイプセットして印刷された本としても読むこと
も出来る。)

また、他の GNU Emacs 附属のオンラインヘルプも読んでみよう。全ての関数に
は説明文字列がついているし、@code{find-tag} というソースを見つけてくれ
るプログラムもある。

例として私がソースを探検する方法を紹介しよう。もう随分と昔のことになるが、
最初に私は、その名前に魅かれて @file{simple.el} というファイルを見た。往々
にしてそんなものだが、@file{simple.el} の中の幾つかの関数は複雑だった。
少なくとも、ぱっと見には複雑そうに見えた。例えば一番最初の 
@code{open-line} 関数からして、いかにも複雑という感じだ。

あなたは、この関数を @code{forward-sentence} 関数の時のように、ゆっくり
と眺めたいかもしれない。 
@ifinfo
(@ref{forward-sentence}.)
@end ifinfo
@iftex
(@ref{forward-sentence, , @code{forward-sentence}}.)
@end iftex
あるいは、この関数は飛ばして他のもっと簡単そうな @code{split-line} 等の
関数を見たいかもしれない。これらの関数を全て読む必要はない。
@code{count-words-in-defun} を使うと、@code{split-line} 関数は27個の単語
とシンボルを含んでいることが分る。

@code{split-line} は、その短さにも関わらず、まだ我々が学んでいない四つの
Ｓ式を含んでいる。@code{skip-chars-forward}、@code{indent-to}、
@code{insert}、そして @samp{?¥n} である。

例えば @code{insert} 関数を考えてみよう。(これについては復習のセクション
である次の所でちょこっと触れられている。)
@iftex
@ref{Regexp Search, , 正規表現の検索}.
@end iftex
@ifinfo
@ref{Regexp Review}.
@end ifinfo
Emacs 上で @kbd{C-h f} (@code{describe-function}) に続けて @code{insert} 
とタイプすれば、この関数についてより詳しいことを知ることが出来る。これは
関数の説明文字列を表示してくれる関数である。ソース
を見る場合は @code{find-tag} を使う。これは @kbd{M-.} にバインドされてい
る。(もっとも今の場合にはあまり役に立たない。この関数は Lisp ではなく C 
で書かれたプリミティブだからだ。) 最後に、この関数についてのリファレンス
マニュアルの記述は次のようにして探せる。まず Info を起動する。そして 
@kbd{i} (@code{Info-index}) に続けてこの関数の名前をタイプする。もしくは
印刷されたマニュアルのインデックスから @code{insert} を探してもよい。

同様に、@samp{?¥n} の意味も調べることが出来る。@code{Info-index} で 
@samp{?¥n} を探してみるとよい。やってみると分るがこれは失敗する。しかし
諦めてはいけない。インデックスで @samp{?} 無しの @samp{¥n} を探してみれ
ば、マニュアルの中で関係するセクションを見つけることが出来る。
(@samp{?¥n} が改行文字を表していることは次の所に出ている。 
@ref{Character Type, , Character Type, elisp, The GNU Emacs Lisp
Reference Manual}.)

@code{skip-chars-forward} と @code{indent-to} で何が行われているかは推察
することが出来るだろう。勿論詳しく見ることだって出来る。(ついでだが、
@code{describe-function} 関数そのものは @file{help.el} にある。これは、
長い割には解読しやすい関数の一つである。これの定義を見れば、どうやって標準
の文字コードを使わずに @code{interactive} 式をカスタマイズ出来るかとか、
どうやってテンポラリバッファを生成するかということが分る。

他の面白いソースとしては、@file{paragraphs.el} や @file{loaddefs.el} そ
れに @file{loadup.el} などがあげられる。@file{paragraphs.el} ファイルに
は、長い関数だけでなく短くて簡単に理解出来る関数も含まれている。
@file{loaddefs.el} ファイルには沢山の標準オートロード式や沢山のキーマッ
プが含まれている。@file{loadup.el} は Emacs の標準部分をロードするファイ
ルである。これを見れば、Emacs がどういうふうに作成されるかがよく分る。
(Emacs の作成については次を参照。@ref{Building Emacs, , Building Emacs,
elisp, The GNU Emacs Lisp Reference Manual}.)

前にも言ったように、これまでに Emacs の部品についてはいくらか学習してき
た。しかし、これは大切なことなのだが、プログラミングの多くの部分について
はほとんど触れることは出来なかった。私は情報のソートについては既に定義さ
れた @code{sort} 関数を使うこと以外全く触れることが出来なかった。また、
変数やリストを使うこと以外の事柄については、例えば情報を貯めておくにはど
うしたらいいかといったことにも触れられなかった。プログラムを書くプログラ
ムについても同様だ。これらの話題については、他の別の種類の本で本書とは異
なる学習形態で学ぶべきであろう。

ともかく、以上で GNU Emacs を使って沢山の実際の仕事をする準備が整った。
出発点に辿り着いたわけである。これは始まりの終わりなのだ。

@c ================ Appendix ================

@node the-the, Kill Ring, Conclusion, Top
@appendix 関数 @code{the-the}
@findex the-the
@cindex Duplicated words function
@cindex Words, duplicated

文章を書いていると、時々単語を二重に書いてしまうことがある---例えば 
``you you'' (訳註：原文では実際にこの文の先頭で you が二重になっている。) 
と書いてしまったりする。個人的には ``the'' をよく二重に書いてしまう。そ
こで、二重になっている単語を見つける関数のことを @code{the-the} と呼ぶこ
とにする。

@need 1250
まず最初の段階として、取り敢えず次の正規表現を使えば、このような二重の単
語を表現出来そうなことが分る。

@example
¥¥(¥¥w+[ ¥t¥n]+¥¥)¥¥1
@end example

@noindent
この正規表現(の前半)は一つ以上の単語構成文字に続いて一つ以上のスペース、
タブないしは改行がくるものにマッチする。しかし、これでは二行に渡るものは
見つけられない。というのも、最初の単語の終わりに改行が来た場合に、次の行
の同じ単語の後にスペースが来ればマッチしないからである。(正規表現につい
ての詳細は、@ref{Regexp Search, , 正規表現の検索}, や
@ref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs
Manual}, それに @ref{Regular Expressions, , Regular Expressions, elisp,
The GNU Emacs Lisp Reference Manual}, を参照。)

単に単語の部分だけを検索すればよいのではと考えるかもしれないが、これでは 
`with the' の中の `th' のようなものまで引っかけてしまう。

上とは別の正規表現検索で、単語構成文字に続いて非単語構成文字が続き、更に
最初の単語が来るものにマッチするものがある。次の式で @w{@samp{¥¥w+}} は
一つ以上の単語構成文字にマッチし、@w{@samp{¥¥W*}} は零個以上の非単語構成
文字にマッチする。

@example
¥¥(¥¥(¥¥w+¥¥)¥¥W*¥¥)¥¥1
@end example

@noindent
が、これも役に立たない。

次に私が使っているものを挙げる。これは完全ではないが、十分使いものになる。
@w{@samp{¥¥b}} は単語の始まりもしくは終わりの空文字列にマッチし、
@w{@samp{[^@@ ¥n¥t]+}} は一つ以上の @@ マーク、空白、改行、もしくはタブの
いずれでもない文字の連続にマッチする。

@example
¥¥b¥¥([^@@ ¥n¥t]+¥¥)[ ¥n¥t]+¥¥1¥¥b
@end example

もっと複雑な式を書くことも出来るが、私自身はこの式で十分であると分ったの
で、これを使っている。

以下が @code{the-the} 関数である。これを使いやすいキーバインディングと共に 
@file{.emacs} ファイルに記述している。

@example
@group
(defun the-the ()
  "Search forward for for a duplicated word."
  (interactive)
  (message "Searching for for duplicated words ...")
  (push-mark)
@end group
@group
  ;; This regexp is not perfect
  ;; but is fairly good over all:
  (if (re-search-forward
       "¥¥b¥¥([^@@ ¥n¥t]+¥¥)[ ¥n¥t]+¥¥1¥¥b" nil 'move)
      (message "Found duplicated word.")
    (message "End of buffer")))
@end group

@group
;; Bind `the-the' to  C-c ¥
(global-set-key "¥C-c¥¥" 'the-the)
@end group
@end example

@sp 1
以下がテスト用の文章である。

@example
@group
one two two three four five
five six seven
@end group
@end example

関数定義の中の正規表現を上に挙げた他の正規表現で置き換えて、このリストの
上で試してみることも出来る。

@node Kill Ring, Full Graph, the-the, Top
@appendix Kill リングの扱い
@cindex Kill ring handling
@cindex Handling the kill ring
@cindex Ring, making a list like a

kill リングは @code{rotate-yank-pointer} の働きによってリングの形態に変
換されたリストである。@code{yank} 及び @code{yank-pop} コマンドは 
@code{rotate-yank-pointer} 関数を利用している。この Appendix では、
@code{yank} や @code{yank-pop} と共に、@code{rotate-yank-pointer} 関数も
説明することにする。

@menu
* rotate-yank-pointer::         リストの中でのポインタの移動と巡回
* yank::                        切り取ったテキストを貼り付ける
* yank-pop::                    ポインタが指しているテキストを貼り付ける
@end menu

@node rotate-yank-pointer, yank, Kill Ring, Kill Ring
@comment  node-name,  next,  previous,  up
@appendixsec 関数 @code{rotate-yank-pointer}
@findex rotate-yank-pointer

@code{rotate-yank-pointer} 関数は @code{kill-ring-yank-pointer} が指す 
kill リングの要素を変更する。例えば、今まで 
@code{kill-ring-yank-pointer} が二番目の要素を指していたなら、それを三番
目の要素に変更する。

これが @code{rotate-yank-pointer} のコードである。

@example
@group
(defun rotate-yank-pointer (arg)
  "Rotate the yanking point in the kill ring."
  (interactive "p")
  (let ((length (length kill-ring)))

    (if (zerop length)

        ;; @r{then-part}
        (error "Kill ring is empty")
@end group
@group

      ;; @r{else-part}
      (setq kill-ring-yank-pointer
            (nthcdr (% (+ arg
                          (- length
                             (length
                              kill-ring-yank-pointer)))
                       length)
                    kill-ring)))))
@end group
@end example

この関数は複雑そうに見えるが、いつも通り幾つかの部分に分けて考えると、
すっきりと理解出来る。最初に骨組みを見てみよう。

@example
@group
(defun rotate-yank-pointer (arg)
  "Rotate the yanking point in the kill ring."
  (interactive "p")
  (let @var{変数リスト}
    @var{本体}@dots{})
@end group
@end example

この関数は @code{arg} という引数を一つ取る。また、簡単な説明文字列がつい
ており、小文字の @samp{p} によりインタラクティブ宣言されている。これは、
引数が処理された前置引数であり、数として関数に渡されなければならないこと
を意味している。

関数定義の本体は @code{let} 式であり、これは変数リスト @var{varlist} と
本体部分からなる。変数は @code{length} と呼ばれ、kill リングの要素の数に
バインドされる。この数は、@code{length} という関数によって調べられる。
(この関数が、変数 @code{length} と同じ名前であることに注意しよう。にもか
かわらず一方では関数名として使われ、もう片方は変数名として使われている。
この二つはきちんと区別されている。同様に、英語を話す人々は @samp{ship} 
という単語の意味を "I must ship this package immediately." という時と "I
must get aboard the ship immediately." という時で区別している。)

関数 @code{length} はリストの中の要素の数を教えてくれるものである。従っ
て、@code{(length kill-ring)} は kill リングの中の要素の数を返すことにな
る。

@menu
* rotate-yk-ptr body::          @code{rotate-yank-pointer} の本体
@end menu

@node rotate-yk-ptr body,  , rotate-yank-pointer, rotate-yank-pointer
@comment  node-name,  next,  previous,  up
@appendixsubsec @code{rotate-yank-pointer} の本体

@code{rotate-yank-pointer} は @code{let} 式であり、@code{let} の本体は、
@code{if} 式である。

この @code{if} 式は、kill リングに何か要素があるかどうかを見るためのもの
である。もし kill リングが空なら @code{error} 関数がこの関数の評価を止め
て、エコー領域にメッセージを表示する。一方、もし kill リングが空でなかっ
た場合は、この関数の残りの仕事が実行される。

以下が、この @code{if} 式の if-part と then-part である。

@findex zerop
@findex error
@example
@group
(if (zerop length)                      ; @r{if-part}
    (error "Kill ring is empty")        ; @r{then-part}
  @dots{}
@end group
@end example

@noindent
もし kill リングに何もなければその長さは零であるから、ユーザに対して 
@samp{Kill ring is empty} というエラーメッセージが表示される。上の 
@code{if} 式では、値が零かどうかの判定に @code{zerop} を使っている。これ 
はテスト対象が零であれば真を返す関数である。もし @code{zerop} テストが真
であれば、@code{if} 式の then-part が評価される。then-part は関数 
@code{error} から始まるリストである。この関数は @code{message} 関数と似
ていて(@ref{message, , 関数 @code{message}}, 参照)、一行メッセージをエコー
領域に表示するのだが、それだけではなくて @code{error} が埋め込まれている
関数の評価を停止する働きも持っている。今の場合、もし kill リングの長さが
零であれば関数の残りの部分は評価されないということになる。

(個人的な意見では、少なくとも人間にとっては、この関数に `error' という用
語を使うのはちょっと誤解を招きやすい気がする。例えば `cancel' という用語
の方がよりしっくりくる。勿論厳密に言えば長さを持たないリストの要素を指す
ことは出来ないし、ましてや指す位置を巡回させることなど出来ない。だから、
計算機の視点に立てば `error' という言葉は全く正しい。しかし人間の立場か
らすると、こういったことをしたいのは kill リングが空かそうでないかを見る
場合だけである。これは一種の調査でしかない。

人間の視点から見ると、調査や発見という行為は必ずしもエラーではない。従っ
て、たとえ計算機の世界の奥底にいる場合でもエラーと呼ぶべきではない。もし
そうだとしたら、Emacs のコードは、正しい態度で自らの環境を調査している人
がエラーを犯していると言っていることになってしまうからだ。これではまずい。
いくら、計算機の方がエラーが起きた場合と同じステップを取ることになるとは
いっても、`cancel' の方がより正しい語感を持っていると言えよう。)

@menu
* rotate-yk-ptr else-part::     @code{if} 式の else-part
* Remainder Function::          剰余関数 @code{%}
* rotate-yk-ptr remainder::     @code{rotate-yank-pointer} での @code{%} の利用
* kill-rng-yk-ptr last elt::    最後の要素を指している場合
@end menu

@node rotate-yk-ptr else-part, Remainder Function, rotate-yk-ptr body, rotate-yk-ptr body
@unnumberedsubsubsec @code{if} 式の else-part

@code{if} 式の else-part は kill リングが空でない場合の 
@code{kill-ring-yank-pointer} の設定に費やされている。コードは以下の通り
である。

@example
@group
(setq kill-ring-yank-pointer
      (nthcdr (% (+ arg
                    (- length
                       (length kill-ring-yank-pointer)))
                 length)
              kill-ring)))))
@end group
@end example

これにはちょっと説明が必要だろう。まず @code{kill-ring-yank-pointer} が 
kill リングの何番目かの @sc{cdr} に設定されるべきであるというのはいいだ
ろう。これには以前説明した @code{nthcdr} 関数を使う。
(@ref{copy-region-as-kill}, 参照。) しかし、実際にはどうしたらいいのだろ
うか。

細かいコードを見る前に、まず @code{rotate-yank-pointer} の目的を考えてみ
よう。

@code{rotate-yank-pointer} 関数は、@code{kill-ring-yank-pointer} が指す
場所を変更する。もし @code{kill-ring-yank-pointer} がリストの最初の要素
を指している状態から出発した場合、@code{rotate-yank-pointer} を呼び出す
と、これが二番目の要素を指すことになる。そして更に 
@code{rotate-yank-pointer} を呼び出すと、三番目に移る。(また、
@code{rotate-yank-pointer} に1より大きな引数を与えて呼び出すと、その数だ
け指す位置が移動される。)

@code{rotate-yank-pointer} 関数は @code{setq} を使って 
@code{kill-ring-yank-pointer} が指す位置をリセットしている。もし 
@code{kill-ring-yank-pointer} が kill リングの最初の要素を指していたなら、
単純な場合、@code{rotate-yank-pointer} 関数は二番目の要素を指さなければ
ならない。別の言い方をすると、@code{kill-ring-yank-pointer} は kill リン
グの @sc{cdr} に等しい値に再設定されなければならないのである。

@need 1250
即ち、

@example
@group
(setq kill-ring-yank-pointer
   ("some text" "a different piece of text" "yet more text"))

(setq kill-ring
   ("some text" "a different piece of text" "yet more text"))
@end group
@end example

@noindent
という状況では、コードは

@example
(setq kill-ring-yank-pointer (cdr kill-ring))
@end example

@noindent
となるべきである。結果として、@code{kill-ring-yank-pointer} は次のように
なっていなければならない。

@example
@group
kill-ring-yank-pointer
     @result{} ("a different piece of text" "yet more text"))
@end group
@end example

実際の @code{setq} 式では @code{nthcdr} 関数が使われている。

以前見たように (@ref{nthcdr}, 参照)、@code{nthcdr} 関数はリストの 
@sc{cdr} を繰り返し取ることによって動作する。これは @sc{cdr} の @sc{cdr} 
の @dots{} の @sc{cdr} を取る、ということである。

次の二つのＳ式は同じことをやっている。

@example
@group
(setq kill-ring-yank-pointer (cdr kill-ring))

(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
@end group
@end example

しかし @code{rotate-yank-pointer} 関数では、@code{nthcdr} の最初の引数の
所に何やら算数が使われていて、複雑そうに見える。

@example
@group
(% (+ arg
      (- length
         (length kill-ring-yank-pointer)))
   length)
@end group
@end example

これを理解するには、いつもの通りまずネストの一番深い所にあるＳ式から順に
見ていく必要がある。

もっとも深い所にあるＳ式は @code{(length kill-ring-yank-pointer)} である。
これは、現在の @code{kill-ring-yank-pointer} の長さを調べるものだ。
(@code{kill-ring-yank-pointer} は値がリストであるような変数の名前である
ことを思い出そう。)

この長さを測定するＳ式は、次のＳ式の中に埋め込まれている。

@example
(- length (length kill-ring-yank-pointer))
@end example

@noindent
このＳ式の中の最初の @code{length} は、この関数の最初の @code{let} 式の
局所変数の宣言の部分で kill リングの長さに設定された変数である。(この 
@code{length} という変数は @code{length-of-kill-ring} と名付けた方が解り
やすいのではないかという人も居るかもしれない。しかし、ここでやっているよ
うに小さい部分に切り分けたりせずに、関数全体を眺めてみれば、短いが故に面
倒でないということが実感出来るだろう。)

従って、@code{(- length (length kill-ring-yank-pointer))} という行で、
kill リングの長さと @code{kill-ring-yank-pointer} という名前のリストの長
さの差を知ることが出来る。

これが @code{rotate-yank-pointer} 関数の中にどう組み込まれているかを見る
ために、まず @code{kill-ring-yank-pointer} が kill リングの最初の要素を
指している場合、つまり、kill リング全体である場合に、
@code{rotate-yank-pointer} を引数1で呼び出すとどうなるかを分析してみるこ
とにしよう。

この場合は、変数 @code{length} と @code{(length kill-ring-yank-pointer)} 
の長さは同じである。というのは、変数 @code{length} の値は kill リングの
長さであり、@code{kill-ring-yank-pointer} は kill リング全体を指している
からである。結果として、

@example
(- length (length kill-ring-yank-pointer))
@end example

@noindent
の値は零になる。引数として1を与えているので、

@example
(+ arg (- length (length kill-ring-yank-pointer)))
@end example

@noindent
全体の値は1になる。

そうすると、@code{nthcdr} の引数としては次の式の値が渡されることになる。

@example
(% 1 length)
@end example

@node Remainder Function, rotate-yk-ptr remainder, rotate-yk-ptr else-part, rotate-yk-ptr body
@unnumberedsubsubsec 剰余関数 @code{%}

@code{(% 1 length)} を理解するには、@code{%} が何かを知らねばならない。
説明文字列によると (これは @kbd{C-h f @key{%} @key{RET}} とタイプすると
見ることが出来る)、@code{%} 関数は最初の引数を二番目の引数で割った余りを
返す関数であることが分る。例えば5を2で割った余りは1である。(2は5の中に二
つ含まれていて、残りが1ということである。)

あまり算数を知らない人の中には、ある数をその数よりも大きな数で割ることが
出来て、しかも余りまで求まると聞くとびっくりする人も多い。上の例では5を2
で割ったのだが、これを逆にして、2を5で割るとどうなるだろうか。もし分数を
使えれば、答えは明らかに2/5もしくは0.4である。が、ここでは整数しか使えな
いので、これとは違う答えにならなければならない。明らかに5は2の中に零個し
か含まれていない。が、残りはいくつだろう。答えを知るために、子供の頃から
親しんでいる場合を考えてみよう。

@itemize @bullet
@item
5を5で割ると、商は1で、余りは0であり、

@item
6を5で割ると、商は1で、余りは1であり、

@item
7を5で割ると、商は1で、余りは2である。 

@item
同様に、10を5で割ると、商は2で、余りは0であり、

@item
11を5で割ると、商は2で、余りは1であり、

@item
12を5で割ると、商は2で、余りは2である。
@end itemize

@need 1250
@noindent
これと全く同じように考えれば、

@itemize @bullet
@item
0を5で割ると、余りは0であり、

@item
1を5で割ると、余りは1であり、

@item
2を5で割ると、余りは2であり、
@end itemize

@noindent
という具合になる。

@need 1250
従って、今回のコードでは、もし @code{length} の値が5であれば、

@example
(% 1 5)
@end example

@noindent
を評価した結果は1になる。(これは、カーソルを上の式の最後に持っていって 
@kbd{C-x C-e} とタイプすれば確かめられる。ちゃんとエコー領域に1が表示さ
れるはずだ。)

@node rotate-yk-ptr remainder, kill-rng-yk-ptr last elt, Remainder Function, rotate-yk-ptr body
@unnumberedsubsubsec @code{rotate-yank-pointer} の中での @code{%} の利用

@code{kill-ring-yank-pointer} が kill リングの最初を指しており、かつ 
@code{rotate-yank-pointer} の引数として1が渡された場合、@code{%} 式が返
す値は1になる。

@example
@group
(- length (length kill-ring-yank-pointer))
     @result{} 0
@end group
@end example

@need 1250
@noindent
故に、

@example
@group
(+ arg (- length (length kill-ring-yank-pointer)))
     @result{} 1
@end group
@end example

@need 1250
@noindent
であり、結果として @code{length} の値に関係無く

@example
@group
(% (+ arg (- length (length kill-ring-yank-pointer)))
   length)
     @result{} 1
@end group
@end example

@noindent
となる。

@need 1250
@noindent
以上から、この場合の @code{setq kill-ring-yank-pointer} 式は、

@example
(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
@end example

@noindent
のようになる。これを見れば、やっていることは一目瞭然だ。
@code{kill-ring-yank-pointer} の指す位置を kill リングの最初の要素ではな
く二番目の要素にセットするのである。

また、@code{rotate-yank-pointer} に渡す引数を2にすれば 
@code{kill-ring-yank-pointer} は @code{(nthcdr 2 kill-ring)} にセットさ
れることも明らかだろう。他の引数を与えた場合も同様である。

同じように、もし @code{kill-ring-yank-pointer} が kill リングの二番目の
要素からスタートした場合、その長さは kill リングの長さより1少ない値にな
り、また余りの計算は @code{(% (+ arg 1) length)} である。従って、引数1で 
@code{rotate-yank-pointer} を評価すると、@code{kill-ring-yank-pointer} 
は kill リングの二番目の要素から三番目の要素を指すように変更される。

@node kill-rng-yk-ptr last elt,  , rotate-yk-ptr remainder, rotate-yk-ptr body
@unnumberedsubsubsec 最後の要素を指している場合

最後の問題は、@code{kill-ring-yank-pointer} が kill リングの最後の要素を
指していた場合にどうなるかである。kill リングにはもう何も残っていないの
で、@code{rotate-yank-pointer} は何も指さない状態になるのだろうか。答え
は No である。実際にはもっと都合の良い結果になる。
@code{kill-ring-yank-pointer} は kill リングの最初の要素を指すようにセッ
トされるのである。

コードを見てどのように動作するのかを見てみることにしよう。取り敢えず 
kill リングの長さは5とし、@code{rotate-yank-pointer} に渡す引数は1である
とする。@code{kill-ring-yank-pointer} が kill リングの最後の要素を指して
いる場合、その長さは1である。コードは次のようになっている。

@example
(% (+ arg (- length (length kill-ring-yank-pointer))) length)
@end example

@need 1250
上の式の中の変数を実際の数値で置き換えると、式は次のようになる。

@example
(% (+ 1 (- 5 1)) 5)
@end example

@noindent
このＳ式をもっとも内側の式から外側に向かって見ていこう。@code{(- 5 1)} 
の値は4である。@code{(+ 1 4)} という和は5になる。そして、5を5で割った余
りは0である。従って @code{rotate-yank-pointer} では、

@example
(setq kill-ring-yank-pointer (nthcdr 0 kill-ring))
@end example

@noindent
というＳ式を評価することになる。これは、@code{kill-ring-yank-pointer} を 
kill リングの最初の要素を指すようにセットするものである。

従って、@code{rotate-yank-pointer} を続けて呼び出すと、
@code{kill-ring-yank-pointer} を kill リングの最初の値から順に移動してい
き、最後の要素まで来たらまた最初に戻るというふうになる。そしてこれこそが 
kill リングがリングと呼ばれる所以である。最後まで来たらまた最初に戻るの
で、あたかもリストには終わりがないように見えるのだ！ (訳註：原文では最後
に "And what is a ring, but an entity with no end?" という文が続く。これ
はどう訳したものだろう？)

@node yank, yank-pop, rotate-yank-pointer, Kill Ring
@comment  node-name,  next,  previous,  up
@appendixsec @code{yank}
@findex yank

@code{rotate-yank-pointer} について学んだ後では、@code{yank} 関数のコー
ドは全く易しく見えるだろう。これには一箇所だけトリッキーな部分がある。
@code{rotate-yank-pointer} に渡す引数の計算の所だ。

@need 1250
コードは以下の通りである。

@example
@group
(defun yank (&optional arg)
  "Reinsert the last stretch of killed text.
More precisely, reinsert the stretch of killed text most 
recently killed OR yanked.
With just C-u as argument, same but put point in front 
(and mark at end).  With argument n, reinsert the nth 
most recently killed stretch of killed text.
See also the command ¥¥[yank-pop]."
@end group
@group

  (interactive "*P")
  (rotate-yank-pointer (if (listp arg) 0
                         (if (eq arg '-) -1
                           (1- arg))))
  (push-mark (point))
  (insert (car kill-ring-yank-pointer))
  (if (consp arg)
      (exchange-point-and-mark)))
@end group
@end example

このコード全体を眺めてみると、最後の数行だけでもほぼ十分なことが分る。ま
ずマークがプッシュされる。つまり、位置が記憶される。そして、
@code{kill-ring-yank-pointer} が指すリストの最初の要素 (即ち @sc{car}) 
が挿入される。更に、もし関数に渡された引数がコンスセルであれば、ポイント
とマークが交換され、ポイントは挿入されたテキストの最後ではなく最初の位置
に置かれる。このオプションは説明文字列の中で説明されている。関数そのもの
はオプション @code{"*P"} でインタラクティブ宣言されている。これは、書き
込み不可のバッファでは動作せず、未処理の前置引数が関数に渡されるという指
定である。

@menu
* rotate-yk-ptr arg::           @code{rotate-yank-pointer} に引数を渡す
* rotate-yk-ptr negative arg::  負の引数を渡す
@end menu

@node rotate-yk-ptr arg, rotate-yk-ptr negative arg, yank, yank
@unnumberedsubsubsec 引数の渡し方

@code{yank} で難しいのは @code{rotate-yank-pointer} に渡される引数の計算
を理解する部分である。幸いなことに、これは見た目程難しいわけではない。

やっていることは、二つある @code{if} 式の片方ないしは両方を評価し、結果
として得られた数値を @code{rotate-yank-pointer} に引数として渡すというこ
とである。

@need 1250
コードをコメント付きで見やすいように書くと、次のようになる。

@example
@group
(if (listp arg)                         ; @r{if-part}
    0                                   ; @r{then-part}
  (if (eq arg '-)                       ; @r{else-part, 内部の if}
      -1                                ; @r{内部の if の then-part}
    (1- arg))))                         ; @r{内部の if の else-part}
@end group
@end example

@noindent
このコードは二つの @code{if} 式からなる。一つはもう一方の else-part になっ
ている。

最初の外側の @code{if} 式は @code{yank} に渡された引数がリストであるかど
うかのテストである。奇妙なことに、@code{yank} が引数無しで呼び出された場
合にはこれは真になる。理由は、この場合省略可能な引数の値として 
@code{nil} が渡されるのだが、@code{(listp nil)} は真になるからである！ 
従って、もし @code{yank} を引数無しで呼び出すと @code{yank} の内部の 
@code{rotate-yank-pointer} には引数として零が渡される。これは、
@code{kill-ring-yank-pointer} が指すリストは変化せず、その最初の要素が挿
入されることを意味する。これは、期待通りの動作である。同様に、もし 
@code{yank} が引数 @kbd{C-u} で呼び出されたとすると、これもリストだと見
倣され、またもや @code{rotate-yank-pointer} には零が渡される。(@kbd{C-u} 
は処理されない前置引数 @code{(4)} を生成するため。) 同時に、この引数はこ
の関数の後の部分でコンスセルと見倣されるので、ポイントは挿入されたテキス
トの始めに、マークは終わりに置かれる。(@code{interactive} の @code{P} と
いう引数は、オプションの引数が渡されなかった場合や @code{C-u} が渡された
場合に上で述べたような値を与えるように設計されている。)

ということで、引数無しの場合や引数が @kbd{C-u} の場合は、外側の 
@code{if} 式の then-part が扱う。そして、その他の場合は else-part が扱う。
else-part はそれ自身が @code{if} 式になっている。

内部の @code{if} 式は、引数が負の符号かどうかを判定するテストである。(こ
れは @key{META} キーと @kbd{-} キーを同時に押すか、@key{ESC} キーを押し
てから @kbd{-} キーを押すと発生する。) この場合、
@code{rotate-yank-pointer} 関数に渡される引数は @kbd{-1} になる。これは、
@code{kill-ring-yank-pointer} の指す位置を一つ手前に戻すことになり、期待
通りの動作となる。

もし内部の @code{if} 式の真偽テストが偽であったなら (つまり引数が負の符
号でなければ)、このＳ式の else-part が評価される。これは、@code{(1-
arg)} という式である。二つの @code{if} 式から、この場合になるのは引数が
正の数であるか、もしくは (単に負の符号だけではない) 負の数である場合のみ
である。@code{(1- arg)} はその数から1を引いた値を返す。(@code{1-} は引数
を1減らす関数である。) これは、もし @code{yank} の引数が1だったとすると、
それが0になるということである。従って、@code{kill-rotate-yank-pointer} 
の最初の要素がヤンクされる。これも期待通りである。

@node rotate-yk-ptr negative arg,  , rotate-yk-ptr arg, yank
@unnumberedsubsubsec 負の引数を渡すとどうなるか

最後に、幾つかの疑問が湧く。もし「剰余関数」@code{%} や @code{nthcdr} 
関数に負の引数を与えたとするとどうなるだろうか。

答えはちょっと実験してみれば分る。@code{(% -1 5)} を評価すると、負の引数
が返る。また、@code{nthcdr} が負の引数と共に呼び出されると、最初の引数が
零であった場合と同じ値が返る。これは次のコードを評価すれば確かめられる。

以下では、@samp{@result{}} の後に書かれているものがその前のコードを評価
した結果である。評価するには、いつものようにコードの直後にカーソルを置い
て @kbd{C-x C-e} (@code{eval-last-sexp}) とタイプすると良い。これは、こ
の文書を GNU Emacs の Info の中で読んでいる場合にはそのまま実行出来る。

@example
@group
(% -1 5)
     @result{} -1
@end group

@group
(setq animals '(cats dogs elephants))
     @result{} (cats dogs elephants)
@end group

@group
(nthcdr 1 animals)
     @result{} (dogs elephants)
@end group

@group
(nthcdr 0 animals)
     @result{} (cats dogs elephants)
@end group

@group
(nthcdr -1 animals)
     @result{} (cats dogs elephants)
@end group
@end example

従って、負の符号や負の数が @code{yank} に渡された場合には、
@code{kill-rotate-yank-pointer} は逆向きに周り、リストの最初に辿りつくと、
そのまま止まるという結果になる。正の引数を与えた場合のように、一番最後ま
で行くとまた最初に戻るというふうにはならず、そこで止まってしまうわけである。
これは合理的な動作である。ヤンクする際は、直前に切り取ったテキストをヤン
クしたい場合が最も多く、普通は30回も前に kill したテキストを挿入しようと
は思わないだろう。だから、リングの中を順に進んでいって一番最後まで行くこ
とはあっても、後から最初の方に戻ろうとして、また一番最後に戻ってしまうな
んてことは、あって欲しくないに違いない。

ついでにいっておくと、負の符号がついた数が @code{yank} に引数として渡さ
れる場合は、全て @minus{}1 として扱われる。これは、明らかにプログラムを
単純にするためのものである。kill リングの中を最初の方に向かって一度に二
つ以上もジャンプする必要はないし、負の数の絶対値を決定する関数を書くより
もこっちの方がずっと簡単である。

@node yank-pop,  , yank, Kill Ring
@comment  node-name,  next,  previous,  up
@appendixsec @code{yank-pop}
@findex yank-pop

@code{yank} を理解してしまえば、@code{yank-pop} 関数は簡単に理解出来る。
スペースの節約のために説明文字列を省くと、コードは次の通りである。

@example
@group
(defun yank-pop (arg)
  (interactive "*p")
  (if (not (eq last-command 'yank))
      (error "Previous command was not a yank"))
@end group
@group
  (setq this-command 'yank)
  (let ((before (< (point) (mark))))
    (delete-region (point) (mark))
    (rotate-yank-pointer arg)
@end group
@group
    (set-mark (point))
    (insert (car kill-ring-yank-pointer))
    (if before (exchange-point-and-mark))))
@end group
@end example

この関数は、小文字の @samp{p} でインタラクティブ宣言されている。従って、
前置引数は処理されてから関数に渡される。このコマンドは、直前にヤンクを行っ
た場合にのみ有効である。そうでなければ、エラーメッセージが出される。この
チェックは変数 @code{last-command} で行う。(これについては他の所で説明し
た。@ref{copy-region-as-kill}, 参照。)

@code{let} 式では、変数 @code{before} を、ポイントがマークの前にあるか後
にあるかによって真もしくは偽にセットする。そして、ポイントとマークの間の
リージョンを削除する。これは、直前のヤンクによって挿入されたリージョンで
あり、置き換えようとしている部分である。次に 
@code{kill-ring-yank-pointer} を回して直前に挿入したテキストがまた挿入さ
れないようにする。マークは新しいテキストが挿入されるべき部分にセットされ、
@code{kill-ring-yank-pointer} が指すリストの最初の要素が挿入される。その
結果、ポイントは新しく挿入されたテキストの直後に置かれる。ここで、もし前
回のヤンクでポイントが挿入されたテキストの前に置かれていたならポイントと
マークを交換して、ポイントを今回挿入したテキストの最初の位置に移動する。
これがこの関数でやっていることの全てである！

@node Full Graph, Index, Kill Ring, Top
@appendix ラベルと軸が付いたグラフ

座標軸を描くと、グラフを理解する手助けになる。目盛もつけたい。以前の章で
は (@ref{Readying a Graph, ,  グラフを描く準備}, 参照) グラフの本体を描
くコードを書いたのであった。ここではその本体にそって縦軸と横軸を表示し、
ラベルをつけるコードを書くことにしよう。

@menu
* Labelled Example::            最終的なグラフはどんな形になるか
* print-graph Varlist::         @code{print-graph} の中の @code{let} 式
* print-Y-axis::                縦軸のラベルの表示
* print-X-axis::                横軸のラベルの表示
* Print Whole Graph::           完全なグラフを表示する関数
@end menu

@node Labelled Example, print-graph Varlist, Full Graph, Full Graph
@ifinfo
@heading ラベルのついたグラフのサンプル
@end ifinfo

ここでの挿入は、バッファのポイントの下方を右方向に向って埋めていくので、
新しいグラフ表示関数では、まず Y 軸ないしは縦軸を表示し、ついで本体を、
そして最後に X 軸ないしは横軸を表示するという順番になる。この流れから、
関数の中身のレイアウトは次のような感じになる。

@enumerate
@item
コードの下準備。

@item
Y 軸の表示。

@item
グラフ本体の表示。

@item
X 軸の表示。
@end enumerate

以下に出来上がったグラフの例がどうあるべきかを載せておく。

@example
@group
    10 -          
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
@end group
@end example

@noindent
このグラフでは、縦軸と横軸には数によるラベルがついている。しかしながら、
グラフの種類によっては横軸が時間で、月によるラベルをつけた方が良い場合も
多いだろう。次のような感じだ。

@example
@group
     5 -      * 
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
         Jan  June   Jan
@end group
@end example

実際には、ちょっと考えれば横軸や縦軸について様々な形式を思いつく。複雑な
関数にすることも可能だ。しかし複雑さは混乱を招く。それよりも、最初は単純
な形式を選んで、後でそれを修正ないしは置き換えるのが良いだろう。

以上のことを考慮すると、次のようなアウトラインで @code{print-graph} 関数
を書いていくのがいいだろう。

@example
@group
(defun print-graph (numbers-list)
@c   "@var{documentation}@dots{}"
  "@var{説明文字列}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end example

この @code{print-graph} 関数の雛型を元にして、各々の部分を順に書いていく
ことにしよう。

@node print-graph Varlist, print-Y-axis, Labelled Example, Full Graph
@comment  node-name,  next,  previous,  up
@appendixsec @code{print-graph} の変数リスト
@cindex @code{print-graph} varlist

@code{print-graph} 関数を書く際に、まずやらなければならないことは、
@code{let} 式の変数リストを書くことである。(取り敢えず、インタラクティブ
式や説明文字列のことは置いておく。)

変数リストでは幾つかの値を設定しなければならない。縦軸のラベルの一番上は
少なくともグラフの高さでなくてはいけないので、まずこれについての情報が必
要になる。@code{print-graph-body} 関数でもこの情報が必要だったことを思い
出そう。同じ計算を別の場所で二度行う理由はどこにもないので、以前定義した 
@code{print-graph-body} を書き換えてこの計算を一度だけにするべきである。

同様に、X 軸のラベルを表示する関数と @code{print-graph-body} 関数のどち
らにおいても記号の幅の値を知る必要がある。これも以前の章の 
@code{print-graph-body} の定義を書き換えて、最初に計算をすませてしまうべ
きであろう。

横軸のラベルの長さは少なくともグラフの長さの分はなければならない。しかし、
この情報は横軸を表示する関数だけに必要なものである。従って、ここでやらな
くとも良い。

以上のことから、@code{print-graph} の @code{let} 式の変数リストは次のよ
うな感じになる。

@example
@group
(let ((height (apply 'max numbers-list)) ; @r{最初のバージョン}
      (symbol-width (length graph-blank)))
@end group
@end example

@noindent
が、後で見るように、これではちょっとまずい。

@node print-Y-axis, print-X-axis, print-graph Varlist, Full Graph
@comment  node-name,  next,  previous,  up
@appendixsec 関数 @code{print-Y-axis}
@cindex Axis, print vertical
@cindex Y axis printing
@cindex Vertical axis printing
@cindex Print vertical axis

@code{print-Y-axis} 関数の仕事は、縦軸として次のようなラベルを表示するこ
とである。

@example
@group
    10 -
        
        
        
        
     5 -
        
        
        
     1 -
@end group
@end example

@noindent
この関数には、グラフの高さを渡してやる必要がある。それを元に適切な目盛と
数を構成し、挿入するわけである。

図で見ると、Y 軸のラベルがどうなるべきかは一目瞭然である。しかし、これを
言葉で表しその仕事をする関数を書くとなると、少々ややこしくなる。単に5行
ごとに数や目盛をつければよいというのは間違いである。@samp{1} と @samp{5} 
の間には三行しかない (2、3、4行)。しかし、@samp{5} と @samp{10} の間には
四行ある (6、7、8、9行)。まずは一行目にベースとなる行として数1と目盛をつ
け、その他に最下行から5行ごとに目盛と数をつけていく方がよいだろう。

次の問題は、ラベルの高さをどうするかである。例えば、グラフの縦の列の中で
最も高いものの高さが7だったとしよう。この場合、最も上のラベルは 
@samp{5 -} にして、グラフを上に突き出させるべきだろうか。それとも7以上の
最大の5の倍数として @samp{10 -} の所までラベルを付けるべきだろうか。

これは後者の方がよいだろう。大抵のグラフは長方形のなかに描かれており、側
面は刻み幅の整数倍になっている。今の場合なら、5、10、15というふうな5の倍
数である。しかし、縦軸の仕様としてこのようなものを採用するとなると、以前
の関数の変数リストでの、単純に高さを計算するＳ式ではまずいことに気付く。
これは @code{(apply 'max numbers-list)} というものだったが、これでは単に
正確なグラフの縦の列の高さの最大値が出るだけで、5の倍数になるような調整
はしてはくれない。もっと複雑な関数が必要なわけである。

いつものことだが、複雑な問題も幾つかの小さな問題に分割して考えれば単純
な問題になることが多い。

最初に、いつグラフの高さが5の整数倍になるかを考えてみよう。これは5、10、
15等の5の倍数の時である。この場合は、この値を即、Y 軸の高さとしてよい。

ある数が5の倍数になるかどうかを見るには、この数を5で割ってみて、余りがど
うなるかを見るのが早い。もし余りが無ければ、その数は5の倍数である。7の場
合は余りが2になるので、これは5の倍数ではない。ちょっと言い方を変えて小学
校ふうに説明するなら、5は7の中に一回だけ含まれて、残りは2になる。一方、5
は10の中には2回含まれ、残りはない。従って、10は5の倍数ということになる。

@menu
* Compute a Remainder::         割った余りの計算方法
* Y Axis Element::              Y 軸の各行の構成
* Y-axis-column::               Y 軸のラベルのリストの生成
* print-Y-axis Final::          縦軸の表示、最終版
@end menu

@node Compute a Remainder, Y Axis Element, print-Y-axis, print-Y-axis
@appendixsubsec 寄り道: 剰余の計算

@findex % @r{(remainder function)}
@cindex Remainder function, @code{%}
Lisp では余りを計算する関数は @code{%} である。この関数は最初の引数を二
番目の引数で割った時の余りを返す。あいにく、@code{%} という Emacs Lisp 
関数は @code{apropos} では見つけられない。つまり、@kbd{M-x apropos
@key{RET} remainder @key{RET}} とすると、何も見つけられない。@code{%} と
いう関数の存在を知るためにはこの文書などの本を見るか、Emacs Lisp のソー
スを眺めるしか方法がない。@code{%} 関数は @code{rotate-yank-pointer} の
中で使われており、これは次の所で説明されている。
(@ref{rotate-yk-ptr body, , @code{rotate-yank-pointer} の本体}, を参照。)

@code{%} 関数を試してみるには、次の二つのＳ式を評価してみると良い。

@example
@group
(% 7 5)

(% 10 5)
@end group
@end example

@noindent
最初のＳ式は2を返すし、二番目のＳ式は0を返す。

返された値が0かそうでないかのテストには @code{zerop} 関数が使える。この
関数は引数として数値を取り、それが零なら @code{t} を返す。

@example
@group
(zerop (% 7 5))
     @result{} nil

(zerop (% 10 5))
     @result{} t
@end group
@end example

というわけで、次のようなＳ式を書けば、高さが5で割切れる場合には @code{t} 
が返される。

@example
(zerop (% height 5))
@end example

@noindent
(@code{height} の値は勿論 @code{(apply 'max numbers-list)}. で分る。)

一方、もし @code{height} が5の倍数でない場合、値が5の倍数になるように再
設定する必要がある。これは既にお馴染みの関数を使えば単純な算数にすぎない。
まずは @code{height} を5で割ってこの中に何回5が含まれるかを調べる。例え
ば12なら2回含まれる。この値に1加えて5倍すれば、棒グラフの最大の高さより
も大きい最初の5の倍数が得られる。5は12の中には2回含まれるので、これに1を
足して5倍すると15が求まる。これが12を越える最初の5の倍数であ。この作業を
行うＳ式は次の通りである。

@example
(* (1+ (/ height 5)) 5)
@end example

@noindent
例えばもし次のＳ式を評価したなら、結果は15になる。

@example
(* (1+ (/ 12 5)) 5)
@end example

これまでの議論では「5」を Y 軸についての目盛幅としてきたわけだが、ここは
他の値を使っても構わない。一般性のために、5を他の値も設定出来るように変
数で置き換えよう。私としては、この変数は @code{Y-axis-label-spacing} と
名付けるのが良いと思う。この変数と @code{if} 式を使うと、次のＳ式が出来
る。

@example
@group
(if (zerop (% height Y-axis-label-spacing))
    height
  ;; @r{else}
  (* (1+ (/ height Y-axis-label-spacing))
     Y-axis-label-spacing))
@end group
@end example

@noindent
このＳ式は、もし @code{height} が @code{Y-axis-label-spacing} の値の倍数
なら @code{height} の値そのものを返し、そうでない場合は、それより大きい
最小の @code{Y-axis-label-spacing} の倍数の値を計算して返す。

それでは、このＳ式を @code{print-graph} 関数の中の @code{let} 式の中に 
(@code{Y-axis-label-spacing} の設定の後で) 埋め込んでみよう。

@vindex Y-axis-label-spacing

@example
@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
@dots{}
(let* ((height (apply 'max numbers-list))
       (height-of-top-line
        (if (zerop (% height Y-axis-label-spacing))
            height
@end group
@group
          ;; @r{else}
          (* (1+ (/ height Y-axis-label-spacing))
             Y-axis-label-spacing)))
       (symbol-width (length graph-blank))))
@dots{}
@end group
@end example

@noindent
(@code{let*} 関数を使っていることに注意。始めに変数 height の初期値が
@code{(apply 'max numbers-list)} 式で計算され、その値を使って他の変数の
値を計算しているためである。@code{let*} についての詳細は、次を参照。
@ref{fwd-para let, , @code{let＊} 式}.)

@node Y Axis Element, Y-axis-column, Compute a Remainder, print-Y-axis
@appendixsubsec Y 軸の要素の構成

縦軸を表示する際には、@w{@samp{5 -}} とか @w{@samp{10 -}} 等を5行ごと
に挿入したい。更に、数は下の部分を揃えたい。つまり、小さな桁の数は、前に
空白を置くことになる。もし二桁の数が出てきた時には、一桁の数の先頭には一
つの空白を置くことになるわけである。

@findex int-to-string
数の長さを求めるには、@code{length} 関数が使われる。しかし、
@code{length} 関数は文字列に対してしかうまく動作せず、数値は扱えない。そ
こでまず、数を数値から文字列に変換する必要がある。これは、
@code{int-to-string} 関数を使って行うことが出来る。例えば、次のような感
じである。

@example
@group
(length (int-to-string 35))
     @result{} 2

(length (int-to-string 100))
     @result{} 3
@end group
@end example

更に、各ラベルにおいて、各々の数には @w{@samp{ - }} のような文字列を付け
加えたい。これを、@code{Y-axis-tic} マーカと呼ぶことにしよう。この変数は、
@code{defvar} を使って定義する。

@vindex Y-axis-tic
@example
@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group
@end example

Y ラベルの長さは、Y axis tick mark とグラフの一番上の数の桁数の和になる。

@example
(length (concat (int-to-string height) Y-axis-tic)))
@end example

この値は、@code{print-graph} 関数の中の変数リストの所で、
@code{full-Y-label-width} の値として計算される。(我々が最初にこの関数を
考えた時には、この関数は変数リストの中に入れることは考えていなかったこと
に注意しよう。)

縦軸を完成させるには、目盛記号を数と結合する必要がある。そして、その前に
は数の桁数によって空白が付いたりする。というわけで、ラベルには三つのパー
トがあることになる。先頭の空白 (無い場合もある)、数、そして目盛記号であ
る。この関数には、指定された行に対する数の値と一番上の行の幅が渡される。
これらの値は @code{print-graph} によって (一回だけ) 計算される。

@example
@group
(defun Y-axis-element (number full-Y-label-width) 
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces 
         (- full-Y-label-width
            (length
             (concat (int-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (int-to-string number)
     Y-axis-tic)))
@end group
@end example

@code{Y-axis-element} 関数は、(もしあれば) 先頭の空白と、文字列としての
数と、目盛記号を結合するものである。

先頭にいくつ空白をつければよいかは、ラベルの実質部分の長さ---数の長さと
目盛記号の長さの和---を望まれるラベルの長さから引くことで求められる。

@findex make-string
空白は @code{make-string} 関数を使って挿入される。この関数は、二つの引数
を取る。一つは文字列の長さ、もう一つは特定の形式で書かれた挿入する文字の
シンボルである。今の場合、この形式は @samp{? } のように、疑問符に続く空
白という形をしている。このような文字の表し方についての説明は、次を参照。
@ref{Character Type, , Character Type, elisp, The GNU Emacs Lisp
Reference Manual}.

@code{int-to-string} 関数は、結合式の中で数を文字列に変換するために使わ
れている。文字列に変換してから先頭の空白と目盛記号と結合するのである。

@node Y-axis-column, print-Y-axis Final, Y Axis Element, print-Y-axis
@appendixsubsec Y 軸全体の構成

前節までの関数で、縦軸のラベルとして挿入する番号と空白のついた文字列の
リストを生成する関数を構成するのに必要なツールが全て揃う。

@findex Y-axis-column
@example
@group
(defun Y-axis-column (height width-of-label)
  "Construct list of Y axis labels and blank strings.
For HEIGHT of line above base and WIDTH-OF-LABEL."
  (let (Y-axis)
@group
@end group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{ラベル挿入}
          (setq Y-axis
                (cons
                 (Y-axis-element height width-of-label)
                 Y-axis))
@group
@end group
        ;; @r{そうでなければ空白挿入}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
    ;; @r{ベースライン挿入}
    (setq Y-axis
          (cons (Y-axis-element 1 width-of-label) Y-axis))
    (nreverse Y-axis)))
@end group
@end example

この関数では、まず @code{height} の値から出発してその値を一つずつ減らし
ていき、各々の引き算が終わった所でその値が @code{Y-axis-label-spacing} 
の整数倍になっているかどうかを判定する。そして、もしそうなっていれば、
@code{Y-axis-element} 関数を使って番号付きのラベルを作成し、そうでなけれ
ば @code{make-string} 関数を使って空白のラベルを作成する。最下行は、番号
1と目盛記号からなっている。

@node print-Y-axis Final,  , Y-axis-column, print-Y-axis
@appendixsubsec @code{print-Y-axis} 最終版

(訳註：題名に最終版と書いてあるが、実際には @ref{Print Whole Graph, ,
グラフ全体の表示}, に出ているものが真の最終版である。原文ではここに最終版
が載っていたのだが、そうすると、中で使っている @code{y-axis-column} 関数
が最終版でないために、その次に述べられているテストでエラーが出てしまう。)

@code{Y-axis-column} 関数によって構成されたリストは @code{print-Y-axis} 
関数に渡される。これが実際にそのリストを挿入する。

@findex print-Y-axis
@example
@group
(defun print-Y-axis
  (height full-Y-label-width)
@c  (height full-Y-label-width &optional vertical-step)
  "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the  maximum height of the graph.
Full width is the width of the highest label element."
@c Bug ここではまだ、Y-axis-column に vertical-step は定義されてない。
@c Optionally, print according to VERTICAL-STEP."
;; Value of height and full-Y-label-width 
;; are passed by `print-graph'.
@end group
@group
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width))
@c Bug
@c     (Y-axis-column height full-Y-label-width vertical-step))
    ;; @r{グラフ挿入の準備としてポイントを移動}
    (goto-char start)      
    ;; full-Y-label-width @r{の値の分だけポイントを前方に移動} 
    (forward-char full-Y-label-width)))
@end group
@end example

@code{print-Y-axis} は @code{Y-axis-column} によって作成された Y 軸のラ
ベルを挿入するのに @code{insert-rectangle} を使っている。更に、グラフの
本体部分を挿入するための適切な位置にポイントを移動している。

以下のようにして @code{print-Y-axis} をテストしてみることが出来る。

@enumerate 
@item 
まず次の変数や関数をインストールする。

@example
@group
Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
@end group
@end example
@c (訳註：この節には @code{Y-axis-label-spacing} は出てきていないので、便宜
@c 上、再掲しておくことにする。他のものは、この節を最初から読んでおればイン
@c ストールされているはずである。)
@c 
@c @example
@c @group
@c (defvar Y-axis-label-spacing 5
@c   "Number of lines from one Y axis label to next.")
@c @end group
@c @end example

@item
次のＳ式をコピーする。

@example
(print-Y-axis 12 5)
@end example

@item
@file{*scratch*} バッファに移り、カーソルを縦軸のラベルを挿入したい位置
まで移動する。

@item
@kbd{M-:} (@code{eval-expression}) とタイプする。(訳註：Emacs 19.28 ベー
スの Mule では @kbd{M-@key{ESC}}.)

@item
@code{print-Y-axis} 式をミニバッファに @kbd{C-y} (@code{yank}) を使っ
てヤンクする。

@item
このＳ式を評価するために @key{RET} を押す。
@end enumerate

Emacs はラベルを縦に表示する。一番上は @w{@samp{10 -@w{ }}} である。
(@code{print-graph} 関数は、@code{height-of-top-line} の値を渡すのだが、
今の場合これは15である。) (訳註：ここは原文も混乱しているみたいである。
@code{print-Y-axis} は @code{print-graph} の中で使われている。その中では 
@code{print-Y-axis} に第一引数として渡されるのは 
@code{height-of-top-line} の値なのであるが、@code{print-graph} 関数の中
の局所変数としての @var{height} の値が12で @var{Y-axis-label-spacing} の
値が5だったとすると、この @code{height-of-top-line} の値が15になるという
ことを言いたかったのであろう。詳しくは最終版 @code{print-graph} を参照の
こと。)

@node print-X-axis, Print Whole Graph, print-Y-axis, Full Graph
@appendixsec 関数 @code{print-X-axis}
@cindex Axis, print horizontal
@cindex X axis printing
@cindex Print horizontal axis
@cindex Horizontal axis printing

X 軸のラベルは Y 軸のラベルと大変似ている。違うのは、目盛記号が数の上に
のっていることである。ラベルは次のようになる。

@example
@group
    |   |    |    |
    1   5   10   15
@end group
@end example

最初の目盛はグラフの最初の桁の下の部分にきており、その前には幾つかの空
白がある。これらの空白は、Y 軸のラベルが上に来る部分である。二番目、三番
目、四番目、あるいはそれに続く目盛は全て等間隔で並んでいる。この間隔は 
@code{X-axis-label-spacing} の値で決まる。

X 軸の二行目は、空白に続く数からなる。この数字の間隔もまた 
@code{X-axis-label-spacing} の値による。

変数 @code{X-axis-label-spacing} の値そのものは @code{symbol-width} とい
う単位を元に決められるべきである。棒グラフを表示するためのシンボルの幅を
変更する時に、ラベルの付け方まで変えなければならないなんて事態は避けたい
だろう。

@code{print-X-axis} 関数は多かれ少なかれ @code{print-Y-axis} 関数と同じ
形をしている。違うのは、目盛の行と数字の行の二行あるということである。こ
の二つは各々別の関数で書いて、@code{print-X-axis} の中で一緒にすることに
する。

以下が、これから行う三段階のステップである。

@enumerate
@item
X 軸の目盛記号を表示する関数 @code{print-X-axis-tic-line} を書く。

@item
X 軸の数字を表示する関数 @code{print-X-axis-numbered-line} を書く。

@item
この @code{print-X-axis-tic-line} と 
@code{print-X-axis-numbered-line} を使って、上の二つの行を両方とも表示す
る関数 @code{print-X-axis} を書く。
@end enumerate

@menu
* X Axis Tic Marks::            横軸に目盛記号を入れる
@end menu

@node X Axis Tic Marks,  , print-X-axis, print-X-axis
@appendixsubsec X 軸の目盛記号

最初の関数では、X 軸の目盛記号を表示する。まずは、目盛記号とその間の記号
を指定しないといけない。

@example
@group
(defvar X-axis-label-spacing 
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end example

@noindent
(@code{graph-blank} の値はまた別の @code{defvar} で設定されることに注意
しよう。@code{boundp} という述語は、既に何かの値がセットされているかどう
かを判定するものである。もし何もセットされていなければ、@code{boundp} は 
@code{nil} を返す。もし @code{graph-blank} が設定されず、また、この条件
分岐式がなかったとすると、@code{Symbol's value as variable is void} とい
うエラーメッセージを受けとることになる。

@example
@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group
@end example

@need 1250
目標は、次のような行を作成することである。

@example
       |   |    |    |
@end example

最初の目盛は、Y 軸のラベルのためのスペースを空けるためにインデントされた
最初の棒グラフの開始の桁と同じだけインデントしないといけない。

目盛の要素は、ある目盛から次の目盛までのスペースと目盛記号からなる。空白
の数は目盛記号の幅と @code{X-axis-label-spacing} から決まる。

@need 1250
コードは次の通りである。

@example
@group
;;; X-axis-tic-element
@dots{}
(concat  
 (make-string 
  ;; @r{空白の文字列を作成}
  (-  (* symbol-width X-axis-label-spacing)
      (length X-axis-tic-symbol))
  ? )
 ;; @r{空白を目盛記号と結合}
 X-axis-tic-symbol)
@dots{}
@end group
@end example

次に、最初の目盛をグラフの開始位置までインデントするために、どれだけ空白
が要るかを数える必要がある。これには、@code{print-graph} 関数によって渡
された @code{full-Y-label-width} の値を利用する。

@need 1250
@code{X-axis-leading-spaces} を作るためのコードは次の通りである。

@example
@group
;; X-axis-leading-spaces
@dots{}
(make-string full-Y-label-width ? )
@dots{}
@end group
@end example

また、横軸の長さも決めなければならない。これは、数のリストの長である。
更に、横軸の目盛の数も決める必要がある。

@example
@group
;; X-length 
@dots{}
(length numbers-list)              
@end group

@group
;; tic-width
@dots{}
(* symbol-width X-axis-label-spacing)
@end group

@group
;; number-of-X-tics 
(if (zerop (% X-length tic-width))
    (/ X-length tic-width)
  (1+ (/ X-length tic-width)))
@end group
@end example

@need 1250
これらを使うと、X 軸の目盛の行を表示する関数は次のようになる。

@findex print-X-axis-tic-line
@example
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print tics for X axis." 
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{最初の桁の下に}
@end group
@group
    ;; @r{右の位置に二番目の目盛記号を挿入}
    (insert (concat  
             (make-string 
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{二番目の目盛記号まで空白を挿入}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{残りの目盛記号を挿入}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end example

数字の行も同様にして簡単に書ける。

@need 1250
まずは前に空白の付いた番号を作成する。

@findex X-axis-element
@example
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces 
         (-  (* symbol-width X-axis-label-spacing)
             (length (int-to-string number)))))
    (concat (make-string leading-spaces ? )
            (int-to-string number))))
@end group
@end example

次に、数字のついた行を表示するための関数を作る。これはまず最初の桁に数 
``1'' を付けるところから始まる。

@findex print-X-axis-numbered-line
@example
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing))
    (insert X-axis-leading-spaces)
    (insert "1")
@end group
@group
    (insert (concat  
             (make-string 
              ;; @r{次の数字の所まで空白を挿入}
              (-  (* symbol-width X-axis-label-spacing) 2)
              ? )
             (int-to-string number)))
@end group
@group
    ;; @r{残りの数字を挿入}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element number))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end example

最後に、@code{print-X-axis-tic-line} と 
@code{print-X-axis-numbered-line} を使って、@code{print-X-axis} を書く。

この関数では @code{print-X-axis-tic-line} と 
@code{print-X-axis-numbered-line} の両方で使われている局所変数の値を決定
してから、これらの関数を呼び出さなければならない。また、二つの行の区切り
に復帰コードを表示する必要もある。

この関数は、5つの局所変数を指定する変数リストと二つの行を表示する関数の
呼び出しからなる。

@findex print-X-axis
@example
@group
(defun print-X-axis (numbers-list)
  "Print X axis labels to length of NUMBERS-LIST."
  (let* ((leading-spaces 
          (make-string full-Y-label-width ? ))
@end group
@group
       ;; symbol-width @r{は} graph-body-print @r{で与えられる。}
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat  
         (make-string 
@end group
@group
          ;; @r{空白の文字列を作成}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{空白を目盛記号と結合}
         X-axis-tic-symbol))
@end group
@group
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group
@group
    (print-X-axis-tic-line tic-number leading-spaces X-tic)
    (insert "¥n")
    (print-X-axis-numbered-line tic-number leading-spaces)))
@end group
@end example

@need 1250
これで、@code{print-X-axis} のテストが出来る。

@enumerate 
@item 
まずは @code{X-axis-tic-symbol},  @code{X-axis-label-spacing},
@code{print-X-axis-tic-line}, などの変数とともに @code{X-axis-element},
@code{print-X-axis-numbered-line}, @code{print-X-axis} という関数をイン
ストールする。

@item
次のＳ式をコピーする。

@example
@group
(progn
 (let ((full-Y-label-width 5)
       (symbol-width 1))
   (print-X-axis
    '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
@end group
@end example

@item
@file{*scratch*} バッファに移り、カーソルを軸のラベルを表示したい位置に
まで動かす。

@item
@kbd{M-:} (@code{eval-expression}) とタイプする。(訳註：Emacs 19.28 ベー
スの Mule では @kbd{M-@key{ESC}}.)

@item
@kbd{C-y} (@code{yank)} を使って、テストのＳ式をヤンクする。

@item
その式を評価するために、@key{RET} を押す。
@end enumerate

@need 1250
これで Emacs は次のような横軸を表示してくれるはずだ。

@example
@group
     |   |    |    |    |
     1   5   10   15   20
@end group
@end example

@node Print Whole Graph,  , print-X-axis, Full Graph
@appendixsec グラフ全体の表示
@cindex Printing the whole graph
@cindex Whole graph printing
@cindex Graph, printing all

さて、これでグラフ全体を表示する準備が整った。

きちんとしたラベルが付いたグラフを表示する関数を書く際には、以前作成した 
アウトラインに従うわけだが (@ref{Full Graph, , ラベルと軸の付いたグラフ}, 
参照)、幾つか追加することがある。

@need 1250
アウトラインは以下のようなものだった。

@example
@group
(defun print-graph (numbers-list)
  "@var{説明文字列}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end example

最終的なバージョンは、上の計画とは二つの点で違っている。まず、変数リスト
の中で追加して計算するものがある。次に、ラベルの増加のさせ方を指定するオ
プションがある。後者の特徴はかなり本質的である。そうしないことには、画面
や紙面に合わなくなってしまう可能性があるからだ。

この新しい特徴を実現するには、@code{Y-axis-column} 関数にいくらか変更を
加えて @code{vertical-step} という変数を加える必要がある。同時に、
@code{print-Y-axis} も書き換える。新しい関数は次のようになる。

@findex Y-axis-column @r{Final version.}
@example
@group
;;; @r{最終バージョン。}
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.  
WIDTH-OF-LABEL is maximum width of label.
VERTICAL-STEP, an option, is a positive integer 
that specifies how much a Y axis label increments 
for each line.  For example, a step of 5 means 
that each line is five units of the graph."
@end group
@group
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
@end group
@group
          ;; @r{ラベルの挿入}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{そうでない場合は, 空白の挿入}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{ベースラインの挿入}
    (setq Y-axis (cons (Y-axis-element 
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end example

@findex print-Y-axis @r{Final version.}
@example
@group
;;; @r{最終バージョン。}
(defun print-Y-axis
  (height full-Y-label-width &optional vertical-step)
  "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the  maximum height of the graph.
Full width is the width of the highest label element.
Optionally, print according to VERTICAL-STEP."
;; Value of height and full-Y-label-width 
;; are passed by `print-graph'.
@end group
@group
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width vertical-step))
    ;; @r{Place point ready for inserting graph.}
    (goto-char start)      
    ;; @r{Move point forward by value of} full-Y-label-width
    (forward-char full-Y-label-width)))
@end group
@end example


グラフの最大の高さの値とシンボルの幅は @code{print-graph} の中の 
@code{let} 式によって計算される。従って、@code{graph-body-print} はそれ
らを受け取ることが出来るように変更しなければならない。

@findex graph-body-print @r{Final version.}
@example
@group
;;; @r{最終バージョン。}
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{各桁ごとにグラフを描写}
      (sit-for 0)               
      (setq numbers-list (cdr numbers-list)))
    ;; @r{X 軸のラベルのためにポイントを移動}
    (forward-line height)
    (insert "¥n")))
@end group
@end example

@need 1250
最後に、@code{print-graph} 関数のコードを載せておこう。

@findex print-graph @r{Final version.}
@example
@group
;;; @r{最終バージョン。}
(defun print-graph
  (numbers-list &optional vertical-step)
  "Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units."
@end group
@group
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{は最大の数でもあり、}
         ;; @r{最大桁の数でもある。}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
@end group
@group
           (concat
            (int-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group

@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
@end group
@group
    (graph-body-print
     numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list)))
@end group
@end example

@menu
* Test print-graph::            簡単なテスト
* Graphing words in defuns::    最終的なコードの実行
* Final Printed Graph::         これがグラフだ！
@end menu

@node Test print-graph, Graphing words in defuns, Print Whole Graph, Print Whole Graph
@appendixsubsec @code{print-graph} のテスト

@need 1250
@code{print-graph} 関数を短い数のリストで試してみよう。

@enumerate 
@item 
(他のコードに加えて) @code{Y-axis-column}、@code{print-Y-axis}、
@code{graph-body-print}、そして @code{print-graph} の各最終バージョンを
インストールする。

@item
次のＳ式をコピーする。

@example
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end example

@item
@file{*scratch*} バッファに移り、カーソルをグラフを表示したい位置にまで
移動する。

@item
@kbd{M-:} (@code{eval-expression}) とタイプする。(訳註：Emacs 19.28 ベー
スの Mule では @kbd{M-@key{ESC}}.)

@item
@kbd{C-y} (@code{yank}) を使って、上のＳ式をミニバッファにヤンクする。

@item
このＳ式を評価するために @kbd{RET} を押す。
@end enumerate

@need 1250
Emacs は次のようなグラフを表示する。

@example
@group
10 -              
                  
                  
         *        
        **   *    
 5 -   ****  *    
       **** ***   
     * *********  
     ************ 
 1 - *************

     |   |    |    |
     1   5   10   15
@end group
@end example

一方、次のＳ式を評価して @code{print-graph} に @code{vertical-step} とし
て2を与えてみたとする。

@example
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
@end example

@need 1250
@noindent
するとグラフは次のようになるはずだ。

@example
@group
20 -              
                  
                  
         *        
        **   *    
10 -   ****  *    
       **** ***   
     * *********  
     ************ 
 2 - *************

     |   |    |    |
     1   5   10   15
@end group
@end example

@noindent
(疑問：横軸の左の `2' はバグだろうか、仕様だろうか。もしバグであると思う
のなら、そして `2' ではなく `1' であるべきだと思うのなら (あるいは `0' 
であるべきだと思うのなら)、ソースを修正すればよい。)

@node Graphing words in defuns, Final Printed Graph, Test print-graph, Print Whole Graph
@appendixsubsec 単語やシンボルの数のグラフ化

さて、やっと目的のグラフの所まで来た。いよいよ単語やシンボルの数が10より
少ない関数定義がどれだけあるか、10から19までの間だとどれだけか、20から29
までだとどうか、といったことを示してくれるグラフを描く関数を書くわけであ
る。

これは幾つかのプロセスに分けて行う。まずは、必要なコードを全てロードし
てあることを確認しよう。

異なる値を設定してしまった場合に備えて、@code{top-of-ranges} の値を再設
定しておく方がよいだろう。それには以下を評価すればよい。

@example
@group
(setq top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
@end group
@end example

@noindent
次に、各々の範囲に入っている単語やシンボルの数のリストを作成しよう。

@need 1500
@noindent
まず次を評価する。

@example
@group
(setq list-for-graph
       (defuns-per-range
         (sort
          (recursive-lengths-list-many-files 
           (directory-files "/usr/local/emacs/lisp"
                            t ".+el$"))
          '<)
         top-of-ranges))
@end group
@end example

@noindent
私の機械では、これに一時間程かかった。私の持っている Emacs version 19.23 
だと303の Lisp ファイルを見ていることになる。この計算の後では、
@code{list-for-graph} の値は次のようになる。

@example
@group
(537 1027 955 785 594 483 349 292 224 199 166 120 116 99 
90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
@end group
@end example

@noindent
これは、私の Emacs には10以下の単語やシンボルしか持たない関数定義が537個
あり、10以上19未満の単語やシンボルを持つものが1,027個、20から29までだと
955個、などというふうになっていることを示している。

このリストから明らかに見て取れることは、殆どの関数定義では、中に含まれる
単語やシンボルの数は、10から30までだということである。

さて、これをグラフに表示することにしよう。我々は、1,030行もの高さのグラ
フは描きたく@emph{ない}。そうではなく、25行以下程度のグラフを描きたいの
である。この高さのグラフであれば、大抵のモニタで表示出来るだろう。また、
紙にも印刷しやすい。

これは、今の場合、@code{list-for-graph} の各々の値を50分の1に縮小しない
といけないということである。

この操作をやってくれる簡単な関数を、以下に挙げる。この関数には、今までに 
出てこなかった二つの関数 @code{mapcar} と @code{lambda} が出てくる。

@example
@group
(defun one-fiftieth (full-range)
  "Return list, each number one-fiftieth of previous."
 (mapcar '(lambda (arg) (/ arg 50)) full-range))
@end group
@end example

@menu
* lambda::                      無名関数の書き方
* mapcar::                      要素のリストに関数を作用させる
* Another Bug::                 でもまだバグが潜んでいる @dots{}
@end menu

@node lambda, mapcar, Graphing words in defuns, Graphing words in defuns
@unnumberedsubsubsec @code{lambda} 式
@cindex Anonymous function
@findex lambda

@code{lambda} は無名関数、即ち名前のない関数のシンボルである。無名関数を
使う場合には毎回本体を全て含めて書かなければならない。

@need 1250
@noindent
従って、

@example
(lambda (arg) (/ arg 50))
@end example

@noindent
であれば、常に @code{arg} として渡されたものを50で割った値を返す、という
関数定義になる。

例えば、以前、@code{multiply-by-seven} 関数というのを説明したことがある。
これは引数を7倍するものであった。今回の関数も同様である。異なる点は、引
数を50で割るということと、名前がないということだけである。
@code{multiply-by-seven} を無名関数で書き直すと次のようになる。

@example
(lambda (number) (* 7 number))
@end example

@noindent
(@ref{defun, , 特殊形式 @code{defun}}, を参照。)

@need 1250
@noindent
もし3を7倍したいなら、次のように書くことが出来る。

@c !!! Clear if machine is too small and cannot handle all 10 figures.
@c lear print-postscript-figures
@c set print-postscript-figures
@c lambda example diagram #1
@ifinfo
@example
@group
(multiply-by-seven 3)
 ＼_____________／ ↑
         |         │
      function  argument
@end group
@end example
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@example
@group
(multiply-by-seven 3)
 ¥_______________/ ^
         |         |
      function  argument
@end group
@end example
@end iftex
@end ifclear

@noindent
このＳ式は21を返す。

@need 1250
@noindent
同様に、次のようにも書ける。

@c lambda example diagram #2
@ifinfo
@example
@group
((lambda (number) (* 7 number)) 3)
 ＼__________________________／ ↑
               |                │
      anonymous function     argument
@end group
@end example
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@example
@group
((lambda (number) (* 7 number)) 3)
 ¥____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end example
@end iftex
@end ifclear

@need 1250
@noindent
100を50で割る場合は次のように書く。

@c lambda example diagram #3
@ifinfo
@example
@group
((lambda (arg) (/ arg 50)) 100)
 ＼_____________________／  ↑
             |              │
    anonymous function    argument
@end group
@end example
@end ifinfo
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@example
@group
((lambda (arg) (/ arg 50)) 100)
 ¥______________________/  ¥_/
             |              |
    anonymous function   argument
@end group
@end example
@end iftex
@end ifclear

@noindent
このＳ式は2を返す。上の100は関数に渡されるもので、その数を関数が50で割っ
ているのである。

@code{lambda} についてのより詳しいことは、@ref{Lambda Expressions, ,
Lambda Expressions, elisp, The GNU Emacs Lisp Reference Manual}, を参照
せよ。Lisp や lambda 式は、Lambda 計算から派生したものである。

@node mapcar, Another Bug, lambda, Graphing words in defuns
@unnumberedsubsubsec 関数 @code{mapcar}
@findex mapcar

@code{mapcar} は最初の引数を二番目の引数の各々の要素にともに、順に呼び出
す関数である。二番目の引数はシーケンス (sequence) でないといけない。

@need 1250
@noindent
例えば、

@example
@group
(mapcar '1+ '(2 4 6))
     @result{} (3 5 7)
@end group
@end example

@noindent
という感じである。関数 @code{1+} は引数に1を加える関数であるが、これがそ
の後のリストの各要素について実行され、新しいリストを返すわけである。

これを @code{apply} と比較してみよう。こちらは最初の要素に対し、二番目以
降の全ての引数を引数として渡して実行させるものだった。(@code{apply} の説
明については @ref{Readying a Graph, , グラフを描く準備}, を参照。)

@need 1250
@code{one-fiftieth} の定義では、最初の引数は、

@example
(lambda (arg) (/ arg 50))
@end example

@noindent
という無名関数である。また、二番目の引数は @code{full-range} であり、こ
れは @code{list-for-graph} にバインドされる。

@need 1250
Ｓ式全体は次の通りである。

@example
(mapcar '(lambda (arg) (/ arg 50)) full-range))
@end example

@code{mapcar} についての詳細は @ref{Mapping Functions, , Mapping
Functions, elisp, The GNU Emacs Lisp Reference Manual}, を参照。

@code{one-fiftieth} 関数を使うと、各々の要素が、対応する 
@code{list-for-graph} の要素の50分の1であるようなリストを生成することが
出来る。

@example
@group
(setq fiftieth-list-for-graph
      (one-fiftieth list-for-graph))
@end group
@end example

@need 1250
結果として出来るリストは次のようになる。

@example
@group
(10 20 19 15 11 9 6 5 4 3 3 2 2 
1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
@end group
@end example

@noindent
これは、今すぐにでも表示出来そうである！ (もっともここで情報が失われてい
ることにも気付く。上の方の範囲の多くの要素は0である。これは、その範囲の
単語やシンボルを持つ関数定義の数が50未満であることを示しているだけであっ
て、そういう関数定義が全くないといっているわけではない。)

@node Another Bug,  , mapcar, Graphing words in defuns
@unnumberedsubsubsec まだバグがある@dots{}
@cindex Bug, most insidious type
@cindex Insidious type of bug

私は、「今すぐにでも表示出来そう」と書いた。勿論、@code{print-graph} に
はバグがあるのだ@dots{} これには @code{vertical-step} オプションがあるが、
@code{horizontal-step} オプションはない。@code{top-of-range} の範囲は、
10ごとに10から300まである。しかし、@code{print-graph} は1ずつしか表示出
来ない。

これは、ある人々が最も見つけにくいタイプのバグだと考えている、考慮不足に
よるバグ (訳註：原文では bug of omission. これはどう訳すべきか) の古典的
な例である。これは、コードを調べることで見つかるようなバグではない。コー
ド自体に誤りはないからだ。これは単に何かが欠落しているということである。
このようなバグに対するもっとも正しい態度は、プログラムをなるべく早く、何
回もテストしてみることである。そして、コードを出来るだけ理解しやすく簡単
に変更出来るようにアレンジしていくのである。また、一度書いたものは、すぐ
にではなくともいつかは書き換えられるものだということを頭に入れておくよう
にしよう。これはなかなか実行が困難な格言ではあるが。

作業対象となるのは @code{print-X-axis-numbered-line} 関数である。また、
@code{print-X-axis} と @code{print-graph} もそれに合わせて書き換える必要
がある。もっともやることはそれ程多いわけではない。一つだけ面倒な部分があ
る。数字が目盛記号の下に綺麗に並ばなければならないということである。この
点はちょっとばかし頭をひねる必要がある。

@need 1250
以下が修正した @code{print-X-axis-numbered-line} である。

@example
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; @r{頭の余計な空白を削除}
    (delete-char
     (- (1-
         (length (int-to-string horizontal-step)))))
    (insert (concat  
             (make-string 
@end group
@group
              ;; @r{空白を挿入}
              (-  (* symbol-width
                     X-axis-label-spacing) 
                  (1-
                   (length
                    (int-to-string horizontal-step)))
                  2)
              ? )
             (int-to-string
              (* number horizontal-step))))
@end group
@group
    ;; @r{残りの数を挿入}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element
               (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end example

もしあなたがこれを Info の中で読んでいるなら、@code{print-X-axis} と 
@code{print-graph} の新しいバージョンを見ることが出来る。もしこれを印刷
された本で読んでいるとしたら、変更する行が下に書かれているはずだ。(印刷
するにはコードがちょっと多過ぎるので。)

@iftex
@example
@group
(defun print-X-axis (numbers-list horizontal-step)
  @dots{}
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step))
@end group
@end example

@example
@group
(defun print-graph
  (numbers-list
   &optional vertical-step horizontal-step)
  @dots{}
    (print-X-axis numbers-list horizontal-step))
@end group
@end example
@end iftex

@ifinfo
@example
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width 
;; are passed by `print-graph'.
  (let* ((leading-spaces 
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{は} graph-body-print @r{で与えらえる。}
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat  
         (make-string 
          ;; @r{空白の文字列を作成。}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{空白を目盛記号と結合。}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "¥n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end example

@example
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{は最大の数でもあり、}
         ;; @r{最大桁の数でもある。}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (int-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end example
@end ifinfo

@ignore
@c @ifinfo
グラフを表示するための定義を、もう一度書き並べておく。(訳註：原文ではこ
の部分が @@ignore によって無視されるようになっていた。これを訳者の判断で、
Info ではこの部分も表示されるようにした。その方が便利であろうと考える。)

@need 1250
以下が、グラフ表示のための定義の最終的な形である。

@example
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250)
 "List specifying ranges for `defuns-per-range'.")
@end group

@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group

@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group

@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group

@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end example

@example
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group

@group
    (while
        (and (< (point) end)
             (re-search-forward 
              "¥¥(¥¥w¥¥|¥¥s_¥¥)+[^ ¥t¥n]*[ ¥t¥n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end example

@example
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group

@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)   
      (goto-char (point-min))
@end group

@group
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end example

@example
@group
(defun lengths-list-many-files (list-of-files) 
  "Return list of lengths of defuns in LIST-OF-FILES."
  (let (lengths-list)
;;; @r{真偽テスト}
    (while list-of-files        
      (setq lengths-list
            (append
             lengths-list
@end group
@group
;;; @r{長さのリストの生成。}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
;;; @r{ファイルのリストを短くする。}
      (setq list-of-files (cdr list-of-files))) 
;;; @r{長さのリストの最後の値を返す。}
    lengths-list))              
@end group
@end example

@example
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{外側のループ。}
    (while top-of-ranges

      ;; @r{内側のループ。}
      (while (and 
              ;; @r{数値のテストのための数字が必要。}
              (car sorted-lengths) 
              (< (car sorted-lengths) top-of-range))

        ;; @r{現在の範囲内にある長さの定義の数をカウント。}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
@end group

@group
      ;; @r{内側のループは抜けるが外側のループにはまだ入っている。}

      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{カウントを零にリセット。}

      ;; @r{次の範囲に移動。}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{次の範囲の上限の値を指定。}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{外側のループを抜け、最も大きい範囲の上限の値よりも大きな}
    ;; @r{  関数定義の数をカウント。}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))

    ;; @r{最小から最大に向かって、各々の範囲にある関数定義の}
    ;; @r{  数のリストを返す。}
    (nreverse defuns-per-range-list)))
@end group
@end example

@example
@group
(defun column-of-graph (max-graph-height actual-height) 
  "Return list of MAX-GRAPH-HEIGHT strings; 
ACTUAL-HEIGHT are graph-symbols.
The graph-symbols are contiguous entries at the end 
of the list.
The list will be inserted as one column of a graph.  
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))

    ;; @r{@code{graph-symbols} の部分。}
    (while (> actual-height 0)                
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{@code{graph-blanks} の部分。}
    (while (> number-of-top-blanks 0) 
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{リスト全体を返す}
    insert-list))
@end group
@end example

@example
@group
(defun Y-axis-element (number full-Y-label-width) 
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces 
         (- full-Y-label-width
            (length
             (concat (int-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (int-to-string number)
     Y-axis-tic)))
@end group
@end example

@example
@group
(defun print-Y-axis
  (height full-Y-label-width &optional vertical-step)
  "Insert Y axis by HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the  maximum height of the graph.
Full width is the width of the highest label element.
Optionally, print according to VERTICAL-STEP."
@end group
@group
;; Value of height and full-Y-label-width 
;; are passed by `print-graph'.
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width vertical-step))
@end group
@group
    ;; @r{グラフを挿入する準備としてのポイントの移動}
    (goto-char start)      
    ;; full-Y-label-width @r{の値だけポイントを移動}
    (forward-char full-Y-label-width)))
@end group
@end example

@example
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print tics for X axis." 
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{グラフの最初の桁の真下}
@end group
@group
    ;; @r{適切な位置に二番目の目盛記号を挿入}
    (insert (concat  
             (make-string 
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{二番目の目盛記号まで空白を挿入}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{残りの目盛記号を挿入}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end example

@example
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces 
         (-  (* symbol-width X-axis-label-spacing)
             (length (int-to-string number)))))
    (concat (make-string leading-spaces ? )
            (int-to-string number))))
@end group
@end example

@example
@group
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{各列ごとにグラフを挿入}
      (sit-for 0)               
      (setq numbers-list (cdr numbers-list)))
    ;; @r{X 軸のラベルのためにポイントを移動}
    (forward-line height)
    (insert "¥n")))
@end group
@end example

@example
@group
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.  
WIDTH-OF-LABEL is maximum width of label.
@end group
@group
VERTICAL-STEP, an option, is a positive integer 
that specifies how much a Y axis label increments 
for each line.  For example, a step of 5 means 
that each line is five units of the graph."
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
@end group
@group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{ラベルの挿入}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{そうでない場合、空白を挿入}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{ベースラインの挿入}
    (setq Y-axis (cons (Y-axis-element 
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end example

@example
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; line up number 
    (delete-char (- (1- (length (int-to-string horizontal-step)))))
    (insert (concat  
             (make-string 
              ;; @r{次の数まで空白を挿入}
              (-  (* symbol-width X-axis-label-spacing) 
                  (1- (length (int-to-string horizontal-step)))
                  2)
              ? )
             (int-to-string (* number horizontal-step))))
@end group
@group
    ;; @r{残りの数を挿入}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end example

@example
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width 
;; are passed by `print-graph'.
  (let* ((leading-spaces 
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{は} graph-body-print @r{で与えられる}
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat  
         (make-string 
          ;; @r{空白のストリングを作成}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{空白と目盛記号を結合}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "¥n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end example

@example
@group
(defun one-fiftieth (full-range)
  "Return list, each number of which is 1/50th previous."
 (mapcar '(lambda (arg) (/ arg 50)) full-range))
@end group
@end example

@example
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{は最大の数でもあり、}
         ;; @r{最大桁の数でもある。}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (int-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group

    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end example
@end ignore
@c @end ifinfo

@page
@node Final Printed Graph,  , Graphing words in defuns, Print Whole Graph
@appendixsubsec 表示されたグラフ

全てをインストールし終ったら、@code{print-graph} コマンドを次のようにし
て呼び出そう。

@example
@group
(print-graph fiftieth-list-for-graph 50 10)
@end group
@end example

次のようなグラフが表示されるはずだ。

@sp 2

@example
@group
1000 -  *                             
        **                            
        **                            
        **                            
        **                            
 750 -  ***                           
        ***                           
        ***                           
        ***                           
        ****                          
 500 - *****                          
       ******                         
       ******                         
       ******                         
       *******                        
 250 - ********                       
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350
@end group
@end example

@sp 2

最も大きな関数のグループは、10から19までの単語やシンボルを含んでいる
もののグループである。

@node Index, About the Author, Full Graph, Top
@comment  node-name,  next,  previous,  up
@unnumbered Index

@ifinfo
MENU ENTRY: NODE NAME.
@end ifinfo

@printindex cp

@iftex
@c Place biographical information on right-hand (verso) page

@tex
¥ifodd¥pageno 
    ¥par¥vfill¥supereject
    ¥global¥evenheadline={¥hfil} ¥global¥evenfootline={¥hfil}
    ¥global¥oddheadline={¥hfil} ¥global¥oddfootline={¥hfil}
    ¥page¥hbox{}¥page
¥else
    ¥par¥vfill¥supereject
    ¥par¥vfill¥supereject
    ¥global¥evenheadline={¥hfil} ¥global¥evenfootline={¥hfil}
    ¥global¥oddheadline={¥hfil} ¥global¥oddfootline={¥hfil}
    ¥page¥hbox{}¥page
    ¥page¥hbox{}¥page
¥fi
@end tex

@page
@w{ }

@c ================ Biographical information ================

@w{ }
@sp 8
@center About the Author
@sp 1
@end iftex

@ifinfo
@node About the Author,  , Index, Top
@unnumbered About the Author
@end ifinfo

@c @quotation
@c Robert J. Chassell は1985年から GNU Emacs の仕事に携わっている。彼は 
@c Emacs や Emacs Lisp を書き、編集し、教えている。また、@w{Free Software
@c Foundation, Inc.} の理事 (director) であり、秘書/会計係 でもある。彼は社
@c 会や経済の歴史にずっと興味を持ち続けており、また自家用機の手入れが好きで
@c ある。(訳註：この部分の訳は全く自信がないので、原文を以下に載せておく。
@c 間抜けな訳をするんじゃない! というお叱り歓迎。)
@c @end quotation

(訳註：以下は原文をそのまま載せておくことにする。)

@quotation
Robert J. Chassell has worked with GNU Emacs since 1985.  He writes
and edits, teaches Emacs and Emacs Lisp, and is a director and the
Secretary/Treasurer of the @w{Free Software Foundation, Inc.}  He has
an abiding interest in social and economic history and flies his own
airplane.
@end quotation

@page
@w{ }

@c Prevent page number on blank verso, so eject it first.
@tex
¥par¥vfill¥supereject
@end tex

@iftex
@headings off
@evenheading @thispage @| @| @thistitle
@oddheading            @| @| @thispage
@end iftex

@c Keep T.O.C. short by tightening up.
@ifset largebook
@tex
¥global¥parskip 2pt plus 1pt
¥global¥advance¥baselineskip by -1pt
@end tex
@end ifset

@shortcontents
@contents

@bye
