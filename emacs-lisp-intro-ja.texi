\input texinfo                                      @c -*-texinfo-*-
@comment %**start of header
@setfilename ../../info/eintr-ja
@c setfilename emacs-lisp-intro-ja.info
@c sethtmlfilename emacs-lisp-intro-ja.html
@settitle Programming in Emacs Lisp
@syncodeindex vr cp
@syncodeindex fn cp
@finalout

@c メモ：当面は日本語版 TeXInfo 元のTeXInfoを使うので、@ref/@xref の扱いについて注意。

@include emacsver.texi

@c ================ How to Print a Book in Various Sizes ================

@c This book can be printed in any of three different sizes.
@c Set the following @-commands appropriately.

@c     7 by 9.25 inches:
@c              @smallbook
@c              @clear largebook

@c     8.5 by 11 inches:
@c              @c smallbook
@c              @set largebook

@c     European A4 size paper:
@c              @c smallbook
@c              @afourpaper
@c              @set largebook

@c (Note: if you edit the book so as to change the length of the
@c table of contents, you may have to change the value of `pageno' below.)

@c <<<< For hard copy printing, this file is now
@c      set for smallbook, which works for all sizes
@c      of paper, and with PostScript figures >>>>

@c smallbook
@afourpaper
@set largebook

@c ================ Included Figures ================

@c If you clear this, the figures will be printed as ASCII diagrams
@c rather than PostScript/PDF.
@c (This is not relevant to Info, since Info only handles ASCII.)
@set print-postscript-figures
@c clear print-postscript-figures
@clear print-postscript-figures

@comment %**end of header

@c per rms and peterb, use 10pt fonts for the main text, mostly to
@c save on paper cost.
@c Do this inside @tex for now, so current makeinfo does not complain.
@tex
@ifset smallbook
@fonttextsize 10

@end ifset
\global\hbadness=6666 % don't worry about not-too-underfull boxes
@end tex

@c These refer to the printed book sold by the FSF.
@set edition-number 3.10
@set edition-number-ja 0.97
@set update-date 28 October 2009
@set update-date-ja 10 January 2000

@c For next or subsequent edition:
@c   create function using with-output-to-temp-buffer
@c   create a major mode, with keymaps
@c   run an asynchronous process, like grep or diff

@c For 8.5 by 11 inch format: do not use such a small amount of
@c whitespace between paragraphs as smallbook format
@ifset largebook
@tex
\global\parskip 6pt plus 1pt
@end tex
@end ifset

@c For all sized formats:  print within-book cross
@c reference with ``...''  rather than [...]

@c This works with the texinfo.tex file, version 2003-05-04.08,
@c in the Texinfo version 4.6 of the 2003 Jun 13 distribution.

@tex
\if \xrefprintnodename
 \global\def\xrefprintnodename#1{\unskip, ``#1''}
 \else
 \global\def\xrefprintnodename#1{ ``#1''}
\fi
% \global\def\xrefprintnodename#1{, ``#1''}
@end tex

@c ----------------------------------------------------

@dircategory GNU Emacs Lisp
@direntry
* Emacs Lisp Intro: (eintr-ja).
                          A simple introduction to Emacs Lisp programming (japanese).
@end direntry

@copying
これは、初心者のための @cite{『Emacs Lisp によるプログラミング』} の入門
です。
@sp 1
@iftex
Edition @value{edition-number}, @value{update-date}
日本語版 @value{edition-number-ja}, @value{update-date-ja}
@end iftex
@ifnottex
Distributed with Emacs version @value{EMACSVER}.
@end ifnottex
@sp 1
Copyright @copyright{} 1990--1995, 1997, 2001--2013 Free Software
Foundation, Inc.
@sp 1

@iftex
Published by the:@*

GNU Press,               @hfill @uref{http://www.fsf.org/licensing/gnu-press/}@*
a division of the               @hfill email: @email{sales@@fsf.org}@*
Free Software Foundation, Inc.  @hfill Tel: +1 (617) 542-5942@*
51 Franklin Street, Fifth Floor @hfill Fax: +1 (617) 542-2652@*
Boston, MA 02110-1301 USA
@end iftex

@ifnottex
Printed copies available from @uref{http://shop.fsf.org/}. Published by:

@example
GNU Press,                        http://www.fsf.org/licensing/gnu-press/
a division of the                 email: sales@@fsf.org
Free Software Foundation, Inc.    Tel: +1 (617) 542-5942
51 Franklin Street, Fifth Floor   Fax: +1 (617) 542-2652
Boston, MA 02110-1301 USA
@end example
@end ifnottex

@sp 1
ISBN 1-882114-43-4

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; there
being no Invariant Section, with the Front-Cover Texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled ``GNU Free
Documentation License''.

(a) The FSF's Back-Cover Text is: ``You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom.''

この Info ファイルは、Programming in Emacs Lisp (An introduction) 1.05
版の日本語訳です。翻訳元のファイルは GNU の配布の中に含まれている
@file{emacs-lisp-intro-1.05.tar.gz} です。

@end copying

@c half title; two lines here, so do not use `shorttitlepage'
@tex
\font\chapmin=goth10 scaled \magstep3
{\begingroup%
    \hbox{}\vskip 1.5in \chaprm \chapmin
      \centerline{Emacs Lisp によるプログラミング}%
	\endgroup}%
{\begingroup\hbox{}\vskip 0.5in \chaprm \chapmin
      \centerline{初心者のための入門}%
	\endgroup\page\hbox{}\page}
@end tex

@titlepage
@sp 6
@center @titlefont{Emacs Lisp によるプログラミング}
@sp 2
@center @titlefont{初心者のための入門}
@sp 2
@center Revised Third Edition
@center 日本語版 @value{edition-number-ja}, @value{update-date-ja}
@sp 4
@center Robert J. Chassell 著 @ 松田茂樹 訳

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@end iftex

@ifnothtml
@c     Keep T.O.C. short by tightening up for largebook
@ifset largebook
@tex
\global\parskip 2pt plus 1pt
\global\advance\baselineskip by -1pt
@end tex
@end ifset
@end ifnothtml

@shortcontents
@contents

@ifnottex
@node Top
@top An Introduction to Programming in Emacs Lisp

@ifset WWW_GNU_ORG
@html
<p>The homepage for GNU Emacs is at
<a href="/software/emacs/">http://www.gnu.org/software/emacs/</a>.<br>
To view this manual in other formats, click
<a href="/software/emacs/manual/eintr.html">here</a>.
@end html
@end ifset

@insertcopying

This master menu first lists each chapter and index; then it lists
every node in every chapter.
@end ifnottex

@c >>>> Set pageno appropriately <<<<

@c The first page of the Preface is a roman numeral; it is the first
@c right handed page after the Table of Contents; hence the following
@c setting must be for an odd negative number.

@c iftex
@c global@pageno = -11
@c end iftex

@set COUNT-WORDS count-words-example
@c Length of variable name chosen so that things still line up when expanded.

@menu
* Preface::                     この文書の目的
* List Processing::             Lisp って何？
* Practicing Evaluation::       プログラムを走らせる
* Writing Defuns::              関数定義の書き方
* Buffer Walk Through::         バッファに関する幾つかの関数
* More Complex::                もうちょっと難しい関数
* Narrowing & Widening::        Emacs の注意を特定のリージョンにせばめる
* car cdr & cons::              Lisp における基本的な関数
* Cutting & Storing Text::      テキストの削除と保存
* List Implementation::         計算機の上でのリストの扱い
* Yanking::                     蓄えられたテキストのペースト
* Loops & Recursion::           プロセスの繰り返し
* Regexp Search::               正規表現の検索
* Counting Words::              繰り返しと正規表現の復習
* Words in a defun::            @code{defun} の中の単語を数える
* Readying a Graph::            グラフ表示関数の雛型
* Emacs Initialization::        @file{.emacs} ファイルの書き方
* Debugging::                   Emacs Lisp のデバッガの走らせ方
* Conclusion::                  基本はこれでおしまい
* the-the::                     Appendix: だぶった単語を見つけるには
* Kill Ring::                   Appendix: kill リングはどう働いているか？
* Full Graph::                  グラフにラベルを付けるには
* Free Software and Free Manuals::
* GNU Free Documentation License::
* Index::                       
* About the Author::            

@detailmenu
 --- The Detailed Node Listing ---

Preface

* Why::                         なぜEmacs Lispを学ぶのか？
* On Reading this Text::        この文書を読むにあたって
* Who You Are::                 誰のために書かれたものか？
* Lisp History::                Lisp の歴史
* Note for Novices::            初心者の人へ
* Thank You::                   謝辞
* Translator Preface::          訳者まえがき

List Processing

* Lisp Lists::                  リストってなあに？
* Run a Program::               Lisp のリストはすぐに実行出来る
* Making Errors::               エラーを発生させる
* Names & Definitions::         シンボルや関数定義の名前
* Lisp Interpreter::            Lisp インタプリタの動作
* Evaluation::                  プログラムの実行
* Variables::                   変数の値を知る
* Arguments::                   引数：関数に情報を与えるもの
* set & setq::                  変数に値を設定する
* Summary::                     大切なポイント
* Error Message Exercises::     エラーメッセージについての練習問題

Lisp Lists

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  分解不可能な存在
* Whitespace in Lists::         リストを読みやすいよう整形する
* Typing Lists::                GNU Emacs がリストのタイプを助けてくれる

The Lisp Interpreter

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              実行速度を速めるための特殊なコード

Evaluation

* How the Interpreter Acts::    Returns and Side Effects...
* Evaluating Inner Lists::      リストの中のリスト...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               値のないシンボルに対するエラーメッセージ

Arguments

* Data types::                  関数に渡されるデータの型
* Args as Variable or List::    引数には変数の値やリストも使える
* Variable Number of Arguments::  関数の中には、可変な数の引数を扱える
                                ものもある
* Wrong Type of Argument::      関数に間違った型の引数を与えると
* message::                     メッセージを表示する時に便利な関数

Setting the Value of a Variable

* Using set::                   値の設定
* Using setq::                  引用符をつけずに値を設定するには
* Counting::                    カウンタとしての @code{setq} の利用

Practicing Evaluation

* How to Evaluate::             編集コマンドのタイプするか @kbd{C-x C-e}
                                で評価を実行出来る。
* Buffer Names::                バッファとファイルの違い
* Getting Buffers::             バッファ名でなくバッファそのものを呼び出す
* Switching Buffers::           別のバッファに移るには
* Buffer Size & Locations::     ポイントの位置とバッファのサイズ
* Evaluation Exercise::         評価についての練習問題

How To Write Function Definitions

* Primitive Functions::         幾つかの関数は C で書かれている
* defun::                       特殊形式 @code{defun}
* Install::                     関数定義のインストール
* Interactive::                 関数をインタラクティブにする
* Interactive Options::         @code{interactive} の他のオプション
* Permanent Installation::      コードをずっとインストールしておきたい時
* let::                         局所変数の作成と初期化
* if::                          if とは？
* else::                        If--then--else 式
* Truth & Falsehood::           Lisp にとっての真と偽
* save-excursion::              ポイントやマークの位置、及びバッファの保存
* Review::                      復習
* defun Exercises::             関数定義についての練習問題

Install a Function Definition

* Effect of installation::
* Change a defun::              関数定義の変更の仕方

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::  インタラクティブバージョン

@code{let}

* Prevent confusion::
* Parts of let Expression::     @code{let} 式にはどんな部分があるか
* Sample let Expression::       @code{let} 式の例
* Uninitialized let Variables::  初期値をバインドしないとどうなるか

The @code{if} Special Form

* if in more detail::
* type-of-animal in detail::    @code{if} 式の例

Truth and Falsehood in Emacs Lisp

* nil explained::               @code{nil} has two meanings.

@code{save-excursion}

* Point and mark::              A review of various locations.
* Template for save-excursion::  埋めるべきスロットは一つだけ

A Few Buffer--Related Functions

* Finding More::                情報の探し方
* simplified-beginning-of-buffer::  @code{goto-char}, @code{point-min},
                                そして @code{push-mark} を見てみよう
* mark-whole-buffer::           @code{beginning-of-buffer} と殆ど同じ
* append-to-buffer::            @code{save-excursion} と
                                @code{insert-buffer-substring} を使う
* Buffer Related Review::       復習
* Buffer Exercises::            バッファについての練習問題

The Definition of @code{mark-whole-buffer}

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   本体は三行しかない

The Definition of @code{append-to-buffer}

* append-to-buffer overview::
* append interactive::          二つの部分からなるインタラクティブ式
* append-to-buffer body::       @code{let} 式との組み合わせ
* append save-excursion::       @code{save-excursion} はどう働くか

A Few More Complex Functions

* copy-to-buffer::              @code{set-buffer} と @code{get-buffer-create} を利用
* insert-buffer::               書き込み不可 と @code{or} の使い方
* beginning-of-buffer::         @code{goto-char}, @code{point-min}, そし
                                て @code{push-mark} を見てみる
* Second Buffer Related Review::  バッファについての練習問題(その２)
* optional Exercise ::           追加の練習問題

The Definition of @code{insert-buffer}

* insert-buffer code::
* insert-buffer interactive::  書き込み不可の状態の時の動作
* insert-buffer body::          本体には @code{or} と @code{let} がある
* if & or::                     @code{or} の代わりに @code{if} を使う
* Insert or::                   @code{or} 式の動作について
* Insert let::                  二つの @code{save-excursion} 式
* New insert-buffer::

The Interactive Expression in @code{insert-buffer}

* Read-only buffer::            書き込み不可のバッファでは
* b for interactive::

Complete Definition of @code{beginning-of-buffer}

* Optional Arguments::
* beginning-of-buffer opt arg::  省略可能引数の例
* beginning-of-buffer complete::  完全版

@code{beginning-of-buffer} with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::           大きなバッファでの割り算と掛け算
* Small buffer case::           括弧の中に何があるか

Narrowing and Widening

* Narrowing advantages::        ナローイングの利点
* save-restriction::            特殊形式 @code{save-restriction}
* what-line::                   ポイントは今何行目にあるか
* narrow Exercise::             ナローイングの練習問題

@code{car}, @code{cdr}, @code{cons}：基本関数

* Strange Names::               寄り道: 何故こんな名前がついているか
* car & cdr::                   リストの一部を取り出すための関数
* cons::                        リストの構成
* nthcdr::                      @code{cdr} を何回もよびだす
* nth::
* setcar::                      リストの最初の要素の変更
* setcdr::                      リストの残りの要素の変更
* cons Exercise::               cons についての練習問題

@code{cons}

* Build a list::
* length::                      リストの長さを知る

Cutting and Storing Text

* Storing Text::                テキストはリストの中に保存される
* zap-to-char::                 テキストをある文字まで削除する
* kill-region::                 リージョンの削除
* copy-region-as-kill::         テキストの複写の定義
* Digression into C::           Minor note on C programming language macros.
* defvar::                      変数に初期値を与える
* cons & search-fwd Review::    cons と search-forward の復習
* search Exercises::            検索についての練習問題

@code{zap-to-char}

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     三つの部分からなるインタラクティブ式
* zap-to-char body::            ちょっと復習
* search-forward::              文字列検索の仕方
* progn::                       関数 @code{progn} について
* Summing up zap-to-char::      @code{point} と @code{search-forward} を使う

@code{kill-region}

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* Lisp macro::

@code{copy-region-as-kill}

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::    @code{copy-region-as-kill} の本体部分

The Body of @code{copy-region-as-kill}

* last-command & this-command::
* kill-append function::        関数 @code{kill-append}
* kill-new function::

Initializing a Variable with @code{defvar}

* See variable current value::
* defvar and asterisk::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::               List についての練習問題

Yanking Text Back

* Kill Ring Overview::          kill リングはリストである
* kill-ring-yank-pointer::      @code{kill-ring-yank-pointer} 変数について
* yank nthcdr Exercises::       ヤンクと nthcdr についての練習問題

Loops and Recursion

* while::                       特定のコードの繰り返し
* dolist dotimes::
* Recursion::                   再帰: 自分自身を呼び出す関数
* Looping exercise::            ループについての練習問題

@code{while}

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                リストを使った @code{while} ループ
* print-elements-of-list::      @code{while}, @code{car}, @code{cdr} の利用
* Incrementing Loop::           増加するカウンタを使ったループ
* Incrementing Loop Details::
* Decrementing Loop::           減少するカウンタを使ったループ

Details of an Incrementing Loop

* Incrementing Example::        三角形に並んだ小石の数を数えてみる
* Inc Example parts::           関数定義はどんな部分からなるか
* Inc Example altogether::      関数を一つにまとめる

Loop with a Decrementing Counter

* Decrementing Example::        またまた浜辺の小石を数えてみる
* Dec Example parts::           関数定義はどんな部分からなるか
* Dec Example altogether::      関数を一つにまとめる

Save your time: @code{dolist} and @code{dotimes}

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         再帰のテストにリストを使う
* Recursive triangle function::  @code{while} ループを再帰で置き換える
* Recursion with cond::         別の条件分岐を用いた再帰の例
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::  引数が 1 か 2 の場合の再帰関数の動作
* Recursive Example arg of 3 or 4::  引数が 3 か 4 の場合の再帰関数の動作

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                @code{sentence-end} の正規表現
* re-search-forward::           @code{search-forward} とほぼ同じ
* forward-sentence::            正規表現検索の単純な例
* forward-paragraph::           もうちょっと複雑な例
* etags::                       @file{TAGS} テーブルの作り方
* Regexp Review::               正規表現の復習
* re-search Exercises::         正規表現の練習問題

@code{forward-sentence}

* Complete forward-sentence::
* fwd-sentence while loops::    二つの @code{while} ループ
* fwd-sentence re-search::      正規表現検索

@code{forward-paragraph}: a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                @code{let*} 式について
* fwd-para while::              前方に向かう場合の @code{while} ループ

Counting: Repetition and Regexps

* Why Count Words::             Emacs には単語を数えるコマンドが欠けている
* @value{COUNT-WORDS}::         正規表現を使う。でも問題が...
* recursive-count-words::       リージョンに単語が一つも無い場合には
* Counting Exercise::           カウントに関する練習問題

The @code{@value{COUNT-WORDS}} Function

* Design @value{COUNT-WORDS}::  The definition using a @code{while} loop.
* Whitespace Bug::              @code{count-words-region} の空白についてのバグ

Counting Words in a @code{defun}

* Divide and Conquer::          遠大な計画は分割しよう
* Words and Symbols::           何を数えればよいか？
* Syntax::                      単語やシンボルは何から構成されているか
* count-words-in-defun::        @code{count-words} とほぼ同じ
* Several defuns::              一つのファイルにある複数の defun を数える
* Find a File::                 ファイルを見つける
* lengths-list-file::           沢山の定義の長さのリスト
* Several files::               異なるファイルの中の定義を数える
* Several files recursively::   異なるファイルの定義を再帰を使って数える
* Prepare the data::            データをグラフに表示するための準備

Count Words in @code{defuns} in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      あるリストを別のリストに追加する

Prepare the Data for Display in a Graph

* Data for Display in Detail::
* Sorting::                     リストをソートする
* Files List::                  ファイルのリストを作る
* Counting function definitions::

Readying a Graph

* Columns of a graph::          縦のグラフはどうやって表示すればよいか
* graph-body-print::            グラフ本体の表示
* recursive-graph-body-print::  グラフ本体の表示を再帰的に行う
* Printed Axes::                軸の表示
* Line Graph Exercise::         棒グラフについての練習問題

Your @file{.emacs} File

* Default Configuration::       Emacs のデフォルトは合理的である
* Site-wide Init::              サイトごとの初期化ファイルもある
* defcustom::                   Emacs will write code for you.
* Beginning init File::         @code{.emacs file} の書き方
* Text and Auto-fill::          自動的に行を折り返す
* Mail Aliases::                Email の短縮アドレス
* Indent Tabs Mode::            @TeX{} ではタブを使わないようにするには
* Keybindings::                 個人的なキーバインディングを設定するには
* Keymaps::                     キーバインディングについて更に詳しく
* Loading Files::               ファイルを自動的にロード(評価)する
* Autoload::                    Autoload: 関数をすぐ使える状態に
* Simple Extension::            関数を定義し、キーにバインドする
* X11 Colors::                  Version 19 の X 上でのカラー表示
* Miscellaneous::               ミニバッファを自動的なリサイズ etc.
* Mode Line::                   モード行のカスタマイズ

Debugging

* debug::                       組み込みデバッガの使い方
* debug-on-entry::              関数呼び出し時にデバッガを起動する
* debug-on-quit::               @kbd{C-g} を押した時にデバッガを起動する
* edebug::                      ソースレベルのデバッガ Edebug
* Debugging Exercises::         デバッグについての練習問題

Handling the Kill Ring

* What the Kill Ring Does::     リストの中でのポインタの移動と巡回
* current-kill::
* yank::                        切り取ったテキストを貼り付ける
* yank-pop::                    ポインタが指しているテキストを貼り付ける
* ring file::

The @code{current-kill} Function

* Code for current-kill::
* Understanding current-kill::

@code{current-kill} in Outline

* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::

A Graph with Labeled Axes

* Labeled Example::             最終的なグラフはどんな形になるか
* print-graph Varlist::         @code{print-graph} の中の @code{let} 式
* print-Y-axis::                縦軸のラベルの表示
* print-X-axis::                横軸のラベルの表示
* Print Whole Graph::           完全なグラフを表示する関数

The @code{print-Y-axis} Function

* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         割った余りの計算方法
* Y Axis Element::              Y 軸の各行の構成
* Y-axis-column::               Y 軸のラベルのリストの生成
* print-Y-axis Penultimate::    縦軸の表示、最終版

The @code{print-X-axis} Function

* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            横軸に目盛記号を入れる

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            簡単なテスト
* Graphing words in defuns::    最終的なコードの実行
* lambda::                      無名関数の書き方
* mapcar::                      要素のリストに関数を作用させる
* Another Bug::                 でもまだバグが潜んでいる @dots{}
* Final printed graph::         The graph itself!

@end detailmenu
@end menu

@node Preface
@unnumbered 序文

GNU Emacs というエディタは大部分が Emacs Lisp と呼ばれるプログラミング言
語で書かれている。このプログラミング言語の中に書かれているコードは、計算
機がコマンドが与えられた時何をすべきかを教えるソフトウェア---命令の集ま
り---である。Emacs は、あなたが Emacs Lisp で新しいコードを書き、簡単に
拡張機能としてエディタに組み込むことが出来るよう設計されている。これが
Emacs が「extensible editor (拡張可能エディタ)」と呼ばれる所以である。

(実際には、Emacs は通常エディタが出来ると思われている機能をはるかに上回
ることをやってのけるので、むしろ「extensible computing environment (拡
張可能計算機環境)」とでもいうべきだろう。まあ、ちょっと長ったらしいフレー
ズになってしまうし、あなたが Emacs の中でする全てのこと---マヤ暦や月の満
ち欠けを調べたり、多項式を整理したり、コードをデバッグしたり、ファイルを
扱ったり、手紙を読んだり書いたりといったこと---はもっとも広い意味では編
集 (edit) の範疇に属するものではあるが。)

@menu
* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        この文書を読むにあたって
* Who You Are::                 誰のために書かれたものか？
* Lisp History::                Lisp の歴史
* Note for Novices::            初心者の人へ
* Thank You::                   謝辞
* Translator Preface::          訳者まえがき
@end menu

@ifnottex
@node Why
@unnumberedsec Why Study Emacs Lisp?
@end ifnottex

Emacs Lisp はテキストエディタに関する言語と思われがちであるが、実際は計算
機全体に関するプログラミング言語である。あなたはこの言語を他のプログラミ
ング言語と同じ様に使うことが出来るのだ。

多分、あなたはプログラミングを理解したいと思っていることだろう。あるいは、
Emacs の機能を拡張したいとか、プログラマになりたいと思っているかもしれな
い。この Emacs Lisp についての文書は、その出発点を示すことを意図している。
つまり、あなたをプログラミングの基本的な事柄に慣れさせ、更により大切なこ
とだが、あなたが自分自身でより先に進むにはどうしたら良いかを示すことを目
的としている。

@node On Reading this Text
@unnumberedsec このテキストを読むにあたって

この文書の中には、Emacs の中で走らせることの出来る小さなサンプルプログラ
ムが登場する。この文書を GNU Emacs の Info の中で読めば、そのプログラム
をその場で走らせることが出来る。(これは簡単に実行出来る。その方法はその
プログラムが出てきた時に説明する。) あるいは、この文書を印刷製本し Emacs
が走っている計算機のそばに座りながら読むことだって出来る。(私はこの方法
が好きだ。私は印刷された本の方が好みなので。) たとえあなたの近くで Emacs
が動いていなくても、この本を読むことは出来る。が、その場合はこれを小説か、
まだ行ったことのない国の旅行ガイドのように扱うのが良いだろう。面白いにし
ても実際とは違うものだ。

この文書の多くの部分は、GNU Emacs の中で使われるコードのガイドツアーとい
うべきことに費やされている。これらのツアーの目的は次の二つである。一つ目
は、あなたを実際に役立つコード (あなたが毎日使うコード) に親しませること。
二つ目は、あなたを Emacs を活用する方法に親しませることである。エディタ
がどのように実装されているかを見ることは面白いものである。また、私はあなた
がソースコードを眺める習慣を身に付けることを望んでいる。あなたはそこから
いろいろなこと学び、そしてアイディアを発掘することが出来る。GNU Emacs を
手に入れるということは、宝が隠されたドラゴンの洞窟を発見したようなものな
のである。

これらの例やガイドツアーを通して、エディタとしての Emacs を学んだり、プ
ログラミング言語としての Emacs Lisp を学習するだけでなく、Emacs が Lisp
プログラミング環境であることを理解するきっかけが与えられることだろう。
GNU Emacs はプログラミングをサポートし、あなたが快適に使いこなしたくなる
ような様々な道具を与えてくれる。例えば @kbd{M-.} (@code{find-tag} コマン
ドを発生させるキー) なんかがそうだ。また、エディタ環境の一部であるバッファ
やその他のものを学べる。Emacs のこれらの特徴を学ぶことは、あなたが故郷に
帰る新しいルートを探すことに例えられよう。

@ignore
以上の他に、私は幾つかのプログラムを例として書き加えた。これらは例に過ぎ
ないが、プログラムは本物である。私はこのプログラムを使っているし、他の人
も利用している。あなたも使うことが出来る。
@end ignore

最後に、私はあなたがまだ知らないプログラミングの側面を学ぶために Emacs
を利用して出来る幾つかのテクニックを伝えることが出来ればと思う。難解な事
柄を理解したり、何か新しいことをしたりする際、その解決方法にしばしば
Emacs そのものを利用することが出来る。こういった自己完結性があることは、
単に気分が良いというだけでなく、実際に非常に便利なものである。

@node Who You Are
@unnumberedsec これは誰のために書かれたものか

この文書は、プログラマではない人々への、初歩的な入門書として書かれている。
もしあなたがプログラマであるなら、あなたはこのような簡単なものでは満足出
来まい。というのも、あなたは既にリファレンスマニュアルを読むのに熟達して
いるかもしれないし、その場合この文書のような書き方ではまどろっこしく感じ
るだろうからだ。

例えば、この文書を読んだある熟練したプログラマは、私に次のように言った。

@quotation
@i{僕は、リファレンスマニュアルから学ぶ方が好きなんだ。各々のパラグ
ラフに「ダイブして」そして各パラグラフの間で「息継ぎをする」感じだ。}

@i{僕はあるパラグラフの最後に辿り着いたら、その主題については終了したも
のと見倣すんだよ。つまり、(次のパラグラフでより詳しいことが説明されるよ
うな場合を除いて) 必要なことは全て分ったと考えるわけなんだ。だから無駄な
沢山の繰り返しがなくって、必要な情報が載っている個所へのポインタがきちん
と整備されているようなのがいいな。}
@end quotation

この入門書はこのような人のために書かれたのではない！

まず一つ目に、私は全てのことを少なくとも３回は繰り返すようにした。まずは
それを紹介し、次にそれがどんな場合に使われるかを見て、そして、別の使われ
方を見るか、それを復習するといった具合だ。

二つ目に、私はその主題についての全ての情報を一箇所にまとめるようなことは
殆どしなかった。ましてや、一つのパラグラフに押し込めるようなことは避けた。
これは個人的な考えだが、そういうやり方は読者に過剰な負担を強いることにな
る。その代わりに、私は各々の場合に必要なことだけを説明するように心がけた。
(時々は、後で正式に説明する時に戸惑うことのないよう、ちょっと先走った事
柄の説明も含めたりしたが。)

この文書を読む時は、あなたは全てのことを初めて学ぶものと考えられている。
取り上げられた幾つかの項目については、言わば、会えば会釈する程度の浅い付
き合いしかする必要がないものもある。あなたが本当に大切なことが何かに気付
き、それに集中することが出来るだけの十分なヒントを提供出来るように、この
文書をうまく構成出来ていればと思う。

あなたは、幾つかのパラグラフには「ダイブする」必要がある。それらには、別
のもっと楽な読み方があるわけではない。しかし、私はそのようなパラグラフの
数はなるべく押さえたつもりだ。この本は、そびえたつ山ではなく、ちゃんと登
ることができる丘であるように書かれている。

この 『Emacs Lisp によるプログラミング』 ---初心者のための入門---
は次の本と兄弟関係にある。

@iftex
@cite{『The GNU Emacs Lisp Reference Manual』}. @footnote{日本語訳もある。
『GNU Emacs Lisp リファレンスマニュアル』Bil Lewis, Dan LaLiberte and
the GNU Manual Group 著、榎並嗣智 井田昌之監訳、発売 丸善、発行 透土社、
定価6796円、ISBN 4-924828-39-4}
@end iftex
@ifnottex
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}. 日本語訳もある。
透土社から出版されている。
@smallexample
GNU Emacs Lisp リファレンスマニュアル
著 Bil Lewis, Dan LaLiberte and the GNU Manual Group.
監訳 榎並嗣智 井田昌之
発売 丸善
発行 透土社
定価 6796円(消費税含まず)
ISBN 4-924828-39-4
@end smallexample
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifnottex
リファレンスマニュアルには、この入門書よりも詳しいことが載っている。また
リファレンスマニュアルでは、あるトピックについての全ての情報は一箇所に固
まっている。もしあなたが、上に挙げたプログラマのようなタイプなら、こっち
を読むべきだろう。また、勿論この入門書を読み終えた後、自分自身でプログラ
ミングをする場合には、リファレンスマニュアルがいろいろと便利であることが
納得出来るだろう。

@node Lisp History
@unnumberedsec Lisp の歴史
@cindex Lisp history

Lisp は最初、1950年代の終わりに、マサチューセッツ工科大学で人工知能の研
究のために開発された。Lisp 言語が持つ素晴しい能力は、エディタのコマンド
を書くことは勿論のこと、他の目的についても優秀さを発揮した。

@cindex Maclisp
@cindex Common Lisp
GNU Emacs Lisp は Maclisp の影響を多く受けている。Maclisp は1960年代に
MIT で書かれた。Common Lisp の影響もいく分受けている。こちらは1980年代
に標準となった。しかしながら、Emacs Lisp は Common Lisp と比べて非常に単
純である。(標準的な Emacs の配布には、オプションとして @file{cl.el} が含
まれている。これは Emacs Lisp に多くの Common Lisp の機能を付け加えるた
めのものである。

@node Note for Novices
@unnumberedsec 初心者の人へ

もしあなたが GNU Emacs について知らないとしても、この文書には何かしら役
に立つことが書かれているだろう。しかしながら、たとえ、コンピュータのスク
リーンの中を動き回るということだけでも良いから、Emacs を学ぶことを薦める。
あなたはオンラインのチュートリアルを使って自分自身でその使い方を学べる。
そのためには、@kbd{C-h t} とタイプするだけでよい。(これは @key{CTRL}
キーと @kbd{h} キーを同時に押して離し、次に、@kbd{t} キーを押して離すこ
とを意味する。) (訳註：Mule ならば、@kbd{C-h T} で日本語や韓国語、タイ語
のチュートリアルが行える。)

また、私はしばしば Emacs の標準的なコマンドを、そのコマンドを引き起こす
キーを書き、その後に、そのコマンドの名前を括弧でくくって書くことで示した
りする。例えば @kbd{M-C-\} (@code{indent-region}) といった感じだ。(もし
望むなら、そのコマンドを引き起こすためにタイプするキーを交換することも出
来る。これは、@dfn{リバインディング} (@dfn{rebinding}) と呼ばれる。
@ref{Keymaps, , キーマップ}, 参照)。この @kbd{M-C-\} という省略形は、
@key{META} キーと @key{CTRL} キーと @key{\} キーを同時にタイプすることを
示している。このような組み合わせはよくキーコードと呼ばれる。理由は、ピア
ノでコードを弾くのに似ているからである。もし、キーボードに @key{META} キー
が無ければ、@key{ESC} キーがその代わりになる。この場合は、@kbd{M-C-\} は、
まず @key{ESC} を押して離し、ついで、@key{CTRL} と @key{\} を同時にタイ
プすることを意味する。

もし、この文書を GNU Emacs の Info を使って読んでいるなら、この文書全て
をただ単にスペースバー、@key{SPC} を押し続けることで読んでしまうことが
出来る。(Info について学ぶには、@kbd{C-h i} とタイプし、ついで Info を選
択すれば良い。)

言葉の使い方についての注意だが、私が単独で Lisp という単語を使う場合は、
大概、Lisp の様々な方言にも通用する、一般的な事柄を述べている。しかし、
Emacs Lisp と言うときは特に GNU Emacs Lisp のことを言及している。

@node Thank You
@unnumberedsec 謝辞

執筆に際し助けて頂いた全ての人々に感謝します。特に、@r{Jim Blandy},
@r{Noah Friedman}, @w{Jim Kingdon}, @r{Roland McGrath}, @w{Frank
Ritter}, @w{Randy Simith}, @w{Richard M.@:Stallman}, そして、@w{Melissa
Weisshaus} に感謝します。また、@w{Philip Johnson} と @w{David Stampe} の
忍耐強い励ましにも感謝します。この文書の間違いは、全て私の責任です。

@node Translator Preface
@unnumberedsec 訳者まえがき

この文書は Robert J. Chassell 氏の『Programming in Emacs Lisp: A simple
introduction』を訳したものです。個人用の訳なので拙い所も多く、また形式上
もあまりしっかりしてはいません。が、一応実用には耐えられるのではないかと
判断しています。また、訳者の実力不足のために訳に間違い等が含まれていると
思われますが、お気付きの方は連絡していただけると嬉しく思います。

また、@w{飯田義朗様}、@w{木村浩一様}、@w{幸田薫様}、@w{本田博通様}、
@w{山下健司様}には、以前の版での誤り、不具合等について指摘して頂きました。
この場をかりて深く感謝いたします。

@flushright
Robert J. Chassell
@ifnothtml
@email{bob@@gnu.org}
@end ifnothtml
@ifhtml
bob@@gnu.org
@end ifhtml
@end flushright

@c ================ Beginning of main text ================

@c Start main text on right-hand (verso) page

@tex
\par\vfill\supereject
\headings off
\ifodd\pageno
    \par\vfill\supereject
\else
    \par\vfill\supereject
    \page\hbox{}\page
    \par\vfill\supereject
\fi
@end tex

@c Note: this resetting of the page number back to 1 causes TeX to gripe
@c about already having seen page numbers 1-4 before (in the preface):
@c   pdfTeX warning (ext4): destination with the same identifier (name{1})
@c   has been already used, duplicate ignored
@c I guess that is harmless (what happens if a later part of the text
@c makes a link to something in the first 4 pages though?).
@c E.g., note that the Emacs manual has a preface, but does not bother
@c resetting the page numbers back to 1 after that.
@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@global@pageno = 1
@end iftex

@node List Processing
@chapter List 処理

訓練を受けてない人にとっては、Lisp は奇妙なプログラミング言語である。
Lisp のコードの中には到る所に括弧が見受けられる。中には、Lisp と言う名前
は、`Lots of Isolated Silly Parentheses' を表わしているのだとほざく人ま
でいる。しかし、これは根拠のない主張である。Lisp は LISt Processing を表
わし、@emph{リスト} (や、リストのリスト) を両側を括弧で狭んで扱うプログ
ラミング言語である。括弧は、リストの境界を示している。時々、リストの頭に
アポストロフィ、即ち引用符 @samp{'} が付いていたりすることもある。リスト
は Lisp の基礎である。

@menu
* Lisp Lists::                  リストってなあに？
* Run a Program::               Lisp のリストはすぐに実行出来る
* Making Errors::               エラーを発生させる
* Names & Definitions::         シンボルや関数定義の名前
* Lisp Interpreter::            Lisp インタプリタの動作
* Evaluation::                  プログラムの実行
* Variables::                   変数の値を知る
* Arguments::                   引数：関数に情報を与えるもの
* set & setq::                  変数に値を設定する
* Summary::                     大切なポイント
* Error Message Exercises::     エラーメッセージについての練習問題
@end menu

@node Lisp Lists
@section Lisp のリスト
@cindex Lisp Lists

Lisp の中では、リストは @code{'(rose violet daisy buttercup)} という格好
をしている。このリストの頭には一つのアポストロフィが付いている。これは、
よりあなたが親しんでいるであろう次のような形のリストに書くことも出来る。

@smallexample
@group
'(rose
  violet
  daisy
  buttercup)
@end group
@end smallexample

@noindent
このリストの要素は四つの異なる花の名前であり、各々が空白で区切られ、
括弧に囲まれている。これは石の壁に囲まれた広場の花を連想させる。
@cindex Flowers in a field

@menu
* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formatting lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.
@end menu

@ifnottex
@node Numbers Lists
@unnumberedsubsec Numbers, Lists inside of Lists
@end ifnottex

リストはまた、要素として数値を持つことも出来る。例えば、@code{(+ 2 2)}
なんかがそうだ。このリストはプラスの符号 @samp{+} とその後に続く二つの
@samp{2} を持っていて、各々は空白で区切られている。

Lisp の中では、データとプログラムの両方が同じ様に表現される。つまり、こ
れらは共に、空白で区切られ括弧で囲まれた単語や数値や他のリストからなるリ
ストである。(プログラムがデータと似ているために、あるプログラムは容易に
他のプログラムのデータとして役に立つ; これが Lisp の極めて強力な特徴の一
つである.) (ついでに言っておくと、この直前の括弧で囲まれた補足は Lisp の
リストでは@emph{ない}。というのも、これらは @samp{;} と @samp{.} という
句読点を中に含んでいるからだ。)

@noindent
(訳註：日本語としては変かもしれないが、つじつまを合わせるために @samp{;}
と @samp{.} を使った。)

@need 1200
ここで別のリストの例を挙げよう。今度は中にリストを含んでいる。

@smallexample
'(this list has (a list inside of it))
@end smallexample

このリストの構成要素は、@samp{this}, @samp{list}, @samp{has}, という単語
と、@samp{(a list inside of it)} というリストである。内部にある方のリス
トは、@samp{a}, @samp{list}, @samp{inside}, @samp{of}, @samp{it} という
単語からなっている。

@node Lisp Atoms
@subsection Lisp のアトム
@cindex Lisp Atoms

Lisp の中では、今まで単語と呼んで来たものは、@dfn{atom} (@dfn{アトム}) と
呼ばれる。この言葉は歴史的には「これ以上分解出来ない」という意味を表わす
単語アトムから来ている。Lisp について話している限りは、我々がリストの中
で使ってきた単語は、それ以上小さなプログラムのパートには分解出来ない。そ
れは数字や @samp{+} みたいな一つの文字からなる記号でも同じである。一方リ
ストは、アトムと違って幾つかの部分に分解することが出来る。(@ref{car cdr
& cons, , @code{car} @code{cdr} & @code{cons}：基本関数}, 参照。)

  リストの中では各々のアトムは互いに空白で区切られている。また括弧のすぐ
隣りに位置することが出来る。

@cindex @samp{null list} defined
技術的な言い方をすると、Lisp のリストとは、空白で区切られた、いくつかの
アトムないしは他のリスト、あるいはアトムと他のリストの両方を括弧でくくっ
たものである。中には一つしかアトムが無くても良いし、全く無くても良い。中
に何も入っていないリストというのは @code{()} であるが、これは@dfn{空リス
ト} (@dfn{null list}) と呼ばれる。空リストは同時にアトムでもリストでもあ
る唯一のものである。

@cindex Symbolic expressions, introduced
@cindex @samp{expression} defined
@cindex @samp{form} defined
アトムやリストを表示したものは、@dfn{symbolic-expression}, もしくはもっ
と簡単に@dfn{Ｓ式}と呼ばれる。@dfn{Expression} という単語自身は、表示さ
れた表現か、あるいは計算機の内部に保持されているアトムやリストのどちらか
を表わす。@dfn{Expression} という言葉はしばしば曖昧に用いられる。(また、
多くの本では@dfn{形式} (@dfn{form}) という言葉が expression の同意語とし
て使われている。)

@noindent
(訳註：この訳では以下、expression を式、ないしはＳ式と訳していることが多
い。)

ついでだが、我々の世界を構成しているアトム(原子)がそう名付けられたのは、
それらが分割不可能と考えられていた時のことである。しかしその後、物理で言
うアトムは分割不可能ではないことが発見された。物質は、一つのアトムかほぼ
同じサイズの二つの部分に分裂する。(訳註：意味不明。) 物理で言うアトムは
まだその本当の性質が解明されぬままに時期尚早にして名付けられてしまった。
Lisp の中では、ある種のアトム、例えば配列 (array) は、複数の部分に分解出
来る。しかし、そのメカニズムはリストを分解する時のメカニズムとは違う。リ
ストの操作に関する限り、リストの中のアトムは分解不可能である。

英語におけるのと同様、Lisp のアトムを構成する文字要素は、一つの単語とし
ての文字とは違う。例えば、南アメリカナマケモノ (South American sloth) を
表わす @samp{ai} は @samp{a} と @samp{i} という二つの単語とは全く異なる。

自然の中には沢山の種類のアトムがあるが、Lisp の中には数種類のアトムしか
ない。例えば、37、511、1729といった@dfn{数値} (@dfn{number})、そして@
@samp{+}、@samp{foo}、や @samp{forward-line} といった@dfn{シンボル}
(@dfn{symbol}) なんかである。今まで挙げたリストの例の中に出てきた単語は
全てシンボルである。普段の Lisp の会話では、アトムという単語はあまり使わ
れないが、それはプログラマは普通今使っているアトムがどの種類のアトムかを
より限定的にみようとしているからである。Lisp のプログラミングはもっぱら
リストの中のシンボル (と、ときどき数値) についてのものである。
@c (ついでに言うと、今出てきた三つの単語を括弧でくくったものはちゃんしたリ
@c ストである。何故なら、それはアトムからなり(今の場合はシンボルである)、空
@c 白で区切られ、括弧でくくられており、Lisp でないような句読点は含んでない
@c からである。) (訳註：これは、(と、ときどき数値) の原文 (and sometimes
@c numbers) のことについて言っている。)

@need 1250
それに加えて、二つの二重引用符で挟まれたテキストは---それが一つの文であ
ろうと、あるいはパラグラフであろうとも---アトムである。例を挙げておこう。
@cindex Text between double quotation marks

@smallexample
'(this list includes "text between quotation marks.")
@end smallexample

@cindex @samp{string} defined
@noindent
Lisp では句読点が入っていようが空白があろうが、全ての二重引用符で囲まれ
た文は一つのアトムである。この種のアトムは @dfn{文字列} (@dfn{string})
と呼ばれ、計算機が人間が読める形でメッセージを出す用途等に使われる。文字
列は数値ともシンボルとも違う種類のアトムであり、異なる使い方をされる。

@node Whitespace in Lists
@subsection リストの中の空白
@cindex Whitespace in lists

@need 1200
The amount of whitespace in a list does not matter.  From the point of view
of the Lisp language,

@smallexample
@group
'(this list
   looks like this)
@end group
@end smallexample

@need 800
@noindent
は、次のリストと全く同じである。

@smallexample
'(this list looks like this)
@end smallexample

どちらの例も、Lisp にとっては @samp{this}、@samp{list}、@samp{looks}、
@samp{like}、そして @samp{this} というシンボルがこの順番で並んでいる全く
同じリストである。

余分な空白と改行は、人間がよりリストを見やすいようにするために用いられて
いる。Lisp が表現を読み取る時は、全ての余分な空白を除いてしまう(ただし、
最低一個の空白は残している。そうでないとアトムとアトムの区切りが分らなく
なってしまう)。

奇妙に思えるかもしれないが、今まで見てきた例で殆どの Lisp のリストがカバー
されてしまう。Lisp における他の全てのリストは、多かれ少なかれ、これらの
例のどれかに似ている。まあ、もっと長くなったり、複雑になったりはするが。
簡単にまとめると、リストは括弧に挟まれ、文字列は二重引用符に挟まれ、シン
ボルとは単語のようなもので、数値とは数のようなものである。(ある場合には、
角括弧や、ドット、それに他の特別な文字が使われたりもする。しかし、それら
が無くても我々はかなり先まで進める。)

@node Typing Lists
@subsection GNU Emacs によるリストのタイプの支援
@cindex Help typing lists
@cindex Formatting help

もし、あなたが Lisp のＳ式を GNU Emacs の Lisp Interaction mode もしくは
Emacs Lisp mode の中でタイプしているなら、幾つかのコマンドを使って、Lisp
のＳ式を整形し読みやすいものにすることが出来る。例えば @key{TAB} キーを
押すと、カーソルがある行を自動的に適当な分だけインデントしてくれる。リー
ジョン内のコードをきちんとインデントしてくれるコマンドは、@kbd{M-C-\} に
バインドされている。インデントは、あなたが、どの要素がどのリストに属して
いるか見やすいように---サブリストの要素がそれを含んでいるようなリストの
要素よりも深くインデントされるように---設計されている。

更に、あなたが括弧を閉じる時に、Emacs は一時的にその括弧にマッチする開き
括弧の位置にジャンプする。そうすることでどの括弧に対応するかを確かめるこ
とが出来る。これは大変便利である。というのも、あなたが Lisp でタイプする
全てのリストについて、開き括弧には必ず閉じ括弧がきちんと対応していなけれ
ばならないからである。(@ref{Major Modes, , Major Modes, emacs, The GNU
Emacs Manual}, に Emacs の mode のより詳しい説明が書かれている。)

@node Run a Program
@section プログラムの実行
@cindex Run a program
@cindex Program, running one

@cindex @samp{evaluate} defined
Lisp におけるリストは、たとえどんなリストであってもそのまま走らせることが
出来る。実際に走らせてみると (Lisp の専門用語では @dfn{評価}
(@dfn{evaluate}) するという)、計算機は次の３つのうちいずれかの動作をする。
まずは、そのリストをそのまま返すだけで何もしない、もしくは、あなたにエラー
メッセージを返す、あるいは、リストの先頭のシンボルをコマンドとして扱い、
なにがしかのことをする。(普通は勿論、最後の動作があなたの求めるものであ
ろう。)

以前のセクションで挙げた例の中での、リストの頭に付けた単独のアポストロフィ
@code{'} は、@dfn{引用符}ないしは @dfn{クウォート} (@dfn{quote}) と呼ば
れる。これがリストの頭に付いている場合は、何も付いていない場合と異なり、
Lisp はこのリストについては何もしなくていいんだなと解釈する。しかし、リ
ストの頭に引用符が付いていない場合は、リストの最初の項が特別な意味を持つ。
つまり、これは計算機が従うべき命令になるのだ。(Lisp ではこれらの命令は
@emph{関数} (@emph{function}) と呼ばれる。) 以前挙げた @code{(+ 2 2)} と
いうリストには頭に引用符は付いていないので、Lisp は @code{+} が残りのリ
ストに関する何らかの命令であると解釈する。この場合は、残りの数を加えると
いうものである。

もし、この文章を GNU Emacs の Info の中で読んでいるのなら、次のようにし
てこのようなリストを評価することが出来る。カーソルを次のリストの右側の括
弧のすぐ後に持ってきて、@kbd{C-x C-e} とタイプするのである。

@smallexample
(+ 2 2)
@end smallexample

@c use code for the number four, not samp.
@noindent
エコー領域に @code{4} が見えたはずだ。(専門用語では、このことを「リスト
を評価する」と言う。エコー領域というのはスクリーンの最下行のことであり、
テキストを表示ないしは「エコー」する。) さて、同じことを頭に引用符が付
いたリストでやってみよう。カーソルを下のリストのすぐ後に移動させ、
@kbd{C-x C-e} とタイプする。

@smallexample
'(this is a quoted list)
@end smallexample

@noindent
この場合はエコー領域に @code{(this is a quoted list)} という文が見えたは
ずだ。

@cindex Lisp interpreter, explained
@cindex Interpreter, Lisp, explained
いずれの場合にも、あなたはコマンドを GNU Emacs の @dfn{Lisp インタプリタ}
(@dfn{Lisp interpreter}) と呼ばれるプログラムに渡している。つまり、イン
タプリタにそのＳ式を評価しろという命令を与えているのだ。Lisp インタプリ
タという名前は、Ｓ式の意味を提供する---つまりそれを解釈する---という人間
の仕事を表わす単語から来ている。

リストの一部ではない、単独のアトム---括弧に囲まれていないもの---を評価す
ることも出来る。この場合も Lisp インタプリタは人間が読むことの出来るＳ式
から、計算機の内部の言語への翻訳をする。しかし、これについて議論する前に
(@ref{Variables, , 変数}, 参照)、まず我々がエラーを犯した場合に Lisp イン
タプリタが何をするかを見ていこう。

@node Making Errors
@section エラーメッセージの出力
@cindex Generate an error message
@cindex Error message generation

まず、Lisp インタプリタがエラーメッセージを出すようなコマンドを与えてみ
よう。偶然このようなことをしてしまっても何も心配することはない。これは、
無害な操作である。実際、我々はしばしば意図的にエラーメッセージを出させる
ことがある。一旦専門用語を理解してしまえば、エラーメッセージから多くの情
報を得ることが出来る。そういう意味ではエラーメッセージと言うよりはヘルプ
メッセージと言うべきだろう。言わば他の国から来た旅行者にとっての道標のよ
うなものである。解読するのは大変だけれども、一度理解してしまえば正しい道
を教えてくれるというわけだ。

The error message is generated by a built-in GNU Emacs debugger.  We
will `enter the debugger'.  You get out of the debugger by typing @code{q}.

What we will do is evaluate a list that is not quoted and does not
have a meaningful command as its first element.  Here is a list almost
exactly the same as the one we just used, but without the single-quote
in front of it.  Position the cursor right after it and type @kbd{C-x
C-e}:

@smallexample
(this is an unquoted list)
@end smallexample

@ignore
@noindent
（無視）What you see depends on which version of Emacs you are running.  GNU
Emacs version 22 provides more information than version 20 and before.
First, the more recent result of generating an error; then the
earlier, version 20 result.

@need 1250
@noindent
In GNU Emacs version 22, a @file{*Backtrace*} window will open up and
you will see the following in it:
@end ignore

@file{*Backtrace*} ウィンドウが開いて、以下のように表示される:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function this)
  (this is an unquoted list)
  eval((this is an unquoted list))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1200
@noindent
（未訳）Your cursor will be in this window (you may have to wait a few seconds
before it becomes visible).  To quit the debugger and make the
debugger window go away, type:

@smallexample
q
@end smallexample

@noindent
（未訳）Please type @kbd{q} right now, so you become confident that you can
get out of the debugger.  Then, type @kbd{C-x C-e} again to re-enter
it.

@cindex @samp{function} defined
（未訳）Based on what we already know, we can almost read this error message.

（未訳）You read the @file{*Backtrace*} buffer from the bottom up; it tells
you what Emacs did.  When you typed @kbd{C-x C-e}, you made an
interactive call to the command @code{eval-last-sexp}.  @code{eval} is
an abbreviation for `evaluate' and @code{sexp} is an abbreviation for
`symbolic expression'.  The command means `evaluate last symbolic
expression', which is the expression just before your cursor.

（未訳）Each line above tells you what the Lisp interpreter evaluated next.
The most recent action is at the top.  The buffer is called the
@file{*Backtrace*} buffer because it enables you to track Emacs
backwards.

@need 800
（未訳）At the top of the @file{*Backtrace*} buffer, you see the line:

@smallexample
Debugger entered--Lisp error: (void-function this)
@end smallexample

@noindent
（未訳）The Lisp interpreter tried to evaluate the first atom of the list, the
word @samp{this}.  It is this action that generated the error message
@samp{void-function this}.

（未訳）The message contains the words @samp{void-function} and @samp{this}.

@cindex @samp{function} defined
@samp{関数} という単語は前に一度出て来た。これは極めて重要な単語である。
ここでは @dfn{関数} (@dfn{function}) とは計算機に何かやらせるための命令
の集まりである、とでも定義しておけば十分だろう。

以上で、@samp{void-function this} というエラーメッセージを理解することが
出来るようになる。これは、シンボル (つまり、@samp{this} という単語) には
計算機が実行出来るような命令セットは定義されていないということである。

この、@samp{void-function} というちょっと奇妙なメッセージは Emacs Lisp の
実装の仕方を表わすように書かれている。つまり、そのシンボルに対して関数が
定義されていない場合、命令が含まれているはずの場所が空@ (void) だというわ
けである。

一方で、@code{(+ 2 2)} を評価した時にちゃんと2に2を加えることが出来るとい
うことから、シンボル @code{+} は計算機が従うべき命令セットを持っており、
それらの命令は @code{+} に続く数を加えるという物であるに違いないと推測出
来る。

（未訳）It is possible to prevent Emacs entering the debugger in cases like
this.  We do not explain how to do that here, but we will mention what
the result looks like, because you may encounter a similar situation
if there is a bug in some Emacs code that you are using.  In such
cases, you will see only one line of error message; it will appear in
the echo area and look like this:

@smallexample
Symbol's function definition is void:@: this
@end smallexample

@noindent
@ignore
(Also, your terminal may beep at you---some do, some don't; and others
blink.  This is just a device to get your attention.)
@end ignore
The message goes away as soon as you type a key, even just to
move the cursor.

We know the meaning of the word @samp{Symbol}.  It refers to the first
atom of the list, the word @samp{this}.  The word @samp{function}
refers to the instructions that tell the computer what to do.
(Technically, the symbol tells the computer where to find the
instructions, but this is a complication we can ignore for the
moment.)

The error message can be understood: @samp{Symbol's function
definition is void:@: this}.  The symbol (that is, the word
@samp{this}) lacks instructions for the computer to carry out.

@node Names & Definitions
@section シンボルの名前と関数定義
@cindex Symbol names

我々は今まで議論してきたことに基づいて、別の Lisp の特徴---それも極めて
大切な特徴---を述べることが出来る。即ち @code{+} のようなシンボルはそれ
自身は計算機が実行出来るような命令ではないということである。その代わりシ
ンボルは、多分、一時的に、命令の定義ないしは命令の集まりの位置を見つける
方法として使うことが出来る。我々に見えているのは、それを通して命令を見つ
けることの出来る名前なのである。人間の名前も同じ働きをする。私は
@samp{Bob} として言及される。しかしながら、私は @samp{B}、@samp{o}、
@samp{b} という文字ではなく、一貫して特定の生命体に付随しているある意識
である。名前は私そのものではないが、私を示すのに使われる。

Lisp では、ある命令セットには幾つかの名前が付随している。例えば、数を
加えろという計算機の命令には、@code{+} というシンボルと同様、@code{plus}
というシンボルも付随させることが出来る。(他の幾つかの Lisp の方言では実
際にそうなっている。) 人間の場合でも、私は @samp{Bob} だけではなく
@samp{Robert} として呼ばれることもあるし、他の呼び方をされることもある。

一方で、一つのシンボルは、一度にただ一つの関数定義しか持つことが出来ない。
そうでないと、計算機がどの定義を使うべきか迷ってしまうからだ。仮にこれが
人間の場合であれば、@samp{Bob} という名前は世界で一人の人間にしかつけて
はいけないということである。ただし、名前に付随する関数定義は簡単に変更
することが出来る。(@ref{Install, , 関数定義のインストール}, 参照。)

Emacs Lisp はでかいので、関数が属する Emacs のパートが識別出来るようなシ
ンボルの名前を付け方をするのが普通である。というわけで、Texinfo を扱うため
の関数の名前は全て @samp{texinfo-} で始まっているし、メールを読むための
(reading mail) 関数の名前は @samp{rmail-} で始まっている。

@node Lisp Interpreter
@section Lisp インタプリタ
@cindex Lisp interpreter, what it does
@cindex Interpreter, what it does

これまでに見てきたことから、リストを評価するよう命令した時に Lisp インタ
プリタが何をするかを理解することが出来る。まずインタプリタは、list の頭
に、引用符が付いているか見る。もし付いていれば、単にそのリストを我々に渡
す。一方、付いていない場合はリストの先頭の要素を見に行き、それが関数の定
義を持っているかどうかを調べる。定義されている場合はその定義にある命令を
実行し、そうでなければエラーメッセージを表示する。

これが Lisp の動作である。単純だ。これに加えて若干複雑なこともある。それ
についてはすぐ後で説明するが、基本はこれだけである。勿論、Lisp のプログ
ラムを書く際には、関数の定義を書いたりそれに名前を付けるにはどうすればい
いか、あるいはそういうことをあなた自身や計算機が混乱しないように行うには
どうすればいいか等、他にも知らなければいけないことはあるが。

@menu
* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.
@end menu

@ifnottex
@node Complications
@unnumberedsubsec Complications
@end ifnottex

さて、さっき述べた「複雑なこと」の一つ目は、Lisp インタプリタは、リスト
に加えて引用符が付いておらず、括弧に囲まれてもいない単独のシンボルも評価
することが出来るということである。この場合、Lisp インタプリタはそのシン
ボルの値を@dfn{変数} (@dfn{variable}) として評価しようとする。このこと
については変数のセクションで説明することにする。(@ref{Variables, , 変数},
参照。)

@cindex Special form
複雑なことの二つ目は、幾つかの関数はその特殊性のために普通のやり方ではう
まく働かないことによる。このような関数は @dfn{特殊形式} (@dfn{special
form}) と呼ばれる。これらは、例えば関数を定義したりといった特別な用途を
持つ。次の幾つかのセクションでもっと大切な特殊形式を紹介するつもりだ。

As well as special forms, there are also @dfn{macros}.  A macro
is a construct defined in Lisp, which differs from a function in that it
translates a Lisp expression into another expression that is to be
evaluated in place of the original expression.  (@xref{Lisp macro}.)

For the purposes of this introduction, you do not need to worry too much
about whether something is a special form, macro, or ordinary function.
For example, @code{if} is a special form (@pxref{if}), but @code{when}
is a macro (@pxref{Lisp macro}).  In earlier versions of Emacs,
@code{defun} was a special form, but now it is a macro (@pxref{defun}).
It still behaves in the same way.

三つ目の、そして最後の複雑なことはこうだ。もし現在 Lisp インタプリタが見
ている関数が特殊形式ではなく、しかもそれがリストの一部であるなら、Lispイ
ンタプリタはリストが内部にリストを含んでいないかどうかを見る。もし内部に
リストを含んでいれば、それがその内部でどういうことをするかを見る。そして、
その後にその外側のリストを処理する。また、もしその内部のリストが更に他の
リストを中に含んでいれば、まず、それを先に処理してからということになる。
即ち、Lisp インタプリタは常に一番内部のリストから処理していく。これは、
内部のリストの結果をそれを包む外側のＳ式で使う場合、内部のリストの結果が
どうなるかを見てから外側のリストを処理しなければいけないためである。

それ以外の場合は、インタプリタは左から右へＳ式を一つずつ処理していく。

@node Byte Compiling
@subsection バイトコンパイル
@cindex Byte compiling

解釈の仕方について、もう一つ興味深いことがある。 Lisp インタプリタは二つ
の種類の物を解釈出来るということである。一つは人間が読めるコードであり、
我々は専らこれに焦点を当てている。もう一つは特別なプロセスコードであり、
これは@dfn{バイトコンパイル} (@dfn{byte compile}) されたコードで、人間に
読める代物ではない。バイトコンパイルされたコードは我々が読めるコードより
も速く走らせることが出来る。

人間が読めるコードをバイトコンパイルされたコードに変換することも出来る。
これは @code{byte-compile-file} 等の、コンパイルコマンドを走らせることに
よって行う。バイトコンパイルされたコードは普通、@file{.el} ではなく、
@file{.elc} という拡張子で終わるファイルに保存される。@file{emacs/lisp}
などといったディレクトリィを覗けば、この両方の種類のファイルが見つかる。
我々が読むのは @file{.el} という拡張子の付いた方である。

実際問題として、あなたが Emacs をカスタマイズしたり拡張したりする場合に
は大抵はバイトコンパイルする必要はない。そして私もここではこの話題につい
ては述べない。@ref{Byte Compilation, , Byte Compilation, elisp, The GNU
Emacs Lisp Reference Manual}, を見ればバイトコンパイルについての全ての情
報が載っている。

@node Evaluation
@section 評価
@cindex Evaluation

Lisp インタプリタがあるＳ式を処理している時、その動作は @dfn{評価}
(@dfn{evaluation}) と呼ばれる。つまり、「インタプリタはＳ式を評価する」
のように言うわけだ。私はこの用語を以前にも何回か用いた。この単語はこの言
葉の日常会話での意味、@cite{Webster's New Collegiate Dictionary} (及び、
小学館 『プログレッシブ英和中辞典』) によれば「価値や量を確かめる、概算
する、見積もる」という意味、から来ている。

@menu
* How the Interpreter Acts::    Returns and Side Effects...
* Evaluating Inner Lists::      Lists within lists...
@end menu

@ifnottex
@node How the Interpreter Acts
@unnumberedsubsec How the Lisp Interpreter Acts
@end ifnottex

@cindex @samp{returned value} explained
 Lisp インタプリタはＳ式を評価した後、大抵その関数の定義の中にある計算機
に対する命令を実行した時に出力する値を @dfn{返し} (@dfn{return})、そうで
ない場合は、おそらくその関数を処理するのを止めてエラーメッセージを出力す
る。(インタプリタは、急に別の関数を渡されることもあり得るし、あるいは、
いわゆる「無限ループ」に入って現在の処理を何回でも繰り返そうとするかもし
れない。が、これらの動作をすることはそれ程多くはないので、我々はこれらの
場合は無視することにする。) つまり殆どの場合、インタプリタは値を返す。

@cindex @samp{side effect} defined
インタプリタは値を返すと同時に、カーソルを動かしたり、ファイルをコピー
したりといった他の動作も行う。このような動作は、@dfn{副作用}
(@dfn{side effect}) と呼ばれる。例えば結果を表示するとか、我々人間が重要
と考える動作もしばしば、Lisp インタプリタにとっては「副作用」でしかない。
この専門用語には異和感があるかもしれないが、副作用自体の使い方を学ぶのは
かなり簡単だということがその内分るだろう。

以上まとめると、Lisp インタプリタはＳ式を評価した時に、まず殆どの場合あ
る値を返し、大抵はある副作用を実行する。そして、そうでない場合はエラーを
出力する、ということになる。

@node Evaluating Inner Lists
@subsection 内部のリストの評価
@cindex Inner list evaluation
@cindex Evaluating inner lists

もしあるリストの内部のリストが評価された場合、その外側のリストが評価され
る時には最初に内部のリストを評価した時に返った値を情報として使うことが出
来る。このことから、何故内部のリストが先に評価されるかが説明出来る。即ち、
内部のＳ式が返す値を外部のＳ式が用いるためである。

@need 1250
我々はこのプロセスを次のような例で実際に確かめることが出来る。次の式の直後
にカーソルを持っていき、@kbd{C-x C-e} とタイプしてみよう。

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
数字の8がエコー領域に表示されたはずだ。

この例で起こったことはこうだ。まず Lisp インタプリタは内部のＳ式である
@code{(+ 3 3)} を評価する。それに対して値6が返される。それによって外部
のＳ式があたかも @code{(+ 2 6)} であるように評価され、値8を返すことにな
る。これらを内部に含む評価すべきＳ式はこれ以上存在しないので、インタプ
リタはこの値をエコー領域に表示する。

さて、ここまでくれば @kbd{C-x C-e} で引き起こされるコマンドの名前を理解
することは簡単だ。このコマンドの名前は @code{eval-last-sexp} となってい
る。この中の @code{sexp} という文字は `symbolic expression' (Ｓ式) の略
である。ということで、これは直前のＳ式を評価する (evaluate last symbolic
expression) ことを表している。

実験的に、次に挙げる例のＳ式の直後の行の先頭やＳ式の内部にカーソルを持っ
ていってＳ式を評価してみることも出来る。

@need 800
これがその例である。

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
もしカーソルをＳ式の直後の空行の先頭に置いて @kbd{C-x C-e} とタイプした
なら、その場合もやはり8がエコー領域に表示されることだろう。では次に、
カーソルをＳ式の内部に持っていこう。最後の括弧のすぐ右側の括弧の後にカー
ソルを持っていって (つまりカーソルは最後の括弧の上に見えている) そこで評
価したならば、エコー領域には6と表示される。これはコマンドが @code{(+ 3
3)} という式を評価したからである。

今度はカーソルを数字の直後に持っていこう。@kbd{C-x C-e} とするとその数字
そのものが返される。Lisp の中では、数字を評価した場合、その値自身が返さ
れる。これが数字がシンボルと違うところである。もし @code{+} みたいなシン
ボルを先頭に持つリストの直後でＳ式を評価したなら、返された値はその名前に
付随する関数の定義の中の命令を計算機が実行した結果が返ってくる。が、もし
シンボルそのものが評価されたなら別のことが起きる。これについては次のセク
ションで見ることにしよう。

@node Variables
@section 変数
@cindex Variables

Lisp の中では、シンボルは、関数定義を持つことが出来るのと同様に、ある値
を持つことが出来る。これら二つは全く別の物である。関数定義は計算機が従う
べき命令の集まりであるのに対し、値は数値とか名前のように、何か変化し得る
ものである。(このようなシンボルが変数と呼ばれるのはこのためである。) ど
んな Lisp のＳ式もシンボルの値になり得る。例えばシンボルや数値、リスト、
文字列なんかが値となることが出来る。値としてのシンボルはしばしば@dfn{変
数} (@dfn{variable}) と呼ばれる。

シンボルは、関数定義と値の両方を同時に持つことが出来る。この二つは分離さ
れているのだ。これは、ケンブリッジという名前がマサチューセッツの中のある
都市そのものを表わすのと同様に、その都市名に付随するなんらかの情報、例え
ば、「大きなプログラミングセンター」であるといった情報をも持ち得るのと似
ている。

@ignore
(結果として Emacs Lisp の中ではシンボルには更に別の二つの物が付随し得る
ことになる。property list と documentation string である。これらについて
は後で説明することにする。)
@end ignore

このことを理解するもう一つの考え方を述べよう。それはシンボルを整理棚であ
ると見倣す方法である。関数定義はその引き出しの一つに入っており、値はまた
別の引き出しに入っている... という具合である。値の入っている引き出しの中
身は同じ棚の関数定義の入っている引き出しの中身に影響を与えることなく変え
ることが可能だし、逆も同様である。

@menu
* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.
@end menu

@ifnottex
@node fill-column Example
@unnumberedsubsec @code{fill-column}, an Example Variable
@end ifnottex

@findex fill-column, @r{an example variable}
@cindex Example variable, @code{fill-column}
@cindex Variable, example of, @code{fill-column}
変数 @code{fill-column} を例にとって、値を持つシンボルというものを説明し
てみよう。GNU Emacs の全てのバッファにおいて、このシンボルはある値にセッ
トされている。大抵は72か70であるが、他の値を持つこともある。この値が何か
を見るにはこのシンボル自身を評価してみれば良い。もしこの文章を GNU Emacs
の Info で読んでいるなら、カーソルを次のシンボルの直後に持っていって
@kbd{C-x C-e} とタイプするだけである。

@smallexample
fill-column
@end smallexample

@noindent
私が今 @kbd{C-x C-e} とタイプしてみたところ、Emacs はエコー領域に72と表
示した。これが、私がこの文章を書いている時に @code{fill-column} にセット
されている値である。あなたの Info のバッファではまた別の値が設定されてい
るかもしれない。変数として評価されて返す値は、ある関数が命令を実行した時
に値を返す時と全く同じように表示されることに注意しよう。Lisp インタプリ
タの立場からすると、どちらも返り値であることに違いはない。どんな種類のＳ
式から来ているかということは一旦その値が分ってしまえば重要ではないのだ。

シンボルはどんな値も持つことが出来る。あるいは専門用語を使っていうなら我々
は変数に72といった数値や @code{"such as this"} といった文字列や、
@code{(spruce pine oak)} を@dfn{バインド} (@dfn{bind}) (束縛とも言う) す
ることが出来る。変数に関数定義をバインドすることすら可能である。

シンボルに値を設定するには幾つか方法がある。その方法の一つについては、
@ref{set & setq, , 変数の値の設定}, を参照のこと。

@node Void Function
@subsection Error Message for a Symbol Without a Function
@cindex Symbol without function error
@cindex Error for symbol without function

@code{fill-column} という単語には周りに括弧がついていないことに注意しよ
う。これは我々がこのシンボルを関数の名前としては使わなかったためである。

@code{fill-column} がリストの最初、もしくは唯一の要素であった場合、Lisp
インタプリタはこれに付随する関数定義を見つけようとする。しかし、
@code{fill-column} は関数定義を持ってはいない。例えば次を評価してみよう。

@smallexample
(fill-column)
@end smallexample

@need 1250
@noindent
You will create a @file{*Backtrace*} buffer that says:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
(Remember, to quit the debugger and make the debugger window go away,
type @kbd{q} in the @file{*Backtrace*} buffer.)

@ignore
@need 800
In GNU Emacs 20 and before, you will produce an error message that says:

@smallexample
Symbol's function definition is void:@: fill-column
@end smallexample

@noindent
(The message will go away as soon as you move the cursor or type
another key.)
@end ignore

@node Void Variable
@subsection 値のないシンボルに対するエラーメッセージ
@cindex Symbol without value error
@cindex Error for symbol without value

もし、値を持たないシンボルを評価しようとしたなら、エラーメッセージが返さ
れるはずだ。2に2を加える例で実験してみよう。次のＳ式のなかで最初の2の直
前にある @code{+} の直後にカーソルを持っていって @kbd{C-x C-e} とタイプ
してみよう。

@smallexample
(+ 2 2)
@end smallexample

@need 1500
@noindent
（未訳）In GNU Emacs 22, you will create a @file{*Backtrace*} buffer that
says:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
（未訳）(Again, you can quit the debugger by
typing @kbd{q} in the @file{*Backtrace*} buffer.)

このバックトレースは我々が見た最初のエラーメッセージとは違っている。さっ
きは@samp{Debugger entered--Lisp error: (void-function this)} というもの
だった。今回のケースでは関数は変数としての値を持っておらず、もう一方のケー
スではシンボル (@samp{this} という単語)は関数定義を持たなかった。

この @code{+} を使った実験の中でやったことは Lisp インタプリタに @code{+} を
評価させ、関数定義では無く変数の値を探させることである。そのためにカーソ
ルを前のようにリストを囲む括弧の後では無く、シンボルのすぐ右隣に持っていっ
たのだった。結果として Lisp インタプリタは直前のＳ式、この場合は @code{+} そ
のもの、を評価したのだ。

@code{+} は関数定義は持っていても値は持ってはいないので、エラーメッセー
ジはシンボルの変数としての値が空だよと報告したのである。

@ignore
@need 800
In GNU Emacs version 20 and before, your error message will say:

@example
Symbol's value as variable is void:@: +
@end example

@noindent
The meaning is the same as in GNU Emacs 22.
@end ignore

@node Arguments
@section 引数
@cindex Arguments
@cindex Passing information to functions

どうしたら情報が関数に渡されるかを見るために、これまで何回か使ってきた2
に2を足す例をもう一度見てみよう。

@smallexample
(+ 2 2)
@end smallexample

もしこのＳ式を評価したなら数字の4がエコー領域に表示される。Lisp インタプ
リタがやったことは @code{+} の後に続く数字を加えることである。

@cindex @samp{argument} defined
@code{+} によって加えられた数字は関数 @code{+} の @dfn{引数}
(@dfn{argument}) と呼ばれる。これらの数字は関数に与えられる、もしくは
@dfn{渡される} (@dfn{pass} される) 情報である。

「argument」という単語は数学での用法から来ているもので、二人の人が議論す
るという意味ではない。そうではなく関数、今の場合でいうと @code{+} という
関数、に与えられる情報のことを指している。Lisp の中では関数に対する引数
は関数に続くアトムもしくはリストである。これらのアトムやリストを評価して
返された値が関数に渡されることになる。異なる関数は異なる数の引数を取り得
る。全く引数を取らない関数もある。@footnote{「argument」という単語が二つ
の異なる意味を持つようになった経緯を追ってみるのは、結構興味深いことであ
る。一つは数学での意味であり、もう一つは日常使われている英語での意味であ
る。@code{Oxford English Dictionary} によると、この単語は @samp{to make
clear, prove} (@samp{明確にする、証明する}) という意味のラテン語から来て
いるということだ。その結果、一方では「証明として与えられる証拠」から「与
えられた情報」という意味になり、それが Lisp での意味の方に派生していった。
しかし、もう一方では「他人が主張するのと対立するような主張をする」という
意味に派生し、それが議論することを表わす単語の意味になっていった。(ここ
でこの英単語が同時に二つの異なる定義を持っていることに注意しよう。これに
対して Emacs Lisp では、シンボルは同時に二つの関数定義を持つことは出来な
い。)}

@menu
* Data types::                  関数に渡されるデータの型
* Args as Variable or List::    引数には変数の値やリストも使える
* Variable Number of Arguments::  関数の中には、可変な数の引数を扱える
                                ものもある
* Wrong Type of Argument::      関数に間違った型の引数を与えると
* message::                     メッセージを表示する時に便利な関数
@end menu

@node Data types
@subsection 引数のデータ型
@cindex Data types
@cindex Types of data
@cindex Arguments' data types

関数に渡されるデータの型はその関数がどんな種類の情報を必要としているかに
よる。@code{+} のような関数の引数は数値でなければならない。というのも
@code{+} は数値を加える命令だからである。他の関数は引数として他の種類の
データを取る。

@need 1250
@findex concat
例えば、@code{concat} という関数は二つ以上のテキストの文字列を連結な
いしは合成して一つの文字列を作る。この場合の引数は文字列である。
二つの文字文字列 @code{abc}, @code{def} を連結 (concatenate) すると、
@code{abcdef} という一つの文字列が出来る。これは次の例で確かめられる。

@smallexample
(concat "abc" "def")
@end smallexample

@noindent
このＳ式を評価すると @code{"abcdef"} という値が返される。

@code{substring} のような関数は引数として文字列と数値の両方を取る。これ
は文字列である最初の引数の部分文字列を返す関数である。引数の数値は
３つである。最初の引数は文字からなる文字列である。二番目と三番目の引
数は部分文字列の初めと終りの場所を示す数値であり、文字列の最初から
の(スペースや句読点も含めた)文字数を指定する。

@need 800
例えば次を評価してみよう。

@smallexample
(substring "The quick brown fox jumped." 16 19)
@end smallexample

@noindent
（未訳）you will see @code{"fox"} appear in the echo area.  The arguments are the
string and the two numbers.

@code{substring} に渡される文字列は、たとえスペースで区切られた複数の単
語からなっていたとしても一つのアトムであることに注意しよう。Lisp は二つ
の二重引用符の間に狭まれる全てを空白も含めて文字列の一部と数える。
@code{substring} という関数は一種の「アトム粉砕機 (atom smasher)」だと見
倣すことが出来る。というのもこいつは他の方法では分離できないアトムを取り
込み、その一部を抽出するからである。しかしながら、@code{substring} は文
字列である引数から部分文字列を抽出することが出来るだけで、他の種類の例え
ば数値とかシンボルであるアトムについてはそのようなことは出来ない。

@node Args as Variable or List
@subsection 引数には変数の値やリストも使える

引数は評価された時に値を返すシンボルであることも可能だ。例えば
@code{fill-column} というシンボルそれ自身が評価された場合には、数値が返
される。この数値は加法演算にも使える。

@need 1250
次のＳ式の後にカーソルを持っていって @kbd{C-x C-e} とタイプしてみよう。

@smallexample
(+ 2 fill-column)
@end smallexample

@noindent
返される値は @code{fill-column} を単独で評価した場合に得られる数に2を加
えたものになるはずだ。私には74が返される。何故なら @code{fill-column} の
値が72であるからだ。

たった今見た様に、引数は評価された時に値を返すシンボルであり得る。それに
加えて、引数は評価された時に値を返すリストでもあっても良い。例えば次のＳ
式の中では関数 @code{concat} の引数は @w{@code{"The "}}, @w{@code{"red
foxes."}} そしてリスト @code{(+ 2 fill-column)} である。

@c For GNU Emacs 22, need number-to-string
@smallexample
(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
@end smallexample

@noindent
もしこのＳ式を評価したならエコー領域には @code{"The 74 red foxes."} が表
示されるはずだ。(最後の文字列を表示させるには @samp{The} という単語
の後と @samp{red} という単語の前に空白を入れなければならないことに注意。)
(訳註：74の所は勿論場合に応じて変わる。)

@node Variable Number of Arguments
@subsection 可変な数の引数
@cindex Variable number of arguments
@cindex Arguments, variable number of

例えば @code{concat}, @code{+}, @code{*} といった幾つかの関数では引数の
数は固定されていない。(@code{*} は乗法を表わすシンボルである。) これは次
に挙げる各々のＳ式を評価してみると分る。エコー領域に表示されるべき結果は
このテキストの中の @samp{@result{}} の後に書かれている。これは「を評価し
た結果は」と読み換えられる。

@need 1250
最初は引数がない場合である。

@smallexample
@group
(+)       @result{} 0

(*)       @result{} 1
@end group
@end smallexample

@need 1250
こちらは一つだけ引数を持っている。

@smallexample
@group
(+ 3)     @result{} 3

(* 3)     @result{} 3
@end group
@end smallexample

@need 1250
次では、各々三つずつ引数を持っている。

@smallexample
@group
(+ 3 4 5) @result{} 12

(* 3 4 5) @result{} 60
@end group
@end smallexample

@node Wrong Type of Argument
@subsection 関数に間違った型の引数を与えると
@cindex Wrong type of argument
@cindex Argument, wrong type of

ある関数に間違った型の引数が与えられると、Lisp インタプリタはエラーメッ
セージを返す。例えば、@code{+} という関数は引数の値として数値を要求する。
実験的に、これに数値ではなく @code{hello} というシンボルを与えてみよう。
次のＳ式の後にカーソルを持っていって @kbd{C-x C-e} とタイプしてみよう。

@smallexample
(+ 2 'hello)
@end smallexample

@noindent
そうするとエラーメッセージが表示される。この場合に起きたことはこうだ。
@code{+} は2に @code{'hello} を評価して返される値を加えようとした。しか
し返された値は @code{hello} というシンボルであり数値ではない。だが数値で
ないものを足すことは出来ない。そのために、@code{+} は加算を実行すること
が出来なかったのである。

@need 1250
（未訳）You will create and enter a @file{*Backtrace*} buffer that says:

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
         (wrong-type-argument number-or-marker-p hello)
  +(2 hello)
  eval((+ 2 (quote hello)))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1250
（未訳）As usual, the error message tries to be helpful and makes sense after you
learn how to read it.@footnote{@code{(quote hello)} is an expansion of
the abbreviation @code{'hello}.}

エラーメッセージの最初の部分は極めて直接的だ。@samp{Wrong type argument}
(引数の型が違う) である。次に来るのはミステリアスな専門用語
@w{@samp{number-or-marker-p}} である。この言葉はあなたに @code{+} という
関数が要求する引数のタイプを教えようとしている。

@code{number-or-marker-p} というシンボルの名前は、Lisp インタプリタが与
えられた情報 (引数の値) が数値 (number) もしくはマーカ (marker) (バッファ
での位置を表わす特殊なオブジェクト) であるかどうかを判定することを意味し
ている。今の場合、実際に行うのは @code{+} にちゃんと加えるべき整数が与え
られたかどうかのテストである。そして、マーカと呼ばれる特殊オブジェクトか
どうかもテストされる。これは Emacs Lisp 固有のものである。(Emacs の中で
はバッファ内での位置がマーカとして記録される。@kbd{C-@@} あるいは
@kbd{C-@key{SPC}} というコマンドによってマークがセットされるとその位置が
マーカとして保持されるのである。このマークは数---バッファの始まりからそ
の位置までの文字数---と考えることが出来る。) Emacs Lisp では @code{+} は
マーカの位置を示す数を数値として加えるのにも使うことが出来るわけである。

@code{number-or-marker-p} の中の @samp{p} は Lisp プログラミングの初期の
頃に始まったある試みの具体化である。@samp{p} は「述語 (predicate)」を表
わしている。初期の Lisp 研究者の間で用いられていた専門用語では「述語」は
ある属性が正しいかどうかを判定する関数のことを指していた。従って、
@samp{p}は @code{number-or-marker-p} が、与えられた引数が数値 (number)
もしくは マーカであるかどうかを判定する関数の名前であることを意味してい
る。他の Lisp のシンボルで @samp{p} で終わるものに @code{zerop} がある。
これは引数が0という値であるかどうかを判定する関数である。同様に@
@code{listp} は引数がリストかどうかを判定する関数である。

さて、いよいよエラーメッセージの最後の部分 @code{hello} であるが、これ
は @code{+} に渡された引数の値である。もし加法演算に正しい型のオブジェク
トが与えられていたとするなら、渡される値は @code{hello} のようなシンボル
ではなく、例えば37のような数値であったはずである。もっとも、その場合は、
エラーメッセージは出ないけれども。

@ignore
@need 1250
（無視）In GNU Emacs version 20 and before, the echo area displays an error
message that says:

@smallexample
Wrong type argument:@: number-or-marker-p, hello
@end smallexample

This says, in different words, the same as the top line of the
@file{*Backtrace*} buffer.
@end ignore

@node message
@subsection 関数 @code{message}
@findex message

@code{+} と同様、@code{message} という関数も引数の数は固定されていない。
この関数はユーザにメッセージを送るものだが、今説明したように、いろいろと
役に立つものである。

@need 1250
メッセージはエコー領域に表示される。例えば次のリストを評価することで、あ
なたのエコー領域にメッセージを表示させてみよう。

@smallexample
(message "This message appears in the echo area!")
@end smallexample

二重引用符に狭まれた文字列全体が一つの引数になっており、その全体が表示さ
れる。(この例ではメッセージそれ自身が二重引用符の中に入っていることに注
意しよう。これは、@code{message} という関数が返す値そのものがそうなって
いるからである。あなたが書くプログラムの中での普通の @code{message} の使
い方ではエコー領域に表示されるのは副作用によるものである。それには、二重
引用符は付いていない。このような例については @ref{multiply-by-seven in
detail, , インタラクティブな @code{multiply-by-seven}}, を参照のこと。)

しかしながら、もし @samp{%s} が二重引用符に挟まれた文字文字列に入ってい
たとしたら、関数 @code{message} は @samp{%s} をそのまま表示したりはせず
に、文字列に続く引数を見にいく。まずは二番目の引数を評価し、その結果を
@samp{%s} のある所に代入して表示する。

@need 1250
次のＳ式の最後にカーソルを持っていって @kbd{C-x C-e} とタイプしてみるこ
とで、このことが確かめられる。

@smallexample
(message "The name of this buffer is: %s." (buffer-name))
@end smallexample

@noindent
Info の中では、@code{"The name of this buffer is: *info*."} という文がエ
コー領域に表示されたことだろう。@code{buffer-name} という関数は現在のバッ
ファ名を文字列として返す。@code{message} はそれを @code{%s} の位置に挿入
したのだ。

値を10進数として表示するには、@samp{%s} の代わりに @samp{%d} という関数
を同じように使う。例えば、現在の @code{fill-column} の値をエコー領域に表
示させるには次を評価すれば良い。

@smallexample
(message "The value of fill-column is %d." fill-column)
@end smallexample

@noindent
（未訳）私の使っているシステムでは、このリストを評価した時点ではエコー領域には
@code{"The value of fill-column is 72."} と表示された
@footnote{Actually, you can use @code{%s} to print a number. It is
non-specific. @code{%d} prints only the part of a number left of a
decimal point, and not anything that is not a number.}。

もし一つ以上の @samp{%s} が二重引用符で狭まれた文字列の中にあったとする
と、最初の @samp{%s} の位置にはその文字列に続く最初の引数の値が表示され、
二番目の @samp{%s} の位置には二番目の引数の値が表示され... という具合に
なる。

@need 1250
例として次を評価してみよう。

@smallexample
@group
(message "There are %d %s in the office!"
         (- fill-column 14) "pink elephants")
@end group
@end smallexample

@noindent
かなり風変わりなメッセージが表示されたことと思う。私のシステムでは、
@code{"There are 58 pink elephants in the office!"}。のように表示された。

ここでは @code{(- fill-column 14)} というＳ式が評価され、その結果として
返された値が @samp{%d} の位置に挿入される。そして二重引用符で狭まれた
@code{"pink elephants"} という文字列が一つの引数として扱われて、
@samp{%s} の位置に置かれる。 (つまり、二重引用符で挟まれた文字列は、評価
された時に、数値と同じ様にそれ自身を値として返すわけである。)

最後に、単なる数の計算ではなく、Ｓ式の中にＳ式を置き、@samp{%s} で置き換
えることで文章を作る例として、ちょっと複雑なものを挙げておこう。

@smallexample
@group
(message "He saw %d %s"
         (- fill-column 32)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
@end group
@end smallexample

この例では、@code{message} は３つの引数を取る。@code{"He saw %d %s"} と
いう文字列と、@code{(- fill-column 32)} というＳ式と、@code{concat} とい
う関数で始まるＳ式である。@code{(- fill-column 32)} を評価して得られた結
果は @samp{%d} の位置に挿入され、@code{concat} から始まるＳ式を評価して
返される値は @samp{%s} の位置に挿入される。

私がこの式を評価したところ、エコー領域には @code{"He saw 38 red foxes
leaping."} というメッセージが表示された。

@node set & setq
@section 変数の値の設定
@cindex Variable, setting value
@cindex Setting value of variable

@cindex @samp{bind} defined
変数に値を格納する方法は幾つかある。一つの方法は、@code{set} もしくは
@code{setq} という関数を使うことである。また別の方法として、@code{let}
を使うというのもある。(@ref{let}, 参照). (このプロセスのことを専門用語で
は、変数に値をバインド (束縛) すると言う。)

この後のセクションでは @code{set} と @code{setq} の働きを説明するだけで
はなく、引数の渡され方の様子も述べることにする。

@menu
* Using set::                   値の設定
* Using setq::                  引用符をつけずに値を設定するには
* Counting::                    カウンタとしての @code{setq} の利用
@end menu

@node Using set
@subsection @code{set} の利用
@findex set

シンボル @code{flowers} の値としてリスト @code{'(rose violet daisy
buttercup)} をセットするために、次のＳ式の後にカーソルを持っていって
@kbd{C-x C-e} とタイプして、この式を評価してみよう。

@smallexample
(set 'flowers '(rose violet daisy buttercup))
@end smallexample

@noindent
すると @code{(rose violet daisy buttercup)} というリストがエコー領域に表
示されたはずだ。これは関数 @code{set} によって返された (@emph{return} さ
れた) 値である。その副作用としてシンボル @code{flowers} が、このリストに
バインドされる。つまり、シンボル @code{flowers} は、変数とみなすことが出
来て、その値がこのリストであるようになったということである。(因みにこの
プロセスは、値をセットするという Lisp インタプリタにとっては副作用でしか
ないことが、我々人間にとっては主効果たりうるということの説明になっている。
Lisp インタプリタはエラーが出ない限り必ず値を返すが、副作用の方は、
そのように意図しないと出ないものなのである。)

さっきの @code{set} を使ったＳ式を評価した後では、@code{flowers} という
シンボルを評価することが出来るようになっている。そして、たった今、我々が
セットした値を返す。実際に次のシンボルの後にカーソルを持っていって
@kbd{C-x C-e} とタイプしてみよう。

@smallexample
flowers
@end smallexample

@noindent
@code{flowers} を評価すると、エコー領域にリスト @code{(rose violet daisy
buttercup)} が現れたはずだ。

もし間違えて頭に引用符を付けた @code{'flowers} の方を評価したとすると、
エコー領域に現れるのはこのシンボル @code{flowers} それ自身になる。引用符
を付けたやつを次に挙げておくので、評価してみて欲しい。

@smallexample
'flowers
@end smallexample

もう一つ注意すべきことは、@code{set} を利用する時は、@code{set} の引数に
は、それらを評価しようとする場合を除いて、必ず引用符を付ける必要があると
いうことである。先の例の場合では、引数 @code{flowers} 及び @code{(rose
violet daisy buttercup)} のどちらも評価したくはなかったので、両方に引用
符を付けている。(@code{set} の一番目の引数に引用符を付けなかった場合、ま
ずまっ先にその引数が評価される。これを @code{flowers} に対してやったとし
て、もしこのシンボルがまだ値を持っていなかったとすると、@samp{Symbol's
value as variable is void} というエラーメッセージが表示される。一方、も
し @code{flowers} がある値を返したとすると、@code{set} はそいつにある値を
設定しようとする。勿論こうなるのが正しい動作である状況もあるが、そういう
ことは稀である。)

@node Using setq
@subsection @code{setq} の利用
@findex setq

実際問題として、大抵の場合は第一引数には引用符をつけることになるだろう。
@code{set} と引用符付きの第一引数の組み合わせというのは極めてよく使われ
るために、それに対して名前がついている。それが特殊形式 @code{setq} であ
る。この特殊形式はほぼ @code{set} と同じなのだが、第一引数に自動的に引用
符を付けてくれる所だけが違う。従ってあなた自身で引用符を付ける必要はない。
また、そのことに加えて、@code{setq} には、一つのＳ式の中で複数の異なる変
数に対して各々に異なる値をセットすることが出来る、という便利さもある。

@code{setq} を使って @code{carnivores} という変数に @code{'(lion tiger
leopard)} というリストをセットするには次のＳ式が使われる。

@smallexample
(setq carnivores '(lion tiger leopard))
@end smallexample

@noindent
これは @code{set} を使ったものと、第一引数に引用符が付いていないことを除
き、全く同じである。(@samp{setq} の @code{q} は @code{quote} を意味して
いる。)

@need 1250
@code{set} を使うと上のＳ式は次のようになる。

@smallexample
(set 'carnivores '(lion tiger leopard))
@end smallexample

また、@code{setq} は異なる変数の各々に異なる値をセットすることも出来ると
書いた。この場合には一番目の引数には二番目の引数の値がバインドされ、三番
目の引数には四番目の引数の値がバインドされ、という風になる。例えば次のＳ
式を使うとシンボル @code{tree} には樹木のリストを、シンボル
@code{herbivores} には草食動物のリストをセットすることが出来る。

@smallexample
@group
(setq trees '(pine fir oak maple)
      herbivores '(gazelle antelope zebra))
@end group
@end smallexample

@noindent
(このＳ式は一行で書いても構わないのだが、そうなるとページの大きさには合
わなってしまう。人間が読む場合には、こういう形式の方が読みやすいことがお
分りいただけると思う。)

@noindent
これまで何度か「セットする」という言葉を使ってきたけれども、@code{set}
とか @code{setq} の働きにはもう一つの捉え方がある。それは @code{set} や
@code{setq} はそのシンボルを特定のリストへの@emph{ポイント}にする、とい
うものだ。このような考え方は大変一般的であり、この後の章で、少なくとも一
つ、名前の中にそのポインタを持つシンボルに出逢うことになる。そういう名前
が付けられたのはそのシンボルに、ある値、より詳しくはリスト、がセットされ
ているためである。もう一つの言い方では、そのシンボルはそのリストへのポイ
ンタに設定されているという風に表現出来る。

@node Counting
@subsection カウント
@cindex Counting

次の例は、@code{setq} をカウンタとして利用する方法を説明してくれる。これ
は、プログラムの中である部分が何回繰り返されたかを数える場合に使うもので
ある。最初に変数を0に設定し、その後、プログラムの中でその部分が現われる
ごとに一つずつ足していくのである。そのためにはカウンタとなる一つの変数に
加えて二つのＳ式を用意する必要がある。初めにこのカウンタを0にセットする
ための @code{setq} 式と、評価されるごとにその変数を一ずつ増やすための
@code{setq} 式である。

@smallexample
@group
(setq counter 0)                ; @r{これをイニシャライザと呼ぼう。}

(setq counter (+ counter 1))    ; @r{これはインクリメンタと呼ぶ。}

counter                         ; @r{これはカウンタ。}
@end group
@end smallexample

@noindent
(@samp{;} に続く文はコメントである。@ref{Change a defun, , 関数定義の変更}, 参照。)

もし最初のイニシャライザであるＳ式 @code{(setq counter 0)} を評価してか
ら三番目の @code{counter} というＳ式を評価したなら、エコー領域には数値0
が表示される。次に二番目のインクリメンタのＳ式 @code{(setq counter (+
counter 1))} を評価すると、カウンタは一つ増える。従って、ここでもう一度
@code{counter} を評価するとエコー領域には数字1が表示される。その後も二番
目のＳ式を評価するごとに値は増えていく。

インクリメンタ @code{(setq counter (+ counter 1))} が評価されると Lisp
インタプリタは最初にもっとも内側にあるリストを評価する。このリストを評価
するために、まず @code{counter}, 次に1が評価される。変数 @code{counter}
を評価すると、その時の値が返される。それが数 @code{1} とともに @code{+}
に渡されて足し合わされる。で、その和は内側のリストの値として @code{setq}
に渡され、カウンタに新しい値が設定されることになる。以上のようにして、変
数 @code{counter} の値が変更される。

@node Summary
@section まとめ

Lisp を学ぶことは、最初の道が急な坂であるような丘を登るようなものである。
あなたが現在登っているのはもっとも急な部分である。先に進むに従って、より
楽に進めるようになるはずだ。

@need 1000
まとめると

@itemize @bullet

@item
Lisp のプログラムはリストもしくは単一のアトムからなるＳ式で出来ている。

@item
リストは0以上のアトムもしくはリストからなる。これらは空白文字で区切ら
れており、括弧で囲まれている。リストの中身は空であっても良い。

@item
アトムは幾つかの文字からなるシンボルである。例えば
@code{forward-paragraph} とか一つの文字からなる @code{+}、二重引用符に両
側を挟まれた文字列からなる文字列、それに数値などがそうである。

@item
数値は評価されるとそれ自身を返す。

@item
二重引用符で挟まれた文字列を評価した時もそれ自身を返す。

@item
シンボルそのものを評価すると、その値が返される。

@item
リストを評価すると、Lisp インタプリタはまずそのリストの一番目のシンボル
を見にいき、そのシンボルにバインドされている関数定義を見る。そしてその定
義の中にある命令を実行する。

@item
引用符
@ifinfo
'
@end ifinfo
@ifnotinfo
@code{'}
@end ifnotinfo
があると Lisp インタプリタはその後に続くＳ式を書かれたま
まの形で返し、二重引用符が無い場合のように評価したりはしない。

@item
引数は関数に渡される情報である。ある関数に渡される引数は、その関数を先頭
に持つリストの残りの要素を評価したものにある。

@item
関数は評価された時は (エラーが起きない限り) 常にある値を返す。また、それ
に加えて「副作用」と呼ばれる効果を生ずる。多くの場合、その関数を使う第一
の目的はその副作用を生じさせることにある。
@end itemize

@node Error Message Exercises
@section 練習問題

幾つか単純な練習問題を挙げておく。

@itemize @bullet
@item
括弧に挟まれない適当なシンボルを評価することにより、エラーメッセージを発
生させなさい。

@item
括弧に挟まれた適当なシンボルを評価することにより、エラーメッセージを発
生させなさい。

@item
1ではなく2ずつ増えるカウンタを作りなさい。

@item
評価された時にエコー領域に何かメッセージを表示するようなＳ式を書きなさい。
@end itemize

@node Practicing Evaluation
@chapter 実際の評価の仕方
@cindex Practicing evaluation
@cindex Evaluation practice

Emacs Lisp での関数の定義の書き方を学ぶ前に、ちょっと時間を取って、今ま
で書いてきた様々なＳ式を評価する方法について述べておこう。これらのＳ式は
関数を最初の (そしてしばしば唯一の) 要素として持つリストである。幾つかの
バッファに関連する関数は、単純であるし、興味深くもあるので、これらの関数
から始めようと思う。また、別のセクションで、同じくバッファに関連する他の
コードについて、それらがどのように書かれているか見てみるつもりだ。

@menu
* How to Evaluate::             編集コマンドのタイプするか @kbd{C-x C-e}
                                で評価を実行出来る。
* Buffer Names::                バッファとファイルの違い
* Getting Buffers::             バッファ名でなくバッファそのものを呼び出す
* Switching Buffers::           別のバッファに移るには
* Buffer Size & Locations::     ポイントの位置とバッファのサイズ
* Evaluation Exercise::         評価についての練習問題
@end menu

@ifnottex
@node How to Evaluate
@heading 評価の仕方
@end ifnottex

Emacs Lisp に対して、カーソルを動かすとかスクリーンをスクロールするなど
の編集コマンドを与える場合、@i{あなたは常に (最初の要素が関数であるよう
な) あるＳ式を評価している。これが Emacs の動作の基本である。}

@cindex @samp{interactive function} defined
@cindex @samp{command} defined
あなたが何かキーを押すと、そのことで Lisp インタプリタはあるＳ式を評価す
る。そういう風にしてあなたは求む結果を得るのである。たとえプレーンテキス
トをタイプしている時でも、Emacs Lisp の関数を評価させているのだ。この場
合に呼ばれるのは @code{self-insert-command} であり、これは、単にあなたが
タイプした文字を挿入するものである。キーを押すことで評価されるような関数
は@dfn{インタラクティブ} (@dfn{interactive}) な関数、あるいは、@dfn{コマ
ンド} (@dfn{command}) と呼ばれる。関数をインタラクティブにする方法は関数
の定義の書き方の章で説明することにする。@ref{Interactive, , 関数をインタ
ラクティブにする}, 参照。

キーボードコマンドをタイプするのに加えて、我々はもう一つＳ式を評価する方
法を学んだのだった。それはカーソルをリストの終端に持っていって @kbd{C-x
C-e} とタイプするやり方である。他にも同様にＳ式を評価する方法がある。そ
れらについては他のセクションでその都度説明するつもりだ。

評価されるのに使われることに加えて、次の幾つかのセクションで出てくる関数
は、それらそのものが元々重要である。これらの関数を学習することで、バッファ
とファイルの違いやバッファを切り替える方法、そしてその中での位置を定める
方法についてよく理解出来るようになるだろう。

@node Buffer Names
@section バッファの名前
@findex buffer-name
@findex buffer-file-name

@code{buffer-name} と @code{buffer-file-name} という二つの関数を見てみる
と、ファイルとバッファの違いがよく分るだろう。@code{(buffer-name)} とい
うＳ式を評価すると、バッファの名前がエコー領域に表示される。一方、
@code{(buffer-file-name)} を評価すると、バッファに関連付けられているファ
イルの名前がエコー領域に表示される。普通は @code{(buffer-name)} で返され
る名前は、それに関連付けられているファイルの名前と一致しており、
@code{(buffer-file-name)} はそのファイルのフルパスを返す。

ファイルとバッファは異なる種類の物である。ファイルというのは計算機に記録
されている情報であり、それを消去しない限りはずっと残っているものである。
一方でバッファは Emacs の内部の情報であり、その時々のセッション (訳註：
つまり、Emacs を起動して終了するまで) が終わると(もしくはそのバッファを
kill すると) 消え去ってしまうものである。普通はバッファはファイルからコ
ピーした情報を保持している。このことを、バッファがそのファイルに@dfn{ビ
ジット} (@dfn{visit}) しているという。我々はこのコピーに対して編集などの
仕事を行う。バッファに対する変更はそのバッファをセーブするまではファイル
には反映されない。バッファをセーブすると、バッファの内容はファイルにコピー
されて、そのまま記録されることになる。

@need 1250
もしこの文を GNU Emacs の Info で読んでいるのであれば、以下のＳ式の直後
にカーソルを持っていって @kbd{C-x C-e} とタイプすることで、各々の式を評
価することが出来る。

@example
@group
(buffer-name)

(buffer-file-name)
@end group
@end example

@noindent
私がこれらの式をInfoで評価してみたところ、@code{(buffer-name)} を評価すると
@file{"*info*"} という値が返され、@code{(buffer-file-name)} を評価すると
@file{nil} が返ってきた。

他方、私がこれらの式を執筆時に評価してみたところ、@code{(buffer-name)} を
評価すると@file{"introduction.texinfo"} という値が返され、@code{(buffer-file-name)} を
評価すると@file{"/gnu/work/intro/introduction.texinfo"} が返ってきた。

@cindex @code{nil}, history of word
前者がバッファの名前で、後者はそのファイル名である。(Ｓ式の中の括弧は、
Lisp インタプリタが @code{buffer-name} と @code{buffer-file-name} を関数
として扱っていることを示している。もし括弧が無ければ、インタプリタはその
シンボルを変数として評価しようとしただろう。詳しくは @ref{Variables, , 変
数}, を参照。)

（未訳）When I am writing, the name of my buffer is
@file{"introduction.texinfo"}.  The name of the file to which it
points is @file{"/gnu/work/intro/introduction.texinfo"}.

（未訳）(In the expressions, the parentheses tell the Lisp interpreter to
treat @w{@code{buffer-name}} and @w{@code{buffer-file-name}} as
functions; without the parentheses, the interpreter would attempt to
evaluate the symbols as variables.  @xref{Variables}.)

ファイルとバッファは違うものであるにも関わらず、しばしばバッファのことを
ファイルと言ったり、また、その逆を言ったりする人は多い。実際、大抵の人は
「私はファイルを編集している」といい、「私はファイルにセーブしようとして
いるバッファを編集している」などとは言ったりはしない。それでも殆どの場合、
状況から言いたいことは通じてしまう。しかしながら計算機のプログラムを扱う
場合は、その違いを心に留めておくことが重要だ。計算機は人間のように賢くは
ないのである。

@cindex Buffer, history of word
ところで `buffer' という言葉は衝突の際の衝撃を吸収するクッションを表わす
言葉から来ている。初期の計算機では、バッファはファイルと計算機の中央演算
処理装置 (CPU) の間のクッションの役目をしていた。ファイルを保存するドラ
ムやテープと CPU は互いに全く異なる装置であり、速度も全然違っている。バッ
ファは各々が互いに効果的に作業出来るようにするものだった。その後、バッファ
は中継ぎとか、一時的な保管場所とかいう意味から変化して作業する場所を示す
ようになった。この変化は小さな港から巨大な町への変化と似ている。かつては
単に船に積まれる貨物が一時的に保管される場所でしかなかった所が、ビジネス
や文化の中心としての存在になってしまったのである。

全てのバッファが必ず何らかのファイルに関連付けられているわけではない。例
えば @file{*scratch*} というバッファはどのファイルにもビジットしていない。
同様に @file{*Help*} というバッファもどのファイルにも関連付けられてはいな
い。

（未訳）In the old days, when you lacked a @file{~/.emacs} file and started an
Emacs session by typing the command @code{emacs} alone, without naming
any files, Emacs started with the @file{*scratch*} buffer visible.
Nowadays, you will see a splash screen.  You can follow one of the
commands suggested on the splash screen, visit a file, or press the
spacebar to reach the @file{*scratch*} buffer.

もし @file{*scratch*} バッファに切り替えて @code{(buffer-name)} とタイプ
し、その直後にカーソルを置いて @kbd{C-x C-e} とタイプしてそのＳ式を評価
したなら、@code{"*scratch*"} という名前が返り、エコー領域に表示される。
つまり、バッファの名前は @code{"*scratch*"} である。しかし、同じことを
@code{(buffer-file-name)} でやったなら、エコー領域には @code{nil} と表示
される。nil は「無 (nothing)」を表わすラテン語の単語である。この場合は@
@file{*scratch*} バッファがどのファイルにも関連付けられていないことを意
味している。(Lisp では @code{nil} は「偽 (false)」という意味や、空のリス
トである @code{()} の同意語としても使われる。)

ついでに言っておくと、もしあなたが、@file{*scratch*} バッファにいて、ある
Ｓ式が返す値をエコー領域ではなく @file{*scratch*} バッファそのものに表示
したい場合は、@kbd{C-x C-e} の代わりに @kbd{C-u C-x C-e} とタイプすれば
良い。こうすると、値はＳ式のすぐ後に表示される。つまり @file{*scratch*}
バッファには次のように表示される。

@smallexample
(buffer-name)"*scratch*"
@end smallexample

@noindent
これは Info の中では実行出来ない。というのも Info バッファは書き込み不可
(read-only) であり、勝手にバッファの中身を修正したりすることは出来ないか
らである。しかし、編集可能なバッファであれば、どのバッファであろうと実行
出来る。コードや文書(例えばこのマニュアルなんか)を書いている時には、この
機能は大変便利である。

@node Getting Buffers
@section バッファの獲得
@findex current-buffer
@findex other-buffer
@cindex Getting a buffer

@code{buffer-name} という関数はバッファの@emph{名前}を返す。従って、バッ
ファ@emph{そのもの}を取り出すには、別の関数が必要になる。これは
@code{current-buffer} という関数である。コードの中でこの関数を使うと、バッ
ファそのものが得られる。

名前と、その名前がついているオブジェクトないしは実体とは、互いに異なって
いる。あなたはあなたの名前とは違う。あなたは、他の人からその名前で呼ばれ
る一人の人間である。もしあなたが George と話したいと頼んだ時に、
@samp{G}, @samp{e}, @samp{o}, @samp{r}, @samp{g}, @samp{e} という文字の
書かれたカードを渡されたとしたら、あなたは面白いとは思うかもしれないが、
本来の要求は満たされない。あなたは名前と話したいというのではなく、その名
前を持つ人間と話したいのだから。バッファもそれと同じだ。スクラッチバッファ
の名前は @file{*scratch*} である。しかし、その名前はバッファそのものでは
ない。ということで、バッファそのものを取り出すときは、
@code{current-buffer} のような関数が必要なわけである。

しかしながら、事情はもう少し複雑である。例えば @code{current-buffer} を
すぐ後で実験するように、Ｓ式の中で評価したとする。そうすると、バッファの
中身ではなく、バッファの名前のみが表示される。Emacs がこのように動作する
のには二つの理由がある。そのバッファは何千行もあるかもしれない---これは
手軽に表示出来るというものではない。そして他のバッファで、名前は違っても
中身は同じものがあるかもしれない。それらを区別するのは、大変大切なことで
ある。

@need 800
さて、これがこの関数を含むＳ式である。

@smallexample
(current-buffer)
@end smallexample

@noindent
もし、ごく普通にこのＳ式を評価したとすると、エコー領域には
@file{#<buffer *info*>} のように表示される。このように特殊な様式で表示す
ることで、バッファの名前ではなく、そのバッファ自身が返されたことを示して
いるのである。

ついでに言うと、プログラムの中には数値やシンボルをタイプすることは出来る
が、表示されているバッファについてはそんなことは出来ない。バッファを取り
込む唯一の方法は @code{current-buffer} のような関数を使うことなのである。

関連する関数に @code{other-buffer} というのがある。これは、今、現在いる
バッファ、つまりカレントバッファを除いてもっとも最近選択したバッファを返
す。もし直前に @file{*scratch*} バッファに行って帰ってきたとしたら、
@code{other-buffer} は、このバッファを返す。

@need 800
このことは次のＳ式を評価することで確かめられる。

@smallexample
(other-buffer)
@end smallexample

@noindent
エコー領域には @file{#<buffer *scratch*>} もしくは、あなたが最近行って帰っ
てきたバッファの名前が表示されたはずだ。
@footnote{Actually, by default, if the buffer from which you
just switched is visible to you in another window, @code{other-buffer}
will choose the most recent buffer that you cannot see; this is a
subtlety that I often forget.}

@node Switching Buffers
@section バッファ間の移動
@findex switch-to-buffer
@findex set-buffer
@cindex Switching to a buffer

@code{other-buffer} という関数はこれを引数とする関数から呼ばれた場合には
実際にそのバッファの中身を提供する。これは @code{other-buffer} と
@code{switch-to-buffer} を使って他のバッファに切り替えることで確かめられ
る。

が、その前に、@code{switch-to-buffer} という関数を簡単に紹介しておこう。
Info バッファから @code{(buffer-name)} を評価するために @file{*scratch*}
バッファに行って戻ってくる際に、多分あなたはまず @kbd{C-x b} とタイプし、
そしてミニバッファにどのバッファに移るか尋ねるプロンプトが出た時に
@file{*scratch*} とタイプしたのではないだろうか。この時のキーストローク
@kbd{C-x b} は Lisp インタプリタに対してインタラクティブに Emacs Lisp の
関数 @code{switch-to-buffer} を評価させているのである。前にも言ったよう
に Emacs はこのようにして動作している。また別のキーストロークはまた別の
関数を呼び出したり走らせたりする。例えば @kbd{C-f} は@
@code{forward-char} を呼び出すし、@kbd{M-e} は @code{forward-sentence}
を呼び出す、といった感じである。

Ｓ式の中で @code{switch-to-buffer} と書いて、そいつに移るべきバッファを
与えると、@kbd{C-x b} と全く同じようにしてバッファを切り替えることが出来
る。

@smallexample
(switch-to-buffer (other-buffer))
@end smallexample

@noindent
@code{switch-to-buffer} というシンボルはこのリストの最初の要素であるから、
Lisp インタプリタは、こいつを関数として扱い、それに定義されている命令を
実行する。しかし、その前に、内側に括弧に挟まれた @code{other-buffer} が
あることを発見し、こちらを先に解釈する。@code{other-buffer} は、このリス
トの最初の (そしてこの場合は唯一の) 要素であるから、Lisp インタプリタは
この関数を走らせる。するとこいつは別のバッファを返す。次にインタプリタは
返ってきたバッファを @code{switch-to-buffer} に引数として渡して、この関
数を走らせる。そうして Emacs は他のバッファに切り替わる。もし、この文書
を Info で読んでいるなら早速試してみよう。上のＳ式を評価するのである。
(戻ってくるには、@kbd{C-x b @key{RET}} とタイプする。)
@footnote{Remember, this
expression will move you to your most recent other buffer that you
cannot see.  If you really want to go to your most recently selected
buffer, even if you can still see it, you need to evaluate the
following more complex expression:

@smallexample
(switch-to-buffer (other-buffer (current-buffer) t))
@end smallexample

@c noindent
In this case, the first argument to @code{other-buffer} tells it which
buffer to skip---the current one---and the second argument tells
@code{other-buffer} it is OK to switch to a visible buffer.
In regular use, @code{switch-to-buffer} takes you to an invisible
window since you would most likely use @kbd{C-x o} (@code{other-window})
to go to another visible buffer.}

後の方のセクションに出てくるプログラミングの例では
@code{switch-to-buffer} よりも @code{set-buffer} という関数の方をより多
く見かけるだろう。これは計算機のプログラムと人間の違いによる。人間は目を
持ち今作業している計算機の端末の上にそのバッファを見たいと思うものである。
これはいうまでもなく当たり前のことである。しかしながら、プログラムは目を
持たない。プログラムがバッファを扱っている時には、バッファはスクリーンに
見えていなくたって良いのである。

@code{switch-to-buffer} は人間のために設計されており、二つのことを行う。
一つは Emacs が注意を向けているバッファを切り替えることであり、もう一つ
は画面に見えているバッファを切り替えることである。一方、
@code{set-buffer} の方は一つの仕事しかしない。単に計算機が注意を向けてい
るバッファを別のバッファに切り替えるだけである。画面に見えているウィンド
ウはそのままだ (勿論、普通はそのコマンドが終了するまでは何も起こらない。)

@cindex @samp{call} defined
ここでまた別の専門用語を紹介しよう。@dfn{呼び出す} (@dfn{call}) という言
葉である。最初のシンボルが関数であるリストを評価すると、その関数が呼び出
される。(call される。)この時の呼び出すという単語の使い方は、「呼び出す」
ことで実体としての関数が何かをやってくれることから来ている---本物の配管
工を「呼び出す」と水洩れを直してくれるのと一緒である。

@node Buffer Size & Locations
@section バッファのサイズとポイントの位置
@cindex Size of buffer
@cindex Buffer size
@cindex Point location
@cindex Location of point

最後に、簡単な関数を幾つか見てみよう。@code{buffer-size}, @code{point},
@code{point-min}, そして @code{point-max} である。これらはバッファのサイ
ズとその中でのポイントの位置の情報を与えてくれるものである。

@code{buffer-size} という関数は現在のバッファの大きさを教えてくれる。
つまり、そのバッファの中の文字の数を返すのである。

@smallexample
(buffer-size)
@end smallexample

@noindent
これをいつものように、Ｓ式の最後にカーソルを持っていって @kbd{C-x C-e}
とタイプすることで評価してみよう。

@cindex @samp{point} defined
Emacs の中では現在のカーソルの位置はポイントと呼ばれる。@code{(point)}
というＳ式はバッファの始まりからポイントまでの文字数を返す。それによって
現在のカーソルの場所が分る。

@need 1250
次のＳ式をこのバッファの中でいつも通りに評価すればポイントまでの文字数が
分る。

@smallexample
(point)
@end smallexample

@noindent
これを書いているときには、@code{point} の値は121905であった。この
@code{point} という関数は、このマニュアルの後の方に出てくる幾つかの例の
中では頻繁に使われる。

@need 1250
勿論ポイントの値はバッファの中での位置に依存している。次の場所でポイント
を評価すれば、その値はさっきよりも大きくなっているはずである。

@smallexample
(point)
@end smallexample

@noindent
私の場合この場所でのポイントの値は66043であった。これは両方のＳ式の間に
(空白も含めて) 319文字あることを示している。  
(Doubtless, you will see different numbers, since I will
have edited this since I first evaluated point.)

@cindex @samp{narrowing} defined
@code{point-min} という関数はちょっと @code{point} に似ているが、こちら
はカレントバッファ中のポイントの値の中で許される最小の値を返す。この値は
@dfn{ナローイング} (@dfn{narrowing}) が有効になっていない限り1という数値
である。(ナローイングというのは、あなた自身もしくはプログラムの操作をバッ
ファの特定部分に制限してしまうある仕組みである。詳しくは @ref{Narrowing
& Widening, , ナローイングとワイドニング}, を参照のこと。) 同様に、
@code{point-max} というのはカレントバッファ中のポイントの値の中で許され
る最大の値を返す。

@node Evaluation Exercise
@section 練習問題

あなたが作業しているファイルを一つ開いて、その中央辺りまで行きなさい。そ
して、そのバッファ名、ファイル名、長さ、及びファイルの中での位置を調べな
さい。

@node Writing Defuns
@chapter 関数定義の書き方
@cindex Definition writing
@cindex Function definition writing
@cindex Writing a function definition

Lisp インタプリタがリストを評価する場合、まずリストの最初のシンボルが関
数定義を持っているかどうか、別の言い方をするとシンボルから関数定義へのポ
インタがあるかを見にいく。もしそうであれば、計算機はその定義に含まれる命
令を実行する。関数定義を持つシンボルのことを単に関数と言う。 (ただし、正
確には定義が関数なのであり、シンボルはそれを指しているだけである。)

@menu
* Primitive Functions::         幾つかの関数は C で書かれている
* defun::                       特殊形式 @code{defun}
* Install::                     関数定義のインストール
* Interactive::                 関数をインタラクティブにする
* Interactive Options::         @code{interactive} の他のオプション
* Permanent Installation::      コードをずっとインストールしておきたい時
* let::                         局所変数の作成と初期化
* if::                          if とは？
* else::                        If--then--else 式
* Truth & Falsehood::           Lisp にとっての真と偽
* save-excursion::              ポイントやマークの位置、及びバッファの保存
* Review::                      復習
* defun Exercises::             関数定義についての練習問題
@end menu

@ifnottex
@node Primitive Functions
@unnumberedsec プリミティブな関数について
@end ifnottex
@cindex Primitive functions
@cindex Functions, primitive

@cindex C language primitives
@cindex Primitives written in C
全ての関数は C 言語で書かれた少数の @dfn{プリミティブ} (@dfn{primitive})
な関数を除いて、別の関数を使って定義されている。関数を書く場合にはそれを
Emacs Lisp を使って書き、他の関数を部品として使うことになる。あなたが使
う関数はそれ自身 (あなたが書いたものを含めて) Emacs Lisp で書かれたもの
かもしれないし、C で書かれたプリミティブなものかもしれない。プリミティブ
な関数も Emacs Lisp で書かれているのものと全く同じように使われ、同じよう
に振舞う。これらが C で書かれているのは、十分な能力を持ち、C を走らせる
ことが出来るどの計算機でも簡単に GNU Emacs が動くようにするためである。

再度強調しておくけれども、Emacs Lisp のコードを書く場合、C で書かれた関
数を使う場合と Emacs Lisp で書かれた関数を使う場合とで区別をつける必要は
全くない。違いは全く無視して構わない。私がこの区別のことを書いたのは、単
に知っていた方が面白いからである。実際、調査でもしない限り、既に書かれて
いる関数が Emacs Lisp で書かれているか C で書かれているかは判断出来ない。

@node defun
@section マクロ @code{defun}
@findex defun

@cindex @samp{function definition} defined
Lisp では @code{mark-whole-buffer} のようなシンボルには、その関数が呼ば
れた時に計算機が何をすべきかを教えるコードが付随している。このコードのこ
とを @dfn{関数定義} (@dfn{function definition}) といい、シンボル
@code{defun} で始まるＳ式を評価した時に作られる。(これは @emph{define
function} の略である。) @code{defun} は通常とは別の引数の評価の仕方をす
るために、@dfn{特殊形式} (@dfn{special form}) と呼ばれる。

この後に続く幾つかのセクションでは、例えば @code{mark-whole-buffer} のよ
うに Emacs のソースコードの中から関数定義を見ていくことにする。が、この
セクションではもっと単純な関数定義を説明し、それがどんなものなのかを、ま
ず理解してもらうことにしよう。簡単な例にするために算数についての例にする。
算数を使った例が嫌いな人達もいるとは思うが、あなたがそうだとしてもがっく
りくる必要はない。この入門書の残りに出てくる殆どのコードには算数とか数学
は出てこない。出てくる例は、大体が何がしかの意味でテキストに関わるもので
ある。

関数定義は @code{defun} という単語に続けて、次のような最大五つの部分を加
えたものである。

@enumerate
@item
関数定義が付けられるシンボルの名前。

@item
関数に渡される引数のリスト。もし一つも引数をつけない場合、ここは空リスト
@code{()} にする。

@item
関数を説明する文章。(技術的には省略可能であるが、書くことが強く望まれて
いる。)

@item
省略可能。この関数をインタラクティブにする、つまり @kbd{M-x} に続けて関
数名をタイプするか、適当なキーないしはキーコードをタイプすることで使うこ
とが出来るようにするためのＳ式を書く。

@cindex @samp{body} defined
@item
計算機に何をすべきかを命令するコードを書く。即ち、関数定義の本体である。
@end enumerate

この関数定義の五つの部分の各々にスロットを割当てて、次のようなテンプレー
トにして整理しておくと役に立つだろう。

@smallexample
@group
(defun @var{関数名} (@var{引数}@dots{})
  "@var{オプションの説明文字列}@dots{}"
  (interactive @var{引数情報}) ; @r{省略可能}
  @var{本体}@dots{})
@end group
@end smallexample

一つの例として、引数に7をかける関数のコードを挙げる。(この例はインタラ
クティブではない。@ref{Interactive, , 関数をインタラクティブにする}, を
見よ。)

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

この定義は括弧と @code{defun} というシンボルで始まり、関数の名前が続いて
いる。

@cindex @samp{argument list} defined
関数の名前の次にはこの関数に渡される引数のリストが来る。このリストは
@dfn{引数リスト} (@dfn{argument list}) と呼ばれる。今の場合、このリスト
の要素は @code{number} というシンボル一つだけである。この関数が使われる
時には、このシンボルは関数の引数として使われる値にバインドされる。

引数の名前として @code{number} という単語を選ぶ代わりに他の名前を選んで
も良い。例えば @code{multiplicand} という単語でも良かった。私が `number'
という単語を選んだのは、このスロットにどういう種類の値が要求されるかが分
るからである。しかし、このスロットに置かれる値がこの関数の働きの中でどう
いう役割を果たすかを示すという意味で `multiplicand' という単語を選ぶのも
悪くなかった。@code{foogle} としても構わないが、これは良い選択だとは思え
ない。これでは何のことか分らない。どういう名前にするかはプログラマ次第だ
が、関数の意味を明確にするようなものが選ばれるべきである。

実の所、引数リストの中のシンボルにはどんな名前でも選ぶことが出来る。たと
え、他の関数の中で使われているシンボル名であっても良いのである。引数リス
トの中で使われる名前は、その特定の定義の中だけでしか使われないプライベー
トなものであるからだ。この定義の中では、他のどんな関数定義の中にある同じ
名前のシンボルとも異なる実体を指すのである。例えば、あなたが家族の間では
`Shorty' というニックネームをつけられているとしよう。この場合、あなたの
家族の誰かが `Shorty' という場合には、それはあなたのことを指している。し
かしあなたの家族以外の所、例えば映画の中などでは `Shorty' というのは別の
誰かを指している。引数リストの中の名前はその関数の中だけで通用するものな
ので、この関数の本体の中でそのシンボルの値をどう変えたとしても外での値に
は何の影響もないというわけだ。似たような効果が @code{let} を使ったＳ式の
場合でも見られる。(@ref{let, , @code{let}}, 参照。)

@ignore
ここで、`number' という単語を二通りの方法で議論したことにも注意しよう。
一つはコードの中に現れるシンボルとして、もう一つはこの関数が評価される時
に置き換わる何かの名前として、である。一つ目の場合には、@code{number} は
シンボルである。これは数値ではない。関数の中ではこれはある変数であって、
その値が問題となる数値なのだが、我々の主な興味はそのシンボルとしての振舞
いであった。一方で、関数について話す場合には、我々の興味は @var{number}
という単語をある数値で置き換えることにある。二つの違いを明確にするために、
それぞれの使い方に従って二通りの書き方をすることにしよう。この関数がどう
働くかについて話す時は、@var{number} と書く。一方、関数そのものの中でシ
ンボルとして話すときには @code{number} と書くことにしよう。
@end ignore

引数リストの次には、関数についての説明である、説明文字列が来る。これは
@w{@kbd{C-h f}} に続けてその関数の名前をタイプした時に表示される内容であ
る。ついでに言っておくと、あなたが説明文字列を書く場合には、最初の一行は
完結した一つの文にすべきである。というのも、@code{apropos} のような幾つ
かのコマンドは複数行に渡って書かれた説明文の文字列のうちの最初の一行だけ
しか表示しないからである。また、二行目も書く場合はこれをインデントすべき
ではない。何故なら、@kbd{C-h f} (@code{describe-function}) を使ったとき
に変な表示のされかたをするからである。説明文字列は省略可能ではあるが、大
変役に立つものなので、関数を書く際にはなるべく書くようにすべきである。

@findex * @r{(multiplication)}
さっきの例での三行目は関数定義の本体をなしている。 (普通の関数定義は勿論
これよりもっと長い。) 今の場合、この本体は @code{(* 7 number)} というリ
ストであり、@var{number} の値に7をかけることを定めている。(Emacs Lisp で
は @code{*} は掛け算を表わす関数である。同様に @code{+} は足し算を表わす。)

@code{multiply-by-seven} という関数を使う場合、引数 @code{number} はあな
たが実際に使いたい値に評価される。次の例では @code{multiply-by-seven} の
使い方を示している。ただし、まだこれを評価しないように！

@smallexample
(multiply-by-seven 3)
@end smallexample

@noindent
次のセクションで詳しく述べるが、今の例ではシンボル @code{number} に3とい
う値が与えられた、ないしは「バインドされた」わけである。@code{number} は
関数定義の括弧の中にあるが、@code{multiply-by-seven} という関数に渡され
る引数は括弧の外にあることに注意しておこう。関数定義の中に括弧があるのは、
計算機が引数のリストが何処で終わり、残りの部分が何処から始まるかを知るた
めにあるのである。

この例を評価すると多分エラーメッセージが出るだろう。(試してみよう！) こ
れは、我々は確かに関数定義を書いたのだが、まだその定義を計算機に伝えてい
ない---つまり、まだ Emacs にこの関数定義をインストール (もしくはロード)
していない---ためである。インストールの仕方については次のセクションで説
明する。

@node Install
@section 関数定義のインストール
@cindex Install a Function Definition
@cindex Definition installation
@cindex Function definition installation

もし Emacs の Info の中でこれを読んでいるのなら、先に関数の定義を評価し、
次に @code{(multiply-by-seven 3)} を評価することで、
@code{multiply-by-seven} という関数を試してみることが出来る。この下に関
数定義の写しを書いておくので、その直後にカーソルを持っていって @kbd{C-x
C-e} とタイプしよう。そうすると、エコー領域に @code{multiply-by-seven}
と表示される。(これは関数定義を評価した時に返す値はその関数の名前である
ことを示している。) 同時に、こうすることで関数定義がインストールされる。

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

@noindent
この @code{defun} を評価することで、たった今 Emacs に
@code{multiply-by-seven} がインストールされた。今ではこの関数は
@code{forward-word} やあなたが編集に使う他の関数と全く同様、Emacs の一部
である。(@code{multiply-by-seven} はあなたが Emacs を終了するまでインス
トールされたままになっている。このコードを Emacs を起動するたびに再ロー
ドする方法については、
@ref{Permanent Installation, , コードをずっとインストールしておくには},
を見よ。)

@menu
* Effect of installation::
* Change a defun::              How to change a function definition.
@end menu

@ifnottex
@node Effect of installation
@unnumberedsubsec The effect of installation
@end ifnottex

@code{multiply-by-seven} をインストールしたことでどうなったかは、次の例
を評価することで見ることが出来る。カーソルを次のＳ式の直後に持っていって
@kbd{C-x C-e} とタイプしてよう。エコー領域には21という数字が表示されたは
ずだ。

@smallexample
(multiply-by-seven 3)
@end smallexample

もし望むなら、@kbd{C-h f} (@code{describe-function}) に続けてこの関数の
名前 @code{multiply-by-seven} をタイプすることで、この関数定義の説明を読
むことも出来る。そうすると、@file{*Help*} というウィンドウに次のように表
示される。

@smallexample
@group
multiply-by-seven is a Lisp function.
(multiply-by-seven NUMBER)

Multiply NUMBER by seven.
@end group
@end smallexample

@noindent
(スクリーンを元の一つのウィンドウに戻すには、@kbd{C-x 1} とタイプすれば
良い。)

@node Change a defun
@subsection 関数定義の変更
@cindex Changing a function definition
@cindex Function definition, how to change
@cindex Definition, how to change

@code{multiply-by-seven} の中のコードを変更したい場合は、単にそれを書き
直すだけである。古いものを新しいバージョンに置き換えるには、その関数定義
をもう一度評価すれば良い。これが Emacs の中のコードを修正する方法である。
極めて単純だ。

例として、@code{multiply-by-seven} という関数を7をかけるのではなく、その
数自身を7回加えるものに変更することが出来る。結果としては同じ答えが得ら
れるけれども、途中の道筋は違っている。同時にコードの中にコメントを加えよ
う。これは Emacs には無視されるけれども、人間が読む場合には便利だなあと
か解りやすいとか思うはずだ。今回は、これが二番目のバージョンであるという
コメントを書いておくことにする。

@smallexample
@group
(defun multiply-by-seven (number) ; @r{二番目のバージョン}
  "Multiply NUMBER by seven."
  (+ number number number number number number number))
@end group
@end smallexample

@cindex Comments in Lisp code
コメントはセミコロン @samp{;} の後に続いている。Lisp では、セミコロンの
後に続く全てのものはコメントである。行の終わりがコメントの終わりになる。
二行以上に渡ってコメントを書きたい場合は各々の行をセミコロンで始める。

@ref{Beginning init File, , @file{.emacs} の書き方},及び
@ref{Comments, , Comments, elisp, The GNU Emacs Lisp Reference Manual},
にコメントについて、より詳しく説明されている。

今のバージョンの @code{multiply-by-seven} 関数をインストールするには最初
のものをインストールした時と全く同じようにして評価してやれば良い。つまり、
カーソルを最後の括弧のすぐ後に持ってきて @kbd{C-x C-e} とタイプすれば良
いのである。

まとめると、Emacs でコードを書く方法は次の通りである。まずは関数を書き、
インストールし、テストしてみる。で、不具合を修正したり拡張したりして再
度インストールするという具合だ。

@node Interactive
@section 関数をインタラクティブにする
@cindex Interactive functions
@findex interactive

関数をインタラクティブなものにするには、特殊形式 @code{interactive} で始
まるリストを説明文字列のすぐ後に置けばよい。インタラクティブな関数はユー
ザーが @kbd{M-x} に続けて関数の名前をタイプすることで呼び出すことが出来る。
あるいは、その関数にバインドしたキーをタイプしてもよい。例えば、
@kbd{C-n} とタイプすると @code{next-line} が呼ばれるし、@kbd{C-x h} とタ
イプすると @code{mark-whole-buffer} が呼ばれる。

面白いことに、インタラクティブな関数をインタラクティブに呼び出すと、返さ
れる値は自動的にはエコー領域に表示されない。これはインタラクティブな関数
はしばしば、単語分や一行分前に進んだりするなどの副作用を目的に呼ぶのであっ
て、返される値のことは気にしないからである。もしキーをタイプするごとにエ
コー領域に値が表示されたら、随分と欝陶しいことだろう。

@menu
* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::    The interactive version.
@end menu

@ifnottex
@node Interactive multiply-by-seven
@unnumberedsubsec An Interactive @code{multiply-by-seven}, An Overview
@end ifnottex

特殊形式 @code{interactive} を使いつつエコー領域に値を表示する方法につい
て説明するために、 @code{multiply-by-seven} のインタラクティブバージョン
を作ってみよう。

@need 1250
これがそのコードである。

@smallexample
@group
(defun multiply-by-seven (number) ; @r{インタラクティブバージョン}
  "Multiply NUMBER by seven."
  (interactive "p")
  (message "The result is %d" (* 7 number)))
@end group
@end smallexample

@noindent
このコードはカーソルをコードのすぐ後に持っていって @code{C-x C-e} とタイ
プすることでインストール出来る。ちゃんと、この関数の名前がエコー領域に表
示されただろうか。次からこのコードを使うには、まず @kbd{C-u} に続けて数
をタイプし、その後に @kbd{M-x multiply-by-seven} とタイプして @kbd{RET}
を押せば良い。エコー領域に、@samp{The result is @dots{}} という文に続い
て計算結果が表示されるはずだ。

もっと一般的に言うと、このような関数は次の二通りの内どちらかの方法で呼び
出すことが出来る。

@enumerate
@item
まず渡されるべき数を含む前置引数をタイプする。ついで @kbd{M-x} と関数名
をタイプする、例えば @kbd{C-u 3 M-x forward-sentence}、とする。

@item
あるいは、その関数にバインドされたキーないしはキーコードをタイプする。例
えば @kbd{C-u 3 M-e}。
@end enumerate

@noindent
今挙げた二つの例では、どちらの場合もポイントが３つの文だけ前方に移動する。
(この関数を例として扱った理由は、@code{multiply-by-seven} はどのキーにも
バインドされてはいないので、キーバインディングの例としては使えないからで
ある。)

(コマンドをキーにバインドする方法については @ref{Keybindings, , 幾つかのキーバインディング}, を参照のこと。)

前置引数をインタラクティブな関数に渡すには、@kbd{M-3 M-e} のように
@kbd{META} キーに続けて数をタイプする方法と、@kbd{C-u 3 M-e} のように
@kbd{C-u} に続けて数をタイプする方法とがある。(もし @kbd{C-u} の後に何も
数をタイプしなかった場合、デフォルトでは4が渡される。)

@node multiply-by-seven in detail
@subsection インタラクティブな @code{multiply-by-seven}

インタラクティブバージョンの @code{multiply-by-seven} の中の特殊形式
@code{interactive} の使い方と、関数 @code{message} を見てみよう。もう一
度この関数の定義を書いておく。

@smallexample
@group
(defun multiply-by-seven (number) ; @r{インタラクティブバージョン}
  "Multiply NUMBER by seven."
  (interactive "p")
  (message "The result is %d" (* 7 number)))
@end group
@end smallexample

この関数の中ではＳ式 @code{(interactive "p")} は二つの要素からなるリスト
である。@code{"p"} は Emacs に対し、この関数に前置引数を渡し、その値を関
数の引数として使うことを知らせるためのものである。

@need 1000
引数は数になる。これは @code{number} というシンボルが

@smallexample
(message "The result is %d" (* 7 number))
@end smallexample

@need 1250
@noindent
という行の中である数にバインドされるという意味である。例えば、前置引数が
5だとすると、Lisp インタプリタはこの行を次のように評価することになる。

@smallexample
(message "The result is %d" (* 7 5))
@end smallexample

@noindent
(もし、この文章を GNU Emacs の中で読んでいるなら、このＳ式をあなた自身で
評価することが出来る。) 最初にインタプリタは内側にあるリストを評価する。
今の場合は @code{(* 7 5)} である。これは値35を返す。次にその外側のリスト
が評価される。つまり、二番目及び残りの要素の値が @code{message} という関
数に渡される。

前に見たように、@code{message} は特に一行のメッセージをユーザに送るため
の Emacs Lisp の関数であった。(@ref{message, , 関数 @code{message}}, 参
照。) 手短に言うと、関数 @code{message} は最初の引数をエコー領域に表示す
るのだが、@samp{%d}, @samp{%s}, 及び @samp{%c} だけは例外で、これらの制
御文字列の内のどれかが現れた時は、残りの二番目以降の引数を順に見に行き、
その値をこれらがある場所に挿入して表示する。

@code{multiply-by-seven} という関数では、制御文字列として @samp{%d} が使
われ、これは数を要求する。今の場合ならその値は @code{(* 7 5)} を評価して
返された35という数である。その結果、@samp{%d} の場所には35が表示され、メッ
セージは @samp{The result is 35} となるわけである。

(ここで注意だが、@code{multiply-by-seven} という関数を呼んだ場合、メッセー
ジは引用符無しで表示される。しかし @code{message} をそのまま呼んだ場合に
は、二重引用符で囲まれている。これは @code{message} が返す値そのものは
@code{message} が先頭にあるＳ式を評価した場合にエコー領域に表示されるも
ので、これには引用符がついているのだが、これが他の関数の中に埋め込まれて
使用された場合、表示されるものは @code{message} が副作用として出力するも
ので、これには二重引用符がついていないからである。)

@node Interactive Options
@section @code{interactive} の他のオプション
@cindex Options for @code{interactive}
@cindex Interactive options

上の例で @code{multiply-by-seven} は @code{interactive} の引数として
@code{"p"}を使っている。この引数がある場合、Emacs はあなたが、@kbd{C-u}
に続けて数をタイプするか、@kbd{Meta} キーに続けて数をタイプするかして、
このコマンドに引数として数を渡すものと解釈する。Emacs はこのような
@code{interactive} の引数を20種類以上用意している。大抵の場合、これらの
オプションの内にあなたが望む通りの情報を関数に渡すものが一つか二つはある
はずだ。(@ref{Interactive Codes, , Code Characters for
@code{interactive}, elisp, The GNU Emacs Lisp Reference Manual}, 参照。)

@need 1250
（未訳）Consider the function @code{zap-to-char}.  Its interactive expression
is

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

（未訳）The first part of the argument to @code{interactive} is @samp{p}, with
which you are already familiar.  This argument tells Emacs to
interpret a `prefix', as a number to be passed to the function.  You
can specify a prefix either by typing @kbd{C-u} followed by a number
or by typing @key{META} followed by a number.  The prefix is the
number of specified characters.  Thus, if your prefix is three and the
specified character is @samp{x}, then you will delete all the text up
to and including the third next @samp{x}.  If you do not set a prefix,
then you delete all the text up to and including the specified
character, but no more.

（旧訳）あるいは、@samp{B} であれば、Emacs はバッファの名前を聞いてきて、入力し
た値をその関数に渡す。もう少し詳しく言うと、Emacs はミニバッファにプロン
プトを出して、ユーザーに名前を要求する。この時のプロンプトには @samp{B}
に続く値が使われるので、例えば、@code{"BAppend to buffer:@: "} とか書い
ておく。Emacs はただ単にプロンプトを出すだけではなくて、判断出来る分だけ
の入力があれば、@kbd{TAB} キーを押すことで補完までしてくれる。

（未訳）The @samp{c} tells the function the name of the character to which to delete.

（未訳）More formally, a function with two or more arguments can have
information passed to each argument by adding parts to the string that
follows @code{interactive}.  When you do this, the information is
passed to each argument in the same order it is specified in the
@code{interactive} list.  In the string, each part is separated from
the next part by a @samp{\n}, which is a newline.  For example, you
can follow @samp{p} with a @samp{\n} and an @samp{cZap to char:@: }.
This causes Emacs to pass the value of the prefix argument (if there
is one) and the character.

（旧訳）関数に二つ以上の引数を渡したい場合、@code{interactive} に続けて複数の文
字列を付け加えることで、各々の引数に情報を渡すことが出来る。この場合その
情報は、各々の引数に @code{interactive} に書いたのと同じ順序で渡される。
付け加える文字列は、各々の部分を @samp{\n}, 即ち改行コードで区切る。例え
ば @code{"BAppend to buffer:@: "} に続けて @samp{\n} と @samp{r} を書い
たりする。こうすると、Emacs はプロンプトでバッファ名を要求すると同時にポ
イントとマークの値もその関数に渡してくれる---三つの引数全てを渡してくれ
るのである。

（未訳）In this case, the function definition looks like the following, where
@code{arg} and @code{char} are the symbols to which @code{interactive}
binds the prefix argument and the specified character:

（旧訳）この場合の関数定義は次のような形式になる。@code{buffer}, @code{start},
及び、@code{end} は @code{interactive} がバッファとその時のリージョンの
始まりと終わりをバインドするシンボルである。

@smallexample
@group
(defun @var{関数名} (arg char)
  "@var{説明文字列}@dots{}"
  (interactive "p\ncZap to char: ")
  @var{関数の本体}@dots{})
@end group
@end smallexample

@noindent
(プロンプトのコロンの後の空白は、プロンプトを出す時の見栄えをよくするた
めのものである。@code{append-to-buffer} という関数はまさにこのようになっ
ている。@ref{append-to-buffer, , @code{append-to-buffer} の定義}, 参照。)

（未訳）When a function does not take arguments, @code{interactive} does not
require any.  Such a function contains the simple expression
@code{(interactive)}.  The @code{mark-whole-buffer} function is like
this.

あるいは、もし上に挙げたような特定の文字による引数の与え方があなたの目的
に合わない場合、あなた自身の引数をリストとして @code{interactive} に渡す
ことも可能である。

@ref{Using interactive, ,Using @code{Interactive},
elisp, The GNU Emacs Lisp Reference Manual}, にこの上級テクニックについ
てのより詳しい解説がある。

@node Permanent Installation
@section コードをずっとインストールしておくには
@cindex Install code permanently
@cindex Permanent code installation
@cindex Code installation

関数定義を評価することで一旦その関数をインストールすると、Emacs を終了す
るまでその関数はインストールされたままになっている。一方、次に Emacs の
新しいセッションを開始した時は、その関数定義を再度評価するまでその関数は
インストールされない。

ある時点で、Emacs の新しいセッションを始める時に自動的にインストールした
いと思うかもしれない。方法は幾つかある。

@itemize @bullet
@item
もし、自分自身で書いたコードがあれば、その関数定義のコードをあなたの初期
化ファイル @file{.emacs} の中に書き込む。そうすると Emacs を起動した時に
この @file{.emacs} というファイルが自動的に評価されて、その中に書かれた
全ての関数がインストールされる。@ref{Emacs Initialization, ,
@file{.emacs} ファイル}, 参照。

@item
あるいは、インストールしたい関数の定義を一つのファイル、もしくは関数ごと
に複数のファイルに書いておき、@code{load} という関数を使って Emacs にそ
れを評価させてそれらの関数をインストールするという方法もある。
@ref{Loading Files, , ファイルのロード}, 参照。

@item
また、あなたのいるサイト全体でそのコードを使いたい場合は、普通はその関数
を @file{site-init.el} 呼ばれるファイルに書いておく。このファイルは
Emacs を作成する時に自動的にロードされる。こうすることで、あなたの計算機
を使う全ての人がその関数を利用出来るようになる。(Emacs distribution の中
の @file{INSTALL} ファイルを参照のこと。)
@end itemize

最後に、もしあなたが Emacs を使う全ての人が欲しくなるようなコードを書い
たなら、そのコピーをネットワーク上にポストしたり、Free Software
Foundation に送ることが出来る。(そうする場合には、どうかポストする前にコー
ドに copy left の注意書きを添付して欲しい。) コピーを Free Software
Foundation に送った場合、次の Emacs のリリース時にはそれを含めて配布され
るかもしれない。大体において、ここ数年はこのような寄付によって Emacs が
成長してきたのである。

@node let
@section @code{let}
@findex let

@code{let} 式は、Lisp では多くの関数定義の中で必要となる特殊形式である。
非常によく使われるものなので、このセクションの中で @code{let} について説
明することにする。

@code{let} は、シンボルに値をバインドする際に、Lisp インタプリタがその関
数以外の関数の中で使われている同じ名前の変数と混同しないようにするために
使用される。

何故こんな関数が必要なのかということを納得するために、次の様
な状況を考えよう。あなたは自分自身の家を持っていて、それを「家」と呼んで
いるとする。例えば、「そろそろ家にもペンキ塗りが必要だなあ」という風に使
うわけである。

しかし、あなたが友人宅を訪問し、そこのホストの人が「家」と
言った場合、大抵それはあなたの家ではなく@emph{彼の}家のことを指している。
即ち、同じ「家」という言葉で言及されてはいても別のものなわけである。もし
彼が彼自身の家のことを言っていて、あなたがあなた自身の家を思い浮かべてい
たなら混乱してしまうことであろう。同じことが Lisp についても言える。ある
関数で使われている変数と同じ名前の変数が他の関数でも使われていて、しかも
その二つが同じ値を持つことを期待されてはいない時である。
The
@code{let} special form prevents this kind of confusion.

@menu
* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::
@end menu

@ifnottex
@node Prevent confusion
@unnumberedsubsec @code{let} Prevents Confusion
@end ifnottex

@cindex @samp{local variable} defined
@cindex @samp{variable, local}, defined
@code{let} という特殊形式を使うことでこのような混乱を防ぐことが出来る。
@code{let} は @dfn{ローカル変数} (@dfn{local variable}) と呼ばれるものを
発生させる。これは、その @code{let} 式の外にある同じ名前の変数からは隔離
されている変数である。訪問先のホストの人が「家」という時は彼は彼自身の家
を指しているのであって、あなたの家を指しているのではないのと似たようなも
のだ。 (引数リストの中のシンボルも同じような働きをする。@ref{defun, ,
特殊形式 @code{defun}}, を見よ。)

@code{let} 式によって発生したローカル変数の値が保持されているのは、その
@code{let} 式の中@emph{だけ}である。(そして、その中のＳ式はその
@code{let} 式の中だけで呼ばれる。) 従って、ローカル変数はその @code{let}
式の外には全く影響を与えない。

@code{let} は一度に複数の変数を発生させることが出来る。また、@code{let}
は各々の変数に初期値を設定する。あなたが指定すればその値になるし、そうし
なければ @code{nil} が設定される。(専門用語では、このことを「その変数に
値をバインドする」と言う。) @code{let} は変数を発生させ、それに値をバイ
ンドした後、本体のコードを実行し、本体の中の最後のＳ式の値を返す。(実行
(Execute) するというのは、リストを評価するという意味の専門用語である。こ
れはこの単語の「実質的な効果を与える (to give practical effect to)」とい
う意味での使い方から来ている (@cite{Oxford English Dictionary})。あなた
はある動作を引き起こすためにＳ式を評価しているのだから、この場合「実行」
するというのは評価するのと同義であろう。)

@node Parts of let Expression
@subsection @code{let} 式の構成部分
@cindex @code{let} expression, parts of
@cindex Parts of @code{let} expression

@cindex @samp{varlist} defined
@code{let} というＳ式は三つの部分からなるリストである。最初の部分はシン
ボル @code{let} である。二番目の部分は @dfn{変数リスト} (@dfn{varlist})
と呼ばれるリストであり、各々の要素はシンボルそのものであるか、最初の要素
がシンボルである二つの要素からなるリストであるかのどちらかであり、三番目
の部分は @code{let} 式の本体である。本体部分は大抵、一つないしは複数のリ
ストからなる。

@need 800
@code{let} 式のテンプレートは次のように書ける。

@smallexample
(let @var{変数リスト} @var{本体}@dots{})
@end smallexample

@noindent
変数リストの中のシンボルは特殊形式 @code{let} 式によって初期値を設定され
る変数である。単独のシンボルそのものの場合は、初期値 @code{nil} が設定さ
れる。また、最初の要素がシンボルであるような二つの要素からなるリストの場
合、その最初のシンボルに対して Lisp インタプリタが二番目の要素を評価した
時に返される値が設定される。

というわけで、変数リストは @code{(thread (needles 3))} という感じの式に
なる。この場合だと、@code{let} 式の中で Emacs はシンボル @code{thread}
を初期値 @code{nil} に、シンボル @code{needles} を初期値3にバインドする。

@code{let} 式を書く場合にすることは、適切なＳ式を @code{let} 式のテンプ
レートの中に置くことである。

もし、変数リストが二つ要素のリストからなる場合、といっても大抵はそうなの
だが、@code{let} 式のテンプレートは次のようになる。

@smallexample
@group
(let ((@var{変数} @var{値})
      (@var{変数} @var{値})
      @dots{})
      @var{本体}@dots{})
@end group
@end smallexample

@node Sample let Expression
@subsection @code{let} 式の例
@cindex Sample @code{let} expression
@cindex @code{let} expression sample

次のＳ式は二つの変数 @code{zebra} と @code{tiger} を発生させ、それに対し
て初期値を与えている。@code{let} 式の本体は関数 @code{message} を呼び出
すリストである。

@smallexample
@group
(let ((zebra 'stripes)
      (tiger 'fierce))
  (message "One kind of animal has %s and another is %s."
           zebra tiger))
@end group
@end smallexample

ここで、変数リストは @code{((zebra 'stripes) (tiger 'fierce))} である。

二つの変数は @code{zebra} と @code{tiger} である。各々の変数は二つの要素
からなるリストの最初の要素であり、その値はそのリストの二番目の要素になっ
ている。Emacs は変数リストの中で @code{zebra} を @code{stripes} にバイン
ドし、
@footnote{According
to Jared Diamond in @cite{Guns, Germs, and Steel}, ``@dots{} zebras
become impossibly dangerous as they grow older'' but the claim here is
that they do not become fierce like a tiger.  (1997, W. W. Norton and
Co., ISBN 0-393-03894-2, page 171)}
また、@code{tiger} を @code{fierce} にバインドしている。この場合、
値は両方とも引用符のついたシンボルである。値は勿論、他のリストや文字列で
あっても構わない。@code{let} 式の本体は変数を含むリストの後に来る。今の
場合は本体は関数 @code{message} を使ったリストであり、エコー領域に文字列
を表示する。

@need 1500
いつものようにカーソルを最後の括弧の直後に置いて @kbd{C-x C-e} とタイプ
することで上の例を評価することが出来る。そうすると、エコー領域に次のよう
に表示されるだろう。

@smallexample
"One kind of animal has stripes and another is fierce."
@end smallexample

以前見たように、@code{message} 関数は最初の引数を @samp{%s} を除いて表示
する。今の場合、最初の @samp{%s} の所には変数 @code{zebra} の値が表示さ
れ、二番目の @samp{%s} の所には変数 @code{tiger} の値が表示される。

@node Uninitialized let Variables
@subsection @code{let} 式の変数宣言の中で初期値を設定しなかった場合
@cindex Uninitialized @code{let} variables
@cindex @code{let} variables uninitialized

もし、@code{let} 式の中で変数に特定の初期値をバインドしなかったとすると、
それらの値は自動的に @code{nil} にバインドされる。次の例を見てみよう。

@smallexample
@group
(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "Here are %d variables with %s, %s, and %s value."
   birch pine fir oak))
@end group
@end smallexample

@noindent
ここで、変数リストは @code{((birch 3) pine fir (oak 'some))} である。

このＳ式をいつもの通りに評価したなら、エコー領域には次のように表示される
だろう。

@smallexample
"Here are 3 variables with nil, nil, and some value."
@end smallexample

@noindent
この場合には Emacs はシンボル @code{birch} に3という数をバインドし、シン
ボル @code{pine} と @code{fir} には @code{nil} をバインドし、更にシンボ
ル @code{oak} には @code{some} をバインドしている。

@code{let} 式の最初の部分で、変数 @code{pine} と @code{fir} は単独のアト
ムであり、括弧で囲まれてはいないことに注意しよう。これは、これらの変数を
@code{nil}, 即ち空リストにバインドするためである。しかし、@code{oak} の
方は、@code{some} にバインドするので、リスト @code{(oak 'some)} の一部と
なっている。同様に、@code{birch} も3にバインドするので、この数と一緒のリ
ストに入っている。(数値は評価された時にそれ自身の値を返すので、引用符は
必要ない。また、message の中にこの数を表示する際は、@samp{%s} ではなくて、
@samp{%d} を使っている。) そして、これら四つの変数がひとつのグループとし
てリストの中に入り、@code{let} 式の本体と区別されているわけである。

@node if
@section 特殊形式 @code{if}
@findex if
@cindex Conditional with @code{if}

@code{defun} と @code{let} に続く三つ目の特殊形式は、条件分岐
(conditional) @code{if} である。この特殊形式は計算機になんらかの判断をさ
せる時に使われる。@code{if} を使わなくても関数定義を書くことも出来るが、
頻繁に使うものであるし、重要でもあるので、ここに含めることにする。これは
例えば、@code{beginning-of-buffer} という関数の中で使われている。

@code{if} の背後にある基本的な考え方は「@emph{もし}(if)、テストした結果
が真@emph{ならば}(then)Ｓ式を評価する」というものだ。テストした結果が真
でなければ、Ｓ式は評価はされない。例えば、「もし、暖かくて太陽が出ていた
なら、ビーチへ行こう。」というような判断をするようなものだ。

@menu
* if in more detail::
* type-of-animal in detail::    An example of an @code{if} expression.
@end menu

@ifnottex
@node if in more detail
@unnumberedsubsec @code{if} in more detail
@end ifnottex

@cindex @samp{if-part} defined
@cindex @samp{then-part} defined
Lisp で書かれる @code{if} 式では、`then' という単語は使われない。テスト
と実行は @code{if} を最初の要素とするリストの二番目と三番目の要素である。
にも関わらず、@code{if} 式のテスト部分は @dfn{if-part} と呼ばれ、二番目
の引数は @dfn{then-part} と呼ばれることが多い。

また、@code{if} 式が書かれる場合、真か偽かのテストは普通、@code{if} と同
じ行に書かれる。しかし、テストが真であった場合に実行される ``then-part''
は二行目以降に書かれる。こうすることで、@code{if} 式がより読みやすいもの
になる。

@smallexample
@group
(if @var{真偽テスト}
    @var{テストが真である場合に実行する動作})
@end group
@end smallexample

@noindent
真偽テスト (true-or-false-test) の部分は List インタプリタにより評価され
るＳ式である。

次にいつものようにして実行出来る例を挙げておく。テスト部分は5が4よりも大
きいかどうかを判断するものだ。そうであれば、@samp{5 is greater than 4!}
というメッセージが表示される。

@smallexample
@group
(if (> 5 4)                             ; @r{if-part}
    (message "5 is greater than 4!"))   ; @r{then-part}
@end group
@end smallexample

@noindent
(関数 @code{>} は最初の引数が二番目の引数よりも大きいかどうかを判断し、
そうであれば真を返すものである。)
@findex > (greater than)

勿論、実際に使う場合には、@code{if} 式のテスト部分は常に @code{(> 5 4)}
に固定されていたりはしない。その代わりに、少なくとも一つの変数が、前もっ
て分らない値にバインドされる。(もし、前もって値が分っているなら、テスト
する必要などない！)

例えば、その値は関数定義の引数にバインドされたりする。次の関数定義では、
関数に渡される値は動物の性格である。もし、@code{characteristic} にバイン
ドされる値が @code{fierce} であれば、@samp{It's a tiger!} というメッセー
ジが表示される。そうでなければ、@code{nil} が返される。

@smallexample
@group
(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the symbol `fierce',
then warn of a tiger."
  (if (equal characteristic 'fierce)
      (message "It's a tiger!")))
@end group
@end smallexample

@need 1500
@noindent
もし、これを GNU Emacs の中で読んでいるなら、上の関数定義を評価すること
で、Emacs にインストールすることが出来る。そうすると、次の二つのＳ式を評
価して結果を見ることも出来るようになる。

@smallexample
@group
(type-of-animal 'fierce)

(type-of-animal 'zebra)

@end group
@end smallexample

@c Following sentences rewritten to prevent overfull hbox.
@noindent
@code{(type-of-animal 'fierce)} を評価すると、エコー領域には @code{"It's
a tiger"} と表示されるはずだ。一方、@code{(type-of-animal 'zebra)} を評
価すると、@code{nil} が表示される。

@node type-of-animal in detail
@subsection 関数 @code{type-of-animal} の詳細

@code{type-of-animal} 関数を詳しく見てみよう。

@code{type-of-animal} の関数定義は二つのテンプレートのスロットを埋めるこ
とで書かれている。一つは全体の関数定義のテンプレートで、もう一つは
@code{if} 式のテンプレートである。

@need 1250
インタラクティブでない関数の関数定義のテンプレートは次の通りである。

@smallexample
@group
(defun @var{関数名} (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  @var{本体}@dots{})
@end group
@end smallexample

このテンプレートに当てはめると、各部分は次のようになる。

@smallexample
@group
(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.  If the
CHARACTERISTIC is the symbol `fierce', then warn of a tiger."
  @var{本体: } @code{if} @var{式})
@end group
@end smallexample

今の場合、関数の名前は @code{type-of-animal} である。これは引数を一つ取
る。引数リストの後に、複数行に渡る説明文字列が続く。例の中にもちゃんと説
明文字列を入れるのは、全ての関数定義に説明文字列を入れるのが良い習慣であ
るからである。関数定義の本体部分は @code{if} 式からなっている。

@need 800
@code{if} 式のテンプレートは次の通りである。

@smallexample
@group
(if @var{真偽テスト}
    @var{テストが真の場合に実行する動作})
@end group
@end smallexample

@code{type-of-animal} 関数では、@code{if} に関する実際のコードは次のよう
になっている。

@smallexample
@group
(if (equal characteristic 'fierce)
    (message "It's a tiger!")))
@end group
@end smallexample

@need 800
ここで、真偽テストの部分は次のＳ式である。

@smallexample
(equal characteristic 'fierce)
@end smallexample

@noindent
Lisp では、@code{equal} は最初の引数と二番目の引数が等しいかどうかを判定
する関数である。二番目の引数は引用符つきのシンボル @code{'fierce} であり、
一番目の引数は @code{characteristic} というシンボルの値---つまり、この関
数に渡される引数の値である。

先に行った @code{type-of-animal} の最初の実行では、@code{fierce} が
@code{type-of-animal} に渡した。@code{fierce} は @code{fierce} と等しい
ので、Ｓ式 @code{(equal characteristic 'fierce)} は真の値を返す。この場
合は、@code{if} は二番目の引数、つまり @code{if} 式の then-part である
@code{(message "It's tiger!")} を評価する。

一方、@code{type-of-animal} の二番目の実行では @code{zebra} を引数として
渡した。@code{zebra} は @code{fierce} ではないので、then-part は評価され
ず、@code{if} 式は @code{nil} を返す。

@node else
@section If--then--else 式
@cindex Else

@code{if} 式は、オプションとして @dfn{else-part} と呼ばれる三番目の引き
数を持つことが出来る。これは真偽テストが偽を返した場合のためのものである。
この場合は @code{if} 式の二番目の引数である then-part は評価@emph{されず}、
代わりに三番目の引数である else-part が評価@emph{される}。このことは、曇
りの日なんかに、「もし、晴れて暖かかったらビーチに行こう。そうでなかった
ら、本でも読むか！」というふうに、代わりの選択肢を考えるのに当てはめてみ
れば納得出来るだろう。

``else'' という単語は Lisp のコードの中には出てこない。単に、else-part
は @code{if} 式の中の then-part の次にくる要素というだけである。実際に
Lisp のコードを書く場合、else-part は新しく改行してから then-part よりは
少ないインデントで書き始めるのが普通である。

@smallexample
@group
(if @var{真偽テスト}
    @var{テストが真の場合に実行する動作})
  @var{テストが偽の場合に実行する動作})
@end group
@end smallexample

例えば次の @code{if} 式は、いつも通りに評価すると、@samp{4 is not
greater than 5!} というメッセージを表示するものである。

@smallexample
@group
(if (> 4 5) ; @r{if-part}
    (message "5 is greater than 4!")  ; @r{then-part}
  (message "4 is not greater than 5!")) ; @r{else-part}
@end group
@end smallexample

@noindent
異なるレベルのインデントをすることで、then-part と else-part の区別がし
やすくなることに注意しよう。(GNU Emacs は @code{if} 式を自動的に正しくイ
ンデントするコマンドを幾つか備えている。@ref{Typing Lists, , GNU Emacs
によるリストのタイプの支援}, を参照のこと。)

@code{type-of-animal} の @code{if} 式に新しく else-part の部分を追加する
だけで、この関数を拡張することが出来る。

@need 1500
次のバージョンの @code{type-of-animal} の関数定義を評価してインストール
すれば、その後の、異なる引数を渡すような二つのＳ式を評価して、結果を見る
ことも出来るようになる。

@smallexample
@group
(defun type-of-animal (characteristic) ; @r{二番目のバージョン}
  "Print message in echo area depending on CHARACTERISTIC.  If the
CHARACTERISTIC is the symbol `fierce', then warn of a tiger; else say
it's not fierce."
  (if (equal characteristic 'fierce)
      (message "It's a tiger!")
    (message "It's not fierce!")))
@end group
@end smallexample
@sp 1

@smallexample
@group
(type-of-animal 'fierce)

(type-of-animal 'zebra)

@end group
@end smallexample

@c Following sentence rewritten to prevent overfull hbox.
@noindent
@code{(type-of-animal 'fierce)} を評価すると、エコー領域には @code{"It's
a tiger"} と表示されるはずだ。一方、@code{(type-of-animal 'zebra)} を評
価すると、@code{"It's not fierce!"} と表示される。

(勿論、@var{characteristic} が @code{ferocious} (獰猛) であったなら、
@code{"It's not fierce!"} と表示されるが、これは間違いである。コードを書
く場合は、@code{if} によってこのような引数がテストされる可能性を考慮に入
れて、それに応じてプログラムを書かなければならない。)

@node Truth & Falsehood
@section Lisp における真と偽
@cindex Truth and falsehood in Lisp
@cindex Falsehood and truth in Lisp
@findex nil

@code{if} 式の中の真偽テストについては、触れておかなければならない重要な
側面がある。今までは、真とか偽とかいう言葉を、述語の値としてあたかも新し
い Lisp のオブジェクトとして話してきた。しかし実際は「偽」というのは単に
我々が親しんできた良き友 @code{nil} なのである。そして、その他は全て---
どんなものであっても---「真」である。

真であるか否かテストされるＳ式は、評価した結果が @code{nil} 以外の値であ
れば @dfn{true} と判断される。別の言い方をすると、テストの結果は返された
値が47のような数値や、@code{"hello"} というような文字列、あるいは
@code{flowers} というような (@code{nil} 以外の) シンボルや、リストであっ
たり、はたまたバッファであったりする場合でも真であると解釈されるわけであ
る。

@menu
* nil explained::               @code{nil} has two meanings.
@end menu

@ifnottex
@node nil explained
@unnumberedsubsec An explanation of @code{nil}
@end ifnottex

このことを説明する前に、@code{nil} について説明せねばならないだろう。

Lisp ではシンボル @code{nil} は二つの意味を持つ。一つ目は空リストである。
そして二つ目は偽であり、真偽テストの結果が間違いであった場合に返る値であ
る。@code{nil} は空リストとして @code{()} のように書いても良いし、
@code{nil} と書いてもよい。Lisp にとっては、@code{()} と @code{nil} は全
く同じものである。しかし、人間にとっては @code{nil} は偽を表わすのに使い、
@code{()} は空リストを表わすのに使うのが普通だろう。

Lisp では @code{nil}以外---即ち空リスト以外---の全ての値は真と解釈される。
これは、評価した時に空リスト以外の何かを返すものは、@code{if} 式のテスト
で真と判断されることを意味する。例えば、もしテストの部分に数値を置いたと
すると、Lisp では数値は評価された時には自分自身を返すように出来ているの
だから、結果としてこの場合の @code{if} 式でのテストは真となる。テストの
結果が偽となるのはＳ式を評価して @code{nil}、即ち、空リストが返る時だけ
である。

次に挙げる二つのＳ式を評価してみることで、このことを確かめることが出来る。

最初の例では、@code{if} 式のテストの結果、数字の4が評価され、その数自身
が返される。結果として then-part が評価され、エコー領域に @samp{true} が
表示される。二番目の例としては、@code{nil} は偽を表わすので 結果として
else-part が評価され、エコー領域に @samp{false} と表示される。

@smallexample
@group
(if 4
    'true
  'false)
@end group

@group
(if nil
    'true
  'false)
@end group
@end smallexample

@need 1250
ついでながら、もしテストで真を返すような適当な値が見つからなければ、Lisp
インタプリタは真を表わすためにシンボル @code{t} を返す。例えば、@code{(>
5 4)} は評価された場合 @code{t} を返す。これもいつものようにして確認出来
る。

@smallexample
(> 5 4)
@end smallexample

@need 1250
@noindent
一方、この関数は偽である場合は @code{nil} を返す。

@smallexample
(> 4 5)
@end smallexample

@node save-excursion
@section @code{save-excursion}
@findex save-excursion
@cindex Region, what it is
@cindex Preserving point, mark, and buffer
@cindex Point, mark, buffer preservation
@findex point
@findex mark

関数 @code{save-excursion} は、この章で説明する4番目の、そして最後の特殊
形式である。

編集用の Emacs Lisp プログラムでは、関数 @code{save-excursion} は大変よ
く使用されるものである。これは、ポイントとマークの位置をセーブし、関数の
本体を実行し、そしてその際にポイントとマークの位置が変わったなら、それを
元の位置に戻す。ポイントとマークが意外な場所に動いて、驚いたり、困惑した
りするのを防ぐことがこの関数の主な目的である。

@menu
* Point and mark::              A review of various locations.
* Template for save-excursion:: 埋めるべきスロットは一つだけ
@end menu

@ifnottex
@node Point and mark
@unnumberedsubsec Point and Mark
@end ifnottex

@code{save-excursion} について議論する前に GNU Emacs にお
いて、ポイントとマークがどういうものであるかを復習しておくのが良いだろう。
@dfn{Point} は現在のカーソルの位置である。カーソルが何処にあろうと、それ
がポイントである。より正確に言うと、カーソルが文字の上にあるような端末で
は、ポイントは、その文字の左端の位置にある。Emacs Lisp ではポイントは整
数である。バッファの最初の文字は1であり、二番目の文字は2であり... といっ
た感じだ。関数 @code{point} は現在の位置を数として返す。各々のバッファが
それ自身のポイントの位置を持っている。

@dfn{mark} は、ポイントとはまた別の、バッファにおけるある位置を指し示す
ものである。その値は @kbd{C-@kbd{SPC}} (@code{set-mark-command}) で設定
される。マークが設定されている場合、@kbd{C-x C-x}
(@code{exchange-point-and-mark}) を使ってカーソルをマークにジャンプさせ、
以前ポイントがあった場所にマークを設定することが出来る。更に、もし他のマー
クが既にあった場合、以前のマークはマークリングに保存される。多くのマーク
をこうして保存することが出来る。@kbd{C-u C-@kbd{SPC}} とタイプすることで、
以前保存されたマークに順にさかのぼって行くことが出来る。

バッファの中で、ポイントとマークに挟まれた部分を @dfn{リージョン}
(@dfn{region}) と呼ぶ。リージョンに関するコマンドは沢山ある。例えば、
@code{center-region}、@code{count-lines-region}、@code{kill-region}、そ
して @code{print-region} なんかがそうである。

特殊形式 @code{save-excursion} はポイントとマークの位置を保存し、この特
殊形式内の本体部分のコードが Emacs Lisp によって評価された後に、その位置
を復元する。 こうして、例えばポイントがあるテキストの先頭にあり、あるコー
ドがその位置をバッファの最後に移動してしまったとしても、本体部分のＳ式が
評価され終わった後に @code{save-excursion} がポイントを元の位置に戻して
くれる。

Emacs ではユーザーが予期しない所でも、しばしば内部的にポイントの位置を動
かしていることがある。例えば @code{count-lines-region} なんかもポイント
の位置を移動している。予期しない、また(ユーザーの立場からみて)不必要な移
動によってユーザーが煩わされるの防ぐために、@code{save-excursion} は頻繁
に使われる。@code{save-excursion} を使うのは家の中を住み心地の良いものに
しておくことと一緒である。

家の中がきちんと整理されているかどうかを確認するために、
@code{save-excursion} は、たとえ、その内部のコードがうまく動かない場合に
も(専門用語を使ってより正確に言うと、「異常終了した場合にも」)、ちゃんと
ポイントとマークの位置を復元してくれる。この機能は大変役に立つ。

@code{save-excursion} は単にポイントとマークの値を記録するだけでなく、カ
ントバッファも保持していて、それを復元してくれる。これは、バッファを変更
するようなコードを書いても、@code{save-excursion} が元のバッファに戻して
くれることを意味している。実際、@code{append-to-buffer} の中では、
@code{save-excursion} はその目的で使われている。(@ref{append-to-buffer, ,
@code{append-to-buffer} の定義}, 参照。)

@node Template for save-excursion
@subsection @code{save-excursion} 式のテンプレート

@need 800
@code{save-excursion} のテンプレートは単純である。

@smallexample
@group
(save-excursion
  @var{本体}@dots{})
@end group
@end smallexample

@noindent
関数の本体は一つないしは複数のＳ式であり、それらが順に Lisp インタプリタ
によって評価されていく。もし本体に二つ以上のＳ式があったとすると、
@code{save-excursion} という関数自体の値としては、それらの内最後のＳ式の
値が返される。他のＳ式は単に副作用として評価されるのである。
@code{save-excursion} 自体は (ポイントとマークを復元するという) 副作用だ
けのために用いられる。

より詳しく書くと、@code{save-excursion} 式のテンプレートは次のように書け
る。

@smallexample
@group
(save-excursion
  @var{本体の一番目の式}
  @var{本体の二番目の式}
  @var{本体の三番目の式}
   @dots{}
  @var{本体の最後の式})
@end group
@end smallexample

@noindent
ここでＳ式は、シンボルそのものか、もしくはリストである。

Emacs Lisp のコードでは、@code{save-excursion} 式は、@code{let} 式の中で
よく使われる。次のような感じだ。

@smallexample
@group
(let @var{変数リスト}
  (save-excursion
    @var{本体}@dots{}))
@end group
@end smallexample

@node Review
@section 復習

ここまでの幾つかの章で、かなりの数の関数と特殊形式を紹介してきた。ここで
それらを簡単にまとめておくと同時に、そこでは触れなかった類似の関数なんか
も紹介しておくことにする。

@table @code
@item eval-last-sexp
現在のポイントの位置より前方の最後のＳ式を評価する。通常はＳ式が返す値は
エコー領域に表示されるが、引数つきで呼び出された時だけはカレントバッファ
に表示する。普通は、@kbd{C-x C-e} にバインドされている。

@item defun
関数を定義する。この特殊形式は最大5つの部分からなる。関数の名前、関数に
渡される引数のリスト、説明文字列、オプションのインタラクティブ宣言、そし
て関数定義の本体である。

@need 1250
（未訳）For example, in an early version of Emacs, the function definition was
as follows.  (It is slightly more complex now that it seeks the first
non-whitespace character rather than the first visible character.)

@smallexample
@group
(defun back-to-indentation ()
  "Move point to first visible character on line."
  (interactive)
  (beginning-of-line 1)
  (skip-chars-forward " \t"))
@end group
@end smallexample

@ignore
In GNU Emacs 22,

(defun backward-to-indentation (&optional arg)
  "Move backward ARG lines and position at first nonblank character."
  (interactive "p")
  (forward-line (- (or arg 1)))
  (skip-chars-forward " \t"))

(defun back-to-indentation ()
  "Move point to the first non-whitespace character on this line."
  (interactive)
  (beginning-of-line 1)
  (skip-syntax-forward " " (line-end-position))
  ;; Move back over chars that have whitespace syntax but have the p flag.
  (backward-prefix-chars))
@end ignore

@item interactive
インタプリタに対してその関数がインタラクティブに使用出来ることを宣言する。
この特殊形式の後に関数に渡す引数に関する情報として複数の部分からなる文字
列が続くことがある。これらの部分の中にはインタプリタに対してその情報を求
めるプロンプトを出すよう要求するものもある。この文字列の中では各々の部分
が改行コード @samp{\n} によって区切られている。

@need 1000
よく使われるコード文字には、次のようなものがある。

@table @code
@item b
現在存在するバッファ。

@item f
現在存在するファイル。

@item p
数値である 前置引数。(`p' が小文字であることに注意。)

@item r
二つの数値引数としてのポイントとマークを、小さい方を先に並べたもの。この
コード文字のみが二つの引数の列を特定する。(他は一つだけ。)
@end table

コード文字の完全なリストについては @ref{Interactive Codes, ,
Code Characters for @samp{interactive}, elisp, The GNU Emacs Lisp
Reference Manual}, を参照。

@item let
変数リストが @code{let} の本体部分のコードのみに対して使われることを宣言
し、かつ、それらの変数に @code{nil} ないしは指定した初期値を与える。そし
て、@code{let} 式の本体部分にあるＳ式を評価し、その中の最後のＳ式を評価
した値を返す。@code{let} 式の本体の内部では、Lisp インタプリタはその
@code{let} 式の外部にある同じ名前の変数は見ない。

@need 1250
例)

@smallexample
@group
(let ((foo (buffer-name))
      (bar (buffer-size)))
  (message
   "This buffer is %s and has %d characters."
   foo bar))
@end group
@end smallexample

@item save-excursion
この特殊形式の本体部分を評価する直前のポイントとマークの位置、及びカレン
トバッファを保存する。そして本体実行後、ポイントとマークの位置及びバッファ
を復元する。

@need 1250
例)

@smallexample
@group
(message "We are %d characters into this buffer."
         (- (point)
            (save-excursion
              (goto-char (point-min)) (point))))
@end group
@end smallexample

@item if
この関数の最初の引数を評価する。そして、もしその値が真であれば、二番目の
引数を評価し、そうでない場合、三番目の引数があればそれを評価する。

特殊形式 @code{if} は@dfn{条件分岐} (@dfn{conditional}) と呼ばれる。
Emacs Lisp には他にも@dfn{条件分岐}があるが、@code{if} はその中でも多分
もっともよく使われるものであろう。

@need 1250
例）

@smallexample
@group
(if (= 22 emacs-major-version)
    (message "This is version 22 Emacs")
  (message "This is not version 22 Emacs"))
@end group
@end smallexample

@need 1250
@item <
@itemx >
@itemx <=
@itemx >=
関数 @code{<} は、最初の引数が二番目の引数よりも小さいかどうかをテストす
る。これと対をなす関数 @code{>} は、最初の引数が二番目よりも大きいかどう
かをテストする。同様に、@code{<=} は最初の引数が二番目の引数以下であるか
どうかを、@code{>=} は最初の引数が二番目の引数以上であるかどうかをテスト
する。どの場合でも引数は両方とも数値でなければいけない。

@need 800
@item =
（未訳）The @code{=} function tests whether two arguments, both numbers or
markers, are equal.

@item equal
@itemx eq
二つのオブジェクトが同じであるかどうかをテストする。@code{equal} の方は、
両者が同じ構造と中身を持ちさえすれば、真を返す。一方、@code{eq} の方は、
引数が両方とも実際に同じオブジェクトである時のみ真を返す。
@findex equal
@findex eq

@need 1250
@item string<
@itemx string-lessp
@itemx string=
@itemx string-equal
The @code{string-lessp} function tests whether its first argument is
smaller than the second argument.  A shorter, alternative name for the
same function (a @code{defalias}) is @code{string<}.

The arguments to @code{string-lessp} must be strings or symbols; the
ordering is lexicographic, so case is significant.  The print names of
symbols are used instead of the symbols themselves.

@cindex @samp{empty string} defined
An empty string, @samp{""}, a string with no characters in it, is
smaller than any string of characters.

@code{string-equal} provides the corresponding test for equality.  Its
shorter, alternative name is @code{string=}.  There are no string test
functions that correspond to @var{>}, @code{>=}, or @code{<=}.

@item message
エコー領域にメッセージを表示する。このメッセージは一行のみでなければなら
ない。最初の引数は @samp{%s}, @samp{%d}, あるいは @samp{%c} を中に含む文
字列であり、これらはその後に続く引数におきかえられる。@samp{%s} の部分に
入る引数は文字列かシンボルでなければならない。また、@samp{%d} の部分に入
る引数は、数でなければならない。@samp{%c} の所に入る引数も数でなければな
らないが、こちらはそれに対応する ascii コードの文字が表示される。

@item setq
@itemx set
関数 @code{setq} は最初の引数に二番目の引数の値をセットする。最初の引数
は @code{setq} により、自動的に引用符が付けられる。続けて引数のペアを書
いた場合、それらについても同じことをする。もう一方の関数 @code{set} の方
は、二つの引数しか取ることが出来ない。また、その引数は両方ともまず最初に
評価され、その後、二番目の引数を評価して返された値を最初の引数を評価して
返された値にセットする。

@item buffer-name
引数は持たず、バッファ名前を文字列として返す。

@itemx buffer-file-name
引数は持たず、バッファがビジットしているファイルの名前を返す。

@item current-buffer
Emacs がアクティブであるようなバッファの中身を返す。これはスクリーンに見
えているバッファとは限らない。

@item other-buffer
(@code{other-buffer} に引数として渡したバッファ及び、カレントバッファを
除いて) もっとも最近選択したバッファの中身を返す。

@item switch-to-buffer
Emacs にとってアクティブなバッファを選択し、カレントウィンドウに表示して
ユーザーが見えるようにする。普通は @kbd{C-x b} にバインドされている。

@item set-buffer
これからプログラムを走らせるバッファに Emacs を切り替える。ただし、表示
しているウィンドウはそのままである。

@item buffer-size
カレントバッファの文字数を返す。

@item point
現在のカーソル位置の値をそのバッファの最初の位置からの文字数として返す。

@item point-min
カレントバッファの中で許される最小のポイントの値を返す。ナローイングが有
効でない場合は1である。

@item point-max
カレントバッファの中で許される最大のポイントの値を返す。ナローイングが有
効でない場合はバッファの最後の位置に一致する。
@end table

@need 1500
@node defun Exercises
@section 練習問題

@itemize @bullet
@item
引数の値を二倍するインタラクティブでない関数を書きなさい。また、それをイ
ンタラクティブにしなさい。

@item
現在の @code{fill-column} の値が関数に渡される引数よりも大きいかどうか判
定し、もしそうなら適当なメッセージを表示するような関数を書きなさい。
@end itemize

@node Buffer Walk Through
@chapter バッファに関する幾つかの関数

この章では、GNU Emacs で使われている関数を、幾つか詳しく見てみることにす
る。こういうことは、``walk-through'' と呼ばれる。これらの関数は Lisp コー
ドの例として扱うのであるが、最初の単純化された例を除いて、決して「机上」
のものではない。実際に GNU Emacs で使われている現実のコードである。これ
らの関数定義から多くのことを学ぶことが出来る。この章で説明する関数は、皆
バッファに関連したものである。他のものについては後で学ぶことにしよう。

@menu
* Finding More::                情報の探し方
* simplified-beginning-of-buffer::  @code{goto-char}, @code{point-min},
                                そして @code{push-mark} を見てみよう
* mark-whole-buffer::           これは @code{beginning-of-buffer} と殆ど同じ
* append-to-buffer::            これは @code{save-excursion} と
                                @code{insert-buffer-substring} の利用している。
* Buffer Related Review::       復習
* Buffer Exercises::            バッファについての練習問題
@end menu

@node Finding More
@section 情報の探し方

@findex describe-function, @r{introduced}
@cindex Find function documentation
この walk-through の中では、新しく出て来た関数はその都度、時には細かく、
時には簡単に、説明することにする。出て来た関数に興味を持った場合は、
@kbd{C-h f} に続けてその関数名をタイプして @kbd{RET} を押せば、どんな
Emacs Lisp 関数についても何時でも、完全な説明文を見ることが出来る。同様
に変数についても @kbd{C-h v} に続けてその変数名(と @kbd{RET}) を押せば、
その変数の完全な説明文を見ることが出来る。

@cindex Find source of function
@c In version 22, tells location both of C and of Emacs Lisp
（未訳）Also, @code{describe-function} will tell you the location of the
function definition.

（未訳）Put point into the name of the file that contains the function and
press the @key{RET} key.  In this case, @key{RET} means
@code{push-button} rather than `return' or `enter'.  Emacs will take
you directly to the function definition.

@ignore
Not In version 22

（無視）If you move point over the file name and press
the @key{RET} key, which in this case means @code{help-follow} rather
than `return' or `enter', Emacs will take you directly to the function
definition.
@end ignore

より一般的には、もしその関数の元のソースを見たくなったら、関数 @code{find-tag} を
使ってその関数に飛ぶことが出来る。まず @kbd{M-.} とタイプし (即ち、
@kbd{META} キーとピリオドキーを同時に押すか、または @kbd{ESC} キーを押し
てからピリオドキーを押し), 出てきたプロンプトに対してソースコードを見た
い関数の名前、例えば @code{mark-whole-buffer} 等、をタイプする。すると、
Emacs はバッファを切り替えて、その関数のソースコードをスクリーンに表示し
てくれる。元のバッファに戻るには、@kbd{C-x b @kbd{RET}} とタイプすれば良
い。

To use the @code{find-tag} command, type @kbd{M-.}  (i.e., press the
period key while holding down the @key{META} key, or else type the
@key{ESC} key and then type the period key), and then, at the prompt,
type in the name of the function whose source code you want to see,
such as @code{mark-whole-buffer}, and then type @key{RET}.  Emacs will
switch buffers and display the source code for the function on your
screen.  To switch back to your current buffer, type @kbd{C-x b
@key{RET}}.  (On some keyboards, the @key{META} key is labeled
@key{ALT}.)

@c !!! 22.1.1 tags table location in this paragraph
@cindex TAGS table, specifying
@findex find-tag
あなたの使っている Emacs のデフォルトの初期値いかんでは `タグテーブル'
を指定する必要があるかもしれない。これは @file{TAGS} と呼ばれるファイル
である。
（未訳）For example, if you are
interested in Emacs sources, the tags table you will most likely want,
if it has already been created for you, will be in a subdirectory of
the @file{/usr/local/share/emacs/} directory; thus you would use the
@code{M-x visit-tags-table} command and specify a pathname such as
@file{/usr/local/share/emacs/22.1.1/lisp/TAGS}.  If the tags table
has not already been created, you will have to create it yourself.  It
will be in a file such as @file{/usr/local/src/emacs/src/TAGS}.

@need 1250
（未訳）To create a @file{TAGS} file in a specific directory, switch to that
directory in Emacs using @kbd{M-x cd} command, or list the directory
with @kbd{C-x d} (@code{dired}).  Then run the compile command, with
@w{@code{etags *.el}} as the command to execute:

@smallexample
M-x compile RET etags *.el RET
@end smallexample

（未訳）For more information, see @ref{etags, , Create Your Own @file{TAGS} File}.

（旧訳）@file{emacs/src} ディレクトリにあるファイルを指定することになる
場合が殆どであろう。その場合 @code{M-x visit-tags-table} コマンドを使っ
て、
などのようにパス名を指定する。@ref{Tags, , Tag Tables, emacs, The GNU
Emacs Manual}, 参照。
また、自分自身のものを作成する方法については @ref{etags, , 自分自身の
@file{TAGS} ファイルの作成}, を見よ。

（旧訳）Emacs Lisp に慣れてしまってからは、ソースコードを眺めるために頻繁に
@code{find-tag} を使うことになるだろう。そして自分自身の @file{TAGS} テー
ブルを作ることになるはずだ。

@cindex Library, as term for `file'
ついでに付け加えておくと、Lisp コードを含むファイルは便宜上ライブラリ
(@code{library}) と呼ばれる。このメタファは、一般的なライブラリではなく、
例えば法律とか工学とかのような特定分野のライブラリから来ている。各々の
ライブラリないしはファイルには特定のトピックや動作に関する関数が含まれて
いる。例えば、@file{abbrev.el} には省略等のショートカットキーを扱う関数
が、また @file{help.el} にはオンラインヘルプを扱う関数が収められている、
といった感じである。(時には複数のライブラリが一つの動作に関するコードを
提供していることもある。電子メールを読むためのコードを提供する
@file{rmail@dots{}} ファイルなんかがそうだ。) @code{The GNU Emacs
Manual} を見れば、「@kbd{C-h p} コマンドによって標準的な Emacs Lisp ライ
ブラリをトピックをキーワードにして検索することが出来る」と言った記述を
見つけることが出来る。

@node simplified-beginning-of-buffer
@section 簡略版 @code{beginning-of-buffer} の定義
@findex simplified-beginning-of-buffer

まず @code{beginning-of-buffer} という関数から始めるのが良いであろう。こ
の関数には既に慣れているだろうし、理解するのも易しいからだ。インタラクティ
ブなコマンドとして使われるものであろうと、@code{beginning-of-buffer} は
カーソルをバッファの先頭に移動させ、以前の位置にマークを置く。この関数は
大抵は @kbd{M-<} にバインドされている。

この章では、この関数の短縮されたバージョンを説明することで、これがどうい
うふうに使われることが多いのかを示そう。この短縮版も上に書いたような動作
をするが複雑なオプションは付いていない。完全版については別のセクションで
説明することにする。(@ref{beginning-of-buffer, ,
@code{beginning-of-buffer} の完全な定義}, 参照。)

コードを見る前に、どんな関数定義が含まれているかを考えてみよう。まず、関
数をインタラクティブにするための、即ち @kbd{M-x beginning-of-buffer} と
タイプしたり、あるいは @kbd{M-<} といったキーコードをタイプすることで呼
び出せるようにするためのＳ式を含んでいなければならない。また、バッファの
元の位置にマークするためのコードも必要だ。更にカーソルをバッファの先頭に
移動するコードも入っていなくてはならない。

@need 1250
これがこの関数の短縮版の完全なテキストである。

@smallexample
@group
(defun simplified-beginning-of-buffer ()
  "Move point to the beginning of the buffer;
leave mark at previous position."
  (interactive)
  (push-mark)
  (goto-char (point-min)))
@end group
@end smallexample

他の関数定義と同様に、この定義も特殊形式 @code{defun} に続く五つの部
分からなっている。

@enumerate
@item
名前: この場合は @code{simplified-beginning-of-buffer}。

@item
引数リスト: この場合は空リスト @code{()}

@item
説明文字列

@item
インタラクティブにするためのＳ式

@item
本体
@end enumerate

@noindent
この関数定義では、引数リストは空である。これは、この関数が引数を必要とし
ないことを意味する。(もっとも完全版の方の定義を見れば、そちらにはオプショ
ンの引数を渡すことが出来ることが分る。)

インタラクティブにするためのＳ式は、Emacs にこの関数がインタラクティブに
使われることを伝えるための物である。今の場合 @code{interactive} は引数を
持たない。というのも @code{simplified-beginning-of-buffer} は引数を必要
としないからである。

@need 800
関数の本体部分は次の二行からなる。

@smallexample
@group
(push-mark)
(goto-char (point-min))
@end group
@end smallexample

一行目は @code{(push-mark)} というＳ式である。このＳ式が Lisp インタプリ
タによって評価されると、カーソルが何処にあろうと、その位置にマークが設定
される。マークの位置はマークリングに保存される。

二行目は @code{(goto-char (point-min))} である。このＳ式はカーソルをバッ
ファ内での最小ポイント、即ちバッファの先頭に移動する。(あるいは、もし
ナローイングがかかっていれば、アクセス出来る範囲内での最初の位置に移動す
る。@ref{Narrowing & Widening, , ナローイングとワイドニング}, 参照。)

@code{push-mark} コマンドによって、@code{(goto-char (point-min))} でカー
ソルがバッファの先頭に飛ぶ前に、そのカーソルの位置にマークがセットされる。
結果として、もし元の位置に戻ろうと思えば、@kbd{C-x C-x} によって元の位置
に戻ることが出来る。

これがこの関数定義の全てである!

@findex describe-function
もし、このようなコードを読んでいて @code{goto-char} のようによく知らない
関数に出くわしたとする。その場合には @code{describe-function} コマンドを
使ってこれがどんな関数かを見ることが出来る。このコマンドを使うには、まず
@kbd{C-h f} とタイプし、次に知りたい関数の名前をタイプしてから @kbd{RET}
を押せば良い。@code{describe-function} コマンドは @file{*Help*} ウィンド
ウにその関数の説明文字列を表示してくれる。例えば @code{goto-char} の説明
文は次の通りである。

@smallexample
@group
Set point to POSITION, a number or marker.
Beginning of buffer is position (point-min), end is (point-max).
@end group
@end smallexample

@noindent
（未訳）The function's one argument is the desired position.

@noindent
(@code{describe-function} はプロンプトを出す時にデフォルトの値としてその
時のカーソルの直前にあるシンボルの値を設定する。従って、カーソルをその関
数の直後に持っていって @kbd{C-h f @key{RET}} とタイプすることも出来る。)

@code{end-of-buffer} 関数についても @code{beginning-of-buffer} とほぼ同
じである。ただし、関数の本体部分で、@code{(goto-char (point-min))} の部
分が @code{(goto-char (point-max))} となっている。

@node mark-whole-buffer
@section @code{mark-whole-buffer} の定義
@findex mark-whole-buffer

関数 @code{mark-whole-buffer} も、関数
@code{simplified-beginning-of-buffer} と同じくらい簡単に理解出来る。
ただし、今回は単純化したものではなく完全な関数を見ることにする。

@code{mark-whole-buffer} 関数は @code{beginning-of-buffer} 関数ほどには
頻繁には使われない。しかし、同じくらい有用である。この関数はポイントをバッ
ファの先頭に、マークをバッファの最後に置くことで、バッファ全体をリージョ
ンとして指定する。また、大抵は @kbd{C-x h} にバインドされている。

@menu
* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.
@end menu

@ifnottex
@node mark-whole-buffer overview
@unnumberedsubsec An overview of @code{mark-whole-buffer}
@end ifnottex

@need 1250
GNU Emacs 22における、この関数の完全なコードは次の通りである。

@smallexample
@group
(defun mark-whole-buffer ()
  "Put point at beginning and mark at end of buffer.
You probably should not use this function in Lisp programs;
it is usually a mistake for a Lisp function to use any subroutine
that uses or sets the mark."
  (interactive)
  (push-mark (point))
  (push-mark (point-max) nil t)
  (goto-char (point-min)))
@end group
@end smallexample

@need 1250
他の全ての関数と同様、@code{mark-whole-buffer} も関数定義のテンプレート
にきちんと当てはまっている。このテンプレートは次のようなものだった。

@smallexample
@group
(defun @var{関数名} (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  (@var{インタラクティブ式}@dots{})
  @var{本体}@dots{})
@end group
@end smallexample

この関数の動作であるが、関数名は @code{mark-whole-buffer} である。引数リ
ストが空リスト @samp{()} になっているので、この関数は引数を必要としない
ことが分る。次に説明文字列が来ている。

次の行は @code{(interactive)} である。これをつけると Emacs はこの関数を
インタラクティブに使えるものとみなす。ここら辺のことは前節の
@code{simplified-beginning-of-buffer} 関数の所でも説明した通りである。

@need 1250
@node Body of mark-whole-buffer
@subsection @code{mark-whole-buffer} の本体

関数 @code{mark-whole-buffer} の本体は次の三行からなる。

@c GNU Emacs 22
@smallexample
@group
(push-mark (point))
(push-mark (point-max) nil t)
(goto-char (point-min))
@end group
@end smallexample

この三行のうち最初の行はＳ式 @code{(push-mark (point))} である。

この行は関数 @code{simplified-beginning-of-buffer} の本体の最初の行の
@code{(push-mark)} と全く同じ働きをする。どちらの場合にも Lisp インタプ
リタはカーソルの現在の位置にマークを設定する。

私には何故 @code{mark-whole-buffer} 関数では @code{(push-mark (point))}
と書かれ、@code{beginning-of-buffer} 関数では @code{(push-mark)} と書か
れているか分らない。多分、このコードを書いた人は @code{(push-mark)} の引
数は省略可能で、引数を受け取らない場合、デフォルトでは自動的に現在のポイ
ントの位置にマークが設定されるということを知らなかったんだろうと思う。あ
るいはこのＳ式が次の行と同じような構造になるように書いたのかもしれない。
いずれにしてもこの行によって Emacs はポイントの位置を決定し、その位置に
マークを設定する。

@code{mark-whole-buffer} の次の行は @code{(push-mark (point-max))} であ
る。このＳ式は、バッファの中でポイントの数が最大の位置にマークを設定する。
これは大抵はバッファの最後である。(もし、バッファがナローイングされてい
れば、バッファの中のアクセス可能な範囲での最後尾になる。ナローイングにつ
いての詳細は @ref{Narrowing & Widening, , ナローイングとワイドニング},
参照。) このマークが設定された時点で、現在のポイントの位置に設定されてい
た、以前のマークは解除される。しかし、Emacs は最近設定されたマークの位置
と同様、その位置を記憶している。もし戻りたければ、@kbd{C-u C-@key{SPC}}
を二度タイプすることで、その位置に戻ることが出来る。

@need 1250
In GNU Emacs 22, the @code{(point-max)} is slightly more complicated.
The line reads

@smallexample
(push-mark (point-max) nil t)
@end smallexample

@noindent
（未訳）The expression works nearly the same as before.  It sets a mark at the
highest numbered place in the buffer that it can.  However, in this
version, @code{push-mark} has two additional arguments.  The second
argument to @code{push-mark} is @code{nil}.  This tells the function
it @emph{should} display a message that says `Mark set' when it pushes
the mark.  The third argument is @code{t}.  This tells
@code{push-mark} to activate the mark when Transient Mark mode is
turned on.  Transient Mark mode highlights the currently active
region.  It is often turned off.

さて、いよいよ最後の行の @code{(goto-char (point-min))} である。これは
@code{beginning-of-buffer} と全く同じように書かれている。このＳ式はカー
ソルをバッファの中でポイントが最小の位置に移動させる。つまり、バッファの
先頭(もしくはアクセス可能な範囲での先頭)に移動させるのである。その結果、
ポイントはバッファの先頭に移動し、バッファの最後尾にマークが設定される。
このようにして、バッファ全体がリージョンになる。

@node append-to-buffer
@section @code{append-to-buffer} の定義
@findex append-to-buffer

@code{append-to-buffer} コマンドも @code{mark-whole-buffer} コマンドと同
じくらい単純な構造をしている。このコマンドがすることはカレントバッファの
リージョン(つまり、バッファ中のポイントとマークある部分) を指定したバッ
ファに複写することである。

@menu
* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a @code{let} expression.
* append save-excursion::       How the @code{save-excursion} works.
@end menu

@ifnottex
@node append-to-buffer overview
@unnumberedsubsec An Overview of @code{append-to-buffer}
@end ifnottex

@findex insert-buffer-substring
@code{append-to-buffer} コマンドは、リージョンを複写するのに関数
@code{insert-buffer-substring} を使う。この関数は名前から察せられる通り、
バッファのある部分から文字からなる文字列、即ち「部分文字列」を取り出して、
それを他のバッファに挿入する。

関数 @code{append-to-buffer} の大部分は
@code{insert-buffer-substring} がうまく動作するような状態に設定すること
に関するものである。このコードはテキストが写されるバッファとそのコピー元
となるリージョンの両方の指定が必要となる。この関数の完全なコードは次の通
りである。

@need 1250
（未訳）Here is the complete text of the function:

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "Append to specified buffer the text of the region.
It is inserted into that buffer before its point.
@end group

@group
When calling from a program, give three arguments:
BUFFER (or buffer name), START and END.
START and END specify the portion of the current buffer to be copied."
  (interactive
   (list (read-buffer "Append to buffer: " (other-buffer
                                            (current-buffer) t))
         (region-beginning) (region-end)))
@end group
@group
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end group
@end smallexample

この関数は一連のテンプレートが埋められたものと見倣すと理解しやすい。

最も外側のテンプレートは、関数定義のものである。今の場合、次のようになっ
ている(幾つか既に埋めてあるスロットもある)。

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{説明文字列}@dots{}"
  (interactive @dots{})
  @var{本体}@dots{})
@end group
@end smallexample

最初の一行は関数の名前とその三つの引数を含んでいる。引数はテキストが複写
される行き先のバッファ及び、複写元のリージョンを指定する @code{start} と
@code{end} である。

（旧訳）関数の次の部分には簡潔で完全な説明が記されている。
（未訳）The next part of the function is the documentation, which is clear and
complete.  As is conventional, the three arguments are written in
upper case so you will notice them easily.  Even better, they are
described in the same order as in the argument list.

（未訳）Note that the documentation distinguishes between a buffer and its
name.  (The function can handle either.)

@node append interactive
@subsection インタラクティブ式 @code{append-to-buffer}

@code{append-to-buffer} という関数はインタラクティブに使われる関数なので、
@code{interactive} 式が必要である。(@code{interactive} について復習する
には、@ref{Interactive, , 関数をインタラクティブにする}, を見よ。)

@smallexample
@group
(interactive
 (list (read-buffer
        "Append to buffer: "
        (other-buffer (current-buffer) t))
       (region-beginning)
       (region-end)))
@end group
@end smallexample

@noindent
（未訳）This expression is not one with letters standing for parts, as
described earlier.  Instead, it starts a list with these parts:

（未訳）The first part of the list is an expression to read the name of a
buffer and return it as a string.  That is @code{read-buffer}.  The
function requires a prompt as its first argument, @samp{"Append to
buffer: "}.  Its second argument tells the command what value to
provide if you don't specify anything.

（未訳）In this case that second argument is an expression containing the
function @code{other-buffer}, an exception, and a @samp{t}, standing
for true.

（未訳）The first argument to @code{other-buffer}, the exception, is yet
another function, @code{current-buffer}.  That is not going to be
returned.  The second argument is the symbol for true, @code{t}. that
tells @code{other-buffer} that it may show visible buffers (except in
this case, it will not show the current buffer, which makes sense).

@need 1250
The expression looks like this:

@smallexample
(other-buffer (current-buffer) t)
@end smallexample

（未訳）The second and third arguments to the @code{list} expression are
@code{(region-beginning)} and @code{(region-end)}.  These two
functions specify the beginning and end of the text to be appended.

@need 1250
（未訳）Originally, the command used the letters @samp{B} and @samp{r}.
The whole @code{interactive} expression looked like this:

@smallexample
(interactive "BAppend to buffer:@: \nr")
@end smallexample

（未訳）But when that was done, the default value of the buffer switched to
was invisible.  That was not wanted.

（未訳）The prompt was separated from the second argument with a newline,
@samp{\n}.  It was followed by an @samp{r} that told Emacs to bind the
two arguments that follow the symbol @code{buffer} in the function's
argument list (that is, @code{start} and @code{end}) to the values of
point and mark.  That argument worked fine.)

（旧訳）一つ目の部分は @samp{BAppend to buffer:@:} である。ここで、@samp{B} は
Emacs に対し、この関数に渡すバッファ名を尋ねるように要求している。これに
よって Emacs はミニバッファに @samp{B} に続く文字列---今の場合は
@samp{Append to buffer:@: }---からなるプロンプトを出して、ユ-ザーに名前
を入力するよう促す。Emacs はこの関数の引数リストにある変数 @code{buffer}
に、そこで指定されたバッファをバインドするのである。

（旧訳）改行コード @samp{\n} は引数の最初の部分と二つ目の部分を分けるために用
いられる。@samp{\n} の次には @samp{r} が続いているが、これは関数の引数リ
ストの中の @code{buffer} に続く二つのシンボル (つまり、@code{start} と
@code{end}) にポイントとマークの値をバインドすることを示している。

@node append-to-buffer body
@subsection @code{append-to-buffer} の本体

@ignore
（無視）in GNU Emacs 22   in    /usr/local/src/emacs/lisp/simple.el

(defun append-to-buffer (buffer start end)
  "Append to specified buffer the text of the region.
It is inserted into that buffer before its point.

When calling from a program, give three arguments:
BUFFER (or buffer name), START and END.
START and END specify the portion of the current buffer to be copied."
  (interactive
   (list (read-buffer "Append to buffer: " (other-buffer (current-buffer) t))
         (region-beginning) (region-end)))
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end ignore

関数 @code{append-to-buffer} の本体部分は @code{let} から始まっている。

以前見たように (@ref{let, , @code{let}}, を参照) @code{let} 式の目的は、
@code{let} 式内部だけで使われる変数を一つないしは複数作り、それに初期値
を与えることである。これは、そのような変数は @code{let} 式外部の同じ名前
の変数と混同されることがない、ということを意味している。

@code{let} 式の部分をアウトラインにして @code{append-to-buffer} のテンプ
レートを書いてみる。これによって @code{let} 式がどういうふうに関数に組み込
まれているかが分る。

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{説明文字列}@dots{}"
  (interactive "BAppend to buffer:@: \nr")
  (let ((@var{変数} @var{値}))
        @var{本体}@dots{})
@end group
@end smallexample

@code{let} 式は三つの要素を持っている。

@enumerate
@item
シンボル @code{let}。

@item
変数リストの中身。今の場合は二つの要素からなるリスト @code{(@var{variable}
@var{value})} が一つあるだけ。


@item
@code{let} 式の本体。
@end enumerate

関数 @code{append-to-buffer} の中では変数リストは次のようになっている。

@smallexample
(oldbuf (current-buffer))
@end smallexample

@noindent
@code{let} 式のこの部分では、変数 @code{oldbuf} が
@code{(current-buffer)} を評価して返された値にバインドされる。変数
@code{oldbuf} は現在作業しているバッファの記録のために使われるものである。

変数リストの要素は一組の括弧に囲まれている。これによって Lisp インタプリ
タは変数リストと @code{let} 式の本体を区別出来るのである。その結果として
変数リストの中の、二つの要素からなるリストであるような要素は更に一組の括
弧によって囲まれることになる。ということで、この行は次のようになる。

@smallexample
@group
(let ((oldbuf (current-buffer)))
  @dots{} )
@end group
@end smallexample

@noindent
ひょっとすると @code{oldbuf} の前に二つの括弧があることに驚くかもしれな
いが、@code{oldbuf} の前の最初の括弧は変数リストの区切りを示すものであり、
次の括弧は二つの要素からなるリスト @code{(oldbuf (current-buffer))} の最
初の括弧であることさえ分れば問題ないだろう。

@node append save-excursion
@subsection @code{append-to-buffer} の中の @code{save-excursion}

@code{append-to-buffer} の中の @code{let} 式の本体は
@code{save-excursion} 式からなっている。

関数 @code{save-excursion} はポイントとマークの位置を保存し、
@code{save-excursion} の本体部分のＳ式の実行が完了した時点でそれらを元の
位置に戻す。更に @code{save-excursion} は元々のバッファが何であったかも
憶えていて、そのバッファに戻してくれる。@code{save-excursion} は
@code{append-to-buffer} の中でこのように使われている。

@need 1500
@cindex Indentation for formatting
@cindex Formatting convention
ついでだが、ここで Lisp の関数の書式としては、通常複数の行に広がって括弧
で閉じられているようなものは全て、最初のシンボルよりも深くインデントされ
ていることに注意しておいた方が良いだろう。今回の関数定義の中では次のよう
に @code{let} 式は @code{defun} よりも深くインデントされている。

@smallexample
@group
(defun @dots{}
  @dots{}
  @dots{}
  (let@dots{}
    (save-excursion
      @dots{}
@end group
@end smallexample

@need 1500
@noindent
このように書式を工夫することで、@code{save-excursion} の本体部分の二行が
@code{save-excursion} に付随する括弧で囲まれていることが簡単に見てとれる。
同様に、@code{save-excursion} それ自身が @code{let} に付随する括弧で囲ま
れていることもすぐに分る。

@smallexample
@group
(let ((oldbuf (current-buffer)))
  (save-excursion
    @dots{}
    (set-buffer @dots{})
    (insert-buffer-substring oldbuf start end)
    @dots{}))
@end group
@end smallexample

関数 @code{save-excursion} の使い方は、次のテンプレートのスロットが埋め
られているものだと思うとよく理解出来るだろう。

@smallexample
@group
(save-excursion
  @var{本体の最初の式}
  @var{本体の二番目の式}
   @dots{}
  @var{本体の最後の式})
@end group
@end smallexample

@need 1200
@noindent
（旧訳）この関数では @code{save-excursion} には二つのＳ式しか含まれていない。そ
の本体は次の通りである。

（未訳）In this function, the body of the @code{save-excursion} contains only
one expression, the @code{let*} expression.  You know about a
@code{let} function.  The @code{let*} function is different.  It has a
@samp{*} in its name.  It enables Emacs to set each variable in its
varlist in sequence, one after another.

（未訳）Its critical feature is that variables later in the varlist can make
use of the values to which Emacs set variables earlier in the varlist.
@xref{fwd-para let, , The @code{let*} expression}.

（未訳）We will skip functions like @code{let*} and focus on two: the
@code{set-buffer} function and the @code{insert-buffer-substring}
function.

@need 1250
（未訳）In the old days, the @code{set-buffer} expression was simply

@smallexample
(set-buffer (get-buffer-create buffer))
@end smallexample

（旧訳）このリストのもっとも内側にあるＳ式は @code{(get-buffer-create buffer)}
というものである。このＳ式は @code{get-buffer-create} 関数を使っている。
これはその名前のバッファの内容を取り込むか、もし存在しない場合は新しくそ
の名前を持つバッファを作成する。これは @code{append-to-buffer} 関数を使
うことで、それ以前には存在してなかったバッファにもテキストを出力すること
が出来ることを示している。

（旧訳）@code{get-buffer-create} はまた @code{set-buffer} が不必要なエラーに遭遇
するのを防いでもいる。つまり @code{set-buffer} を使う時は行き先のバッファ
が存在している必要があるのだ。もしありもしないバッファを指定したりすると
Emacs はそこで仕事をやめてしまう。存在しないバッファである場合には
@code{get-buffer-create} がそのバッファを作ってくれるので、
@code{set-buffer} は常にバッファを得ることが出来るというわけである。

@need 1250
@noindent
しかし今日では

@smallexample
(set-buffer append-to)
@end smallexample

@noindent
（未訳）@code{append-to} is bound to @code{(get-buffer-create buffer)} earlier
on in the @code{let*} expression.  That extra binding would not be
necessary except for that @code{append-to} is used later in the
varlist as an argument to @code{get-buffer-window-list}.

@ignore
（無視）in GNU Emacs 22

  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end ignore

（未訳）The @code{append-to-buffer} function definition inserts text from the
buffer in which you are currently to a named buffer.  It happens that
@code{insert-buffer-substring} copies text from another buffer to the
current buffer, just the reverse---that is why the
@code{append-to-buffer} definition starts out with a @code{let} that
binds the local symbol @code{oldbuf} to the value returned by
@code{current-buffer}.

（旧訳）関数 @code{append-to-buffer} が評価されると、@code{save-excursion} の本体
部分の二つのＳ式が順に評価される。最後のＳ式の値が @code{save-excursion}
関数の値として返される。もう一方のＳ式は単に副作用だけのために評価される。

（旧訳）@code{save-excursion} の本体の最初の行は、現在のバッファを
@code{append-to-buffer} の引数の最初の引数で指定されたものに切り替えるた
めに関数  @code{set-buffer} を使っている。(バッファの切替は副作用である。
前にも言ったように Lisp にとっての副作用こそが我々の主目的であることが多
い。) 二行目がこの関数の本来の作業を行う。

（旧訳）関数 @code{set-buffer} は Emacs の注意をテキストをコピーしようとしている
バッファの方に向けさせる。そのバッファから @code{save-excursion} によっ
て元のバッファに帰ってくるのである。

（旧訳）@code{append-to-buffer} の最後の行はテキストを追加する働きをする。
@need 1250
The @code{insert-buffer-substring} expression looks like this:

@smallexample
(insert-buffer-substring oldbuf start end)
@end smallexample

@noindent
関数 @code{insert-buffer-substring} は最初の引数で指定されたバッファ
@emph{から}文字列をコピーし、それを現在のバッファに挿入する。今の場合は
@code{insert-buffer-substring} の引数は @code{let} で生成されバインドさ
れた変数 @code{oldbuf} の値であり、これは @code{append-to-buffer} コマン
ドを実行した時点でのカレントバッファである。

@code{insert-buffer-substring} が作業を終えると、@code{save-excursion}
が元のバッファに戻してくれる。そうして @code{append-to-buffer} の仕事は
完了する。

@need 800
骨組みだけ書くと、本体部分がやっていることは次の通りである。

@smallexample
@group
(let (@code{oldbuf}@var{を}@code{current-buffer}@var{の値にバインド})
  (save-excursion                       ; @r{バッファの状態の保存}
    @var{バッファ切替}
    @var{現在のバッファに}@code{oldbuf}@var{から部分文字列を挿入})

  @var{終わったら元のバッファに戻る}
@var{終了後は}@code{oldbuf}@var{の局所的な意味は消え去る}

@end group
@end smallexample

以上まとめると、@code{append-to-buffer} は次のような働きをする。まずはカ
レントバッファの値を @code{oldbuf} という変数に保存する。次に別のバッファ
をユーザーから聞き出し、もし必要なら新規に作成して、そのバッファに移る。
@code{oldbuf} の値を利用して元のバッファのリージョン内のテキストを取り出
し新しいバッファに挿入する。そして最後に @code{save-excursion} を用いて
元のバッファに戻る。

@code{append-to-buffer} を見ていく中で、かなり複雑な関数を探検したことと
思う。@code{let} や @code{save-excursion} の使い方も見られたし、複数のバッ
ファ間の行き来の仕方も見た。他の多くの関数定義の中でもこのようにして
@code{let}, @code{save-excursion}, そして @code{set-buffer} を利用している。

@node Buffer Related Review
@section 復習

ここで、この章で議論した様々な関数について簡単にまとめておく。

@table @code
@item describe-function
@itemx describe-variable
関数ないしは変数の説明文字列を表示する。通常は、@kbd{C-h f} と
@kbd{C-h v} にバインドされている。

@item find-tag
関数のソースや変数を含むファイルを探して、そのバッファに移り、その関数や
変数が定義されている位置にポイントを移動する。通常は @kbd{M-.} にバイン
ドされている。(これは、@key{META} キーを押して終止符を押すという意味で
ある。)

@item save-excursion
ポイントとマークの位置を保存し、@code{save-excursion} の引数が評価された
後で、それらの値を元に戻す。また、カレントバッファも憶えていて、そのバッ
ファに戻してくれる。

@item push-mark
マークを現在の位置に設定し、直前のマークの値を、マークリングに記録する。
このマークは、バッファ内の位置を示し、たとえそのバッファにテキストが追加
されたり削除されたりしても、その相対的な位置を保持してくれる。

@item goto-char
ポイントを引数の値で指定された位置に移動する。引数は数値あるいはマーカ、も
しくは @code{(point-min)} のように位置を表わす数値を返すようなＳ式でなけれ
ばならない。

@item insert-buffer-substring
この関数に引数として渡されたバッファのリージョンを現在のバッファに挿入す
る。

@item mark-whole-buffer
バッファ全体をリージョンに設定する。普通は @kbd{C-x h} にバインドされて
いる。

@item set-buffer
Emacs が注目しているバッファを他のバッファに切り替える。が、ディスプレイ
しているウィンドウは変更しない。人間が他のバッファで作業したい時よりかは
プログラムの中でよく使われるものである。

@item get-buffer-create
@itemx get-buffer
ある名前を持つバッファを見つける。その名前のバッファが無い場合は新しく作
る。@code{get-buffer} はもしその名前のバッファが無い場合には @code{nil}
を返す。
@end table

@need 1500
@node Buffer Exercises
@section 練習問題

@itemize @bullet
@item
あなた自身の @code{simplified-end-of-buffer} を書きなさい。そして、それ
が実際に動くことかどうかテストしてみなさい。

@item
（未訳）Use @code{if} and @code{get-buffer} to write a function that prints a
message telling you whether a buffer exists.

@item
@code{find-tag} を利用して、@code{copy-to-buffer} 関数のソースを見つけな
さい。
@end itemize

@node More Complex
@chapter もう少し複雑な関数

この章では、前の章で学んだことを基礎により複雑な関数を見ていくことにする。
@code{copy-to-buffer} 関数は、一つの定義の中で @code{save-excursion} を
二回使う方法を示してくれる。一方、@code{insert-buffer} 関数の方は
@code{interactive} 式の中での @key{*} の使い方と、@code{or} の使い方、
そして、オブジェクトの名前と、その名前のついたオブジェクトとの違いについ
て教えてくれる。

@menu
* copy-to-buffer::              @code{set-buffer} と @code{get-buffer-create} を利用
* insert-buffer::               書き込み不可 と @code{or} の使い方
* beginning-of-buffer::         @code{goto-char}, @code{point-min}, そし
                                て @code{push-mark} を見てみる
* Second Buffer Related Review::  バッファについての練習問題(その２)
* optional Exercise ::          optional の練習問題
@end menu

@node copy-to-buffer
@section @code{copy-to-buffer} の定義
@findex copy-to-buffer

@code{append-to-buffer} がどのように動作するかを理解した後であれば、
@code{copy-to-buffer} の方も簡単に理解出来る。この関数はテキストを他のバッ
ファにコピーする。ただし、そのバッファに付け加えるのではなく、以前あった
テキストを置き換えてしまう。@code{copy-to-buffer} 関数のコードは
@code{append-to-buffer} のコードとほぼ同じであるが、@code{erase-buffer}
を使い、また @code{save-excursion} を二回使っている点が違う。
(@code{append-to-buffer} の説明については @ref{append-to-buffer, ,
@code{append-to-buffer} の定義}, を参照。)

@need 800
@code{copy-to-buffer} の本体は次の通りである。

@smallexample
@group
@dots{}
(interactive "BCopy to buffer: \nr")
(let ((oldbuf (current-buffer)))
  (with-current-buffer (get-buffer-create buffer)
    (barf-if-buffer-read-only)
    (erase-buffer)
    (save-excursion
      (insert-buffer-substring oldbuf start end)))))
@end group
@end smallexample

（未訳）The @code{copy-to-buffer} function has a simpler @code{interactive}
expression than @code{append-to-buffer}.

@need 800
The definition then says

@smallexample
(with-current-buffer (get-buffer-create buffer) @dots{}
@end smallexample

（未訳）First, look at the earliest inner expression; that is evaluated first.
That expression starts with @code{get-buffer-create buffer}.  The
function tells the computer to use the buffer with the name specified
as the one to which you are copying, or if such a buffer does not
exist, to create it.  Then, the @code{with-current-buffer} function
evaluates its body with that buffer temporarily current.

（未訳）(This demonstrates another way to shift the computer's attention but
not the user's.  The @code{append-to-buffer} function showed how to do
the same with @code{save-excursion} and @code{set-buffer}.
@code{with-current-buffer} is a newer, and arguably easier,
mechanism.)

（未訳）The @code{barf-if-buffer-read-only} function sends you an error
message saying the buffer is read-only if you cannot modify it.

（未訳）The next line has the @code{erase-buffer} function as its sole
contents.  That function erases the buffer.

（未訳）Finally, the last two lines contain the @code{save-excursion}
expression with @code{insert-buffer-substring} as its body.
The  @code{insert-buffer-substring} expression copies the text from
the buffer you are in (and you have not seen the computer shift its
attention, so you don't know that that buffer is now called
@code{oldbuf}).

（未訳）Incidentally, this is what is meant by `replacement'.  To replace text,
Emacs erases the previous text and then inserts new text.

（旧訳）@code{append-to-buffer} の定義との違いが現れるのは、テキストがコピーされ
るバッファに移ってからである。つまり、この後 @code{copy-to-buffer} 関数
では以前の内容を消去してしまう。(これが、「置き換え」と言った意味である。
Emacs ではテキストを置き換える場合、以前の内容をまず消去し、次に新しいテ
キストを挿入する。) 以前の内容を消去した後、もう一度
@code{save-excursion} が使われる。そして新しいテキストが挿入される。

（旧訳）何故 @code{save-excursion} が二回も使われるのか？ それを理解するために、
もう一度この関数が何をやっているか見てみよう。

@need 1250
大ざっぱには、@code{copy-to-buffer} の本体は次のようになっている。

@smallexample
@group
(let (@code{oldbuf}@var{を}@code{current-buffer}@var{の値にバインド})
      (@var{with-the-buffer-you-are-copying-to}
      (@var{but-do-not-erase-or-copy-to-a-read-only-buffer})
      (erase-buffer)
      (save-excursion
        @var{現在のバッファに}@code{oldbuf}@var{から部分文字列を挿入})))
@end group
@end smallexample

（旧訳）最初の @code{save-excursion} は Emacs にテキストのコピー元のバッファを返
している。これは当たり前のことで、@code{append-to-buffer} でも同じような
使われ方をしていたのだった。では何故二番目が必要なのか？ 理由は、
@code{insert-buffer-substring} が常にポイントを挿入されたリージョンの
@emph{最後}に移動してしまうからである。二番目の @code{save-excursion}
があるおかげで、Emacs は挿入されたテキストの最初の位置にポイントを移動す
る。大抵の状況では、ユーザーは挿入されたテキストの最初の位置にポイントが
あるほうを好むものである。(勿論、@code{copy-to-buffer} 関数は終了時に元
居たバッファに戻る---しかし、もしユーザが@emph{次に}コピー先のバッファに
移ったとすると、ポイントはそのテキストの先頭に移動してくれるというわけで
ある。このように、二番目の @code{save-excursion} はちょっぴり気の効いた
働きをしてくれるものなのだ。)

@node insert-buffer
@section @code{insert-buffer} の定義
@findex insert-buffer

@code{insert-buffer} もまた、バッファに関する関数である。このコマンドは
他のバッファをカレントバッファの@emph{中に}挿入する。これは
@code{append-to-buffer} や @code{copy-to-buffer} と逆である。これらの方
は、カレントバッファ@emph{から}リージョンを取り出して他のバッファにコピー
するのであった。

Here is a discussion based on the original code.  The code was
simplified in 2003 and is harder to understand.

(@xref{New insert-buffer, , New Body for @code{insert-buffer}}, to see
a discussion of the new body.)

更に、このコードは @dfn{read-only} なバッファに関する @code{interactive}
の使い方や、オブジェクトの名前と、その名前のついたオブジェクトそのものと
の違いの重要性を理解させてくれる。これがそのコードである。

@menu
* insert-buffer code::
* insert-buffer interactive::   書き込み不可の状態の時の動作
* insert-buffer body::          The body has an @code{or} and a @code{let}.
* if & or::                     Using an @code{if} instead of an @code{or}.
* Insert or::                   How the @code{or} expression works.
* Insert let::                  Two @code{save-excursion} expressions.
* New insert-buffer::
@end menu

@ifnottex
@node insert-buffer code
@unnumberedsubsec The Code for @code{insert-buffer}
@end ifnottex

@need 800
Here is the earlier code:

@smallexample
@group
(defun insert-buffer (buffer)
  "Insert after point the contents of BUFFER.
Puts mark after the inserted text.
BUFFER may be a buffer or a buffer name."
  (interactive "*bInsert buffer:@: ")
@end group
@group
  (or (bufferp buffer)
      (setq buffer (get-buffer buffer)))
  (let (start end newmark)
    (save-excursion
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
@end group
@group
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark)))
@end group
@end smallexample

@need 1200
他の関数定義と同様に、テンプレートを使ってこの関数のアウトラインを見るこ
とが出来る。

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{説明文字列}@dots{}"
  (interactive "*bInsert buffer:@: ")
  @var{本体}@dots{})
@end group
@end smallexample

@node insert-buffer interactive
@subsection @code{insert-buffer} のインタラクティブ式
@findex interactive, @r{example use of}

@code{insert-buffer} ではインタラクティブ宣言の引数には二つの部分がある。
一つはアスタリスク @samp{*} であり、もう一つは @samp{bInsert buffer:@: }
である。

@menu
* Read-only buffer::            書き込み不可のバッファでは
* b for interactive::
@end menu

@node Read-only buffer
@unnumberedsubsubsec 書き込み不可のバッファ
@cindex Read-only buffer
@cindex Asterisk for read-only buffer
@findex * @r{for read-only buffer}

アスタリスクはバッファが read-only---つまり変更出来ないバッファである場合
のためのものである。もし、@code{insert-buffer} が read-only なバッファで呼
ばれた場合、エコー領域にその旨を知らせるメッセージが表示され、ビープ音が
鳴るか、画面が明滅する。「あなたはこのバッファに如何なるものも挿入しては
いけませんよ」というわけである。アスタリスクの後には、次の引数と分離するた
めに改行コードを付ける必要はない。

@node b for interactive
@unnumberedsubsubsec インタラクティブ式の中の @samp{b}

インタラクティブ式の次の引数は小文字の @samp{b} から始まっている。(これ
は @code{append-to-buffer} のコードの中のとは違うことに注意。こっちでは
大文字の @samp{B} を使っていたのだった。@ref{append-to-buffer, ,
@code{append-to-buffer} の定義}, 参照。)
小文字の @samp{b} は Lisp インタプリタに @code{insert-buffer} の引数が存
在するバッファないしは、その名前でなければならないことを示している。(大
文字の @samp{B} オプションの方は存在しないバッファであっても良い。)
Emacs はプロンプトを出してバッファの名前を要求し、同時にデフォルトのバッ
ファも提示してくれる。名前の補完もやってくれる。もし、ここで存在しないバッ
ファを指定すると、``No match'' というメッセージを受け取る。端末によって
はビープ音がするかもしれない。

（未訳）The new and simplified code generates a list for @code{interactive}.
It uses the @code{barf-if-buffer-read-only} and @code{read-buffer}
functions with which we are already familiar and the @code{progn}
special form with which we are not.  (It will be described later.)

@node insert-buffer body
@subsection 関数 @code{insert-buffer} の本体部分

関数 @code{insert-buffer} の本体は、主に二つの部分からなっている。一つは
@code{or} 式であり、もう一つは @code{let} 式である。@code{or} 式を使う目
的は、引数 @code{buffer} がバッファの名前ではなくちゃんとバッファそのも
のにバインドされていることを確認することである。@code{let} 式の本体は、
他のバッファをカレントバッファに挿入するコードを含んでいる。

@need 1250
大まかに言って、二つのＳ式は次のように @code{insert-buffer} 関数の中に組
み込まれている。

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{説明文字列}@dots{}"
  (interactive "*bInsert buffer:@: ")
  (or @dots{}
      @dots{}
@end group
@group
  (let (@var{変数リスト})
      @code{let}@var{の本体}@dots{} )
@end group
@end smallexample

引数 @code{buffer} がバッファの名前ではなくバッファそのものにバインドさ
れているかを @code{or} 式がどのようにして確かめているかを理解するには、
最初に関数 @code{or} を理解する必要がある。

が、その前にまずこの部分を @code{if} を使って書き直してみたい。そうすれ
ばより身近な方法で何がなされているかを見ることが出来るだろう。

@node if & or
@subsection @code{or} の代わりに @code{if} を使った @code{insert-buffer}

やるべき仕事は @code{buffer} の値がバッファそのものであり、バッファ名で
はないことを確認することである。もし値が名前であったら、その名前のついた
バッファを持ってこないといけない。

まずあなたが何かのコンファレンスに参加しており、案内係があなた方の名前が
書かれたリストをもってあなたを探している状況を思い浮かべて欲しい。この状
態では案内係はあなた自身ではなく、あなたの名前に「バインド」されている。
しかし、案内係があなたを見つけてあなたの腕を取った時点で、案内係はあなた
自身に「バインド」されたことになる。

@need 800
Lisp ではこの状況を次のように説明出来る。

@smallexample
@group
(if (not (お客をつかまえている))
    (お客を見つけて腕を取る))
@end group
@end smallexample

我々はこれと同じことをバッファについてやりたいわけである---バッファそのも
のでない場合も、バッファを見つけて取って来たいのだ。

@need 1200
@code{bufferp} という(バッファの名前ではなく)バッファかどうかを判定して
くれる述語を使うと、このコードを次のように書くことが出来る。

@smallexample
@group
(if (not (bufferp buffer))              ; @r{if-part}
    (setq buffer (get-buffer buffer)))  ; @r{then-part}
@end group
@end smallexample

@noindent
コメントにもあるが、上の式で、@code{if} 式の真偽テストの部分は
@w{@code{(not (bufferp buffer))}} であり、一方 then-part の部分は
@w{@code{(setq buffer (get-buffer buffer))}} である。

このテストの中では @code{bufferp} 関数は引数がバッファであれば真の値を返
す---しかしバッファの名前であれば偽の値を返す。(@code{bufferp} という関
数の名前の最後は @samp{p} で終わっている。以前見たようにこの @samp{p} は、
この関数が述語、つまり、ある性質を持つか否かを判定する関数であることを示
すための工夫として付けられている。
@ref{Wrong Type of Argument, , 関数に間違った型の引数を与えると}, を参照
のこと。)

@need 1200
@code{(bufferp buffer)} 式の前には関数 @code{not} がある。即ち
真偽テストは次の通りである。

@smallexample
(not (bufferp buffer))
@end smallexample

@noindent
@code{not} は引数が偽であれば真を返し、偽であれば真を返す関数である。従っ
て、もし @code{(bufferp buffer)} が真を返せば、@code{not} 式が偽を返すし、
偽を返せば真を返す。「真でない」というのは偽ということだし、「偽でない」
というのは真だというわけである。

@code{if} は、このテストを使って次のように動作する。変数 @code{buffer}
の値がバッファの名前ではなく実際にバッファだった場合、真偽テストの結果
は偽である。すると、@code{if} 式は then-part を評価しない。これはまとも
な動作である。というのは、もし変数 @code{buffer} が本当にバッファであれ
ば、これに対して特に何もする必要はないからである。

一方で、@code{buffer} の値がもしバッファそのものではなくバッファの名前で
あったとすると、真偽テストでは真が返り、結果として then-part が評価される。
今の場合、then-part は @code{(setq buffer (get-buffer buffer))} である。
このＳ式は、その名前のついた実際のバッファを得るために @code{get-buffer}
関数を使っている。そして、@code{setq} で、変数 @code{buffer} の値をバッ
ファの名前から実際のバッファそのものに置き換えている。

@node Insert or
@subsection 本体部分の @code{or}

@code{insert-buffer} 関数で @code{or} 式を使う目的は引数 @code{buffer}
がバッファの名前ではなくバッファそのものにバインドされているかどうかを確
認することにある。前節で、どのようにして @code{if} を使ってこの作業をす
るかを見た。しかし、@code{insert-buffer} 関数では実際は @code{or} を使っ
ている。この理由を理解するには、@code{or} 関数の働きを理解しなければなら
ない。

@findex or
関数 @code{or} はいくらでも引数を持つことが出来る。この関数は各引数を順に
評価していき、@code{nil} でなかった最初の引数の値を返す。また、これが
@code{or} の重要な特徴なのだが、この関数は引数で @code{nil} 以外の値を返
すものがあった場合、その後の引数はもはや評価しない。

今の場合の @code{or} 式は次の通りである。

@smallexample
@group
(or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
@end group
@end smallexample

@noindent
@code{or} の最初の引数は Ｓ式 @code{(bufferp buffer)} である。この式は、
もし buffer がバッファそのものでありバッファの名前ではない場合は、真を返
す。@code{or} 式では、この場合、@code{or} 式の値として真を返し、その後の
引数は評価されない---我々にはこの方が都合が良い。というのもこの場合には
つまり @code{buffer} が真のバッファである場合には、この値について何もす
る必要がないからである。

一方で、もし @code{(bufferp buffer)} が @code{nil} であれば、それは
@code{buffer} の値がバッファの名前であるということである。この場合、Lisp
インタプリタは @code{or} 式の次の引数も評価する。これは @code{(setq
buffer (get-buffer buffer))} という式である。この式は値 @code{nil} を返
す。これが変数 @code{buffer} にセットされた値である---そしてこの値はバッ
ファそのものであり、バッファの名前ではない。

以上のことから、シンボル @code{buffer} は常に、あるバッファの名前ではな
くバッファそのものにバインドされることになる。また、以上の手続きは全てが
必要なことである。というのも、次の行の @code{set-buffer} 関数はバッファ
に対してしか働かないからである。

@need 1250
ついでだが、@code{or} を使った場合、案内係というのは次のように書ける。

@smallexample
(or (お客をつかまえている) (お客を見つけて腕を取る))
@end smallexample

@node Insert let
@subsection @code{insert-buffer} の中の @code{let} 式

@code{insert-buffer} 関数では、変数 @code{buffer} がバッファの名前ではな
くバッファそのものを表わすことを確認した後には、 @code{let} 式が続く。
ここでは三つの変数 @code{start}, @code{end}, @code{newmark} を指定してい
る。これらの変数は @code{let} 式の内部でのみ使われ、@code{let} 式の評価
が終わるまでの間は、一次的に Emacs 内の同じ名前の他の変数は隠されている。

@need 1200
@code{let} 式の本体は二つの @code{save-excursion} を使っている。まずは、
内側にある方の @code{save-excursion} 式を細かく見ていこう。この式は次の
通りである。

@smallexample
@group
(save-excursion
  (set-buffer buffer)
  (setq start (point-min) end (point-max)))
@end group
@end smallexample

@noindent
Ｓ式 @code{(set-buffer buffer)} は、Emacs が注目するバッファをテキストが
コピー元のバッファに切り替える。このバッファの中で、@code{point-min} コ
マンド及び、@code{point-max} コマンドを使って変数 @code{start} と 変数
@code{end} に各々バッファの始まりと終わりの位置を設定する。@code{setq}
を使って、一つのＳ式で二つの変数を同時に設定する方法についてはもう既に説
明したのだった。@code{setq} の最初の引数は二番目の値に、三番目の引数は四
番目の引数の値にセットされる。

（未訳）After the body of the inner @code{save-excursion} is evaluated, the
@code{save-excursion} restores the original buffer, but @code{start} and
@code{end} remain set to the values of the beginning and end of the
buffer from which the text will be copied.

@need 1250
外側の @code{save-excursion} 式は次の通りである。

@smallexample
@group
(save-excursion
  (@var{内側の}@code{save-excursion}@var{式}
     (@var{新しいバッファに移動し}@code{start}@var{と}@code{end}@var{をセット})
  (insert-buffer-substring buffer start end)
  (setq newmark (point)))
@end group
@end smallexample

@noindent
関数 @code{insert-buffer-substring} は @code{buffer} @emph{から}、その中
の@code{start} と @code{end} で指定されたリージョン内のテキストを、カレ
ントバッファの@emph{中に}コピーする。今の場合、コピー元のバッファ全体が
@code{start} と @code{end} の間にあるために、そのバッファ全体が現在編集
中のバッファにコピーされることになる。次に、この時点で挿入されたテキスト
の最後にあるポイントの値が、変数 @code{newmark} に記録される。

外側の @code{save-excursion} の本体が評価された後、ポイントとマークの位
置は元の位置に戻される。

しかしながら、ポイントとマークの位置は新しく挿入されたテキストの最初と最
後にある方が、何かと都合が良い。@code{newmark} 変数は挿入されたテキスト
の最後の位置を記録する。@code{let} 式の最後の行で @code{(push-mark
newmark)} というＳ式でマークをこの位置に設定している。(以前のマークの位
置に移動することも可能である。この値はマークリングに保存されていて、
@kbd{C-u C-@key{SPC}} で遡ることが出来る。) 一方、ポイントの方は初めから
挿入されたテキストの最初の位置にある。これは @code{insert} 関数を呼び出
す前のポイントの位置がここだからである。

@need 1250
完全な @code{let} 式は次の通りである。

@smallexample
@group
(let (start end newmark)
  (save-excursion
    (save-excursion
      (set-buffer buffer)
      (setq start (point-min) end (point-max)))
    (insert-buffer-substring buffer start end)
    (setq newmark (point)))
  (push-mark newmark))
@end group
@end smallexample

@code{append-to-buffer} 関数の時と同じように、@code{insert-buffer} 関数
も @code{let}, @code{save-excursion}, そして @code{set-buffer} を使って
いる。それに加えて、この関数は @code{or} の使い方の一つも教えてくれてい
る。これらの関数は皆大切な部品であり、これから何度でも出てくることだろう。

@node New insert-buffer
@subsection @code{insert-buffer} の新しい本体
@findex insert-buffer, new version body
@findex new version body for insert-buffer

（未訳）The body in the GNU Emacs 22 version is more confusing than the original.

@need 1250
（未訳）It consists of two expressions,

@smallexample
@group
  (push-mark
   (save-excursion
     (insert-buffer-substring (get-buffer buffer))
     (point)))

   nil
@end group
@end smallexample

@noindent
except, and this is what confuses novices, very important work is done
inside the @code{push-mark} expression.

（未訳）The @code{get-buffer} function returns a buffer with the name
provided.  You will note that the function is @emph{not} called
@code{get-buffer-create}; it does not create a buffer if one does not
already exist.  The buffer returned by @code{get-buffer}, an existing
buffer, is passed to @code{insert-buffer-substring}, which inserts the
whole of the buffer (since you did not specify anything else).

（未訳）The location into which the buffer is inserted is recorded by
@code{push-mark}.  Then the function returns @code{nil}, the value of
its last command.  Put another way, the @code{insert-buffer} function
exists only to produce a side effect, inserting another buffer, not to
return any value.


@node beginning-of-buffer
@section @code{beginning-of-buffer} の完全な定義
@findex beginning-of-buffer

@code{beginning-of-buffer} 関数の基本的な構造については、既に議論したこ
とがあるのだった。(@xref{simplified-beginning-of-buffer, , 簡略版
@code{beginning-of-buffer} の定義}.) このセクションではこの定義の複雑な
部分を説明することにする。

以前説明した通り、引数無しで @code{beginning-of-buffer} を呼び出すと、そ
の時点でのポイントの位置にマークを設定して、カーソルがバッファの先頭に移
動する。しかしながら、もしこのコマンドが1から10までの数と一緒に呼び出さ
れた場合、この関数はバッファ全体を10としてこの数の割合の分を計算し、バッ
ファの先頭からその割合の分だけ進んだ位置にカーソルを移動させる。というわ
けで、@kbd{M-<} でこのコマンドを呼び出せば、カーソルはバッファの先頭に移
動するし、もし例えば @kbd{C-u 7 M-<} として呼び出せば、カーソルはバッファ
全体の70%分の位置にポイントを移動する。もし引数が10より大きかった場合は
バッファの最後に位置に移動する。

@code{beginning-of-buffer} 関数は、引数無しで呼び出すことが出来る。つま
り、引数は省略可能である。

@menu
* Optional Arguments::
* beginning-of-buffer opt arg:: 省略可能引数の例
* beginning-of-buffer complete:: 完全版
@end menu

@node Optional Arguments
@subsection 省略可能な引数

特にそうでないと言われない限り、Lisp は、関数定義で引数が指定された関数
はその引数のための値とともに呼ばれるものと思っている。もし、そうでなかっ
た場合、エラーが出され、@samp{Wrong number of arguments} というメッセー
ジを受け取ることになる。

@cindex Optional arguments
@cindex Keyword
@findex optional
しかしながら、Lisp の特徴として省略可能引数というものがある。ある
@dfn{キーワード} (@dfn{keyword}) を使うと Lisp インタプリタにその引数が
省略可能だと伝えることが出来るのだ。そのキーワードとは @code{&optional} で
ある。(@samp{optional} の前の @samp{&} もこのキーワードの一部分である。)
関数定義の中でこのキーワード @code{&optional} の後に続く引数は、関数が呼
ばれる際に必ずしも値を渡される必要はない。

@need 1200
というわけで、@code{beginning-of-buffer} の関数定義の最初の行は次のように
なる。

@smallexample
(defun beginning-of-buffer (&optional arg)
@end smallexample

@need 1250
また、関数定義全体のアウトラインは次のようになっている。

@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "@var{説明文字列}@dots{}"
  (interactive "P")
  (or (@var{is-the-argument-a-cons-cell} arg)
      (and @var{are-both-transient-mark-mode-and-mark-active-true})
      (push-mark))
  (let (@var{determine-size-and-set-it})
  (goto-char
    (@var{もし引数があれば}
        @var{どこへ行けばよいか調べる}
      @var{そうでなければ次の場所に}
      (point-min))))
   @var{do-nicety}
@end group
@end smallexample

この関数は @code{simplified-beginning-of-buffer} と似ている。違うのは、
@code{interactive} 式に @code{"P"} が引数として使われていることと、
引数が指定されている場合にカーソルを何処に移動するかを判断する
@code{goto-char} 関数に続いて if-then-else 式が来ていることである。

（未訳）(Since I do not explain a cons cell for many more chapters, please
consider ignoring the function @code{consp}.  @xref{List
Implementation, , How Lists are Implemented}, and @ref{Cons Cell Type,
, Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference
Manual}.)

@code{interactive} 式の中の @code{"P"} は、Emacs に、関数に前置
引数を渡すように伝えるものである。前置引数というのは
@kbd{META} キーに続いて数をタイプするか、@kbd{C-u} に押してから数をタイ
プすることで作ることが出来る。(もし @kbd{C-u} に続いて数を入力しない場合
には、デフォルトとして4が渡される。)

@code{if} 式の真偽テストの部分は単純である。単に @code{arg} だけだ。もし、
@code{arg} が @code{nil} 以外の値を持てば、即ち
@code{beginning-of-buffer} が引数付きで呼ばれた場合は、真偽テストでは
真が返り、@code{if} 式の then-part が評価される。一方、もし
@code{beginning-of-buffer} が引数とともに呼ばれなかったなら、@code{arg}
の値は @code{nil} になり、@code{if} 式の else-part の方が評価される。
else-part は単に @code{point-min} であり、この場合には
@code{goto-char} 式の全体は @code{(goto-char (point-min))} になる。
これは、以前の短縮版 @code{beginning-of-buffer} 関数で見た通りである。

@node beginning-of-buffer opt arg
@subsection 引数付きで呼び出された場合の @code{beginning-of-buffer}

@code{beginning-of-buffer} が引数付きで呼び出された場合は、
@code{goto-char} に渡す値を計算する、あるＳ式が評価される。このＳ式は、
ちょっと見にはかなり複雑に見える。内部に @code{if} 式を含んでいるし、算
数を沢山使っている。実際のコードは次の通りである。

@smallexample
@group
(if (> (buffer-size) 10000)
    ;; @r{バッファサイズが大きい場合のオーバーフローを避ける！}
                          (* (prefix-numeric-value arg)
                             (/ size 10))
  (/
   (+ 10
      (*
       size (prefix-numeric-value arg))) 10)))
@end group
@end smallexample

@menu
* Disentangle beginning-of-buffer::
* Large buffer case::           大きなバッファでの割り算と掛け算
* Small buffer case::           括弧の中に何があるか
@end menu

@ifnottex
@node Disentangle beginning-of-buffer
@unnumberedsubsubsec Disentangle @code{beginning-of-buffer}
@end ifnottex

他の複雑そうなＳ式と同様に、これもテンプレートに当てはめてみれば
理解しやすくなる。この場合は、if-then-else 式のテンプレートに当てはめる。
骨組みは次のようになる。

@smallexample
@group
(if (@var{バッファが大きいなら}
    @var{バッファのサイズを10で割り引数を掛ける}
  @var{そうでなければ別の計算をする}
@end group
@end smallexample

この中の @code{if} 式の真偽テストはバッファのサイズをチェックしている。
その理由は、Emacs Lisp の version 18 は約8,000,000以下の数値しか扱わない
のだが(そんなに大きな数は必要ない)、この計算に従うと、大きなバッファの場
合は Emacs は大き過ぎる数を扱うことになってしまうからだ。コードのコメン
トの中に出てくる「オーバーフロー」とは数が大き過ぎることを意味している。

ということで、バッファが大きい場合と、そうでない場合の二つに分けている。

@node Large buffer case
@unnumberedsubsubsec 大きなバッファの場合

（旧訳）@code{beginning-of-buffer} の中で内側にある方の @code{if} 式はバッファの
サイズが10,000文字を越えているかどうかをテストしている。そのために、
@code{>} と @code{buffer-size} という関数を使っている。

（未訳）In the old days, the function @code{buffer-size} was used.  Not only
was that function called several times, it gave the size of the whole
buffer, not the accessible part.  The computation makes much more
sense when it handles just the accessible part.  (@xref{Narrowing &
Widening, , Narrowing and Widening}, for more information on focusing
attention to an `accessible' part.)

@need 800
その行は次の通りである。

@smallexample
(if (> size 10000)
@end smallexample

@need 1200
@noindent
もしバッファが大きい場合は、@code{if} 式の then-part が評価される。この
部分を読みやすいよう書き直すと次のようになる。

@smallexample
@group
(*
  (prefix-numeric-value arg)
  (/ size 10))
@end group
@end smallexample

@noindent
このＳ式は乗法であり、二つの引数を関数 @code{*} に渡している。

最初の引数は @code{(prefix-numeric-value arg)} である。
@code{interactive} 宣言で @code{"P"} が指定されている場合、引数は関数に
「未処理の前置引数」(raw prefix argument) として渡され、数値としては渡さ
れない。(リストの中では数値である。) 算数で使えるようにするには変換する
必要があり、その仕事を @code{prefix-numeric-value} がやっているのである。

@findex / @r{(division)}
@cindex Division
二番目の引数は @code{(/ (buffer-size) 10)} である。この式は数値としての
バッファの値を10で割る。これはバッファサイズの一割にどれだけの文字数が含
まれているかを計算するものだ。(Lisp では @code{/} は除法に使われる。
@code{*} が乗法に使われるのと同様である。)

@need 1200
乗法の式全体としては、この値に前置引数の値を掛けることになる---こんな感
じだ。

@smallexample
@group
(* @var{数値としての前置引数}
   @var{バッファの10分の1の文字数})
@end group
@end smallexample

@noindent
例えば、仮に前置引数が @samp{7} だったとするなら、この10分の1の数に7を掛
けることで、バッファの中の70%の位置が得られることになる。

@need 1200
結局、バッファが大きい場合の @code{goto-char} 式全体は次のようになる。

@smallexample
@group
(goto-char (* (prefix-numeric-value arg)
              (/ size 10)))
@end group
@end smallexample

これでカーソルは望む場所に移動してくれる。

@node Small buffer case
@unnumberedsubsubsec 小さなバッファの場合

バッファが10,000文字よりも小さかった場合は、ちょっと違った計算方法が取ら
れる。さっきの方法でも出来るのだから、こんなことをする必要はないと思うか
もしれない。しかし、バッファが小さい場合、初めの方法ではカーソルを望む場
所にきちんと移動してくれない。次に説明する二番目の方法の方がちゃんとした
仕事をしてくれる。

@need 800
コードは次の通りである。

@c Keep this on one line.
@smallexample
(/ (+ 10 (* size (prefix-numeric-value arg))) 10))
@end smallexample

@need 1200
@noindent
このコードの中で何をしているかは、括弧の中にどのように関数が埋め込まれて
いるかを見れば分る。各々の式をそれを含む括弧より深くインデントしてやれば、
より見やすくなる。

@smallexample
@group
  (/
   (+ 10
      (*
       size
       (prefix-numeric-value arg)))
   10))
@end group
@end smallexample

@need 1200
@noindent
これらの括弧を見ると、もっとも内側にある関数は
@code{(prefix-numeric-value arg)} であることが分る。これは未処理の
前置引数を数値に変換するものである。この数値は次の式によってバッファサイズと
掛け合わされる。

@smallexample
(* size (prefix-numeric-value arg))
@end smallexample

@noindent
この掛け算では、バッファのサイズの値よりも大きな数が生ずる---例えば引数
が7なら7倍大きな数になる。これに10が加えられ、最後にこの大きな数が10で割
られる。こうして得られる値は、バッファのサイズ中の目的とする割合よりも一
文字分だけ大きな数である。

これら一連の操作の結果で得られた数が @code{goto-char} に渡され、カーソル
がその位置に移動する。

@need 1500
@node beginning-of-buffer complete
@subsection 完全版 @code{beginning-of-buffer}

@need 1000
ここで、@code{beginning-of-buffer} の完全なコードを挙げておく。
@sp 1

@c In GNU Emacs 22
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "Move point to the beginning of the buffer;
leave mark at previous position.
With \\[universal-argument] prefix,
do not set mark at previous position.
With numeric arg N,
put point N/10 of the way from the beginning.

If the buffer is narrowed,
this command uses the beginning and size
of the accessible part of the buffer.
@end group

@group
Don't use this command in Lisp programs!
\(goto-char (point-min)) is faster
and avoids clobbering the mark."
  (interactive "P")
  (or (consp arg)
      (and transient-mark-mode mark-active)
      (push-mark))
@end group
@group
  (let ((size (- (point-max) (point-min))))
    (goto-char (if (and arg (not (consp arg)))
                   (+ (point-min)
                      (if (> size 10000)
                          ;; Avoid overflow for large buffer sizes!
                          (* (prefix-numeric-value arg)
                             (/ size 10))
                        (/ (+ 10 (* size (prefix-numeric-value arg)))
                           10)))
                 (point-min))))
  (if (and arg (not (consp arg))) (forward-line 1)))
@end group
@end smallexample

@ignore
（無視）From before GNU Emacs 22
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "Move point to the beginning of the buffer;
leave mark at previous position.
With arg N, put point N/10 of the way
from the true beginning.
@end group
@group
Don't use this in Lisp programs!
\(goto-char (point-min)) is faster
and does not set the mark."
  (interactive "P")
  (push-mark)
@end group
@group
  (goto-char
   (if arg
       (if (> (buffer-size) 10000)
           ;; @r{大きなバッファサイズの場合のオーバーフローを避ける！}
           (* (prefix-numeric-value arg)
              (/ (buffer-size) 10))
@end group
@group
         (/ (+ 10 (* (buffer-size)
                     (prefix-numeric-value arg)))
            10))
     (point-min)))
  (if arg (forward-line 1)))
@end group
@end smallexample
@end ignore

@noindent
二つの細かな点を除けば、これまでの議論でこの関数がどう動くかが分るだろう。
細かな点の一つ目は、説明文字列についてであり、二つ目は、この関数の最後の
行に関するものである。

@need 800
で、一点目だが、説明文字列の中に、あるＳ式についてのリファレンスがある。

@smallexample
\\[universal-argument]
@end smallexample

@noindent
（旧訳）この式の最初の括弧の前に @samp{\} が使われている。この @samp{\} は Lisp
インタプリタに対し、このＳ式は説明として表示されるもので
あって、Ｓ式として評価されるものではないことを示すものである。

@need 1200
次に二点目だが、@code{beginning-of-buffer} コマンドの最後の行は、この関
数が引数とともに呼ばれた場合に、ポイントを次の行の最初に持ってくためのも
のである。

@smallexample
(if (and arg (not (consp arg))) (forward-line 1))
@end smallexample

@noindent
（旧訳）これによって、カーソルはバッファの中の適当な割合の位置の次の行の先頭に移
動する。これが最良の位置であろう。カーソルは@emph{少くとも}要求された割
合よりかは常に大きい位置に移動するからだ。この動作はちょっと几帳面過ぎる
かもしれないが、かと言ってそうしなければ、必ず文句を言う人がいるだろう。

@node Second Buffer Related Review
@section 復習

ここで、この章の幾つかのトピックを手短にまとめておく。

@table @code
@item or
引数を順に評価していき、@code{nil} でない最初の値を返す。ただし、もしど
の引数も @code{nil} を返した場合は @code{nil} を返す。一言で言うと、引数
の中で真である最初の値を返す。つまり、ある引数が真であるか@emph{または}
(or) その他の引数のどれかが真であれば真の値を返す。

@item and
引数を順に評価していき、どれか一つでも @code{nil} があれば、@code{nil}
を返し、どれも @code{nil} で無ければ最後の引数の値を返す。一言で言うと、
全ての引数が真である場合のみ真である値を返す。つまり、ある引数が真であり、
@emph{かつ} (and) その他の引数も全て真である場合に真の引数を返す。

@item &optional
関数定義での引数が省略可能であることを示すために使うキーワード。これが
あると、その引数がなくともその関数を評価することが出来る。

@item prefix-numeric-value
（未訳）Convert the `raw prefix argument' produced by @code{(interactive
"P")} to a numeric value.

@item forward-line
ポイントを次の行の先頭に移動する。1より大きい引数が与えられた場合はその
数の行だけ進む。進めない場合は行けるところまで進み、行くはずではあったが
進めなかった分の行数を値として返す。

@item erase-buffer
カレントバッファの内容を全て削除する。

@item bufferp
引数がバッファの場合、@code{t} を返す。そうでない場合は @code{nil} を返す。
@end table

@node optional Exercise
@section @code{optional} 引数の練習問題

省略可能な引数を持ち、その引数の数が @code{fill-column} の値よりも大きい
か小さいかをテストして結果を教えてくれるようなインタラクティブな関数を書
きなさい。ただし、引数なしの場合は56をデフォルトとして使うようにしなさい。

@node Narrowing & Widening
@chapter ナローイングとワイドニング
@cindex Focusing attention (narrowing)
@cindex Narrowing
@cindex Widening

ナローイングはバッファの特定部分にのみ注目し、その他の部分を間違って変更
したりすることなく作業するための Emacs の機能である。ナローイングは普通
は使えないようになっている。これは初心者を混乱させないためである。

@menu
* Narrowing advantages::        ナローイングの利点
* save-restriction::            特殊形式 @code{save-restriction}
* what-line::                   ポイントは今何行目にあるか
* narrow Exercise::             ナローイングの練習問題
@end menu

@ifnottex
@node Narrowing advantages
@unnumberedsec ナローイングの利点
@end ifnottex

ナローイングを使うと、バッファのその他の部分はあたかも存在しないかのよう
に見えなくなる。これは、例えばバッファのある部分でのみ単語を置き換えたい
場合なんかに有効である。つまり特定の部分にナローイングしてそこで置換を実
行すると、その部分のみ置換が実行されて残りの部分は無視される。検索につい
ても同様で、ナローイングされた部分でのみ検索を行い、外の部分は探さない。
というわけで、文書のある部分のみ修正したい場合など、そのリージョンにナロー
イングをかけることで、間違って修正不要な箇所まで見てしまうのを防ぐことが
出来るのである。

しかしながら、ナローイングするとバッファの残りの部分が見えなくなるので、
意図せずナローイングしてしまった場合、ファイルのその部分を削除してしまっ
たのではないかと不安に思う人も出てくるかもしれない。更に、@code{undo} コ
マンド (これは大抵 @kbd{C-x u} にバインドされている) でもナローイングは
解除されない(それに、そうすべきではない)。従って、もし @code{widen} コマ
ンドでまた見えるように出来るということを知らなかった場合、パニックに陥い
るかもしれない。(Emacs version 18 では、@code{widen} のキーバインディン
グは @code{C-x w} だった。version 19 では @kbd{C-x n w} になっている。)

ナローイングは、人間だけではなく Lisp インタプリタにとっても便利なように
なっている。 Emacs Lisp の関数はしばしば、バッファのある限定された部分に
対してのみ働くように設計されている。逆に言うと、Emacs Lisp 関数はナロー
イングされたバッファ全体に対して働くようになっているとも言える。例えば
@code{what-line} 関数は、もしバッファにナローイングがかかっていればそれ
を解除し、仕事が終わるとまたナローイングを元に戻す。一方、
@code{what-line} 関数の中から呼び出される @code{count-lines} 関数は、ま
ずナローイングを用いてバッファの目的とする部分に限定して仕事を行い、その
後ナローイングを解除して元の状態に戻す。

@node save-restriction
@section 特殊形式 @code{save-restriction}
@findex save-restriction

Emacs Lisp では、@code{save-restriction} という特殊形式を使うことで、
ナローイングのかかった状態を保持することが出来るようになっている。Lisp
インタプリタが @code{save-restriction} 式に出逢った場合、まず
@code{save-restriction} 式の本体部分を評価し、次にそのコードを実行するこ
とでナローイングの状況が変わった場合にそれを元に戻す。例えば、バッファが
ナローイングされていて、@code{save-restriction} の本体で、ナローイングが
解除された場合、実行後に@code{save-restriction} はバッファにナローイング
されたリージョンを返してくれる。@code{what-line} コマンドでは、バッファ
にどんなナローイングが設定されていても @code{save-restriction} に続く
@code{widen} コマンドで解除してしまう。元のナローイングはこの関数が終了
する直前に元に戻されるわけである。

@need 1250
@code{save-restriction} 式のテンプレートは単純である。

@smallexample
@group
(save-restriction
  @var{本体}@dots{} )
@end group
@end smallexample

@noindent
@code{save-restriction} の本体は一つないしは複数のＳ式であり、それらは
Lisp インタプリタによって順に評価される。

最後に注意しておくことがある。それは @code{save-excursion} と
@code{save-restriction} の両方を、片方のすぐ後にもう片方を続けて使う場合、
@code{save-excursion} の方を外側にすることだ。これを逆にすると、
@code{save-excursion} を呼び出してからナローイングが設定されたバッファに
移動した場合にそのナローイングの状況を記録しそこねることがあるのだ。とい
うことで、もし @code{save-excursion} と @code{save-restriction} を両方一
緒に使うなら、次のように使うことになる。

@smallexample
@group
(save-excursion
  (save-restriction
    @var{本体}@dots{}))
@end group
@end smallexample

（未訳）In other circumstances, when not written together, the
@code{save-excursion} and @code{save-restriction} special forms must
be written in the order appropriate to the function.

@need 1250
For example,

@smallexample
@group
  (save-restriction
    (widen)
    (save-excursion
    @var{本体}@dots{}))
@end group
@end smallexample

@ignore
（無視）Emacs 22
/usr/local/src/emacs/lisp/simple.el

(defun what-line ()
  "Print the current buffer line number and narrowed line number of point."
  (interactive)
  (let ((start (point-min))
        (n (line-number-at-pos)))
    (if (= start 1)
        (message "Line %d" n)
      (save-excursion
        (save-restriction
          (widen)
          (message "line %d (narrowed line %d)"
                   (+ n (line-number-at-pos start) -1) n))))))

(defun line-number-at-pos (&optional pos)
  "Return (narrowed) buffer line number at position POS.
If POS is nil, use current buffer location.
Counting starts at (point-min), so the value refers
to the contents of the accessible portion of the buffer."
  (let ((opoint (or pos (point))) start)
    (save-excursion
      (goto-char (point-min))
      (setq start (point))
      (goto-char opoint)
      (forward-line 0)
      (1+ (count-lines start (point))))))

(defun count-lines (start end)
  "Return number of lines between START and END.
This is usually the number of newlines between them,
but can be one more if START is not equal to END
and the greater of them is not at the start of a line."
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@node what-line
@section @code{what-line}
@findex what-line
@cindex Widening, example of

@code{what-line} コマンドは現在カーソルがある場所までの行数を教えてくれ
るものである。この関数を見ることで、@code{save-restriction} と
@code{save-excursion} の使い方を知ることが出来る。以下がこの関数の完全な
コードである。

@smallexample
@group
(defun what-line ()
  "Print the current line number (in the buffer) of point."
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (beginning-of-line)
      (message "Line %d"
               (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

（未訳）(In recent versions of GNU Emacs, the @code{what-line} function has
been expanded to tell you your line number in a narrowed buffer as
well as your line number in a widened buffer.  The recent version is
more complex than the version shown here.  If you feel adventurous,
you might want to look at it after figuring out how this version
works.  You will probably need to use @kbd{C-h f}
(@code{describe-function}).  The newer version uses a conditional to
determine whether the buffer has been narrowed.

（未訳）(Also, it uses @code{line-number-at-pos}, which among other simple
expressions, such as @code{(goto-char (point-min))}, moves point to
the beginning of the current line with @code{(forward-line 0)} rather
than @code{beginning-of-line}.)

関数 @code{what-line} は一行の説明文字列を持ち、あなたが予想した通
り、インタラクティブな関数である。次の二つの行では
@code{save-restriction} と @code{widen} を使っている。

特殊形式 @code{save-restriction} は、カレントバッファにどのようなナロー
イングがかかっていようと、それを記録して本体のコードが評価し終わった後に
その状態に戻してくれる。

特殊形式 @code{save-restriction} の後には @code{widen} が続いている。
この関数は、@code{what-line} が呼ばれた時にカレントバッファのナローイン
グを解除する。(ここでのナローイングは、@code{save-restriction} が憶えて
いるナローイングである。) これによって行数を数えるコマンドは、バッファの
最初からの行数を数えることが出来るのである。そうしない場合は、現在アクセ
ス可能なリージョンの範囲内でしか行数をカウントしない。元のナローイングは
特殊形式 @code{save-restriction} によってこの関数が終了する直前に元の状
態に戻される。

@code{widen} の呼び出しに続いて @code{save-excursion} が使われている。こ
れはカーソルの位置、(即ち、point の位置) とマークの位置を保存し、本体部
分のコードの中の @code{beginning-of-line} 関数によって動かされたポイント
の位置を元に戻す、という働きをしている。

(@code{(widen)} 式が @code{save-restriction} と @code{save-excursion} の
間にあることに注意しよう。これら二つの @code{save- @dots{}} 式を続けて使
う場合は @code{save-excursion} を外側に書かないといけないのであった。)

@need 1200
@code{what-line} 関数の最後の二つの行は、バッファ内の行数を数え、それを
エコー領域に表示するものである。

@smallexample
@group
(message "Line %d"
         (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

@code{message} 関数は Emacs の画面の最下行に一行メッセージを表示する関数
である。最初の引数は二重引用符に挟まれていて、これは文字文字列を表示する
ものである。ただし、@samp{%d}, @samp{%s}, @samp{%c} も入れることが出来て、
これらはこの文字列の後に続く引数を表示する。@samp{%d} は引数を10進数とし
て表示するので、メッセージは例えば @samp{Line 243} と言った感じになる。

@need 1200
@samp{%d} の場所に表示される数字は、この関数の最後の行で計算される。

@smallexample
(1+ (count-lines 1 (point)))
@end smallexample

@ignore
GNU Emacs 22

(defun count-lines (start end)
  "Return number of lines between START and END.
This is usually the number of newlines between them,
but can be one more if START is not equal to END
and the greater of them is not at the start of a line."
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@noindent
これがやっていることは1で示された位置、つまりバッファの最初の位置から
@code{(point)} までの行数を数え、それに1を加えることである。(@code{1+}
という関数は引数に 1 を加える関数である。)1を加えるのは、例えば二行目は
その前に一行しかないからである。@code{count-lines} はカレント行の
@emph{前の}行までしか数えないので、こうしないと一行ずれてしまうのだ。

@code{count-lines} が仕事を終えてメッセージがエコー領域に表示された後は
@code{save-excursion} によってポイントとマークの位置が元の状態に戻される。
そして、@code{save-restriction} がナローイングの状態を元に戻す。

@node narrow Exercise
@section ナローイングの練習問題

カレントバッファの最初の60文字を表示するような関数を書きなさい。その際、
例えばナローイングにより後半部分しかアクセス不能であり、最初の行が見えな
い状態であってもきちんと表示するようなものにしなさい。また、ポイント、マー
ク、及びナローイングを復元するようにすること。この練習問題のためには、
@code{save-restriction}、@code{widen}、@code{goto-char}、
@code{point-min}、@code{buffer-substring}、@code{message} 及び他の関数を
うまく組み合わせて使う必要がある。

@cindex Properties, mention of @code{buffer-substring-no-properties}
（未訳）(@code{buffer-substring} is a previously unmentioned function you will
have to investigate yourself; or perhaps you will have to use
@code{buffer-substring-no-properties} or
@code{filter-buffer-substring} @dots{}, yet other functions.  Text
properties are a feature otherwise not discussed here.  @xref{Text
Properties, , Text Properties, elisp, The GNU Emacs Lisp Reference
Manual}.)

（未訳）Additionally, do you really need @code{goto-char} or @code{point-min}?
Or can you write the function without them?

@node car cdr & cons
@chapter @code{car}, @code{cdr}, @code{cons}：基本関数
@findex car, @r{introduced}
@findex cdr, @r{introduced}

Lisp では @code{car}、@code{cdr}、そして @code{cons} が基本的な関数であ
る。@code{cons} 関数はリストを作るのに使われ、@code{car} 関数と
@code{cdr} 関数はそれらを分解するのに使われる。

@code{copy-region-as-kill} 関数を ``walk-through'' する時に、@code{cons}
と共に @code{cdr} の二つの変種である @code{setcdr} と @code{nthcdr} につ
いても見るつもりだ。(@ref{copy-region-as-kill}).

@menu
* Strange Names::               寄り道: 何故こんな名前がついているか
* car & cdr::                   リストの一部を取り出すための関数
* cons::                        リストの構成
* nthcdr::                      @code{cdr} を何回もよびだす
* nth::
* setcar::                      リストの最初の要素の変更
* setcdr::                      リストの残りの要素の変更
* cons Exercise::               cons についての練習問題
@end menu

@ifnottex
@node Strange Names
@unnumberedsec 奇妙な名前の由来
@end ifnottex

@code{cons} 関数の名前は特に非合理的なものではない。この名前は
`construct' という単語を略したものである。一方、@code{car} と @code{cdr}
の名前の由来は難解である。@code{car} は `Contents of the Address part of
the Register' というフレーズの頭文字から来ており、@code{cdr} (`could-er'
と発音する) は `Contents of the Decrement part of the Register' というフ
レーズから来ている。これらのフレーズは、Lisp が開発された頃の極めて初期
のハードウェアの特定の部分に基づくものであるが、単に時代遅れであるという
だけでなく、実に25年以上もの間、Lisp に関わる人々にとって全く見当はずれ
のものであった。だがしかし、これらの関数をもっと合理的な名前で呼ぼうとし
た学者も何人かいたにも関わらず、現在でもこの古い用語が使われている。特に
Emacs Lisp のソースコードでもこの用語が使われているので、この入門書でも
これらを使うことにしよう。

@node car & cdr
@section @code{car} と @code{cdr}

リストの @code{car} とは、単にそのリストの最初の要素のことである。従って、
リスト @code{(rose violet daisy buttercup)} の @code{car} は @code{rose}
である。

@need 1200
もし、この文章を GNU Emacs の Info で読んでいるなら、次を評価してみるこ
とでこのことを確認出来る。

@smallexample
(car '(rose violet daisy buttercup))
@end smallexample

@noindent
このＳ式を評価すると、エコー領域に @code{rose} と表示されたはずだ。

明らかに @code{car} には @code{first} という名前の方がふさわしいし、
よくそのように提案されてもいる。

@code{car} は最初の要素を除いたりはしない。ただ単にそれが何かを伝えるだ
けである。あるリストに @code{car} を施した後も、そのリストは元のままであ
る。専門用語では、@code{car} は「非破壊的 (non-destructive)」であると言っ
たりする。この特徴は、後で重要であることが分るだろう。

List の @code{cdr} はリストの残りの部分である。つまり、@code{cdr} 関数は
リストの最初の要素を除いた部分を返す。従って、@code{'(rose violet daisy
buttercup)} というリストの @code{car} が @code{rose} であるように、この
リストの残りの部分、つまり @code{cdr} を施して返される値は @code{(violet
daisy buttercup)} である。

@need 800
このことも、次をいつも通り評価してみることで確かめられる。

@smallexample
(cdr '(rose violet daisy buttercup))
@end smallexample

@noindent
これを評価すると、エコー領域に @code{(violet daisy buttercup)} と表示さ
れたはずだ。

@code{car} と同様、@code{cdr} もリストから要素を取り除いたりしない---た
だ単に二番目以降の要素のリストを返すだけである。

ついでに言っておくと、上の例では花のリストに引用符が付いている。もしこれ
が付いていなければ Lisp インタプリタは @code{rose} を関数として呼び出し
て評価しようとするだろう。この例では、そういうことをしたいのではなかった。

明らかに @code{cdr} には @code{rest} という名前の方が、ふさわしい。

(ここでちょっと教訓。あなたが新しい関数に名前をつける場合、それについて
極めて注意深く考えないといけない。というのも、あなたは多分、あなたが思う
よりずっと長い間、その名前につきまとわれることになるからだ。この文章でこ
れらの名前を使っているのは、Emacs Lisp のソースコードでこれらを使ってい
るからであり、そうしないとコードを読むのがつらいだろうからである。しかし、
どうかあなた自身はなるべくこういった言葉使いを避けて欲しい。そうすれば後
からやってきた人々から感謝されるだろう。)

@code{car} や @code{cdr} を @code{(pine fir oak maple)} といったシンボル
からなるリストに施した時、@code{car} によって返される要素はシンボル
@code{pine} であり、括弧は付いてはいない。@code{pine} はこのリストの最初
の要素である。しかしながら、リストの @code{cdr} は
@code{(fir oak maple)} というリストである。それは、次の式をいつものよう
に評価してみればすぐに分る。

@smallexample
@group
(car '(pine fir oak maple))

(cdr '(pine fir oak maple))
@end group
@end smallexample

一方、リストのリストでは、そのリストの最初の要素がそれ自身リストである。
この場合、@code{car} は最初のリストとしての要素を返す。例えば次のリストは
三つのサブリストを含んでいる。各々、肉食動物、草食動物、海洋哺乳類の
リストである。

@smallexample
@group
(car '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

@noindent
この場合、最初の要素、つまり全体のリストの @code{car} は肉食動物のリスト
@code{(lion tiger cheetah)} である。そしてリストの残りは@code{((gazelle
antelope zebra) (whale dolphin seal))} である。

@smallexample
@group
(cdr '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

ここでもう一度、@code{car} と @code{cdr} が非破壊的であると言っておいた
ほうがいいだろう。これらの関数はリストを変化させないのだ。このことはこれ
らの関数を使うにあたって極めて重要になる。

また最初の章でアトムについて議論した時に、Lisp では「ある種のアトム、
例えば配列 (array)、は複数の部分に分解出来る。しかし、そのメカニズムはリ
ストを分解する時のメカニズムとは違う。リストの操作に関する限り、リストの
アトムは分解不可能である。」と書いた。(@ref{Lisp Atoms}). @code{car} 関
数と @code{cdr} 関数はリストを分解するのに使われ、Lisp の基本と考えられ
ている。しかし、これらの関数は配列を分解したり、部分を取り出したりするの
には使えない。従って、配列はリストではなくアトムであると考えられるわけであ
る。また、もう一つの基本的な関数である @code{cons} も、リストを構築するこ
とは出来るが、配列を作ることは出来ない。(配列は、配列を扱う特殊な関数を
使って操作する。詳しくは @ref{Arrays, , Arrays, elisp, The GNU Emacs Lisp
Reference Manual}, を参照のこと。)

@node cons
@section @code{cons}
@findex cons, @r{introduced}

@code{cons} は、リストを作る関数である。@code{car} や @code{cdr} とは逆
の働きをするものだと言える。例えば、@code{cons} は三つの要素を持つリスト
@code{(fir oak maple)} から四つの要素を持つリストを作ることが出来る。つ
まり、

@smallexample
(cons 'pine '(fir oak maple))
@end smallexample

@need 800
@noindent
を評価すると、

@smallexample
(pine fir oak maple)
@end smallexample

@noindent
というリストがエコー領域に表示される。このように、@code{cons} はリストの
先頭に新しい一つの要素を付け加える。リストに要素を追加するわけである。

（未訳）We often say that `@code{cons} puts a new element at the beginning of
a list; it attaches or pushes elements onto the list', but this
phrasing can be misleading, since @code{cons} does not change an
existing list, but creates a new one.

（未訳）Like @code{car} and @code{cdr}, @code{cons} is non-destructive.

@menu
* Build a list::
* length::                      リストの長さを知る
@end menu

@ifnottex
@node Build a list
@unnumberedsubsec Build a list
@end ifnottex

@code{cons} には、まず要素を付け加えるべきリストが必要になる。
@footnote{実際は、アトムに要素を @code{cons} してドット対を作ることも出
来る。が、ドット対のことはここでは説明しない。これについては次を参照せよ。
@ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU Emacs
Lisp Reference Manual}.} 何も無いところからスタートすることは出来ないの
である。もし、リストを作りたいならば、少くともまず初めに空リストを用意す
る必要がある。次に挙げるのは、@code{cons} を連続して使って花のリストを作
るものである。もし、この文章を Emacs の Info で読んでいるのなら、各々の
Ｓ式をいつものように評価することが出来る。表示される値が @samp{@result{}}
の後に書かれている。これを「次のように評価される」と置き換えて読んで欲し
い。

@smallexample
@group
(cons 'buttercup ())
     @result{} (buttercup)
@end group

@group
(cons 'daisy '(buttercup))
     @result{} (daisy buttercup)
@end group

@group
(cons 'violet '(daisy buttercup))
     @result{} (violet daisy buttercup)
@end group

@group
(cons 'rose '(violet daisy buttercup))
     @result{} (rose violet daisy buttercup)
@end group
@end smallexample

@noindent
最初の例では、空リストが @code{()} という形で出ている。そして、
@code{buttercup} とこの空リストから新しいリストが作られる。見ればわかる
と思うが、空リストは作成されたリストの要素としては出て来ない。
@code{(buttercup)} というリストが見えるだけである。空リストは要素として
は数えられない。というのも、空リストには要素が一つもないからである。一般
的にいうと、空リストは見えないのである。

二番目の例では @code{(cons 'daisy '(buttercup))} を評価することで
@code{daisy} を @code{buttercup} の前に付け加えて、二つの要素を持つリス
トを作っている。三番目の例では @code{daisy} と @code{buttercup} の前に
@code{violet} を加えて三つの要素を持つリストを作っている。

@node length
@subsection リストの長さを調べる: @code{length}
@findex length

あるリストがどれだけ多くの要素を持つかを見るには、@code{length} という
Lisp の関数を使えばよい。次のように感じである。

@smallexample
@group
(length '(buttercup))
     @result{} 1
@end group

@group
(length '(daisy buttercup))
     @result{} 2
@end group

@group
(length (cons 'violet '(daisy buttercup)))
     @result{} 3
@end group
@end smallexample

@noindent
三番目の例では、三つの要素を持つリストを作るために @code{cons} 関数が使
われ、その結果出来たリストが @code{length} 関数に引数として渡されている。

@code{length} 関数を使って、空リストの中の要素の数を数えることも出来る。

@smallexample
@group
(length ())
     @result{} 0
@end group
@end smallexample

@noindent
予想した通りだと思うが、空リストの中の要素の数は零個と数えられる。

リストが無い場合にその長さを求めさせてみるのも面白い実験である。つまり、
引数として空リストすら渡さずに @code{length} を呼び出すのである。

@smallexample
(length )
@end smallexample

@need 800
@noindent
やってみれば分るが、これを評価すると、エラーメッセージが表示される。

@smallexample
Lisp error: (wrong-number-of-arguments length 0)
@end smallexample

@noindent
（旧訳）これは引数の数が間違っているという意味のメッセージである。今の場合なら、
本当は一つの引数が渡されなければならない。例えば引数がリストなら、そのリ
ストの長さをこの関数が測ることになるはずだったのである。(リストが沢山の
要素を持っていたとしても、@emph{一つ}のリストは@emph{一つ}の引数であるこ
とに注意。)

（未訳）The part of the error message that says @samp{length} is the name of
the function.

@ignore
（無視）@code{length} is still a subroutine, but you need C-h f to discover that.

In an earlier version:
    （エラーメッセージの中の @samp{#<subr length>} という部分は、関数の名前で
    ある。これは、特殊な表記法で書かれている。@samp{#<subr} は @code{length}
    が Emacs Lisp ではなく C で書かれたプリミティブな関数であることを表して
    いる。(@samp{subr} は `subroutine' の略である。) @ref{What Is a
    Function, ,What Is a Function?, elisp , The GNU Emacs Lisp Reference
    Manual}, にこの辺りのことについてのより詳しい情報がある。
@end ignore

@node nthcdr
@section @code{nthcdr}
@findex nthcdr

@code{nthcdr} 関数は、@code{cdr} 関数に関連した関数である。これは、リス
トの @code{cdr} を繰り返し取るものである。

@code{(pine fir oak maple)} の @code{cdr} を取ると、@code{(fir oak
maple)} が返される。もしこの返された値にもう一度同じ操作をすると、
@code{(oak maple)} が返される。(勿論、リストに何回 @code{cdr} を施しても、
元のリストは変化しない。@code{cdr} は対象リストを変化させはしないからで
ある。従って、@code{cdr} の @code{cdr} を評価する必要がある。) これを続
ければ、結果として空リストが返る。この場合、@code{()} ではなく
@code{nil} が表示される。

@need 1200
復習のために、以下に @code{cdr} の繰り返しの例を書いておく。
@samp{@result{}} の後に表示される結果が書いてある。

@smallexample
@group
(cdr '(pine fir oak maple))
     @result{}(fir oak maple)
@end group

@group
(cdr '(fir oak maple))
     @result{} (oak maple)
@end group

@group
(cdr '(oak maple))
     @result{}(maple)
@end group

@group
(cdr '(maple))
     @result{} nil
@end group

@group
(cdr 'nil)
     @result{} nil
@end group

@group
(cdr ())
     @result{} nil
@end group
@end smallexample

@need 1200
複数の @code{cdr} を、間に表示される値を挟まずに続けて書くことも出来る。

@smallexample
@group
(cdr (cdr '(pine fir oak maple)))
     @result{} (oak maple)
@end group
@end smallexample

@noindent
この場合は、Lisp インタプリタは最も内側のリストを先に評価する。最も内側
にあるリストには引用符が付いているので、それはそのままリストとして返され、
内側の方の @code{cdr} に渡される。この内側の @code{cdr} はこのリストの二
番目以降の要素からなるリストを返し、外側の @code{cdr} に渡す。これは、元
のリストの三番目以降の要素からなるリストを返すというわけである。この例の
ように、@code{cdr} 関数を二回続けて使うと、元のリストの最初の二つの要素
を除いたリストが返されることになる。

@code{nthcdr} 関数は、@code{cdr} 関数を繰り返して使うのと同じことをして
くれる。次の例では引数2がリストと一緒に @code{nthcdr} 関数に渡され、その
結果最初の二つの要素を除いたリストが返されている。これはまさに
@code{cdr} を二回繰り返してリストに施したのと同じ結果である。

@smallexample
@group
(nthcdr 2 '(pine fir oak maple))
     @result{} (oak maple)
@end group
@end smallexample

@need 1200
元の4つの要素を持ったリストを使って、0、1、5などを含むいろいろな引数を
@code{nthcdr} に与えた場合に何が起こるかを見てみよう。

@smallexample
@group
;; @r{リストはそのまま。}
(nthcdr 0 '(pine fir oak maple))
     @result{} (pine fir oak maple)
@end group

@group
;; @r{最初の要素を除いた残りのコピーを返す。}
(nthcdr 1 '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
;; @r{三つの要素を除いた残りのコピーを返す。}
(nthcdr 3 '(pine fir oak maple))
     @result{} (maple)
@end group

@group
;; @r{四つ全部を除いた残りを返す。}
(nthcdr 4 '(pine fir oak maple))
     @result{} nil
@end group

@group
;; @r{これも全部を除いた残りを返す。}
(nthcdr 5 '(pine fir oak maple))
     @result{} nil
@end group
@end smallexample

@node nth
@section @code{nth}
@findex nth

@code{nthcdr} も @code{cdr} と同様に元のリストを変化させないことに一言触
れておくほうがいいだろう。この関数もまた非破壊的なのである。これは
@code{setcar} 関数や @code{setcdr} 関数とはっきり違っているところである。

@need 1500
（未訳）Thus, if it were not defined in C for speed, the definition of
@code{nth} would be:

@smallexample
@group
(defun nth (n list)
  "Returns the Nth element of LIST.
N counts from zero.  If LIST is not that long, nil is returned."
  (car (nthcdr n list)))
@end group
@end smallexample

@noindent
（未訳）(Originally, @code{nth} was defined in Emacs Lisp in @file{subr.el},
but its definition was redone in C in the 1980s.)

（未訳）The @code{nth} function returns a single element of a list.
This can be very convenient.

（未訳）Note that the elements are numbered from zero, not one.  That is to
say, the first element of a list, its @sc{car} is the zeroth element.
This is called `zero-based' counting and often bothers people who
are accustomed to the first element in a list being number one, which
is `one-based'.

@need 1250
For example:

@smallexample
@group
(nth 0 '("one" "two" "three"))
    @result{} "one"

(nth 1 '("one" "two" "three"))
    @result{} "two"
@end group
@end smallexample

（未訳）It is worth mentioning that @code{nth}, like @code{nthcdr} and
@code{cdr}, does not change the original list---the function is
non-destructive.  This is in sharp contrast to the @code{setcar} and
@code{setcdr} functions.

@node setcar
@section @code{setcar}
@findex setcar

この二つの名前から連想されるように、@code{setcar} と @code{setcdr} とい
う関数は、リストの @code{car} や @code{cdr} に新しい値を持たせる。これら
は @code{car} や @code{cdr} が値を変化させないのとは異なり、実際に元のリ
ストの値を変化させてしまう。これがどういうことなのかを見る一つの方法は、
実験してみることだろう。まずは @code{setcar} 関数から始めてみよう。

@need 1200
最初にリストを作り、@code{setq} を使ってある変数の値にそのリストをセット
する。動物のリストでやってみよう。

@smallexample
(setq animals '(antelope giraffe lion tiger))
@end smallexample

@noindent
GNU Emacs の Info でこの文章を読んでいるなら、このＳ式をいつものように評
価してみよう。カーソルをＳ式の後に持っていき、@kbd{C-x C-e} とタイプする
のである。(私はこう書く時には実際にこの操作を試している。これは計算機環
境にインタプリタが組み込まれていることの利点の一つである。
Incidentally, when
there is nothing on the line after the final parentheses, such as a
comment, point can be on the next line.  Thus, if your cursor is in
the first column of the next line, you do not need to move it.
Indeed, Emacs permits any amount of white space after the final
parenthesis.)

@need 1200
変数 @code{animals} を評価してみれば、この変数が @code{(antelope giraffe
lion tiger)} というリストにバインドされていることが確かめられる。

@smallexample
@group
animals
     @result{} (giraffe antelope tiger lion)
@end group
@end smallexample

@noindent
別の言い方をすれば、変数 @code{animals} はリスト @code{(giraffe antelope
tiger lion)} を指しているとも言える。

次に、関数 @code{setcar} に変数 @code{animals} と引用符付きのシンボル
@code{hippopotamus} の二つ引数を渡して評価してみよう。これは三つの要素を
持つ @code{(setcar animals 'hippopotamus)} というリストを書いて、これを
いつものように評価することで行うことが出来る。

@smallexample
(setcar animals 'hippopotamus)
@end smallexample

@need 1200
@noindent
このＳ式を評価した後で、変数 @code{animals} をもう一度評価してみよう。す
ると、動物のリストが変化していることが分る。

@smallexample
@group
animals
     @result{} (hippopotamus giraffe lion tiger)
@end group
@end smallexample

@noindent
リストの最初の要素 @code{antelope} が @code{hippopotamus} に変わっている。

以上のことから分るように、@code{setcar} は @code{cons} のように新しい要
素を付け加えるのではなく、@code{giraffe} を @code{hippopotamus} に置き換
えている。即ち、この関数はリストの最初の要素を@emph{変更する}ものなのだ。

@node setcdr
@section @code{setcdr}
@findex setcdr

@code{setcdr} 関数も、@code{setcar} 関数と似ているのだが、こちらはリスト
の最初の要素ではなく、二番目以降の要素を置き換えるものである。

(To see how to change the last element of a list, look ahead to
@ref{kill-new function, , The @code{kill-new} function}, which uses
the @code{nthcdr} and @code{setcdr} functions.)

@need 1200
実際どのように働くかを見るために、まず次のＳ式を評価して、変数の値を家畜
のリストにセットしておく。

@smallexample
(setq domesticated-animals '(horse cow sheep goat))
@end smallexample

@noindent
この時点でこの変数を評価したなら、リスト @code{(horse cow sheep goat)}
が返されるはずだ。

@smallexample
@group
domesticated-animals
     @result{} (horse cow sheep goat)
@end group
@end smallexample

@need 1200
次に、@code{setcdr} に、このリストを値に持つ変数名とそのリストの
@code{cdr} の部分を置き換えるリストの二つの引数を与えて、評価してみる。

@smallexample
(setcdr domesticated-animals '(cat dog))
@end smallexample

@noindent
このＳ式を評価すると、リスト @code{(cat dog)} がエコー領域に表示される。
これがこの関数によって返される値である。我々にとって興味があるのは副作用
の方であるが、こちらは変数 @code{domesticated-animal} を評価してみれば
どんなものか理解出来る。

@smallexample
@group
domesticated-animals
     @result{} (horse cat dog)
@end group
@end smallexample

@noindent
このリストが @code{(horse cow sheep goat)} から @code{(horse cat dog)}
に変化しているのが分る。リストの @code{cdr} が @code{(cow sheep goat)}
から @code{(cat dog)} に置き換わっているのである。

@node cons Exercise
@section 練習問題

四種類の鳥のリストを幾つかの @code{cons} を使ったＳ式を評価することで
作りなさい。また、あるリストにそれ自身を @code{cons} した時に、何が起き
るかを見なさい。四種類の鳥のリストの最初の要素を魚で置き換えなさい。更に、
そのリストの残りの要素も他の魚で置き換えなさい。

@node Cutting & Storing Text
@chapter テキストの切り取りと保存
@cindex Cutting and storing text
@cindex Storing and cutting text
@cindex Killing text
@cindex Clipping text
@cindex Erasing text
@cindex Deleting text

GNU Emacs で `kill' コマンドを使ってバッファからテキストをカットないしは
切り取った (clip した) 場合、常にその情報はリストとして保持されており、
それをヤンク (yank) コマンドで取り出すことが出来る。

(Emacs で特に何らかの実体を破壊@emph{しない}プロセスに対して `kill' とい
う言葉を使うのは、不幸な歴史的出来事である。これには `clip' という単語の
方がずっとふさわしい。これこそ kill コマンドがやっていることに他ならない
からである。このコマンドはバッファからテキストを `clip' し、それをまた取
り出すことが出来るような置場所に移しているのだ。私はしばしば Emacs のソー
スの中に出てくるあらゆる `kill' を `clip' に、あらゆる `killed' を
`clipped' に置き換えたい衝動にかられる。)

@menu
* Storing Text::                テキストはリストの中に保存される
* zap-to-char::                 テキストをある文字まで削除する
* kill-region::                 リージョンの削除
* copy-region-as-kill::         テキストの複写の定義
* Digression into C::           Minor note on C programming language macros.
* defvar::                      変数に初期値を与える
* cons & search-fwd Review::    cons と search-forward の復習
* search Exercises::            検索についての練習問題
@end menu

@ifnottex
@node Storing Text
@unnumberedsec リストへのテキストの保存
@end ifnottex

テキストがバッファから切り取られた場合、そのテキストはあるリストに保存され
る。次にまたテキストを切り取りると、そのテキストもまたこのリストの中に続けて
保存される。従ってリストは次のようになる。

@smallexample
("a piece of text" "last piece")
@end smallexample

@need 1200
@noindent
関数 @code{cons} を使えば、以下のように、このリストにテキストを加えるこ
とが出来る。

@smallexample
@group
(cons "another piece"
      '("a piece of text" "previous piece"))
@end group
@end smallexample

@need 1200
@noindent
このＳ式を評価すると、次の三つの要素を持つリストがエコー領域に表示される
はずだ。

@smallexample
("another piece" "a piece of text" "last piece")
@end smallexample

関数 @code{car} や @code{nthcdr} を使うと、この中からどの部分でも取り出
すことが出来る。例えば次に挙げるコードでは @code{nthcdr 1 @dots{}} が最
初の要素を除いたリストを返し、@code{car} がその残りのリストの中の最初の
要素---元々のリストでは二番目の要素---を返す。

@smallexample
@group
(car (nthcdr 1 '("another piece"
                 "a piece of text"
                 "previous piece")))
     @result{} "a piece of text"
@end group
@end smallexample

勿論、実際に Emacs で使われている関数はこれよりももっと複雑である。テキ
ストをカットしたり取り出したりするためのコードは Emacs があなたが取り出
したいテキストがどれか分るように書かれていなければならない。それが一番目
にあろうと二番目にあろうと三番目にあろうと、あるいはもっと他の場所にあっ
てもである。また、もしリストの最後まで来た場合、そこで終わりとはせずに再
度最初の要素に戻らなくてはなるまい。

テキストの部分を保存しているリストは @dfn{kill リング} (@dfn{kill ring})
と呼ばれる。この章では少しずつ kill リングについて話していくことにする。
そのために、まず @code{zap-to-char} 関数がどのように働くかを見ることで、
kill リングの使い方を見ていきたいと思う。山の頂上を目指す前にまず手頃な丘
に登ってみるわけである。

実際にテキストがどのようにバッファから切り取られ、あるいは取り出されるの
かについては、次の章で説明する。@ref{Yanking, , Yanking Text Back}, 参照。

@node zap-to-char
@section @code{zap-to-char}
@findex zap-to-char

Let us look at the interactive @code{zap-to-char} function.

@menu
* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The @code{progn} special form.
* Summing up zap-to-char::      Using @code{point} and @code{search-forward}.
@end menu

@ifnottex
@node Complete zap-to-char
@unnumberedsubsec The Complete @code{zap-to-char} Implementation
@end ifnottex

インタラクティブ関数 @code{zap-to-char} は、
カーソルの位置 (つまりポイントの位置) から次に指定した文字が現れるまでの、
その文字も含めた領域のテキストを取り去る。@code{zap-to-char} によって取
り除かれたテキストは、kill リングに置かれる。これは @kbd{C-y}
(@code{yank}) とタイプすることで取り出すことが出来る。もし、このコマンド
が引数と共に呼び出されたなら、その回数だけ指定された文字が出てくるまでの
間のテキストを取り去る。従って、もしカーソルが次の文の先頭にあり、特定の
文字が `s' だったとすると、`Thus' が取り去られることになる。

Thus, if the cursor were at the beginning of this sentence and the
character were `s', `Thus' would be removed.

@noindent
(訳註：日本語の文章では @code{zap-to-char} は使えないので、止むなく英文
のままにした。)

またもし引数が2であれば、@samp{Thus, if the curs} が取り去られる。ここで
も最後の @samp{s} が含まれていることに注目しよう。

もし指定した文字が現れなかった場合には
単にエラーを返すだけである。(従って、テキストを取り除いたりもしない。)

どれだけのテキストを取り去るかを決定するために、どちらのバージョンの場合
でも検索関数を使っている。検索はもっぱらテキストを扱うコードの中で使われ
る。そして、削除コマンドだけでなく検索関数にも注目するのは意味のあること
である。

@ignore
@c GNU Emacs version 19
(defun zap-to-char (arg char)  ; version 19 implementation
  "Kill up to and including ARG'th occurrence of CHAR.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "*p\ncZap to char: ")
  (kill-region (point)
               (progn
                 (search-forward
                  (char-to-string char) nil nil arg)
                 (point))))
@end ignore

@need 1250
Here is the complete text of the version 22 implementation of the function:

@c GNU Emacs 22
@smallexample
@group
(defun zap-to-char (arg char)
  "Kill up to and including ARG'th occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "p\ncZap to char: ")
  (if (char-table-p translation-table-for-input)
      (setq char (or (aref translation-table-for-input char) char)))
  (kill-region (point) (progn
                         (search-forward (char-to-string char)
                                         nil nil arg)
                         (point))))
@end group
@end smallexample

The documentation is thorough.  You do need to know the jargon meaning
of the word `kill'.

@node zap-to-char interactive
@subsection @code{interactive} 式

@need 800
@code{zap-to-char} コマンド内のインタラクティブ式は、次の通りである。

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

（旧訳）引用符の中の部分は、@code{"p\ncZap to char:@: "} であり、二つのことを指
定している。一番目の部分は単なるアスタリスク @samp{*} で、バッファが
read-only だったら警告のためにエラーを出すためのものである。つまり、
read-only なバッファで @code{zap-to-char} を使おうとしてもテキストを取り
除くことは出来ず、代わりに ``buffer is read-only'' というメッセージを受
け取ることになることを意味する。端末によってはビープ音もなる。

（旧訳）@code{p\ncZap to char:@: "} の二番目の部分は @samp{p} である。この部分
は改行 @samp{\n} で終っている。@samp{p} はこの関数の最初の引数として、処
理された前置引数の値が渡されることを意味する。前置引数は @kbd{C-u} に続
いてある数を、もしくは @kbd{M-} に続いてある数をタイプすることで渡される。
もし、この関数が前置引数なしで呼び出された場合、1が引数として渡される。

（旧訳）@code{*p\ncZap to char:@: "} の三番目の部分は、@samp{cZap to char:@: }
である。この部分の最初の小文字の @samp{c} は @code{interactive} がプロン
プトを出して、文字の入力を要求することを指示するものである。プロンプトは
@samp{c} の後に続くもので、この場合は文字列 @samp{Zap to char:@: }
である。(コロンの後の空白は、単に見栄えをよくするためのものである。)

結局これがすることは、正しい型の @code{zap-to-char} の引数を用意し、ユー
ザーに対してプロンプトを出すということである。

（未訳）In a read-only buffer, the @code{zap-to-char} function copies the text
to the kill ring, but does not remove it.  The echo area displays a
message saying that the buffer is read-only.  Also, the terminal may
beep or blink at you.

@node zap-to-char body
@subsection @code{zap-to-char} の本体部分

@code{zap-to-char} 関数の本体部分は、現在のカーソルの位置から指定した文
字までの間の領域のテキストを削除するコードを含んでいる。

その最初の部分は次の通りである。

@smallexample
(if (char-table-p translation-table-for-input)
    (setq char (or (aref translation-table-for-input char) char)))
(kill-region (point) (progn
                       (search-forward (char-to-string char) nil nil arg)
                       (point)))
@end smallexample

@noindent
（未訳）@code{char-table-p} is an hitherto unseen function.  It determines
whether its argument is a character table.  When it is, it sets the
character passed to @code{zap-to-char} to one of them, if that
character exists, or to the character itself.  (This becomes important
for certain characters in non-European languages.  The @code{aref}
function extracts an element from an array.  It is an array-specific
function that is not described in this document.  @xref{Arrays, ,
Arrays, elisp, The GNU Emacs Lisp Reference Manual}.)

@noindent
@code{(point)} は現在のカーソルの位置である。

この後には、@code{progn} を使った式が続いている。@code{progn} の本体部分
では、@code{search-forward} と @code{point} を呼び出している。

まず @code{search-forward} を学んでからの方が @code{progn} の働きを理解
しやすいので、先にこちらを見て、次に @code{progn} について述べることにし
よう。

@node search-forward
@subsection 関数 @code{search-forward}
@findex search-forward

@code{search-forward} 関数は、@code{zap-to-char} の中で、削除する範囲の
端を定める文字 (以下 zapped-to-character と書く) の位置を定めるのに使わ
れている。もし検索が成功すると、@code{search-forward} は目的の文字列の最
後の文字のすぐ後にポイントを移動する。(今の場合、目的の文字列はちょうど
一文字である。) もし検索が後方に向かうものであれば、
@code{search-forward} は目的の文字列の最初の一文字のすぐ前にポイントを移
動する。また、@code{search-forward} 自身は値として @code{t} を返す。(従っ
て、ポイントの移動は副作用である。)

@need 1250
@code{zap-to-char} の中で @code{search-forward} は次のように使われている。

@smallexample
(search-forward (char-to-string char) nil nil arg)
@end smallexample

関数 @code{search-forward} は四つの引数を取る。

@enumerate
@item
最初の引数は、検索しようとするターゲットである。これは @samp{"z"} のよう
に文字列でなければならない。

今回の場合は、たまたま @code{zap-to-char} に渡される引数は単独の文字であ
る。計算機の設計上、Lisp インタプリタは単独の文字を一文字からなる文字列
とは区別して扱う。計算機の中では単独の文字は一文字からなる文字列とは別の
電気的なフォーマットを持っているのである。(単独の文字はたいてい計算機の
中で1バイトで記録されている。(訳註：勿論日本語とかでは事情は別である。)
しかし、文字列の方は長いものもあれば短いものもあるので、計算機の方でそれ
に備えなければならないのである。) @code{search-forward} は文字列を検索す
るものなので、@code{zap-to-char} 関数に引数として渡された文字を計算機の
内部で別のフォーマットに変換しないといけない。でないと、
@code{search-forward} は検索に失敗してしまう。この変換をするために、
@code{char-to-string} という関数が使われている。

@item
二番目は、検索の範囲を指定するためのものである。これはバッファ内の
位置として指定される。今の場合、検索はバッファの最後まで行うので、範囲を
制限したりはしない。従って、二番目の引数は @code{nil} である。

@item
三番目は、この関数に検索が失敗し場合にどうするか---警告してエラー
を表示するか、単に @code{nil} を返すか---を伝えるものである。 三番目の引
数として @code{nil} が指定されていると、検索に失敗した場合にはエラーを出
して警告する。

@item
@code{search-forward} の四番目の引数は、繰り返しの回数---つまり検索対象
の文字列が何回現れるのを調べるか---を指定するものである。この引数は省略
可能であり、もしこの引数なしで関数が呼び出された場合、この引数として1が
渡される。引数が負であれば、検索は後方に向かってなされる。
@end enumerate

@need 800
テンプレートで書くと、@code{search-forward} 式は次のようになる。

@smallexample
@group
(search-forward "@var{目的とする文字列}"
                @var{検索の範囲の限界}
                @var{検索に失敗した時の動作}
                @var{繰り返しの階数})
@end group
@end smallexample

次に @code{progn} を見ることにしよう。

@node progn
@subsection 関数 @code{progn}
@findex progn

@code{progn} は引数を各々順番に評価していき、最後の式の値を返すよう
な関数である。それ以前のＳ式はその副作用のためだけに評価され、これらが返
す値は無視される。

@code{progn} 式のテンプレートは極めて単純である。

@smallexample
@group
(progn
  @var{本体}@dots{})
@end group
@end smallexample

@code{zap-to-char} の中では、@code{progn} 式は二つのことを行う。まず、ポ
イントをちょうど正しい位置に置くこと。次に、ポイントの位置を返して、
@code{kill-region} がどこまでテキストを削除すればよいかを教えることである。

@code{progn} の最初の引数は @code{search-forward} である。
@code{search-forward} は検索する文字列を見つけた場合、その文字列
の最後の文字のすぐ後にポイントを移す。(今の場合、検索文字列は一文字
である。) ただし、もし検索が後方方向なら最初の一文字の直前の位置にポイン
トを移す。ポイントの移動は副作用である。

二番目の、そして最後の @code{progn} の引数は @code{(point)} である。この
Ｓ式はポイントの位置を返す。今の場合なら、これは @code{search-forward}
によって移動されたポイントの位置である。この値が @code{progn} 式の値とし
て返され、@code{kill-region} に @code{kill-region} の二番目の引数として
渡される。

@node Summing up zap-to-char
@subsection @code{zap-to-char} についての総括

さて、以上で @code{search-forward} と @code{progn} の働きを見てきた。こ
こで @code{zap-to-char} 全体がどのように動作するかを見ることにしよう。

@code{zap-to-char} コマンドが与えられた時の @code{kill-region} の最初の
引数はカーソルの位置---その時点でのポイントの値---である。また
@code{progn} の中で検索コマンドによってポイントが zapped-to-character の
すぐ後に移され、@code{point} によってその位置の値が返される。
@code{kill-region} 関数はこれら二つの値の最初の値をリージョンの始まりに、
二番目の値をリージョンの終わりに指定して、そのリージョンを削除する。

@code{progn} 関数が必要なのは、@code{kill-region} 関数の引数が二つである
からである。仮に @code{search-forward} 式と @code{point} 式が続けて二つ
の引数として書かれていたとしたら、うまく動作してはくれない。@code{progn}
は @code{kill-region} にとって一つの引数であり、@code{kill-region} が第
二引数として必要な一つの値を返すのである。

@node kill-region
@section @code{kill-region}
@findex kill-region

@code{zap-to-char} は @code{kill-region} 関数を使っている。
This function clips text from a region and copies that text to
the kill ring, from which it may be retrieved.

@ignore
GNU Emacs 22:

(defun kill-region (beg end &optional yank-handler)
  "Kill (\"cut\") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command \\[yank] can retrieve it from there.
\(If you want to kill and then yank immediately, use \\[kill-ring-save].)

If you want to append the killed region to the last killed text,
use \\[append-next-kill] before \\[kill-region].

If the buffer is read-only, Emacs will beep and refrain from deleting
the text, but put the text in the kill ring anyway.  This means that
you can use the killing commands to copy text from a read-only buffer.

This is the primitive for programs to kill text (as opposed to deleting it).
Supply two arguments, character positions indicating the stretch of text
 to be killed.
Any command that calls this function is a \"kill command\".
If the previous command was also a kill command,
the text killed this time appends to the text killed last time
to make one entry in the kill ring.

In Lisp code, optional third arg YANK-HANDLER, if non-nil,
specifies the yank-handler text property to be set on the killed
text.  See `insert-for-yank'."
  ;; Pass point first, then mark, because the order matters
  ;; when calling kill-append.
  (interactive (list (point) (mark)))
  (unless (and beg end)
    (error "The mark is not set now, so there is no region"))
  (condition-case nil
      (let ((string (filter-buffer-substring beg end t)))
        (when string                        ;STRING is nil if BEG = END
          ;; Add that string to the kill ring, one way or another.
          (if (eq last-command 'kill-region)
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
    ((buffer-read-only text-read-only)
     ;; The code above failed because the buffer, or some of the characters
     ;; in the region, are read-only.
     ;; We should beep, in case the user just isn't aware of this.
     ;; However, there's no harm in putting
     ;; the region's text in the kill ring, anyway.
     (copy-region-as-kill beg end)
     ;; Set this-command now, so it will be set even if we get an error.
     (setq this-command 'kill-region)
     ;; This should barf, if appropriate, and give us the correct error.
     (if kill-read-only-ok
         (progn (message "Read only text copied to kill ring") nil)
       ;; Signal an error if the buffer is read-only.
       (barf-if-buffer-read-only)
       ;; If the buffer isn't read-only, the text is.
       (signal 'text-read-only (list (current-buffer)))))))
@end ignore

（未訳）The Emacs 22 version of that function uses @code{condition-case} and
@code{copy-region-as-kill}, both of which we will explain.
@code{condition-case} is an important special form.

（未訳）In essence, the @code{kill-region} function calls
@code{condition-case}, which takes three arguments.  In this function,
the first argument does nothing.  The second argument contains the
code that does the work when all goes well.  The third argument
contains the code that is called in the event of an error.

@menu
* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* Lisp macro::
@end menu

@ifnottex
@node Complete kill-region
@unnumberedsubsec The Complete @code{kill-region} Definition
@end ifnottex

@need 1200
（未訳）We will go through the @code{condition-case} code in a moment.  First,
let us look at the definition of @code{kill-region}, with comments
added:

@c GNU Emacs 22:
@smallexample
@group
(defun kill-region (beg end)
  "Kill (\"cut\") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command \\[yank] can retrieve it from there. @dots{} "
@end group

@group
  ;; @bullet{} Since order matters, pass point first.
  (interactive (list (point) (mark)))
  ;; @bullet{} And tell us if we cannot cut the text.
  ;; `unless' is an `if' without a then-part.
  (unless (and beg end)
    (error "The mark is not set now, so there is no region"))
@end group

@group
  ;; @bullet{} `condition-case' takes three arguments.
  ;;    If the first argument is nil, as it is here,
  ;;    information about the error signal is not
  ;;    stored for use by another function.
  (condition-case nil
@end group

@group
      ;; @bullet{} The second argument to `condition-case' tells the
      ;;    Lisp interpreter what to do when all goes well.
@end group

@group
      ;;    It starts with a `let' function that extracts the string
      ;;    and tests whether it exists.  If so (that is what the
      ;;    `when' checks), it calls an `if' function that determines
      ;;    whether the previous command was another call to
      ;;    `kill-region'; if it was, then the new text is appended to
      ;;    the previous text; if not, then a different function,
      ;;    `kill-new', is called.
@end group

@group
      ;;    The `kill-append' function concatenates the new string and
      ;;    the old.  The `kill-new' function inserts text into a new
      ;;    item in the kill ring.
@end group

@group
      ;;    `when' is an `if' without an else-part.  The second `when'
      ;;    again checks whether the current string exists; in
      ;;    addition, it checks whether the previous command was
      ;;    another call to `kill-region'.  If one or the other
      ;;    condition is true, then it sets the current command to
      ;;    be `kill-region'.
@end group
@group
      (let ((string (filter-buffer-substring beg end t)))
        (when string                    ;STRING is nil if BEG = END
          ;; Add that string to the kill ring, one way or another.
          (if (eq last-command 'kill-region)
@end group
@group
              ;;    @minus{} `yank-handler' is an optional argument to
              ;;    `kill-region' that tells the `kill-append' and
              ;;    `kill-new' functions how deal with properties
              ;;    added to the text, such as `bold' or `italics'.
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
@end group

@group
    ;;  @bullet{} The third argument to `condition-case' tells the interpreter
    ;;    what to do with an error.
@end group
@group
    ;;    The third argument has a conditions part and a body part.
    ;;    If the conditions are met (in this case,
    ;;             if text or buffer are read-only)
    ;;    then the body is executed.
@end group
@group
    ;;    The first part of the third argument is the following:
    ((buffer-read-only text-read-only) ;; the if-part
     ;; @dots{}  the then-part
     (copy-region-as-kill beg end)
@end group
@group
     ;;    Next, also as part of the then-part, set this-command, so
     ;;    it will be set in an error
     (setq this-command 'kill-region)
     ;;    Finally, in the then-part, send a message if you may copy
     ;;    the text to the kill ring without signaling an error, but
     ;;    don't if you may not.
@end group
@group
     (if kill-read-only-ok
         (progn (message "Read only text copied to kill ring") nil)
       (barf-if-buffer-read-only)
       ;; If the buffer isn't read-only, the text is.
       (signal 'text-read-only (list (current-buffer)))))
@end group
@end smallexample

@ignore
@c v 21
@smallexample
@group
(defun kill-region (beg end)
  "Kill between point and mark.
The text is deleted but saved in the kill ring."
  (interactive "r")
@end group

@group
  ;; 1. `condition-case' takes three arguments.
  ;;    If the first argument is nil, as it is here,
  ;;    information about the error signal is not
  ;;    stored for use by another function.
  (condition-case nil
@end group

@group
      ;; 2. The second argument to `condition-case'
      ;;    tells the Lisp interpreter what to do when all goes well.
@end group

@group
      ;;    The `delete-and-extract-region' function usually does the
      ;;    work.  If the beginning and ending of the region are both
      ;;    the same, then the variable `string' will be empty, or nil
      (let ((string (delete-and-extract-region beg end)))
@end group

@group
        ;; `when' is an `if' clause that cannot take an `else-part'.
        ;; Emacs normally sets the value of `last-command' to the
        ;; previous command.
@end group
@group
        ;; `kill-append' concatenates the new string and the old.
        ;; `kill-new' inserts text into a new item in the kill ring.
        (when string
          (if (eq last-command 'kill-region)
              ;; if true, prepend string
              (kill-append string (< end beg))
            (kill-new string)))
        (setq this-command 'kill-region))
@end group

@group
    ;; 3. The third argument to `condition-case' tells the interpreter
    ;;    what to do with an error.
@end group
@group
    ;;    The third argument has a conditions part and a body part.
    ;;    If the conditions are met (in this case,
    ;;             if text or buffer are read-only)
    ;;    then the body is executed.
@end group
@group
    ((buffer-read-only text-read-only) ;; this is the if-part
     ;; then...
     (copy-region-as-kill beg end)
@end group
@group
     (if kill-read-only-ok            ;; usually this variable is nil
         (message "Read only text copied to kill ring")
       ;; or else, signal an error if the buffer is read-only;
       (barf-if-buffer-read-only)
       ;; and, in any case, signal that the text is read-only.
       (signal 'text-read-only (list (current-buffer)))))))
@end group
@end smallexample
@end ignore

@node condition-case
@subsection @code{condition-case}
@findex condition-case

As we have seen earlier (@pxref{Making Errors, , Generate an Error
Message}), when the Emacs Lisp interpreter has trouble evaluating an
expression, it provides you with help; in the jargon, this is called
``signaling an error''.  Usually, the computer stops the program and
shows you a message.

However, some programs undertake complicated actions.  They should not
simply stop on an error.  In the @code{kill-region} function, the most
likely error is that you will try to kill text that is read-only and
cannot be removed.  So the @code{kill-region} function contains code
to handle this circumstance.  This code, which makes up the body of
the @code{kill-region} function, is inside of a @code{condition-case}
special form.

@need 800
The template for @code{condition-case} looks like this:

@smallexample
@group
(condition-case
  @var{var}
  @var{bodyform}
  @var{error-handler}@dots{})
@end group
@end smallexample

The second argument, @var{bodyform}, is straightforward.  The
@code{condition-case} special form causes the Lisp interpreter to
evaluate the code in @var{bodyform}.  If no error occurs, the special
form returns the code's value and produces the side-effects, if any.

In short, the @var{bodyform} part of a @code{condition-case}
expression determines what should happen when everything works
correctly.

However, if an error occurs, among its other actions, the function
generating the error signal will define one or more error condition
names.

An error handler is the third argument to @code{condition case}.
An error handler has two parts, a @var{condition-name} and a
@var{body}.  If the @var{condition-name} part of an error handler
matches a condition name generated by an error, then the @var{body}
part of the error handler is run.

As you will expect, the @var{condition-name} part of an error handler
may be either a single condition name or a list of condition names.

Also, a complete @code{condition-case} expression may contain more
than one error handler.  When an error occurs, the first applicable
handler is run.

Lastly, the first argument to the @code{condition-case} expression,
the @var{var} argument, is sometimes bound to a variable that
contains information about the error.  However, if that argument is
nil, as is the case in @code{kill-region}, that information is
discarded.

@need 1200
In brief, in the @code{kill-region} function, the code
@code{condition-case} works like this:

@smallexample
@group
@var{If no errors}, @var{run only this code}
    @var{but}, @var{if errors}, @var{run this other code}.
@end group
@end smallexample

@ignore
2006 Oct 24
In Emacs 22,
copy-region-as-kill is short, 12 lines, and uses
filter-buffer-substring, which is longer, 39 lines
and has delete-and-extract-region in it.
delete-and-extract-region is written in C.

see Initializing a Variable with @code{defvar}
this is line 8054
Initializing a Variable with @code{defvar} includes line 8350
@end ignore

@node Lisp macro
@subsection Lisp macro
@cindex Macro, lisp
@cindex Lisp macro

The part of the @code{condition-case} expression that is evaluated in
the expectation that all goes well has a @code{when}.  The code uses
@code{when} to determine whether the @code{string} variable points to
text that exists.

A @code{when} expression is simply a programmers' convenience.  It is
an @code{if} without the possibility of an else clause.  In your mind,
you can replace @code{when} with @code{if} and understand what goes
on.  That is what the Lisp interpreter does.

Technically speaking, @code{when} is a Lisp macro.  A Lisp macro
enables you to define new control constructs and other language
features.  It tells the interpreter how to compute another Lisp
expression which will in turn compute the value.  In this case, the
`other expression' is an @code{if} expression.

The @code{kill-region} function definition also has an @code{unless}
macro; it is the converse of @code{when}.  The @code{unless} macro is
an @code{if} without a then clause

For more about Lisp macros, see @ref{Macros, , Macros, elisp, The GNU
Emacs Lisp Reference Manual}.  The C programming language also
provides macros.  These are different, but also useful.

@ignore
We will briefly look at C macros in
@ref{Digression into C}.
@end ignore

@need 1200
Regarding the @code{when} macro, in the @code{condition-case}
expression, when the string has content, then another conditional
expression is executed.  This is an @code{if} with both a then-part
and an else-part.

@smallexample
@group
(if (eq last-command 'kill-region)
    (kill-append string (< end beg) yank-handler)
  (kill-new string nil yank-handler))
@end group
@end smallexample

The then-part is evaluated if the previous command was another call to
@code{kill-region}; if not, the else-part is evaluated.

@code{yank-handler} is an optional argument to @code{kill-region} that
tells the @code{kill-append} and @code{kill-new} functions how deal
with properties added to the text, such as `bold' or `italics'.

@code{last-command} is a variable that comes with Emacs that we have
not seen before.  Normally, whenever a function is executed, Emacs
sets the value of @code{last-command} to the previous command.

@need 1200
In this segment of the definition, the @code{if} expression checks
whether the previous command was @code{kill-region}.  If it was,

@smallexample
(kill-append string (< end beg) yank-handler)
@end smallexample

@noindent
concatenates a copy of the newly clipped text to the just previously
clipped text in the kill ring.

@node copy-region-as-kill
@section @code{copy-region-as-kill}
@findex copy-region-as-kill
@findex nthcdr

The @code{copy-region-as-kill} function copies a region of text from a
buffer and (via either @code{kill-append} or @code{kill-new}) saves it
in the @code{kill-ring}.

（旧訳）@code{copy-region-as-kill} 関数はバッファからリージョンのテキストを複写
して、@code{kill-ring} と呼ばれる変数の中に保存する。

もし、@code{kill-region} コマンドを前回の @code{kill-region} コマンドの
直後に呼び出したとすると、Emacs は新しく複写したテキストを以前複写したテ
キストに付加 (append) する。これは、もしそのテキストをヤンクした場合、以
前複写した分と今回複写した分を合わせた全体を戻すことになるということを意
味する。一方、もし @code{copy-region-as-kill} に先立って他のコマンドを使
用した場合には、複写したテキストは kill リングの新しい別の部分に、それま
でに複写したものと区別されて保存される。

@menu
* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::      @code{copy-region-as-kill} の本体部分
@end menu

@ifnottex
@node Complete copy-region-as-kill
@unnumberedsubsec The complete @code{copy-region-as-kill} function definition
@end ifnottex

@need 1200
Here is the complete text of the version 22 @code{copy-region-as-kill}
function:

@smallexample
@group
(defun copy-region-as-kill (beg end)
  "Save the region as if killed, but don't kill it.
In Transient Mark mode, deactivate the mark.
If `interprogram-cut-function' is non-nil, also save the text for a window
system cut and paste."
  (interactive "r")
@end group
@group
  (if (eq last-command 'kill-region)
      (kill-append (filter-buffer-substring beg end) (< end beg))
    (kill-new (filter-buffer-substring beg end)))
@end group
@group
  (if transient-mark-mode
      (setq deactivate-mark t))
  nil)
@end group
@end smallexample

@need 800
これまで同様、この関数もまとまりのある幾つかの部分に分けることが出来る。

@smallexample
@group
(defun copy-region-as-kill (@var{argument-list})
  "@var{documentation}@dots{}"
  (interactive "r")
  @var{body}@dots{})
@end group
@end smallexample

The arguments are @code{beg} and @code{end} and the function is
interactive with @code{"r"}, so the two arguments must refer to the
beginning and end of the region.  If you have been reading through this
document from the beginning, understanding these parts of a function is
almost becoming routine.

（旧訳）引数は @code{beg} と @code{end} であり、@code{"r"} によってインタラクティ
ブ宣言がなされている。つまり、二つの引数は各々リージョンの始まりと終わり
を示すものである。もしこの文書をきちんと最初から読んできたなら、この部分
を理解するのは殆どルーティーンワークにすぎないだろう。

The documentation is somewhat confusing unless you remember that the
word `kill' has a meaning different from usual.  The `Transient Mark'
and @code{interprogram-cut-function} comments explain certain
side-effects.

After you once set a mark, a buffer always contains a region.  If you
wish, you can use Transient Mark mode to highlight the region
temporarily.  (No one wants to highlight the region all the time, so
Transient Mark mode highlights it only at appropriate times.  Many
people turn off Transient Mark mode, so the region is never
highlighted.)

Also, a windowing system allows you to copy, cut, and paste among
different programs.  In the X windowing system, for example, the
@code{interprogram-cut-function} function is @code{x-select-text},
which works with the windowing system's equivalent of the Emacs kill
ring.

The body of the @code{copy-region-as-kill} function starts with an
@code{if} clause.  What this clause does is distinguish between two
different situations: whether or not this command is executed
immediately after a previous @code{kill-region} command.  In the first
case, the new region is appended to the previously copied text.
Otherwise, it is inserted into the beginning of the kill ring as a
separate piece of text from the previous piece.

（旧訳）この関数の本体は、@code{if} 式で始まっている。この式でやっているのは二つ
の状況を区別することである。つまり、このコマンドが@code{kill-region} コ
マンドが呼び出された直後に実行されたかどうかの判断である。もし直後に実行
されたなら、新しく複写されるリージョンは以前複写された部分に付加される。
そうでない場合は、kill リングの先頭に、以前複写されたものとは区別されて
保存される。

The last two lines of the function prevent the region from lighting up
if Transient Mark mode is turned on.

（旧訳）この関数定義の最後の二行は、二つの @code{setq} 式である。一つは変数
@code{this-command} を @code{kill-region} に、もう一つは変数
@code{kill-ring-yank-pointer} を kill リングに設定する。


この @code{copy-region-as-kill} の本体部分は詳しく見る価値がある。

@node copy-region-as-kill body
@subsection @code{copy-region-as-kill} の本体部分

The @code{copy-region-as-kill} function works in much the same way as
the @code{kill-region} function.  Both are written so that two or more
kills in a row combine their text into a single entry.  If you yank
back the text from the kill ring, you get it all in one piece.
Moreover, kills that kill forward from the current position of the
cursor are added to the end of the previously copied text and commands
that copy text backwards add it to the beginning of the previously
copied text.  This way, the words in the text stay in the proper
order.

（旧訳）@code{copy-region-as-kill} 関数は、二行以上の kill を一つの項目につなげ
るように書かれている。もし、それらを kill リングからヤンクして取り出すと、
一箇所にまとめて取り出される。更に、現在のカーソルの位置から前方 (つまり
テキストの終わりの方) に向かって kill すると、その部分は以前 kill したテ
キストの後に付け加えられ、後方 (つまりテキストの始まりの方) に向かって
kill すると、以前 kill したテキストの前に付け加えられる。こうしてテキス
トの部分は正しい順序に保たれることになる。

Like @code{kill-region}, the @code{copy-region-as-kill} function makes
use of the @code{last-command} variable that keeps track of the
previous Emacs command.

（旧訳）この関数は、現在、及びその一つ前に Emacs が実行したコマンドを憶えておく
ために二つの変数 @code{this-command} と @code{last-command} を使っている。

@menu
* last-command & this-command::
* kill-append function::
* kill-new function::
@end menu

@ifnottex
@node last-command & this-command
@unnumberedsubsubsec @code{last-command} and @code{this-command}
@end ifnottex

Normally, whenever a function is executed, Emacs sets the value of
@code{this-command} to the function being executed (which in this case
would be @code{copy-region-as-kill}).  At the same time, Emacs sets
the value of @code{last-command} to the previous value of
@code{this-command}.

（旧訳）通常、Emacs はどんな関数を実行している場合でも @code{this-command} の値
を現在実行中のコマンドの値 (今の場合なら @code{copy-region-as-kill}) に
セットしている。しかしながら、@code{copy-region-as-kill} の場合は違う。
この関数は @code{this-command} の値を @code{kill-region} にセットする。
これは @code{copy-region-as-kill} を呼び出している関数の名前である。

In the first part of the body of the @code{copy-region-as-kill}
function, an @code{if} expression determines whether the value of
@code{last-command} is @code{kill-region}.  If so, the then-part of
the @code{if} expression is evaluated; it uses the @code{kill-append}
function to concatenate the text copied at this call to the function
with the text already in the first element (the @sc{car}) of the kill
ring.  On the other hand, if the value of @code{last-command} is not
@code{kill-region}, then the @code{copy-region-as-kill} function
attaches a new element to the kill ring using the @code{kill-new}
function.

（旧訳）@code{copy-region-as-kill} の本体部分の最初のパートでは、@code{if} 式で
@code{last-command} が @code{kill-region} かどうかを判定している。もしそ
うであれば、@code{kill-append} 関数を使って今回複写したテキストを kill
リングの最初の要素 (つまり @sc{car}) のテキストと結合する。一方、もしも
@code{last-command} の値が @code{kill-region} で無ければ
@code{copy-region-as-kill} 関数は kill リングに新しい要素を付け加えること
になる。


@need 1250
The @code{if} expression reads as follows; it uses @code{eq}:
@code{if} 式は次の通りである。これは @code{eq} を使っている。

@smallexample
@group
  (if (eq last-command 'kill-region)
      ;; @r{then-part}
      (kill-append  (filter-buffer-substring beg end) (< end beg))
    ;; @r{else-part}
    (kill-new  (filter-buffer-substring beg end)))
@end group
@end smallexample

@findex filter-buffer-substring
（未訳）(The @code{filter-buffer-substring} function returns a filtered
substring of the buffer, if any.  Optionally---the arguments are not
here, so neither is done---the function may delete the initial text or
return the text without its properties; this function is a replacement
for the older @code{buffer-substring} function, which came before text
properties were implemented.)

@findex eq @r{(example of use)}
@noindent
@code{eq} 関数は、最初の引数が二番目の引数と同じ Lisp オブジェクトかどう
かを判定するものである。@code{eq} 関数は @code{equal} 関数と、等しいかど
うかの判定をするという点では似ているが、異なる名前を持つものが、計算機の
内部で実際に同じオブジェクトかどうかを判定するのかそうでないか、という点
で異なっている。@code{eq} の方は同じオブジェクトの場合でないと真を返さな
いが、@code{equal} 関数の方は二つの式が同じ構造でありかつ同じ内容であり
さえすれば真を返す。

@noindent
(訳註：ここはちょっと分り難いかもしれない。詳しくは @ref{Equality
Predicates, , Equality Predicates, elisp, The GNU Emacs Lisp Reference
Manual}, を参照。なお、
@ref{List Implementation, , リストはどのように実装されているか}, も参考
になる。)

（未訳）If the previous command was @code{kill-region}, then the Emacs Lisp
interpreter calls the @code{kill-append} function

@node kill-append function
@unnumberedsubsubsec 関数 @code{kill-append}
@findex kill-append

@need 800
@code{kill-append} 関数は次のようなものである。

@c in GNU Emacs 22
@smallexample
@group
(defun kill-append (string before-p &optional yank-handler)
  "Append STRING to the end of the latest kill in the kill ring.
If BEFORE-P is non-nil, prepend STRING to the kill.
@dots{} "
  (let* ((cur (car kill-ring)))
    (kill-new (if before-p (concat string cur) (concat cur string))
              (or (= (length cur) 0)
                  (equal yank-handler
                         (get-text-property 0 'yank-handler cur)))
              yank-handler)))
@end group
@end smallexample

@ignore
was:
(defun kill-append (string before-p)
  "Append STRING to the end of the latest kill in the kill ring.
If BEFORE-P is non-nil, prepend STRING to the kill.
If `interprogram-cut-function' is set, pass the resulting kill to
it."
  (kill-new (if before-p
                (concat string (car kill-ring))
              (concat (car kill-ring) string))
            t))
@end ignore

@noindent
The @code{kill-append} function is fairly straightforward.  It uses
the @code{kill-new} function, which we will discuss in more detail in
a moment.

(Also, the function provides an optional argument called
@code{yank-handler}; when invoked, this argument tells the function
how to deal with properties added to the text, such as `bold' or
`italics'.)

@c !!! bug in GNU Emacs 22 version of  kill-append ?
It has a @code{let*} function to set the value of the first element of
the kill ring to @code{cur}.  (I do not know why the function does not
use @code{let} instead; only one value is set in the expression.
Perhaps this is a bug that produces no problems?)

Consider the conditional that is one of the two arguments to
@code{kill-new}.  It uses @code{concat} to concatenate the new text to
the @sc{car} of the kill ring.  Whether it prepends or appends the
text depends on the results of an @code{if} expression:

（旧訳）この関数をパートごとに見ていこう。@code{setcar} 関数は @code{concat} を
使って新しいテキストを kill リングの @sc{car} と結合している。新しい方の
テキストを前に持ってくるか、後に持ってくるかは @code{if} 式の結果による。

@smallexample
@group
(if before-p                            ; @r{if-part}
    (concat string cur)                 ; @r{then-part}
  (concat cur string))                  ; @r{else-part}
@end group
@end smallexample

@noindent
もし、今回切り取ったリージョンが直前のコマンドで切り取ったテキストよりも
前にあれば、今回切り取ったものは以前保存したものの前につなげるべきである
し、逆に、今回切り取ったテキストが以前切り取ったテキストの後に続くものな
ら、以前保存したものの後につなげるべきである。@code{if} 式は今回保存する
テキストを以前保存しておいたテキストの前につけるか後につけるかを
@code{before-p} という述語で判断している。

シンボル @code{before-p} は @code{kill-append} の引数の名前の一つである。
@code{kill-append} 関数が評価されると、これは実際の引数を評価して返され
た値にバインドされる。今の場合であれば、@code{(< end beg)} の値がバイン
ドされる。このＳ式は、今回のコマンドで切り取られたテキストが直前のコマン
ドで切り取られたテキストの前に属しているか、それとも後に属しているかを、
直接判定しているわけではない。この式がやっているのは変数 @code{end} の値
が変数 @code{beg} の値よりも小さいかどうかの判定だけである。もし小さけれ
ば、それはユーザがおそらくはバッファの先頭に向かっているということを意味
する。というわけで、この場合は以前のテキストの前に今回のテキストを追加す
るようになっている。一方、もし @code{end} の値の方が @code{beg} の値より
も大きかった場合、今回のテキストは以前のテキストの後尾に追加される。

@need 800
新しく保存したテキストが以前保存したテキストの前に追加される場合は、その
新しいテキストを前にして古いテキストと結合される。

@smallexample
(concat string cur)
@end smallexample

@need 1200
@noindent
逆に、テキストが後に追加される場合は、新しいテキストを古いテキストの後に
して結合する。

@smallexample
(concat cur string))
@end smallexample

この関数の動作を理解するためには、@code{concat} 関数の復習から始めなけれ
ばならないだろう。@code{concat} 関数は二つのテキスト文字列を一つにつ
なげるものである。結果も文字列になる。例えば次のような感じである。

@smallexample
@group
(concat "abc" "def")
     @result{} "abcdef"
@end group

@group
(concat "new "
        (car '("first element" "second element")))
     @result{} "new first element"

(concat (car
        '("first element" "second element")) " modified")
     @result{} "first element modified"
@end group
@end smallexample

以上で @code{kill-append} 関数が理解出来るようになる。これは、kill リング
の中身を修正するものである。kill リングはリストであり、各々の要素は保存さ
れたテキストである。 @code{kill-append} 関数は @code{kill-new} 関数を使い、
この関数は @code{setcar} 関数を使う。

@node kill-new function
@unnumberedsubsubsec The @code{kill-new} 関数
@findex kill-new

@c in GNU Emacs 22, additional documentation to kill-new:
@ignore
（無視）Optional third arguments YANK-HANDLER controls how the STRING is later
inserted into a buffer; see `insert-for-yank' for details.
When a yank handler is specified, STRING must be non-empty (the yank
handler, if non-nil, is stored as a `yank-handler' text property on STRING).

When the yank handler has a non-nil PARAM element, the original STRING
argument is not used by `insert-for-yank'.  However, since Lisp code
may access and use elements from the kill ring directly, the STRING
argument should still be a \"useful\" string for such uses."
@end ignore

@need 1200
（未訳）The @code{kill-new} function looks like this:

@smallexample
@group
(defun kill-new (string &optional replace yank-handler)
  "Make STRING the latest kill in the kill ring.
Set `kill-ring-yank-pointer' to point to it.

If `interprogram-cut-function' is non-nil, apply it to STRING.
Optional second argument REPLACE non-nil means that STRING will replace
the front of the kill ring, rather than being added to the list.
@dots{}"
@end group
@group
  (if (> (length string) 0)
      (if yank-handler
          (put-text-property 0 (length string)
                             'yank-handler yank-handler string))
    (if yank-handler
        (signal 'args-out-of-range
                (list string "yank-handler specified for empty string"))))
@end group
@group
  (if (fboundp 'menu-bar-update-yank-menu)
      (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@group
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (push string kill-ring)
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample
@ignore
（無視）was:
(defun kill-new (string &optional replace)
  "Make STRING the latest kill in the kill ring.
Set the kill-ring-yank pointer to point to it.
If `interprogram-cut-function' is non-nil, apply it to STRING.
Optional second argument REPLACE non-nil means that STRING will replace
the front of the kill ring, rather than being added to the list."
  (and (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (setq kill-ring (cons string kill-ring))
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end ignore

(Notice that the function is not interactive.)

As usual, we can look at this function in parts.

The function definition has an optional @code{yank-handler} argument,
which when invoked tells the function how to deal with properties
added to the text, such as `bold' or `italics'.  We will skip that.

@need 1200
（未訳）The first line of the documentation makes sense:

@smallexample
Make STRING the latest kill in the kill ring.
@end smallexample

@noindent
Let's skip over the rest of the documentation for the moment.

@noindent
Also, let's skip over the initial @code{if} expression and those lines
of code involving @code{menu-bar-update-yank-menu}.  We will explain
them below.

@need 1200
The critical lines are these:

@smallexample
@group
  (if (and replace kill-ring)
      ;; @r{then}
      (setcar kill-ring string)
@end group
@group
    ;; @r{else}
  (push string kill-ring)
@end group
@group
    (setq kill-ring (cons string kill-ring))
    (if (> (length kill-ring) kill-ring-max)
        ;; @r{avoid overly long kill ring}
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

The conditional test is @w{@code{(and replace kill-ring)}}.
This will be true when two conditions are met:  the kill ring has
something in it, and the @code{replace} variable is true.

@need 1250
When the @code{kill-append} function sets @code{replace} to be true
and when the kill ring has at least one item in it, the @code{setcar}
expression is executed:

@smallexample
(setcar kill-ring string)
@end smallexample

The @code{setcar} function actually changes the first element of the
@code{kill-ring} list to the value of @code{string}.  It replaces the
first element.

@need 1250
On the other hand, if the kill ring is empty, or replace is false, the
else-part of the condition is executed:

@smallexample
(push string kill-ring)
@end smallexample

@noindent
@need 1250
@code{push} puts its first argument onto the second.  It is similar to
the older

@smallexample
(setq kill-ring (cons string kill-ring))
@end smallexample

@noindent
@need 1250
or the newer

@smallexample
(add-to-list kill-ring string)
@end smallexample

@noindent
When it is false, the expression first constructs a new version of the
kill ring by prepending @code{string} to the existing kill ring as a
new element (that is what the @code{push} does).  Then it executes a
second @code{if} clause.  This second @code{if} clause keeps the kill
ring from growing too long.

Let's look at these two expressions in order.

The @code{push} line of the else-part sets the new value of the kill
ring to what results from adding the string being killed to the old
kill ring.

We can see how this works with an example.

@need 800
First,

@smallexample
(setq example-list '("here is a clause" "another clause"))
@end smallexample

@need 1200
@noindent
After evaluating this expression with @kbd{C-x C-e}, you can evaluate
@code{example-list} and see what it returns:

@smallexample
@group
example-list
     @result{} ("here is a clause" "another clause")
@end group
@end smallexample

@need 1200
@noindent
Now, we can add a new element on to this list by evaluating the
following expression:
@findex push, @r{example}

@smallexample
(push "a third clause" example-list)
@end smallexample

@need 800
@noindent
When we evaluate @code{example-list}, we find its value is:

@smallexample
@group
example-list
     @result{} ("a third clause" "here is a clause" "another clause")
@end group
@end smallexample

@noindent
Thus, the third clause is added to the list by @code{push}.

@need 1200
Now for the second part of the @code{if} clause.  This expression
keeps the kill ring from growing too long.  It looks like this:

@smallexample
@group
(if (> (length kill-ring) kill-ring-max)
    (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
@end group
@end smallexample

The code checks whether the length of the kill ring is greater than
the maximum permitted length.  This is the value of
@code{kill-ring-max} (which is 60, by default).  If the length of the
kill ring is too long, then this code sets the last element of the
kill ring to @code{nil}.  It does this by using two functions,
@code{nthcdr} and @code{setcdr}.

We looked at @code{setcdr} earlier (@pxref{setcdr, , @code{setcdr}}).
It sets the @sc{cdr} of a list, just as @code{setcar} sets the
@sc{car} of a list.  In this case, however, @code{setcdr} will not be
setting the @sc{cdr} of the whole kill ring; the @code{nthcdr}
function is used to cause it to set the @sc{cdr} of the next to last
element of the kill ring---this means that since the @sc{cdr} of the
next to last element is the last element of the kill ring, it will set
the last element of the kill ring.

@findex nthcdr, @r{example}
The @code{nthcdr} function works by repeatedly taking the @sc{cdr} of a
list---it takes the @sc{cdr} of the @sc{cdr} of the @sc{cdr}
@dots{}  It does this @var{N} times and returns the results.
(@xref{nthcdr, , @code{nthcdr}}.)

@findex setcdr, @r{example}
Thus, if we had a four element list that was supposed to be three
elements long, we could set the @sc{cdr} of the next to last element
to @code{nil}, and thereby shorten the list.  (If you set the last
element to some other value than @code{nil}, which you could do, then
you would not have shortened the list.  @xref{setcdr, ,
@code{setcdr}}.)

You can see shortening by evaluating the following three expressions
in turn.  First set the value of @code{trees} to @code{(maple oak pine
birch)}, then set the @sc{cdr} of its second @sc{cdr} to @code{nil}
and then find the value of @code{trees}:

@smallexample
@group
(setq trees '(maple oak pine birch))
     @result{} (maple oak pine birch)
@end group

@group
(setcdr (nthcdr 2 trees) nil)
     @result{} nil

trees
     @result{} (maple oak pine)
@end group
@end smallexample

@noindent
(The value returned by the @code{setcdr} expression is @code{nil} since
that is what the @sc{cdr} is set to.)

To repeat, in @code{kill-new}, the @code{nthcdr} function takes the
@sc{cdr} a number of times that is one less than the maximum permitted
size of the kill ring and @code{setcdr} sets the @sc{cdr} of that
element (which will be the rest of the elements in the kill ring) to
@code{nil}.  This prevents the kill ring from growing too long.

@need 800
The next to last expression in the @code{kill-new} function is

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

The @code{kill-ring-yank-pointer} is a global variable that is set to be
the @code{kill-ring}.

Even though the @code{kill-ring-yank-pointer} is called a
@samp{pointer}, it is a variable just like the kill ring.  However, the
name has been chosen to help humans understand how the variable is used.

@need 1200
Now, to return to an early expression in the body of the function:

@smallexample
@group
  (if (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@end smallexample

@noindent
It starts with an @code{if} expression

In this case, the expression tests first to see whether
@code{menu-bar-update-yank-menu} exists as a function, and if so,
calls it.  The @code{fboundp} function returns true if the symbol it
is testing has a function definition that `is not void'.  If the
symbol's function definition were void, we would receive an error
message, as we did when we created errors intentionally (@pxref{Making
Errors, , Generate an Error Message}).

@noindent
The then-part contains an expression whose first element is the
function @code{and}.

@findex and
The @code{and} special form evaluates each of its arguments until one
of the arguments returns a value of @code{nil}, in which case the
@code{and} expression returns @code{nil}; however, if none of the
arguments returns a value of @code{nil}, the value resulting from
evaluating the last argument is returned.  (Since such a value is not
@code{nil}, it is considered true in Emacs Lisp.)  In other words, an
@code{and} expression returns a true value only if all its arguments
are true.  (@xref{Second Buffer Related Review}.)

The expression determines whether the second argument to
@code{menu-bar-update-yank-menu} is true or not.
@ignore
    ;; If we're supposed to be extending an existing string, and that
    ;; string really is at the front of the menu, then update it in place.
@end ignore

@code{menu-bar-update-yank-menu} is one of the functions that make it
possible to use the `Select and Paste' menu in the Edit item of a menu
bar; using a mouse, you can look at the various pieces of text you
have saved and select one piece to paste.

The last expression in the @code{kill-new} function adds the newly
copied string to whatever facility exists for copying and pasting
among different programs running in a windowing system.  In the X
Windowing system, for example, the @code{x-select-text} function takes
the string and stores it in memory operated by X@.  You can paste the
string in another program, such as an Xterm.

@need 1200
The expression looks like this:

@smallexample
@group
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

If an @code{interprogram-cut-function} exists, then Emacs executes
@code{funcall}, which in turn calls its first argument as a function
and passes the remaining arguments to it.  (Incidentally, as far as I
can see, this @code{if} expression could be replaced by an @code{and}
expression similar to the one in the first part of the function.)

We are not going to discuss windowing systems and other programs
further, but merely note that this is a mechanism that enables GNU
Emacs to work easily and well with other programs.

This code for placing text in the kill ring, either concatenated with
an existing element or as a new element, leads us to the code for
bringing back text that has been cut out of the buffer---the yank
commands.  However, before discussing the yank commands, it is better
to learn how lists are implemented in a computer.  This will make
clear such mysteries as the use of the term `pointer'.  But before
that, we will digress into C.

（旧訳）この辺りの話をするにはやはり、バッファから切り取ったテキストを取り戻すた
めのコマンド---ヤンクコマンドについて話さなければなるまい。が、その話をす
る前に、リストが計算機の内部でどのように扱われるかを説明しておいた方が良
いだろう。そうすることで、「ポインタ」といったミステリアスな言葉を明確に
理解出来るようになるだろう。

@ignore
@c is this true in Emacs 22?   Does not seems to be

  (If the @w{@code{(< end beg))}}
expression is true, @code{kill-append} prepends the string to the just
previously clipped text.  For a detailed discussion, see
@ref{kill-append function, , The @code{kill-append} function}.)

If you then yank back the text, i.e., `paste' it, you get both
pieces of text at once.  That way, if you delete two words in a row,
and then yank them back, you get both words, in their proper order,
with one yank.  (The @w{@code{(< end beg))}} expression makes sure the
order is correct.)

On the other hand, if the previous command is not @code{kill-region},
then the @code{kill-new} function is called, which adds the text to
the kill ring as the latest item, and sets the
@code{kill-ring-yank-pointer} variable to point to it.
@end ignore
@ignore

@c Evidently, changed for Emacs 22. The zap-to-char command does not
@c use the delete-and-extract-region function

2006 Oct 26, the Digression into C is now OK but should come after
copy-region-as-kill and filter-buffer-substring

2006 Oct 24
In Emacs 22,
copy-region-as-kill is short, 12 lines, and uses
filter-buffer-substring, which is longer, 39 lines
and has delete-and-extract-region in it.
delete-and-extract-region is written in C.

see Initializing a Variable with @code{defvar}
@end ignore

@node Digression into C
@section @code{delete-region}: ちょっと脱線して C の話を
@findex delete-region
@cindex C, a digression into
@cindex Digression into C

@code{copy-region-as-kill} 関数 (@pxref{copy-region-as-kill, ,
@code{copy-region-as-kill}}) は @code{filter-buffer-substring} 関数を使っている。そし
て、これはこれでまた別の関数 @code{delete-and-extract-region} 
を利用している。It removes the contents of a region and you cannot get them
back.

これまでに議論してきたコードとは異なり、@code{delete-and-extract-region} は Emacs
Lisp では書かれていない。これは C で書かれており、GNU Emacs system のプ
リミティブの一つである。これは大変単純なものなので、ちょっとの間 Lisp か
ら脱線して、これについて説明することにしよう。

@c GNU Emacs 24  in src/editfns.c
@c the DEFUN for  delete-and-extract-region

@c 以下の部分はあまりよく分らずに訳しているので、間違いがある可能性が大
@c きいです。「インスタンス」は instance なのだが、これは単に「例」の意
@c 味で使っているのかもしれない。原文は以下の通り
@c Like many of the other Emacs primitives, @code{delete-region} is written
@c as an instance of a C macro, a macro being a template for code.  The
@c first section of the macro looks like this:

@need 1500
他の多くの Emacs のプリミティブと同様、@code{delete-region-extract-region} も C のマク
ロのインスタンス、つまりコードのテンプレートとしてのマクロとして書かれて
いる。このマクロの最初の部分は次のようである。

@smallexample
@group
DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
       Sdelete_and_extract_region, 2, 2, 0,
       doc: /* Delete the text between START and END and return it.  */)
       (Lisp_Object start, Lisp_Object end)
@{
  validate_region (&start, &end);
  if (XINT (start) == XINT (end))
    return empty_unibyte_string;
  return del_range_1 (XINT (start), XINT (end), 1, 1);
@}
@end group
@end smallexample

マクロの記述の細かい点に立ち入ることはしないが、このマクロが
@code{DEFUN} という単語から始まっていることを指摘しておく。ここで
@code{DEFUN} という単語を選んだのは、このコードが Lisp における
@code{defun} と同じ目的を持っているためである。単語 @code{DEFUN} の後に
続く括弧の中に7つの部分がある。

@itemize @bullet
@item
最初の部分は、この関数に Lisp の中で与えられる関数の名前である。この場合
は @code{delete-region} である。

@item
二番目は、この関数の C での名前 @code{Fdelete_region} である。便宜上、
@samp{F} から始まっている。C では名前にハイフンを使わないので、代わりに
下線 (underscore) が使われている。

@item
三番目は、内部でこの関数の情報を記録しておくための C の constant な
構造体の名前である。これは、C での関数名であるが、@samp{F} ではなく
@samp{S} で始まっている。

@item
四番目と五番目は、この関数が引数として取れる最小の数と最大の数を指定して
いる。今の場合はちょうど2つの引数を取る。

@item
六番目は Lisp の関数定義のインタラクティブ宣言に続く引数と同じようなもの
である。文字と、大抵はそれに続くプロンプトが書かれる。今の場合、その文字
は @code{"r"} である。これは、この関数の引数がそのバッファのリージョンの
最初と最後の位置であることを示している。この場合はプロンプトはない。

@item
七番目は、説明文字列である。これも Emacs Lisp の関数
定義の場合とほぼ同じであるが、全ての改行が明示的に @samp{\n} に続いてバッ
クスラッシュと復帰コードを書くことで示されている。
@end itemize

次に形式的なそのオブジェクトの種類の宣言と一緒にパラメータが来て、そして、
このマクロの本体部分と呼ばれる部分が来る。@code{delete-region} の場合は、
本体は次の三行からなる。

@smallexample
@group
validate_region (&start, &end);
if (XINT (start) == XINT (end))
  return empty_unibyte_string;
return del_range_1 (XINT (start), XINT (end), 1, 1);
@end group
@end smallexample

最初の関数 @code{validate_region} は、リージョンの始まりと終わりとして渡
された値が正しい型で、適切な範囲かどうかをチェックしている。二番目の関数、
@code{del_range} は、実際にテキストを削除する関数である。もしこの関数が
エラーを起こさず仕事を終えたら、三行目がそのことを示すために @code{Qnil}
を返す。

@code{del_range} は複雑な関数なので、立ち入らないことにする。これはバッ
ファを更新するなどの働きをする。しかしながら、@code{del_range} に渡され
る二つの引数には注目しておいた方がいいだろう。@w{@code{XINT(b)}} と
@w{@code{XINT(e)}} の二つである。

C 言語として見る限り、@code{b} と
@code{e} は削除するリージョンの始まりと終わりを表わす二つの整
数である。
@footnote{More precisely, and requiring more expert knowledge
to understand, the two integers are of type `Lisp_Object', which can
also be a C union instead of an integer type.}.

（旧訳）しかしながら、他の Emacs Lisp の数と同様、本来の数として使用さ
れるのは32ビット中の最初の24ビットだけである。残りの8ビットは情報の種類
を保持したりするなど、他の目的のために使われる。(ある種の機械では、最初
のほんの6ビットしか使わなかったりもする。) 今の場合は、この8ビットはこれ
らの数がバッファ内での位置を表すためのものであることを示すために用いられ
る。このような目的のために使われる数は、@dfn{tag} と呼ばれる。このように
32ビット整数の中に8ビットのタグを埋め込むことで、そうしないよりも Emacs
がずっと速く動作するようにすることが出来る。一方で、数を24ビットに制限し
てしまうために、Emacs のバッファは約8メガバイトに制限されてしまう。(バッ
ファの最大サイズは、コンパイルする前に @file{emacs/src/config.h} の中で
@code{VALBITS} と @code{GCTYPEBITS} を定義することでぐっと増やすことが出
来る。Emacs の配布に含まれる @file{emacs/etc/FAQ} を参照のこと。)

（未訳）In early versions of Emacs, these two numbers were thirty-two bits
long, but the code is slowly being generalized to handle other
lengths.  Three of the available bits are used to specify the type of
information; the remaining bits are used as `content'.

@samp{XINT} is a C macro that extracts the relevant number from the
longer collection of bits; the three other bits are discarded.

（旧訳）@samp{XINT} は、32ビットの Lisp オブジェクトから 24ビットの数を取り出す
C のマクロである。他の目的に使われる8ビットの部分は破棄される。

@need 800
The command in @code{delete-and-extract-region} looks like this:

@smallexample
del_range_1 (XINT (start), XINT (end), 1, 1);
@end smallexample

@noindent
これは、開始位置 @code{b} か
ら 終了位置 @code{e} までの間を消去することになる。

Lisp を書く人の立場か
ら見れば、Emacs はおしなべて大変単純な構造をしている。しかし、そのような
動作をさせるために、裏では極めて複雑な処理をやっているというわけである。

@node defvar
@section @code{defvar} を用いた変数の初期化
@findex defvar
@cindex Initializing a variable
@cindex Variable initialization

@ignore
2006 Oct 24
In Emacs 22,
copy-region-as-kill is short, 12 lines, and uses
filter-buffer-substring, which is longer, 39 lines
and has delete-and-extract-region in it.
delete-and-extract-region is written in C.

see Initializing a Variable with @code{defvar}

@end ignore

（旧訳）@code{delete-region} 関数と違って、@code{copy-region-as-kill} 関数は
Emacs Lisp で書かれている。これはバッファのリージョンを複写して
@code{kill-ring} と呼ばれる変数に保存するものである。このセクションでは
この変数がどのようにして生成され初期化されるのかを説明する。

(ここでも、@code{kill-ring} という言葉は誤用と言えるだろう。バッファから
切り取られたテキストは取り戻すことが出来るのである。これは、死体の輪なんか
ではなく、復活出来るテキストの輪なのだ。)

Emacs Lisp では、@code{kill-ring} のような変数は @code{defvar} という特
殊形式によって生成され、初期値を与えられる。この名前は ``define
variable'' から来ている。

@code{defvar} という特殊形式は、変数に値を設定する点で @code{setq}
と似ている。@code{setq} と違う点は二つある。一つ目は、その変数がまだ値を
持っていない場合にのみ値を設定するということである。既に値がある場合には、
@code{defvar} はその値を上書きしたりはしない。二つ目は @code{defvar} に
は説明文字列があるということである。

（未訳）(There is a related macro, @code{defcustom}, designed for variables
that people customize.  It has more features than @code{defvar}.
(@xref{defcustom, , Setting Variables with @code{defcustom}}.)

@menu
* See variable current value::
* defvar and asterisk::
@end menu

@ifnottex
@node See variable current value
@unnumberedsubsec Seeing the Current Value of a Variable
@end ifnottex

現在の変数の値は、どんな値であれ、@code{describe-variable} 関数を使って
見ることが出来る。これは普通は @kbd{C-h v} をタイプすることで呼び出せる。
@kbd{C-h v} とタイプして、プロンプトが出た所で @code{kill-ring} (と改行)
を入力すると、現在の kill リングの中身がどうなっているか見ることが出来る。
これは、滅茶苦茶多いこともある！ 逆に、もし今回 Emacs を起動してからこの
文書を読むだけで他には何もしていなければ、中には何もないはずだ。
また、@file{*Help*} バッファの最後に @code{kill-ring} の説明がなされてい
ることも見てとれる。

@smallexample
@group
Documentation:
List of killed text sequences.
Since the kill ring is supposed to interact nicely with cut-and-paste
facilities offered by window systems, use of this variable should
@end group
@group
interact nicely with `interprogram-cut-function' and
`interprogram-paste-function'.  The functions `kill-new',
`kill-append', and `current-kill' are supposed to implement this
interaction; you may want to use them instead of manipulating the kill
ring directly.
@end group
@end smallexample

@need 800
この kill リングは @code{defvar} を使って次のように定義されている。

@smallexample
@group
(defvar kill-ring nil
  "List of killed text sequences.
@dots{}")
@end group
@end smallexample

@noindent
この変数定義の中では、この変数は初期値 @code{nil} を与えられている。これ
はもっともなことである。何もセーブしないうちから、ヤンク (yank) コマンド
で何かを取り出したいとは思わないだろう。説明文字列は @code{defun} の
説明文字列と同じように書かれている。
@code{defun} のものと同様、最初の行はそれだけで完全な文になっているべき
だ。何故なら @code{apropos} のような幾つかのコマンドは、最初の一行しか
表示しないからである。また、その後に続く行はインデントすべきではない。そ
うしないと @code{C-h v} (@code{describe-variable}) を使って見た場合に見
栄えがよくない。

@node defvar and asterisk
@subsection @code{defvar} and an asterisk
@findex defvar @r{for a user customizable variable}
@findex defvar @r{with an asterisk}

In the past, Emacs used the @code{defvar} special form both for
internal variables that you would not expect a user to change and for
variables that you do expect a user to change.  Although you can still
use @code{defvar} for user customizable variables, please use
@code{defcustom} instead, since it provides a path into
the Customization commands.  (@xref{defcustom, , Specifying Variables
using @code{defcustom}}.)

When you specified a variable using the @code{defvar} special form,
you could distinguish a variable that a user might want to change from
others by typing an asterisk, @samp{*}, in the first column of its
documentation string.  For example:

@smallexample
@group
(defvar shell-command-default-error-buffer nil
  "*Buffer name for `shell-command' @dots{} error output.
@dots{} ")
@end group
@end smallexample

@findex set-variable
@noindent
You could (and still can) use the @code{set-variable} command to
change the value of @code{shell-command-default-error-buffer}
temporarily.  However, options set using @code{set-variable} are set
only for the duration of your editing session.  The new values are not
saved between sessions.  Each time Emacs starts, it reads the original
value, unless you change the value within your @file{.emacs} file,
either by setting it manually or by using @code{customize}.
@xref{Emacs Initialization, , Your @file{.emacs} File}.

For me, the major use of the @code{set-variable} command is to suggest
variables that I might want to set in my @file{.emacs} file.  There
are now more than 700 such variables, far too many to remember
readily.  Fortunately, you can press @key{TAB} after calling the
@code{M-x set-variable} command to see the list of variables.
(@xref{Examining, , Examining and Setting Variables, emacs,
The GNU Emacs Manual}.)

@need 1250
@node cons & search-fwd Review
@section 復習

この辺りで導入した関数についての簡単なまとめを載せておく。

@table @code
@item car
@itemx cdr
@code{car} はリストの最初の要素を返す。@code{cdr} はリストの二番目以降の
要素からなるリストを返す。

@need 1250
例）

@smallexample
@group
(car '(1 2 3 4 5 6 7))
     @result{} 1
(cdr '(1 2 3 4 5 6 7))
     @result{} (2 3 4 5 6 7)
@end group
@end smallexample

@item cons
@code{cons} は最初の引数を二番目の引数の前に加えることで新たなリストを作
成する。

@need 1250
例）

@smallexample
@group
(cons 1 '(2 3 4))
     @result{} (1 2 3 4)
@end group
@end smallexample

@item funcall
@code{funcall} evaluates its first argument as a function.  It passes
its remaining arguments to its first argument.

@item nthcdr
リストに対して `n' 回 @code{cdr} を取った結果を返す。
@iftex
The
@tex
$n^{th}$
@end tex
@code{cdr}.
@end iftex
言わば `残り' の
`残り' である。

@need 1250
例）

@smallexample
@group
(nthcdr 3 '(1 2 3 4 5 6 7))
     @result{} (4 5 6 7)
@end group
@end smallexample

@item setcar
@itemx setcdr
@code{setcar} はリストの最初の要素を置き換える。@code{setcdr} はリストの
二番目以降の要素を置き換える。

@need 1250
例）

@smallexample
@group
(setq triple '(1 2 3))

(setcar triple '37)

triple
     @result{} (37 2 3)

(setcdr triple '("foo" "bar"))

triple
     @result{} (37 "foo" "bar")
@end group
@end smallexample

@item progn
引数を順に評価していき、最後の値を返す。

@need 1250
例）

@smallexample
@group
(progn 1 2 3 4)
     @result{} 4
@end group
@end smallexample

@item save-restriction
カレントバッファのナローイングの情報をどんな状態であれ保存し、引数を評価
し終った後、その状態を復元する。

@item search-forward
文字列を検索し、もし文字列が見つかれば、そこにポイントを移動する。
With a
regular expression, use the similar @code{re-search-forward}.
(@xref{Regexp Search, , Regular Expression Searches}, for an
explanation of regular expression patterns and searches.)

@need 1250
@noindent
引数は次の四つ

@enumerate
@item
検索文字列。

@item
(省略可能) 検索範囲。

@item
(省略可能) 検索に失敗した時に @code{nil} を返すかエラーメッセージを出すか
を指定。

@item
(省略可能) 検索を何回実行するかを指定。負数の場合は後方検索になる。
@end enumerate

@item kill-region
@item delete-region
@item copy-region-as-kill

@code{kill-region} はバッファのポイントとマークの間のテキストを切り取って
それを kill リングに保存する。このテキストはヤンクによって取り出すことが
出来る。

@code{copy-region-as-kill} はポイントとマークの間のテキストを kill リング
に複写する。これはヤンクによって取り出すことが出来る。この関数はバッファ
からテキストを切り取ったり削除したりはしない。

@code{delete-and-extract-region} はポイントとマークの間のテキストをバッファから削除
して捨ててしまう。復活させることは出来ない。
(This is not an interactive command.)

@end table

@need 1500
@node search Exercises
@section 検索についての練習問題

@itemize @bullet
@item
文字列を検索するインタラクティブな関数を書きなさい。もし文字列の
検索に成功すればその直後にポイントを移動し、「見つけた！」というメッセー
ジを表示するようにしなさい。(この関数の名前に @code{search-forward} とい
う名前を使ってはいけない。そうしてしまうと、元の Emacs で定義された現在
の @code{search-forward} を上書きしてしまう。例えば @code{test-search}
という名前を使いなさい。

@item
現在の kill リングの三番目の内容をエコー領域に表示するような関数を書きな
さい。その際、もし kill リングに三番目の要素が無い場合にも適切なメッセー
ジを表示するようにしなさい。

@end itemize

@node List Implementation
@chapter リストはどのように実装されているか
@cindex Lists in a computer

Lisp では、アトムは直接的な方法で記録される。たとえ現実の実装方法が直接
的ではなかったとしても、理論上は直接的である。例えば @samp{rose} という
アトムは四つの隣接する文字 @samp{r}, @samp{o}, @samp{s}, @samp{e} として
記録される。一方、リストはもっと異なる方法で記録される。メカニズムとして
は同じくらい単純なのだが、そのアイディアに慣れるのにはちょっと時間がかか
るかもしれない。リストは、ポインタのペアの列として記録される。この列の中
で、各々のペアの一番目のポインタは、あるアトムか、もしくは他のリストを指
している。そして、二番目のポインタは次のペアか、シンボル @code{nil} を指
している。@code{nil} の場合はリストの終わりということである。

ポインタそれ自身は、指されている対象の極めて単純な電気的な住所だと言える。
従って、リストも電気的な住所の列として記録されていると言える。

@menu
* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::
@end menu

@ifnottex
@node Lists diagrammed
@unnumberedsec Lists diagrammed
@end ifnottex

例えば、
@code{(rose violet buttercup)} というリストは @samp{rose},
@samp{violet}, @samp{buttercup} という三つの要素を持っている。計算機の中
では、@samp{rose} の電気的な住所は、ある計算機のメモリのセグメントに
@samp{violet} というアトムの電気的な住所を示すアドレスに並んで記されてい
る。そしてこっちの住所 (@samp{violet} の場所を示すもの) は
@samp{buttercup} というアトムの電気的な住所を示すアドレスに並んで記され
ている。

@need 1200
このように書くと何やら複雑に思えるかもしれないが、図に書いてみれば簡単に
理解出来るだろう。

@c clear print-postscript-figures
@c !!! cons-cell-diagram #1
@ifnottex
@smallexample
@group
@c ascii diagram
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@c    ┌─┬─┐   ┌─┬─┐   ┌─┬─┐
@c    │  │  ├─>│  │  ├─>│  │  ├─> nil
@c    └┬┴─┘   └┬┴─┘   └┬┴─┘
@c      │           │           │
@c      └─> rose   └─> violet └─> buttercup
@c ascii diagram end
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
上の図の中で、各々の箱は Lisp オブジェクトを保持する計算機のメモリのワー
ドを表現している。これは普通はメモリアドレスの形をしている。これらの箱、
即ち住所は、ペアになっている。各々の矢印は、そのアドレスを持つ住所を指し
ている。その場所には、アトムか他のアドレスのペアがある。最初の箱は
@samp{rose} の電気的な住所であり、矢印は @samp{rose} を指している。二番
目の箱は次の箱のペアを指しており、こっちのペアの一番目の箱は
@samp{violet} の住所、そして二番目の箱はまた次のペアのアドレス、という具
合になっている。そして最後の箱は、シンボル @code{nil} を指している。これ
は、リストの最後を示している。

@need 1200
@code{setq} などの関数によってある変数がこのリストにセットされた場合、こ
のリストの先頭の箱のアドレスがこの変数にセットされる。従って、

@smallexample
(setq bouquet '(rose violet buttercup))
@end smallexample

@need 1250
@noindent
を評価すると、以下のような状況になる。

@c cons-cell-diagram #2
@ifnottex
@smallexample
@group
@c ascii diagram
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@c bouquet
@c    │
@c    │   ┌─┬─┐   ┌─┬─┐   ┌─┬─┐
@c    └─>│  │  ├─>│  │  ├─>│  │  ├─> nil
@c         └┬┴─┘   └┬┴─┘   └┬┴─┘
@c           │           │           │
@c           └─> rose   └─> violet └─> buttercup
@c ascii diagram end
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
この場合、シンボル @code{bouquet} が最初のペアのアドレスを持つことになる。

@need 1200
同じリストをちょっと箱の書き方を変えた別のイラストで描いてみると、次のよ
うになる。

@c cons-cell-diagram #2a
@ifnottex
@smallexample
@group
@c ascii diagram
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@c bouquet
@c  │
@c  │   ┌───┬──┐   ┌───┬──┐   ┌─────┬──┐
@c  │   │car   │cdr │   │car   │cdr │   │car       │cdr │
@c  └─>│rose  │  ・──>│violet│  ・──>│buttercup │ nil│
@c       └───┴──┘   └───┴──┘   └─────┴──┘
@c ascii diagram end
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2a}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end iftex
@end ifclear

(Symbols consist of more than pairs of addresses, but the structure of
a symbol is made up of addresses.  Indeed, the symbol @code{bouquet}
consists of a group of address-boxes, one of which is the address of
the printed word @samp{bouquet}, a second of which is the address of a
function definition attached to the symbol, if any, a third of which
is the address of the first pair of address-boxes for the list
@code{(rose violet buttercup)}, and so on.  Here we are showing that
the symbol's third address-box points to the first pair of
address-boxes for the list.)

もし、シンボルがあるリストの @sc{cdr} にセットされたなら、そのリスト自身
は変化しない。そのシンボルは単にそのリストのアドレスを持つようになるだけ
である。(専門用語では、@sc{car} や @sc{cdr} は
「非破壊的 (non-destructive)」 であると言う。) 従って、次のＳ式を評価す
ると、

@smallexample
(setq flowers (cdr bouquet))
@end smallexample

@need 800
@noindent
以下のような状況が生ずる。

@c cons-cell-diagram #3
@ifnottex
@sp 1
@smallexample
@group
@c ascii diagram
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@c bouquet        flowers
@c   │             │
@c   │   ┌─┬─┐│   ┌─┬─┐   ┌─┬─┐
@c   └─>│  │  │└─>│  │  │   │  │  │
@c        │  │  ├──>│  │  ├─>│  │  ├─> nil
@c        └┬┴─┘     └┬┴─┘   └┬┴─┘
@c          │             │           │
@c          └─> rose     └─> violet └─> buttercup
@c ascii diagram end
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@noindent
@code{flowers} の値は @code{(violet buttercup)} であるが、これはシンボル
@code{flowers} がアドレスボックスのペアのアドレスを持ったということである。
このペアの最初の箱には @code{violet} のアドレスがあり、二番目の箱には
@code{buttercup} のアドレスが入っている。

アドレスボックスのペアは@dfn{コンスセル} (@dfn{cons cell}) もしくは
@dfn{ドット対} (@dfn{dotted pair}) と呼ばれる。@ref{Cons Cell Type, ,
Cons Cell and List Type , elisp, The GNU Emacs Lisp Reference Manual},
及び @ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU
Emacs Lisp Reference Manual}, にコンスセルとドット対についてのより詳しい
情報がある。

@need 1200
関数 @code{cons} は、上に述べたようなアドレスの列の先頭に新しいアドレス
ペアを付け加える。例えば、

@smallexample
(setq bouquet (cons 'lily bouquet))
@end smallexample

@need 1500
@noindent
を評価すると

@c cons-cell-diagram #4
@ifnottex
@sp 1
@smallexample
@group
@c ascii diagram
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily       --> rose       --> violet    --> buttercup
@c bouquet                     flowers
@c   │                          │
@c   │   ┌─┬─┐   ┌─┬─┐│   ┌─┬─┐   ┌─┬─┐
@c   └─>│  │  │   │  │  │└─>│  │  │   │  │  │
@c        │  │  ├─>│  │  ├──>│  │  ├─>│  │  ├─> nil
@c        └┬┴─┘   └┬┴─┘     └┬┴─┘   └┬┴─┘
@c          │           │             │           │
@c          └─> lily   └─> rose     └─> violet └─> buttercup
@c ascii diagram end
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-4}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@need 1200
@noindent
という状況になる。この操作ではシンボル @code{flowers} の値を変更している
わけではない。これは次を評価することで確かめられる。

@smallexample
(eq (cdr (cdr bouquet)) flowers)
@end smallexample

@noindent
これは、@code{t} を返すはずだ。

再設定されない限り、@code{flowers} はずっ
と @code{(violet buttercup)} という値を持ったままである。つまり、最初の
アドレスが @code{violet} であるコンスセルのアドレスを持っているというこ
とだ。また上の操作は、既に存在しているコンスセルを変えたりはしない。そ
れらは全てそのままである。

従って、Lisp でリストの @sc{cdr} を得るには、単にその列の隣りのコンスセ
ルのアドレスを得ればよく、また @sc{car} を得るには、単にそのリストの最初
の要素のアドレスを得ればよい。更に、リストに新しい要素を @code{cons} す
るには、リストの先頭に新しいコンスセルを加えればよい。以上がこの話題に
関する全てである。Lisp の裏側は驚くほど明解で単純のなのだ。

では、コンスセルの列の最後のアドレスはどこに関連づけられているのか？ こ
れは @code{nil}, 即ち、空リストである。

まとめると、Lisp の変数にある値にセットされる時は、その変数には、その変
数が見にいくリストのアドレスが与えられるというわけである。

@node Symbols as Chest
@section Symbols as a Chest of Drawers
@cindex Symbols as a Chest of Drawers
@cindex Chest of Drawers, metaphor for a symbol
@cindex Drawers, Chest of, metaphor for a symbol

In an earlier section, I suggested that you might imagine a symbol as
being a chest of drawers.  The function definition is put in one
drawer, the value in another, and so on.  What is put in the drawer
holding the value can be changed without affecting the contents of the
drawer holding the function definition, and vice-verse.

Actually, what is put in each drawer is the address of the value or
function definition.  It is as if you found an old chest in the attic,
and in one of its drawers you found a map giving you directions to
where the buried treasure lies.

(In addition to its name, symbol definition, and variable value, a
symbol has a `drawer' for a @dfn{property list} which can be used to
record other information.  Property lists are not discussed here; see
@ref{Property Lists, , Property Lists, elisp, The GNU Emacs Lisp
Reference Manual}.)

@need 1500
Here is a fanciful representation:

@c chest-of-drawers diagram
@ifnottex
@sp 1
@smallexample
@group
           Chest of Drawers             Contents of Drawers

            __   o0O0o   __
          /                 \
         ---------------------
        |    directions to    |            [map to]
        |     symbol name     |             bouquet
        |                     |
        +---------------------+
        |    directions to    |
        |  symbol definition  |             [none]
        |                     |
        +---------------------+
        |    directions to    |            [map to]
        |    variable value   |             (rose violet buttercup)
        |                     |
        +---------------------+
        |    directions to    |
        |    property list    |             [not described here]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{drawers}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
            Chest of Drawers            Contents of Drawers

            __   o0O0o   __
          /                 \
         ---------------------
        |    directions to    |            [map to]
        |     symbol name     |             bouquet
        |                     |
        +---------------------+
        |    directions to    |
        |  symbol definition  |             [none]
        |                     |
        +---------------------+
        |    directions to    |            [map to]
        |    variable value   |             (rose violet buttercup)
        |                     |
        +---------------------+
        |    directions to    |
        |    property list    |             [not described here]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@node List Exercise
@section 練習問題

@code{flowers} に @code{violet} と @code{buttercup} をセットしなさい。ま
た、このリストに更に二つの花を consし、新しく出来たリストを
@code{more-flowers} にセットしなさい。@code{flowers} の @sc{car} に魚の
名前をセットしなさい。この時、@code{more-flowers} のリストの中身はどうな
るか。

@node Yanking
@chapter テキストのヤンク
@findex yank
@cindex Text retrieval
@cindex Retrieving text
@cindex Pasting text

GNU Emacs で `kill' コマンドでバッファからテキストを切り取った場合、その
テキストは常に、ヤンク (yank) コマンドで取り戻すことが出来る。バッファか
ら切り取られたテキストは kill リングに置かれており、ヤンクコマンドは、こ
の kill リングの中から該当する内容を取り出してバッファに挿入する (これは、
元のバッファとは限らない)。

単なる @kbd{C-y} (@code{yank}) コマンドは、kill リングの最初の要素をカレ
ントバッファに挿入する。もし、@kbd{C-y} コマンドのすぐ後に続けて
@kbd{M-y} とタイプすると、その最初の要素が二番目の要素と取り換えられる。
続けて何回も @kbd{M-y} をタイプすると、その回数だけ最初の要素を入れ替え
ていき、一回りするとまた最初に戻ってそれを繰り返す。(そういうわけで kill
リングは「リスト」ではなく「リング」と呼ばれるのである。しかし、実際にテ
キストを保存しているデータの型はリストに他ならない。リストをリングとして
扱う方法についてのより詳しい話は @ref{Kill Ring, , kill リングの扱い},
を参照。)

@menu
* Kill Ring Overview::          kill リングはリストである
* kill-ring-yank-pointer::      @code{kill-ring-yank-pointer} 変数について
* yank nthcdr Exercises::       ヤンクと nthcdr についての練習問題
@end menu

@node Kill Ring Overview
@section Kill リングについての概観
@cindex Kill ring overview

kill リングはテキスト形式の文字列のリストである。例えば次のような形を
している。

@smallexample
("some text" "a different piece of text" "yet more text")
@end smallexample

もし私の kill リングが上のものだったとして、ここで私が @kbd{C-y} と押す
と、@samp{some text} という文字列が私が現在いるバッファのカーソルの位置
に挿入される。

@code{yank} コマンドはまた、テキストを複写するのにも使われる。コピーされ
るテキストはバッファから切り取られるのではなく、一旦 kill リングに置かれ、
その後ヤンクされることで挿入されることになる。

kill リングのテキストを取り出すには三つの関数が使われる。通常 @kbd{C-y}
にバインドされている @code{yank}, 同じく通常 @kbd{M-y} にバインドされて
いる @code{yank-pop}、そして、この二つの関数によって使われる
@code{rotate-yank-pointer} である。

These functions refer to the kill ring through a variable called the
@code{kill-ring-yank-pointer}.  Indeed, the insertion code for both the
@code{yank} and @code{yank-pop} functions is:

@smallexample
(insert (car kill-ring-yank-pointer))
@end smallexample

@noindent
（未訳）(Well, no more.  In GNU Emacs 22, the function has been replaced by
@code{insert-for-yank} which calls @code{insert-for-yank-1}
repetitively for each @code{yank-handler} segment.  In turn,
@code{insert-for-yank-1} strips text properties from the inserted text
according to @code{yank-excluded-properties}.  Otherwise, it is just
like @code{insert}.  We will stick with plain @code{insert} since it
is easier to understand.)

@code{yank} や @code{yank-pop} の働きを理解するには、まず
変数 @code{kill-ring-yank-pointer} と、関数 @code{rotate-yank-pointer}
を理解する必要がある。

@node kill-ring-yank-pointer
@section 変数 @code{kill-ring-yank-pointer}

@code{kill-ring-yank-pointer} は、@code{kill-ring} と同じく変数である。
一般に変数は、あるものの値にバインドされることで、それを指し示す働きをす
る。

@need 1000
従って、もし kill リングの値が

@smallexample
("some text" "a different piece of text" "yet more text")
@end smallexample

@need 1250
@noindent
であり、また @code{kill-ring-yank-pointer} が二番目の位置を指していたとす
ると、@code{kill-ring-yank-pointer} の値は

@smallexample
("a different piece of text" "yet more text")
@end smallexample

である。前章で説明したように
(@ref{List Implementation, , リストはどのように実装されているか},)、
計算機は @code{kill-ring} と @code{kill-ring-yank-pointer} とに指された
テキストを各々別々に保持しているわけではない。``a different piece of
text'' と ``yet more text'' の二つの言葉は、二重に複製されているのではな
いのである。その代わり二つの Lisp 変数は同じテキストの集まりを指している。
図に表わすと次の通りである。

@c cons-cell-diagram #5
@ifnottex
@smallexample
@group
@c ascii diagram
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text"
            |
             --> "some text"
@c kill-ring    kill-ring-yank-pointer
@c     │             │
@c     │   ┌─┬─┐│   ┌─┬─┐   ┌─┬─┐
@c     └─>│  │  │└─>│  │  │   │  │  │
@c          │  │  ├──>│  │  ├─>│  │  ├─> nil
@c          └┬┴─┘     └┬┴─┘   └┬┴─┘
@c            │             │           │
@c            │             │           └─> "yet more text"
@c            │             │
@c            │             └─> "a different piece of text"
@c            │
@c            └─> "some text"
@c ascii diagram end
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-5}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text"
            |
             --> "some text"
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

変数 @code{kill-ring} と 変数 @code{kill-ring-yank-pointer} は両方ともポ
インタである。しかし、kill リングそのものは、実際に要素を組み合わせたもの
として説明されることが多い。つまり、@code{kill-ring} はリストの計算機内
での位置を指しているというよりは、リストそのものの意味で使われる。それに対
し、@code{kill-ring-yank-pointer} の方は、リストへのポインタという意味で
使われることが多い。

全く同じことについて、こういうふうに二つの言い方を使うと最初は混乱するよ
うに思えるかもしれない。しかしよく考えてみれば合理的である。kill リング
は一般に、Emacs のバッファから最近切り取られたテキストのデータからなって
いると捉えられている。一方 @code{kill-ring-yank-pointer} の方は、kill リ
ングの中でその最初の要素 (つまり @sc{car}) がこれから挿入するデータであ
るような部分、を指し示すために使われる。

@ignore
In GNU Emacs 22, the @code{kill-new} function calls

@code{(setq kill-ring-yank-pointer kill-ring)}

(defun rotate-yank-pointer (arg)
  "Rotate the yanking point in the kill ring.
With argument, rotate that many kills forward (or backward, if negative)."
  (interactive "p")
  (current-kill arg))

(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill.
If N is zero, `interprogram-paste-function' is set, and calling it
returns a string, then that string is added to the front of the
kill ring and returned as the latest kill.
If optional arg DO-NOT-MOVE is non-nil, then don't actually move the
yanking point; just return the Nth kill forward."
  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
    (if interprogram-paste
        (progn
          ;; Disable the interprogram cut function when we add the new
          ;; text to the kill ring, so Emacs doesn't try to own the
          ;; selection, with identical text.
          (let ((interprogram-cut-function nil))
            (kill-new interprogram-paste))
          interprogram-paste)
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element)))))

@end ignore

（旧訳、削除？）@code{rotate-yank-pointer} 関数は、@code{kill-ring-yank-pointer} が指し
示す要素を交換するものである。より詳しく言うと、ポインタが kill リングの
最後の要素を越えて更に次の要素に移ろうとする際に、自動的にポインタを
kill リングの最初の要素に移動してくれるのだ。このようにしてリストがあた
かもリングであるように扱えるのである。@code{rotate-yank-pointer} 関数そ
れ自身は単純であるが、その中身には多くの細かい説明が必要である。この関数
及び、これよりずっと単純な @code{yank}, @code{yank-pop} 関数については次
の所で説明する。@ref{Kill Ring, , kill リングの扱い}.

@need 1500
@node yank nthcdr Exercises
@section @code{yank} と @code{nthcdr} についての練習問題

@itemize @bullet
@item
@kbd{C-h v} (@code{describe-variable}) を使って、あなたの kill リングの値
を見なさい。幾つか kill リングの要素を増やしてから、もう一度 kill リング
の中身を見なさい。@kbd{M-y} (@code{yank-pop}) を使って kill リングの中を
動き回りなさい。あなたの kill リングの中にはどのくらい多くの要素がありま
すか？ @code{kill-ring-max} の値を見なさい。kill リングはもう一杯ですか？
それともまだテキストのブロックを追加出来ますか？

@item
@code{nthcdr} と  @code{car} を使って、各々リストの一番目、二番目、三番目、
及び四番目の要素を返すような四つのＳ式を作りなさい。
@end itemize

@node Loops & Recursion
@chapter ループと再帰
@cindex Loops and recursion
@cindex Recursion and loops
@cindex Repetition (loops)

Emacs Lisp は、一つないしは複数のＳ式を繰り返し評価させるのに、主として
二つの方法を持っている。一つは @code{while} ループを利用するもの、もう一
つは@dfn{再帰} (@dfn{recursion}) を使うものである。

繰り返しは非常に役に立つものである。例えば四つの文の分だけ先に移動したい
場合には、一つの文だけ移動するプログラムを書いて、そのプロセスを四回繰り
返せば良い。計算機には飽きるとか疲れるとかいった感情はないので、このよう
な繰り返しをいくらやらせたところで、人間のように過度の繰り返しをさせてし
まってミスを犯しやすくなるといった弊害は無い。

（未訳）People mostly write Emacs Lisp functions using @code{while} loops and
their kin; but you can use recursion, which provides a very powerful
way to think about and then to solve problems@footnote{You can write
recursive functions to be frugal or wasteful of mental or computer
resources; as it happens, methods that people find easy---that are
frugal of `mental resources'---sometimes use considerable computer
resources.  Emacs was designed to run on machines that we now consider
limited and its default settings are conservative.  You may want to
increase the values of @code{max-specpdl-size} and
@code{max-lisp-eval-depth}.  In my @file{.emacs} file, I set them to
15 and 30 times their default value.}.

@menu
* while::                       特定のコードの繰り返し
* dolist dotimes::
* Recursion::                   再帰: 自分自身を呼び出す関数
* Looping exercise::            ループについての練習問題
@end menu

@node while
@section @code{while}
@cindex Loops
@findex while

特殊形式 @code{while} は、最初の引数を評価して返された値が真か偽かを
テストする。ここまでは @code{if} の時と同じである。しかし、次に Lisp イ
ンタプリタがやることはちょっと違っている。

@code{while} 式においても、返された値が偽の場合は、Lisp インタプリタは残
りのＳ式 (このＳ式の本体部分) をスキップし、それを評価したりはしない。し
かし、返された値が真の場合は、Lisp インタプリタは本体部分を評価した後、
もう一度 @code{while} の最初の引数が真か偽かをテストする。もし、返された
値がまたもや真であったなら、Lisp インタプリタは再度本体部分を実行する。

@need 1200
@code{while} 式のテンプレートは次の通りである。

@smallexample
@group
(while @var{真偽テスト}
  @var{本体}@dots{})
@end group
@end smallexample

@menu
* Looping with while::          Repeat so long as test returns true.
* Loop Example::                リストを使った @code{while} ループ
* print-elements-of-list::      @code{while}, @code{car}, @code{cdr} の利用
* Incrementing Loop::           増加するカウンタを使ったループ
* Incrementing Loop Details::
* Decrementing Loop::           減少するカウンタを使ったループ
@end menu


@ifnottex
@node Looping with while
@unnumberedsubsec Looping with @code{while}
@end ifnottex

@code{while} 式の真偽テストの部分が真を返している限り、本体部分は繰り返
し評価される。このプロセスはループと呼ばれる。これは、Lisp インタプリタ
が何回も同じことを繰り返す様子が、飛行機の宙返りと似ているためである。
真偽テストの結果が偽の場合は、Lisp インタプリタはそこで @code{while} 式
の残りの部分を評価するのを止めて「ループを抜ける」。

当たり前のことだが、もし @code{while} 式の最初の引数が常に真を返すとする
と、その後の本体部分は何回でも無限に評価され続ける。逆にもし真になり得な
いとすると、本体部分の式は決して評価されることはない。@code{while} 式
のループを書く工程とは、本体部分のＳ式の評価を繰り返したい回数だけ真偽テ
ストが真の値を返し、そしてその後、偽を返すような仕掛けを作ることである。

@code{while} 式を評価した場合に返される値は真偽テストが返す値である。従っ
て面白いことに、エラーなく評価された @code{while} ループは、たとえ100回
ループを繰り返した後でも一度もループしなかった場合でも、必ず @code{nil}
を返す。正しく評価された @code{while} 式は決して真の値を返すことはないわ
けだ！ このことは、@code{while} 式は常に副作用を目的として評価されること
を意味する。即ち、@code{while} ループの中の本体部分のＳ式を評価するため
に評価されるのである。これは理にかなっている。単にループを繰り返すことが
目的なのではなく、ループの中のＳ式を繰り返し評価した時に生じる結果こそが
望むものなのだから。

@node Loop Example
@subsection @code{while} ループとリスト

@code{while} ループをコントロールする一般的な方法は、リストが要素を持っ
ているかどうかをテストすることである。もし要素が一つもなければ、それは空
リストであり、結果として空リスト @code{()} が返される。これは、
@code{nil} もしくは偽 (false) の同義語である。一方、要素を持つリストの場
合は、それらの要素そのものが返される。Lisp は @code{nil} 以外のものは全
て真と見倣すので、この場合は @code{while} ループでは真が返されたことにな
る。

@need 1200
例えば、次のＳ式を評価すると、変数 @code{empty-list} の値を @code{nil}
にセットすることが出来る。

@smallexample
(setq empty-list ())
@end smallexample

@noindent
この @code{setq} 式を評価した後、変数 @code{empty-list} をいつものように
カーソルをこのシンボルのすぐ後に持っていって @code{C-x C-e} とタイプすこ
とで評価してみよう。エコー領域に @code{nil} が表示されるはずだ。

@smallexample
empty-list
@end smallexample

一方、変数を要素を持つリストにセットした場合は、その変数を評価するとその
リストが表示される。これは次の二つのＳ式を評価することで確かめられる。

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

animals
@end group
@end smallexample

ということで、リスト @code{animals} に要素があるかをテストに使用するよう
な @code{while} ループを作るには、ループの最初の部分を次のように書けばよ
い。

@smallexample
@group
(while animals
       @dots{}
@end group
@end smallexample

@noindent
@code{while} が最初の引数をテストすると、変数 @code{animals} が評価され
る。これはリストを返す。このリストが要素を持っている限り、@code{while}
はテストの結果が真だと判断する。しかし、リストが空になると、結果は偽だと
判断される。

@code{while} ループが無限に続くことを避けるためには、最終的にリストが空
になるような何らかの仕掛けが必要である。よく使われるテクニックは、
@code{while} 式の本体部分の形式の一つでそのリストの値をそのリストの
@code{cdr} で置き換えるようにしておくことである。@code{cdr} 関数が評価さ
れるごとにそのリストは短くなっていき、ついには空リストが残されるというわ
けである。そうなると @code{while} ループのテストは偽を返し、@code{while}
の引数はもはや評価されず、ループが終了する。

例えば、動物のリストが変数 @code{animals} にバインドされていた時は、次
のＳ式を使ってその変数を元のリストの @sc{cdr} にセットすることが出来る。

@smallexample
(setq animals (cdr animals))
@end smallexample

@noindent
もし一つ前のＳ式を評価してあったなら、このＳ式を評価するとエコー領域に
@code{(gazelle lion tiger)} が表示されるはずだ。もう一度このＳ式を評価す
ると、今度は @code{(lion tiger)} が表示される。更に評価すると、
@code{(tiger)} が表示され、そこでまた評価すると、やっと空リストになって、
@code{nil} が表示される。

@code{cdr} 関数を繰り返し使うことで最終的に真偽テストで偽を返す
@code{while} ループのテンプレートは次のようになる。

@smallexample
@group
(while @var{リストが空かどうかのテスト}
  @var{本体}@dots{}
  @var{リストに自分自身の cdr をセット})
@end group
@end smallexample

このテストと @code{cdr} の利用を組み合わせて、リストの各要素を各々一行ご
とに表示するような関数を作ることが出来る。これを次に説明することにしよう。

@node print-elements-of-list
@subsection リストを使ったループの例: @code{print-elements-of-list}
@findex print-elements-of-list

リストを使った @code{while} ループのことを理解するには
@code{print-elements-of-list} 関数を見ると良い。

@cindex @file{*scratch*} buffer
（旧訳）この関数は、出力を表示するために幾つかの行を必要とする。エコー領域は一行
しかないので、今まで説明して来たように Info の中で評価するようなやり方で
はその動作をうまく描写出来ない。
If you are
reading this in a recent instance of GNU Emacs,
@c GNU Emacs 21, GNU Emacs 22, or a later version,
you can evaluate the following expression inside of Info, as usual.

代わりに必要なＳ式を @file{*scratch*} バッ
ファにコピーして、そこでそれらを評価する必要がある。

コピーするには、まず
対象となるリージョンの最初を @kbd{C-@key{SPC}} (@code{set-mark-command})
でマークしてからカーソルをリージョンの最後に移動し、@kbd{M-w}
(@code{copy-region-as-kill}) でそのリージョンをコピーする。そして
@file{*scratch*} バッファで @kbd{C-y} (@code{yank}) することで、そのＳ式
を取り出せばよい。

@file{*scratch*} バッファにそのＳ式をコピーしたら、今度はそのＳ式を評価
するのだが、最後の @code{(print-elements-of-list animal)} は @kbd{C-u
C-x C-e} とタイプして評価する必要がある。つまり @code{eval-last-sexp} に
前置引数を与えるのである。すると、評価した結果はエコー領域ではなく
@code{*scratch*} バッファに表示される。(単に @kbd{C-x C-e} とするだけだ
と、返された値はエコー領域に @code{^Jgiraffe^J^Jlion^J^Jtiger^Jnil} のよ
うに表示されてしまう。ここで出て来る @samp{^J} は改行を表している。従っ
て @code{*scratch*} バッファでは各々の単語は一行ごとに表示されることにな
るわけである。このことは、今 Info バッファで次のＳ式を評価してみても確か
められる。)

@need 1500
In a recent instance of GNU Emacs, you can evaluate these expressions
directly in the Info buffer, and the echo area will grow to show the
results.

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-of-list (list)
  "Print each element of LIST on a line of its own."
  (while list
    (print (car list))
    (setq list (cdr list))))

(print-elements-of-list animals)
@end group
@end smallexample

@need 1200
@noindent
これらの三つのＳ式を順に @file{*scratch*} バッファで評価していくと、その
バッファの中で次のように表示されるはずだ。

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

リストの各要素が各々一行ごとに表示され (これは @code{print} の仕事である)、
そして最後にこの関数自体が返した値が表示される。この関数の中の最後のＳ式
は @code{while} ループであり、@code{while} ループは常に @code{nil} を返
すので、@code{nil} がリストの最後の要素の後に表示される。

@node Incrementing Loop
@subsection 増加するカウンタを使ったループ

ループは止まるべき時に止まってくれないことには役に立たない。リストを使っ
たループの制御以外の一般的な方法としては、最初の引数として、正しい回数だ
け繰り返すと偽を返すテストを書くという方法がある。これは、ループがカウン
タ---つまりループを繰り返した回数を数えるＳ式---を持つということである。

@ifnottex
@node Incrementing Loop Details
@unnumberedsubsec Details of an Incrementing Loop
@end ifnottex

真偽テストとしては、@code{(< count desired-number)} といったＳ式が使える。
これは @code{count} の値が期待する繰り返しの数 @code{desired-number} よ
りも小さければ、@code{t} という真の値を返し、@code{desired-number} 以上
であれば、偽の値 @code{nil} を返す。カウンタを増加させるＳ式は
@code{(setq count (1+ count))} といったごく簡単な @code{setq} 式でよい。
ここで @code{1+} は Emacs Lisp の組み込み関数で、引数に1を加えるものであ
る。(@code{(1+ count)} は @code{(+ count 1)} としても同じだが、この方が
人間にとって読みやすいであろう。)

@need 1250
ということで、増加するカウンタを使った @code{while} ループのテンプレート
は次のようになる。

@smallexample
@group
@var{カウンタを初期値に戻す}
(while (< count desired-number)         ; @r{真偽テスト}
  @var{本体}@dots{}
  (setq count (1+ count)))              ; @r{インクリメンタ}
@end group
@end smallexample

@noindent
この場合 @code{count} の初期値を定めなければならないことに注意しよう。通
常は1にセットする。

@menu
* Incrementing Example::        三角形に並んだ小石の数を数えてみる
* Inc Example parts::           関数定義はどんな部分からなるか
* Inc Example altogether::      関数を一つにまとめる
@end menu

@node Incrementing Example
@unnumberedsubsubsec  増加カウンタの例

あなたは浜辺で遊んでおり、小石で三角形を作ろうと思ったとしよう。まず、一
行目に1つの小石を置き、二行目に 2 つ置き、三行目に 3 つ置き..., という具
合に続けていくのだ。図で描くと次のようになる。

@sp 1
@c pebble diagram
@ifnottex
@smallexample
@group
               *
              * *
             * * *
            * * * *
@end group
@end smallexample
@end ifnottex
@iftex
@smallexample
@group
               @bullet{}
              @bullet{} @bullet{}
             @bullet{} @bullet{} @bullet{}
            @bullet{} @bullet{} @bullet{} @bullet{}
@end group
@end smallexample
@end iftex
@sp 1

@noindent
(約2500年前、ピタゴラス一派はこのような問題を考えて数論の初歩を発展させ
ていった。)

ここで、七行の三角形を作るにはいくつの小石が必要かを知りたいと思ったとする。

当然、ここであなたがしなければならないのは1から7までの数を加えることであ
る。これを行うには二通りの方法がある。小さい数から始めて1、2、3、4、...
という数列を加えて行くか、大きい方から始めて7、6、5、4、... という数列の
和を取るかである。どちらの場合にも @code{while} ループを書く時の共通の方
法を説明してくれるので、この下から登るのと、上から降りるのと両方の例を作っ
てみようと思う。最初の例として1に2、3、4を加えていくものから始めよう。

和を取る数のリストが短い場合は、一度に全部足してしまうのがもっとも簡単な
方法である。しかしながら、もし前もって数のリストがどれくらいの長さになる
か分らなかったり、あるいは極めて長いリストの場合にも対処したい場合には、
複雑なプロセスを一度にやるのではなく、単純なプロセスを沢山繰り返して和を
求めるような方法を考える必要がある。

例えば、小石を一度に全部加える代わりに、まず最初の行の小石の数1に二行目
の小石の数2を加え、次にその合計に三行目の小石の数3を加え、今度はその和に
四行目の数4を加え、という操作を続けるのである。

このプロセスで大切な特徴は、繰り返し行う操作は単純ですむということである。
今の場合、各々のステップでやっていることは、二つの数を加えるということだ
けである。その時点での行の小石の数と、それまでの合計は既に分っている。こ
の二数の和を取るプロセスは、最後の行の数をそれまでの合計に加えるまで何回
でも繰り返される。もっと複雑なループでは、繰り返し行う操作はそれ程単純で
はない。しかしそれでも全てを一度にやるよりはずっと簡単なのである。

@node Inc Example parts
@unnumberedsubsubsec 関数定義の各部分

前節での分析は、我々の関数定義の骨組みを与えてくれる。まず、小石の全体の
数を表わす変数が要る。これは @code{total} としていいだろう。これがこの関
数の返す値である。

次に、この関数には三角形の全行数を表わす引数が要る。これは
@code{number-of-rows} として良いだろう。

最後に、カウンタとして使う変数が必要である。これは @code{counter} として
も構わないのだが、それよりも @code{row-number} とする方が良い。何故なら、
このカウンタがやることは行を数えることであり、プログラムは出来るだけ分り
やすく書くべきものだからである。

Lisp インタプリタがこの関数内のＳ式の評価を開始すると、まず @code{total}
の値が零にセットされる。これはまだ何も加えていないからである。次に、最初
の行の小石の数が足される。そして二行目の数を加え、三行目の数を加え、とい
うふうに続き、最後の行の小石を加えたところで終了する。

@code{total} も @code{row-number} も共にこの関数内部でしか使われない。従っ
て、@code{let} を使って局所変数として宣言し、初期値を与えればよい。明ら
かに @code{total} の初期値は0であり、また @code{row-number} の初期値は1
である。ということで、@code{let} 式は次のようになる。

@smallexample
@group
  (let ((total 0)
        (row-number 1))
    @var{本体}@dots{})
@end group
@end smallexample

内部変数が宣言されて初期値にバインドされたなら、@code{while} ループを開
始する。テストの部分のＳ式は @code{row-number} が @code{number-of-rows}
以下である場合その時のみ @code{t} を返すようなものでなければならない。
(@code{row-number} と @code{number-of-rows} が一致する場合も含めないと最
後の行の小石の数が加えられないことに注意。)

@need 1500
@findex <= @r{(less than or equal)}
Lisp には @code{<=} という、最初の引数が二番目の引数以下の場合に真を返し、
そうでない場合は偽を返す関数がある。これを使うと、@code{while} 式のテス
ト部分のＳ式は次のように書ける。

@smallexample
(<= row-number number-of-rows)
@end smallexample

全体の小石の数は、各々の行の小石の数をそれまでの合計に繰り返し加えていく
ことで計算される。ある行の小石の数はその行の番号と一致するので、全体の数
は行の番号を加えていくことで求まることになる。(言うまでもないが、状況が
複雑な場合には、ある行の小石の数とその行の番号とはもっと複雑な関係で結ば
れている。そういう場合は行番号は他の適当なＳ式で置き換えることになる。)

@smallexample
(setq total (+ total row-number))
@end smallexample

@noindent
このＳ式では @code{total} の新しい値としてそれまでの合計に現在の行の小石
の数を加えたものをセットしている。

@code{total} の値をセットしたら、次のループに移る場合のために条件を整え
ておかなければならない。それには、カウンタ用の変数 @code{row-number} の
値に1を加えれば良い。@code{row-number} の値が1増やされると、次のループの
@code{while} 式の先頭の真偽テストで、この新しい値が @code{number-of-row}
の値以下であるかが判定される。もしそうであれば、変数 @code{row-number}
の新しい値が前回のループでの @code{total} の値に加えられる。

Emacs Lisp の組み込み関数 @code{1+} は数に1を加えてくれる。従って、
@code{row-number} 変数は次のＳ式で1増加させることが出来る。

@smallexample
(setq row-number (1+ row-number))
@end smallexample

@node Inc Example altogether
@unnumberedsubsubsec 各部分の総合

これまでで関数定義の各々の部分を書いたので、ここでそれらを一つにまとめる
ことにしよう。

まず @code{while} 式の中身は次の通り。

@smallexample
@group
(while (<= row-number number-of-rows)   ; @r{真偽テスト}
  (setq total (+ total row-number))
  (setq row-number (1+ row-number)))    ; @r{インクリメンタ}
@end group
@end smallexample

これに @code{let} 式の変数リストを加えればほぼ関数定義の本体部分は完成す
るが、最後にほんの少しだけ加えるべき要素がある。

それは変数 @code{total} それ自身を @code{while} 式の後に書くことである。
そうしないと関数全体が返す値は @code{let} 式の本体部分の最後のＳ式が返す
値、即ち @code{while} 式が返す値になるので、常に @code{nil} が返されてし
まうからである。

このことはぱっと見ただけでは気がつかないかもしれない。値を1増加させる式
が最後だから良いように思えるかもしれないが、これはあくまで @code{while}
式の一部なのである。シンボル @code{while} から始まるリストの最後の要素な
のだ。更に @code{while} ループ全体は @code{let} 式の本体部分の中のリスト
なのである。

@need 1250
大ざっぱに書くと関数は次のような形をしている。

@smallexample
@group
(defun @var{関数名} (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  (let (@var{変数リスト})
    (while (@var{真偽テスト})
      @var{while の本体}@dots{} )
      @dots{} )                     ; @r{ここに最後の式が来る。}
@end group
@end smallexample

このように定義された関数が返す値は @code{let} 式が返す値になる。というの
も @code{let} は @code{defun} 以外の他のどのリストにも含まれてはいないか
らである。だから、もし @code{while} が @code{let} 式の本体の最後のＳ式で
あれば、この関数は常に @code{nil} を返してしまうことになる。これは我々が
望む結果ではない！ これを回避するには、単にシンボル @code{total} を
@code{let} で始まるリストの最後に置けば良い。この式はこのリストの他のＳ
式が評価された後に評価される。これによって、全体として正しい値が返される
ことになる。

@code{let} で始まるリスト全体を一行で表示してみると、理解しやすいだろう。
こう書くと変数リスト @var{varlist} と @code{while} 式が @code{let} 式の
二番目と三番目の要素であることがよく分る。そして最後の要素が
@code{total} になるわけである。

@smallexample
@group
(let (@var{変数リスト}) (while (@var{真偽テスト}) @var{while の本体}@dots{} ) total)
@end group
@end smallexample

@need 1200
以上を一つにまとめると、@code{triangle} 関数の定義は次のようになる。

@smallexample
@group
(defun triangle (number-of-rows)    ; @r{インクリメンタを使った}
                                    ; @r{  バージョン。}
  "Add up the number of pebbles in a triangle.
The first row has one pebble, the second row two pebbles,
the third row three pebbles, and so on.
The argument is NUMBER-OF-ROWS."
@end group
@group
  (let ((total 0)
        (row-number 1))
    (while (<= row-number number-of-rows)
      (setq total (+ total row-number))
      (setq row-number (1+ row-number)))
    total))
@end group
@end smallexample

これを評価して @code{triangle} をインストールした後、実際に試してみよう。
二つの例を挙げる。

@smallexample
@group
(triangle 4)

(triangle 7)
@end group
@end smallexample

@noindent
最初の4つの数の和は10になり、最初の7つの数の和は28になる。

@node Decrementing Loop
@subsection 減少するカウンタを使ったループ

@code{while} ループのテスト部分のもう一つの一般的な書き方としては、カウ
ンタが零を越えるかどうかを判定するというものがある。カウンタが零より大き
い間はループを繰り返すが、零以下になると止まるというわけである。このように
動作させるためにはカウンタは零以上の数から始めて繰り返しの部分が評価され
るごとに小さくなるようにしなければならない。

テスト部分は @code{(> counter 0)} のようになる。これは @code{counter} の
値が零よりも大きければ真として @code{t} を返し、零以下なら偽として
@code{nil} を返すというものである。数を次第に小さくしていくには、
@code{(setq counter (1- counter))} という単純な @code{setq} 式を使う。こ
こで、@code{1-} は引数を1減らす Emacs Lisp の組み込み関数である。

@need 1250
ということで、@code{while} ループのテンプレートは次のようになる。

@smallexample
@group
(while (> counter 0)                    ; @r{真偽テスト}
  @var{本体}@dots{}
  (setq counter (1- counter)))          ; @r{デクリメンタ}
@end group
@end smallexample

@menu
* Decrementing Example::        またまた浜辺の小石を数えてみる
* Dec Example parts::           関数定義はどんな部分からなるか
* Dec Example altogether::      関数を一つにまとめる
@end menu

@node Decrementing Example
@unnumberedsubsubsec 減少するカウンタを使った例

減少するカウンタを使ったループを説明するために、@code{triangle} 関数を、
このようなカウンタを使って書き直してみることにする。

数え方は、この関数の前回のバージョンの逆である。今回は、例えば三行からな
る三角形の小石の数を求めるために、まず三行目の3つの小石を加え、次にその
前の二行目の2個の小石の数を加え、更にその合計に1行目の小石の数1を加える
という操作をすることになる。

同様にして、七行からなる三角形の小石の数を求めるには、七行目の小石の数7
にその前の行の小石の数6を加え、次にその合計に その前の行に小石の数5を加
え、とやっていくことになる。前回の例と同じく、各々の足し算ではそれまでの
合計と現在の行の小石の数の二つの数を加えているだけである。このプロセスは、
足す小石の数がなくなるまで繰り返される。

最初に加える小石の数も分る。最後の行の小石の数は全体の行の数に等しいから
である。三角形が七行からなっていれば、最終行の小石の数は7である。同様に、
次々と足していく小石の数も分る。それは、前回足した数から1を引いたもので
ある。

@node Dec Example parts
@unnumberedsubsubsec 関数定義の各部分

まず三つの変数が必要である。三角形の行の総数、各々の行の小石の数、そして、
小石の総数だ。この最後の数が今回求めようとしている数である。これら三つの
変数を各々 @code{number-of-rows}, @code{number-of-pebbles-in-row},
@code{total} と名付ることにする。

@code{total} も @code{number-of-pebbles-in-row} もこの関数の内部でしか使
われないので、@code{let} を用いて宣言される。@code{total} の初期値は勿論
零である。一方、@code{number-of-pebbles-in-row} の初期値は三角形の行の数
に等しくなるべきである。これは、もっとも長い行から小石の数を数えていくた
めである。

@need 1250
従って @code{let} 式の始めの部分は次のようになる。

@smallexample
@group
(let ((total 0)
      (number-of-pebbles-in-row number-of-rows))
  @var{本体}@dots{})
@end group
@end smallexample

小石全体の数は、各々の行の小石の数を順番に数えていくことで求められる。
つまり、繰り返し次のＳ式を評価していけばよい。

@smallexample
(setq total (+ total number-of-pebbles-in-row))
@end smallexample

@noindent
@code{number-of-pebbles-in-row} は @code{total} に加えられた後、次のルー
プに備えて一つだけ値を減らさなければならない。というのも次に加えられる行
は一段上の行であり、現在の長さよりも一つ分短いからである。これは次のＳ式
を評価することでなされる。

The number of pebbles in a preceding row is one less than the number of
pebbles in a row, so the built-in Emacs Lisp function @code{1-} can be
used to compute the number of pebbles in the preceding row.  This can be
done with the following expression:

@smallexample
@group
(setq number-of-pebbles-in-row
      (1- number-of-pebbles-in-row))
@end group
@end smallexample

最後に、小石が無くなった時点で @code{while} ループを抜けなければならない
が、そのための条件部は次のような簡単なものでよい。

@smallexample
(while (> number-of-pebbles-in-row 0)
@end smallexample

@node Dec Example altogether
@unnumberedsubsubsec 各部分の総合

（未訳）We can put these expressions together to create a function definition
that works.  However, on examination, we find that one of the local
variables is unneeded!

@need 1250
関数定義は次のようになる。

@smallexample
@group
;;; @r{デクリメンタを使った最初のバージョン。}
(defun triangle (number-of-rows)
  "Add up the number of pebbles in a triangle."
  (let ((total 0)
        (number-of-pebbles-in-row number-of-rows))
    (while (> number-of-pebbles-in-row 0)
      (setq total (+ total number-of-pebbles-in-row))
      (setq number-of-pebbles-in-row
            (1- number-of-pebbles-in-row)))
    total))
@end group
@end smallexample

これはこれで、うまく動作する。

しかしながら、実は変数 @code{number-of-pebbles-in-row} は必要でない！

@cindex Argument as local variable
@code{triangle} 関数が評価されると、シンボル @code{number-of-rows} は初期
値を与えられて、ある数にバインドされる。この数は関数の本体の中であたかも
局所変数であるかのごとく変化させることが可能で、この関数の外でのこの変数
の値には何の影響も与える心配はない。これは Lisp の大変便利な特徴であるが、
このことから関数内の @code{number-of-pebbles-in-row} を全て変数
@code{number-of-rows} で置き換えても良いことが分る。

@need 800
ということで、以下に、この関数の少し整理したバージョンを挙げる。

@smallexample
@group
(defun triangle (number)                ; @r{二番目のバージョン。}
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1- number)))
    total))
@end group
@end smallexample

まとめてみよう。きちんと書かれた @code{while} ループは以下の三つの部分か
らなる。

@enumerate
@item
ループを正しい回数繰り返した後、偽を返すテスト

@item
繰り返し評価された後、最後に望む値を返すようなＳ式

@item
正しい回数だけループを繰り返した後にテストが偽を返すよう、真偽テストに渡
される値を変化させるＳ式
@end enumerate

@node dolist dotimes
@section Save your time: @code{dolist} and @code{dotimes}

In addition to @code{while}, both @code{dolist} and @code{dotimes}
provide for looping.  Sometimes these are quicker to write than the
equivalent @code{while} loop.  Both are Lisp macros.  (@xref{Macros, ,
Macros, elisp, The GNU Emacs Lisp Reference Manual}. )

@code{dolist} works like a @code{while} loop that `@sc{cdr}s down a
list':  @code{dolist} automatically shortens the list each time it
loops---takes the @sc{cdr} of the list---and binds the @sc{car} of
each shorter version of the list to the first of its arguments.

@code{dotimes} loops a specific number of times: you specify the number.

@menu
* dolist::
* dotimes::
@end menu

@node dolist
@unnumberedsubsec The @code{dolist} Macro
@findex dolist

Suppose, for example, you want to reverse a list, so that
``first'' ``second'' ``third'' becomes ``third'' ``second'' ``first''.

@need 1250
In practice, you would use the @code{reverse} function, like this:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(reverse animals)
@end group
@end smallexample

@need 800
@noindent
Here is how you could reverse the list using a @code{while} loop:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-while (list)
  "Using while, reverse the order of LIST."
  (let (value)  ; make sure list starts empty
    (while list
      (setq value (cons (car list) value))
      (setq list (cdr list)))
    value))

(reverse-list-with-while animals)
@end group
@end smallexample

@need 800
@noindent
And here is how you could use the @code{dolist} macro:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-dolist (list)
  "Using dolist, reverse the order of LIST."
  (let (value)  ; make sure list starts empty
    (dolist (element list value)
      (setq value (cons element value)))))

(reverse-list-with-dolist animals)
@end group
@end smallexample

@need 1250
@noindent
In Info, you can place your cursor after the closing parenthesis of
each expression and type @kbd{C-x C-e}; in each case, you should see

@smallexample
(tiger lion giraffe gazelle)
@end smallexample

@noindent
in the echo area.

For this example, the existing @code{reverse} function is obviously best.
The @code{while} loop is just like our first example (@pxref{Loop
Example, , A @code{while} Loop and a List}).  The @code{while} first
checks whether the list has elements; if so, it constructs a new list
by adding the first element of the list to the existing list (which in
the first iteration of the loop is @code{nil}).  Since the second
element is prepended in front of the first element, and the third
element is prepended in front of the second element, the list is reversed.

In the expression using a @code{while} loop,
the @w{@code{(setq list (cdr list))}}
expression shortens the list, so the @code{while} loop eventually
stops.  In addition, it provides the @code{cons} expression with a new
first element by creating a new and shorter list at each repetition of
the loop.

The @code{dolist} expression does very much the same as the
@code{while} expression, except that the @code{dolist} macro does some
of the work you have to do when writing a @code{while} expression.

Like a @code{while} loop, a @code{dolist} loops.  What is different is
that it automatically shortens the list each time it loops---it
`@sc{cdr}s down the list' on its own---and it automatically binds
the @sc{car} of each shorter version of the list to the first of its
arguments.

In the example, the @sc{car} of each shorter version of the list is
referred to using the symbol @samp{element}, the list itself is called
@samp{list}, and the value returned is called @samp{value}.  The
remainder of the @code{dolist} expression is the body.

The @code{dolist} expression binds the @sc{car} of each shorter
version of the list to @code{element} and then evaluates the body of
the expression; and repeats the loop.  The result is returned in
@code{value}.

@node dotimes
@unnumberedsubsec The @code{dotimes} Macro
@findex dotimes

The @code{dotimes} macro is similar to @code{dolist}, except that it
loops a specific number of times.

The first argument to @code{dotimes} is assigned the numbers 0, 1, 2
and so forth each time around the loop, and the value of the third
argument is returned.  You need to provide the value of the second
argument, which is how many times the macro loops.

@need 1250
For example, the following binds the numbers from 0 up to, but not
including, the number 3 to the first argument, @var{number}, and then
constructs a list of the three numbers.  (The first number is 0, the
second number is 1, and the third number is 2; this makes a total of
three numbers in all, starting with zero as the first number.)

@smallexample
@group
(let (value)      ; otherwise a value is a void variable
  (dotimes (number 3 value)
    (setq value (cons number value))))

@result{} (2 1 0)
@end group
@end smallexample

@noindent
@code{dotimes} returns @code{value}, so the way to use
@code{dotimes} is to operate on some expression @var{number} number of
times and then return the result, either as a list or an atom.

@need 1250
Here is an example of a @code{defun} that uses @code{dotimes} to add
up the number of pebbles in a triangle.

@smallexample
@group
(defun triangle-using-dotimes (number-of-rows)
  "Using dotimes, add up the number of pebbles in a triangle."
(let ((total 0))  ; otherwise a total is a void variable
  (dotimes (number number-of-rows total)
    (setq total (+ total (1+ number))))))

(triangle-using-dotimes 4)
@end group
@end smallexample

@node Recursion
@section 再帰
@cindex Recursion

再帰関数とは、自分自身を評価するようなコードを含んでいるものである。関数
が自分自身を評価した場合、それはまた自分自身を評価するコードに出くわす。
結果としてその関数はまた自分自身を評価し @dots{} となってこれがずっと続
く。再帰関数は自分自身止める条件を与えられない限り、永久に自分自身を繰り
返し呼び出し続けることになる。

（未訳）Eventually, if the program is written correctly, the `slightly
different arguments' will become sufficiently different from the first
arguments that the final instance will stop.

@menu
* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         再帰のテストにリストを使う
* Recursive triangle function::  @code{while} ループを再帰で置き換える
* Recursion with cond::         別の条件分岐を用いた再帰の例
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::
@end menu

@node Building Robots
@subsection Building Robots: Extending the Metaphor
@cindex Building robots
@cindex Robots, building

（未訳）It is sometimes helpful to think of a running program as a robot that
does a job.  In doing its job, a recursive function calls on a second
robot to help it.  The second robot is identical to the first in every
way, except that the second robot helps the first and has been
passed different arguments than the first.

（未訳）In a recursive function, the second robot may call a third; and the
third may call a fourth, and so on.  Each of these is a different
entity; but all are clones.

（未訳）Since each robot has slightly different instructions---the arguments
will differ from one robot to the next---the last robot should know
when to stop.

（未訳）Let's expand on the metaphor in which a computer program is a robot.

（未訳）A function definition provides the blueprints for a robot.  When you
install a function definition, that is, when you evaluate a
@code{defun} macro, you install the necessary equipment to build
robots.  It is as if you were in a factory, setting up an assembly
line.  Robots with the same name are built according to the same
blueprints.  So they have, as it were, the same `model number', but a
different `serial number'.

（未訳）We often say that a recursive function `calls itself'.  What we mean
is that the instructions in a recursive function cause the Lisp
interpreter to run a different function that has the same name and
does the same job as the first, but with different arguments.

（未訳）It is important that the arguments differ from one instance to the
next; otherwise, the process will never stop.

@node Recursive Definition Parts
@subsection The Parts of a Recursive Definition
@cindex Parts of a Recursive Definition
@cindex Recursive Definition Parts

再帰関数は、典型的には次のような三つの部分からなる条件分岐部を含んでいる。

@enumerate
@item
この関数がもう一度呼び出されるかどうかを決定する真偽テスト。ここでは
@dfn{do-again-test} と呼ぶ。

@item
この関数の名前

@item
条件分岐部が正しい回数だけ繰り返しを行った後に偽を返すようにするためのＳ
式。ここでは @dfn{next-step-expression} と呼ぶ。
@end enumerate

再帰関数は、他の種類の関数に比べて最も簡単な形に書ける。実際、再帰関数を
使い始めると、しばしば奇妙な程単純な形になってしまい、不可解な感じがする
ことが多いようである。再帰関数の定義を読むためには、ある種のコツが必要で、
最初は難しく思えても、慣れると単純であることが分ってくる。初めて自転車に
乗るときと同じである。

@need 1200
There are several different common recursive patterns.  A very simple
pattern looks like this:
（旧訳）再帰関数のテンプレートは次のようになる。

@smallexample
@group
(defun @var{再帰関数名} (@var{変数リスト})
  "@var{説明文字列}@dots{}"
  @var{本体}@dots{}
  (if @var{do-again-test}
    (@var{再帰関数名}
         @var{next-step-expression})))
@end group
@end smallexample

Each time a recursive function is evaluated, a new instance of it is
created and told what to do.  The arguments tell the instance what to do.

引数が next-step-expression の値にバイン
ドされ、そしてその値が do-again-test で使われる。

next-step-expression は
関数をもう繰り返す必要がなくなった場合に do-again-test が偽を返すように
設計されている。

The value returned by the next-step-expression is passed to the new
instance of the function, which evaluates it (or some
transmogrification of it) to determine whether to continue or stop.
The next-step-expression is designed so that the do-again-test returns
false when the function should no longer be repeated.

The do-again-test is sometimes called the @dfn{stop condition},
since it stops the repetitions when it tests false.

do-again-test は @dfn{停止条件} (@dfn{stop-condition}) と呼ばれることも
ある。これはテストが偽の場合に繰り返しが止まるからである。

@node Recursion with list
@subsection List を使った再帰

先に挙げた、 @code{while} ループを使ったリストの要素を表示する関数の例は、
再帰的に書くことも可能である。次に、変数 @code{animals} の値をあるリスト
にセットするＳ式も含めて、そのコードを書いてみることにしよう。

この例は @file{*scratch*} バッファにコピーして、各々のＳ式をそのバッファ
で評価してやらなければならない。そして @code{(print-elements-recursively
animals)} を評価する際は @kbd{C-u C-x C-e} を使う必要がある。でないと、
Lisp インタプリタは結果をエコー領域に一行分だけしか表示してくれない。

また、カーソルを @code{print-elements-recursively} 関数の最後の閉じ括弧
の直後の、コメントの手前の位置に持っていって評価しないといけない。そうし
ないと、Lisp インタプリタはコメントまで評価しようとしてしまう。

@findex print-elements-recursively
@smallexample
@group
(setq animals '(giraffe gazelle lion tiger))

(defun print-elements-recursively (list)
  "Print each element of LIST on a line of its own.
Uses recursion."
  (print (car list))                  ; @r{本体}
  (if list                            ; @r{do-again-test}
      (print-elements-recursively     ; @r{再帰呼び出し}
       (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

（旧訳）@code{print-elements-recursively} 関数は最初にリストの一番目の引数、即ち、
リストの @sc{car} を表示する。そしてもしリストが空でなければ、この関数内
で自分自身を呼び出す。ただし引数としては、全体のリストではなく二番目以降
の要素からなるリスト、即ち、そのリストの @sc{cdr} を渡す。

Put another way, if the list is not empty, the function invokes
another instance of code that is similar to the initial code, but is a
different thread of execution, with different arguments than the first
instance.

Put in yet another way, if the list is not empty, the first robot
assembles a second robot and tells it what to do; the second robot is
a different individual from the first, but is the same model.

この時の評価では、この関数は引数として受け取ったリストの最初の要素 (これ
は元々のリストでは二番目の要素であたる) を表示する。そして @code{if} 式
が評価され、それが真であれば、この関数は自分自身を今回受け取った引数の
@sc{cdr} (これは、元々のリストの @sc{cdr} の @sc{cdr} である) を引数とし
て再度自分自身を呼び出す。

Note that although we say that the function `calls itself', what we
mean is that the Lisp interpreter assembles and instructs a new
instance of the program.  The new instance is a clone of the first,
but is a separate individual.

関数が自分自身を呼び出す度に、引数として渡されるリストは元々のリストに比べ
て短くなっていき、結果として最後には空リストとともに呼び出すことになる。
@code{print} 関数は空リストを @code{nil} として表示する。そして次に条件
分岐の部分が @code{list} の値をテストする。@code{list} は @code{nil} な
ので、@code{if} 式は偽を返し、もはや then-part は実行しない。関数全体と
しては @code{nil} が返されるので、この関数を評価すると最後に二回
@code{nil} が現れる。

Eventually, the function invokes itself on an empty list.  It creates
a new instance whose argument is @code{nil}.  The conditional expression
tests the value of @code{list}.  Since the value of @code{list} is
@code{nil}, the @code{when} expression tests false so the then-part is
not evaluated.  The function as a whole then returns @code{nil}.

@need 1200
@code{(print-elements-recursively animals)} を @file{*scratch*} バッファ
で評価すると、次のような結果が表示されるはずだ。

@smallexample
@group
gazelle

giraffe

lion

tiger

nil
nil
@end group
@end smallexample

(最初の @code{nil} は空リストの値が表示されたものであり、二番目の
@code{nil} は関数全体の値である。)

@need 2000
@node Recursive triangle function
@subsection カウンタの代わりに再帰を使う
@findex triangle-recursively

前節で説明した @code{triangle} 関数もまた再帰的に書ける。これは次のよう
になる。

@smallexample
@group
(defun triangle-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{再帰呼び出し}
        (1- number)))))               ; @r{next-step-expression}

(triangle-recursively 7)
@end group
@end smallexample

@noindent
これを評価することでこの関数をインストールし、試しに
@code{(triangle-recursively 7)} を評価してみよう。(カーソルを関数定義の
直後の、コメントの手前の位置に持っていって評価することを忘れずに。)
The function evaluates to 28.

この関数がどのように動作するかを確かめるため、この関数に1、2、3、4等の様々
な引数を与えた場合に何が起きるかを考えてみよう。

@menu
* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::
@end menu

@ifnottex
@node Recursive Example arg of 1 or 2
@unnumberedsubsubsec 引数が1か2の場合の再帰関数の動作
@end ifnottex


まず引数の値が1だとどうなるか？

この関数では説明文字列の後に @code{if} 式がくる。これは @code{number} の
値が1かどうかテストするものである。もし1であれば、Emacs は @code{if} 式
の then-part を評価する。この場合は関数の値として1が返される。(一行から
なる三角形の中には小石は1つしかない。)

では引数の値が2であればどうだろう。この場合は Emacs は @code{if} 式の
else-part を評価する。

@need 1200
今の場合、else-part は足し算と @code{triangle-recursively} の
再帰呼び出し、そしてデクリメントからなっている。具体的には次の通り。

@smallexample
(+ number (triangle-recursively (1- number)))
@end smallexample

Emacs がこのＳ式を評価する時は、まず最も内側のＳ式から評価していき、順に
他の部分を評価していく。詳しく書くと次のようなステップを踏むことになる。

@table @i
@item Step 1 @w{  } 最も内側のＳ式の評価。

今の場合、最も内側のＳ式は @code{(1- number)} なので、Emacs は
@code{number} を2から1に減らす。

@item Step 2 @w{  } @code{triangle-recursively} 関数の評価。

（旧訳）この関数が自分自身の内部に含まれていることとは関係なく、Emacs は Step 1
の結果をこの関数の引数として渡す。

The Lisp interpreter creates an individual instance of
@code{triangle-recursively}.  It does not matter that this function is
contained within itself.  Emacs passes the result Step 1 as the
argument used by this instance of the @code{triangle-recursively}
function

今の場合、Emacs は @code{triangle-recursively} を引数1とともに評価する。
さっき見たように、この場合この関数は1を返す。

@item Step 3 @w{  } @code{number} の値の評価。

ここでいう変数 @code{number} は @code{+} で始まるリストの二番目の要素。
その値は2である。

@item Step 4 @w{  } @code{+} 式の評価。

@code{+} 式は二つの引数を受け取る。一つ目は @code{number} を評価して返さ
れた値 (Step 3) であり、二つ目は @code{triangle-recursively} を評価して
返された値 (Step 2) である。

足し算の結果は2と1の和であり、3が返される。これは正しい結果である。
二行からなる三角形の中には小石は3個含まれる。
@end table

@node Recursive Example arg of 3 or 4
@unnumberedsubsubsec 引数3か4の場合

@code{triangle-recursively} が引数3とともに呼び出されたとする。

@table @i
@item Step 1 @w{  } do-again-test の評価。

まずは @code{if} 式が評価される。これは do-again-test であり、偽が返され
る。従って、@code{if} 式の else-part が評価される。(この例では、テストの
結果が真の時ではなく偽の時に自分自身を再帰呼び出しすることに注意しよう。)

@item Step 2 @w{  } else-part のもっとも内側のＳ式の評価。

else-part の最も内側のＳ式が評価され、3が2にデクリメントされる。これ
が next-step-expression である。

@item Step 3 @w{  } @code{triangle-recursively} 関数の評価。

数値2が @code{triangle-recursively} 関数に渡される。

前節で説明した通り、@code{triangle-recursively} は引数2とともに評価さ
れると3を返すのであった。

@item Step 4 @w{  } 足し算の評価。

足し算の式では3がこの時の @code{number} の値3に加えられる。
@end table

@noindent
全体として、この関数が返す値は6になる。

以上で @code{triangle-recursively} に引数3を与えるとどうなるかが分った。
もはや引数が4の場合に何が起きるかは明らかであろう。次のような感じだ。

@quotation
@need 800
再帰呼び出しで

@smallexample
(triangle-recursively (1- 4))
@end smallexample

@need 800
@noindent
が評価され、結果として

@smallexample
(triangle-recursively 3)
@end smallexample

@noindent
の値を返す。これは6であり、この値に三行目の足し算で4が加えられる。
@end quotation

@noindent
全体としてこの関数が返す値は10になる。

（旧訳）@code{triangle-recursively} が評価されるごとに、より小さい引数とともに自
分自身を評価し、その状況が、引数がもはや再帰呼び出しを起こさない程小さく
なるまで続けられるというわけである。

Each time @code{triangle-recursively} is evaluated, it evaluates a
version of itself---a different instance of itself---with a smaller
argument, until the argument is small enough so that it does not
evaluate itself.

Note that this particular design for a recursive function
requires that operations be deferred.

Before @code{(triangle-recursively 7)} can calculate its answer, it
must call @code{(triangle-recursively 6)}; and before
@code{(triangle-recursively 6)} can calculate its answer, it must call
@code{(triangle-recursively 5)}; and so on.  That is to say, the
calculation that @code{(triangle-recursively 7)} makes must be
deferred until @code{(triangle-recursively 6)} makes its calculation;
and @code{(triangle-recursively 6)} must defer until
@code{(triangle-recursively 5)} completes; and so on.

If each of these instances of @code{triangle-recursively} are thought
of as different robots, the first robot must wait for the second to
complete its job, which must wait until the third completes, and so
on.

There is a way around this kind of waiting, which we will discuss in
@ref{No Deferment, , Recursion without Deferments}.

@node Recursion with cond
@subsection @code{cond} を使った再帰の例
@findex cond

以前説明したバージョンの @code{triangle-recursively} は特殊形式
@code{if} を用いて書かれていた。これは @code{cond} と呼ばれる特殊形式を
用いても書くことが出来る。特殊形式 @code{cond} の名前は
@code{conditional} という単語の短縮形から来ている。

特殊形式 @code{cond} は Emacs Lisp では @code{if} ほど頻繁に使われている
とは言えないが、ここで説明する価値がある程度には使われている。

@need 800
@code{cond} 式のテンプレートは次の通りである。

@smallexample
@group
(cond
 @var{本体}@dots{})
@end group
@end smallexample

@noindent
ここで @var{本体} はリストの列である。

@need 800
本体の中身をもっと詳しく書くと次のような感じになる。

@smallexample
@group
(cond
 ((@var{最初の真偽テスト} @var{最初の結果部})
  (@var{二番目の} @var{二番目の結果部})
  (@var{三番目の} @var{三番目の結果部})
  @dots{})
@end group
@end smallexample

Lisp インタプリタが @code{cond} 式を評価する時は、まず @code{cond} の本
体のＳ式の列の最初のＳ式の最初の要素 (@sc{car} つまり真偽テストの部分)
から評価する。

もし、真偽テストが @code{nil} を返したなら、その式の残りの部分 (これを結
果部 (consequent) と呼ぼう) はスキップされて、次のＳ式の真偽テストが評価
される。こうして、もしあるＳ式で真偽テストが @code{nil} 以外の値を返した
なら、そのＳ式の結果部が評価される。結果部は一つでも複数でも構わない。複
数の場合は各々の式が順に評価されていき、最後の値が返される。もしそのＳ式
が結果部を持たなければ、真偽テストの結果が返される。(訳註：そして、真偽
テストが真であったＳ式以降は無視される。)

どのＳ式の真偽テストも偽を返した場合は @code{cond} 式は @code{nil} を返
す。

@need 1250
@code{cond} を使って書くと、@code{triangle} 関数は次のようになる。

@smallexample
@group
(defun triangle-using-cond (number)
  (cond ((<= number 0) 0)
        ((= number 1) 1)
        ((> number 1)
         (+ number (triangle-using-cond (1- number))))))
@end group
@end smallexample

@noindent
この例では、@code{cond} は number が0以下の場合は0を返し、1の場合は1を返
し、1より大きい場合は @code{(+ number (triangle-using-cond (1-
number)))} が評価される。

@node Recursive Patterns
@subsection Recursive Patterns
@cindex Recursive Patterns

Here are three common recursive patterns.  Each involves a list.
Recursion does not need to involve lists, but Lisp is designed for lists
and this provides a sense of its primal capabilities.

@menu
* Every::
* Accumulate::
* Keep::
@end menu

@node Every
@unnumberedsubsubsec Recursive Pattern: @emph{every}
@cindex Every, type of recursive pattern
@cindex Recursive pattern: every

In the @code{every} recursive pattern, an action is performed on every
element of a list.

@need 1500
The basic pattern is:

@itemize @bullet
@item
If a list be empty, return @code{nil}.
@item
Else, act on the beginning of the list (the @sc{car} of the list)
    @itemize @minus
    @item
    through a recursive call by the function on the rest (the
    @sc{cdr}) of the list,
    @item
    and, optionally, combine the acted-on element, using @code{cons},
    with the results of acting on the rest.
    @end itemize
@end itemize

@need 1500
Here is example:

@smallexample
@group
(defun square-each (numbers-list)
  "Square each of a NUMBERS LIST, recursively."
  (if (not numbers-list)                ; do-again-test
      nil
    (cons
     (* (car numbers-list) (car numbers-list))
     (square-each (cdr numbers-list))))) ; next-step-expression
@end group

@group
(square-each '(1 2 3))
    @result{} (1 4 9)
@end group
@end smallexample

@need 1200
@noindent
If @code{numbers-list} is empty, do nothing.  But if it has content,
construct a list combining the square of the first number in the list
with the result of the recursive call.

(The example follows the pattern exactly: @code{nil} is returned if
the numbers' list is empty.  In practice, you would write the
conditional so it carries out the action when the numbers' list is not
empty.)

The @code{print-elements-recursively} function (@pxref{Recursion with
list, , Recursion with a List}) is another example of an @code{every}
pattern, except in this case, rather than bring the results together
using @code{cons}, we print each element of output.

@need 1250
The @code{print-elements-recursively} function looks like this:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))
@end group

@group
(defun print-elements-recursively (list)
  "Print each element of LIST on a line of its own.
Uses recursion."
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

@need 1500
The pattern for @code{print-elements-recursively} is:

@itemize @bullet
@item
When the list is empty, do nothing.
@item
But when the list has at least one element,
    @itemize @minus
    @item
    act on the beginning of the list (the @sc{car} of the list),
    @item
    and make a recursive call on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@node Accumulate
@unnumberedsubsubsec Recursive Pattern: @emph{accumulate}
@cindex Accumulate, type of recursive pattern
@cindex Recursive pattern: accumulate

Another recursive pattern is called the @code{accumulate} pattern.  In
the @code{accumulate} recursive pattern, an action is performed on
every element of a list and the result of that action is accumulated
with the results of performing the action on the other elements.

This is very like the `every' pattern using @code{cons}, except that
@code{cons} is not used, but some other combiner.

@need 1500
The pattern is:

@itemize @bullet
@item
If a list be empty, return zero or some other constant.
@item
Else, act on the beginning of the list (the @sc{car} of the list),
    @itemize @minus
    @item
    and combine that acted-on element, using @code{+} or
    some other combining function, with
    @item
    a recursive call by the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@need 1500
Here is an example:

@smallexample
@group
(defun add-elements (numbers-list)
  "Add the elements of NUMBERS-LIST together."
  (if (not numbers-list)
      0
    (+ (car numbers-list) (add-elements (cdr numbers-list)))))
@end group

@group
(add-elements '(1 2 3 4))
    @result{} 10
@end group
@end smallexample

@xref{Files List, , Making a List of Files}, for an example of the
accumulate pattern.

@node Keep
@unnumberedsubsubsec Recursive Pattern: @emph{keep}
@cindex Keep, type of recursive pattern
@cindex Recursive pattern: keep

A third recursive pattern is called the @code{keep} pattern.
In the @code{keep} recursive pattern, each element of a list is tested;
the element is acted on and the results are kept only if the element
meets a criterion.

Again, this is very like the `every' pattern, except the element is
skipped unless it meets a criterion.

@need 1500
The pattern has three parts:

@itemize @bullet
@item
If a list be empty, return @code{nil}.
@item
Else, if the beginning of the list (the @sc{car} of the list) passes
        a test
    @itemize @minus
    @item
    act on that element and combine it, using @code{cons} with
    @item
    a recursive call by the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@item
Otherwise, if the beginning of the list (the @sc{car} of the list) fails
the test
    @itemize @minus
    @item
    skip on that element,
    @item
    and, recursively call the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@need 1500
Here is an example that uses @code{cond}:

@smallexample
@group
(defun keep-three-letter-words (word-list)
  "Keep three letter words in WORD-LIST."
  (cond
   ;; First do-again-test: stop-condition
   ((not word-list) nil)

   ;; Second do-again-test: when to act
   ((eq 3 (length (symbol-name (car word-list))))
    ;; combine acted-on element with recursive call on shorter list
    (cons (car word-list) (keep-three-letter-words (cdr word-list))))

   ;; Third do-again-test: when to skip element;
   ;;   recursively call shorter list with next-step expression
   (t (keep-three-letter-words (cdr word-list)))))
@end group

@group
(keep-three-letter-words '(one two three four five six))
    @result{} (one two six)
@end group
@end smallexample

It goes without saying that you need not use @code{nil} as the test for
when to stop; and you can, of course, combine these patterns.

@node No Deferment
@subsection Recursion without Deferments
@cindex Deferment in recursion
@cindex Recursion without Deferments

Let's consider again what happens with the @code{triangle-recursively}
function.  We will find that the intermediate calculations are
deferred until all can be done.

@need 800
Here is the function definition:

@smallexample
@group
(defun triangle-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{recursive call}
        (1- number)))))               ; @r{next-step-expression}
@end group
@end smallexample

What happens when we call this function with a argument of 7?

The first instance of the @code{triangle-recursively} function adds
the number 7 to the value returned by a second instance of
@code{triangle-recursively}, an instance that has been passed an
argument of 6.  That is to say, the first calculation is:

@smallexample
(+ 7 (triangle-recursively 6))
@end smallexample

@noindent
The first instance of @code{triangle-recursively}---you may want to
think of it as a little robot---cannot complete its job.  It must hand
off the calculation for @code{(triangle-recursively 6)} to a second
instance of the program, to a second robot.  This second individual is
completely different from the first one; it is, in the jargon, a
`different instantiation'.  Or, put another way, it is a different
robot.  It is the same model as the first; it calculates triangle
numbers recursively; but it has a different serial number.

And what does @code{(triangle-recursively 6)} return?  It returns the
number 6 added to the value returned by evaluating
@code{triangle-recursively} with an argument of 5.  Using the robot
metaphor, it asks yet another robot to help it.

@need 800
Now the total is:

@smallexample
(+ 7 6 (triangle-recursively 5))
@end smallexample

@need 800
And what happens next?

@smallexample
(+ 7 6 5 (triangle-recursively 4))
@end smallexample

Each time @code{triangle-recursively} is called, except for the last
time, it creates another instance of the program---another robot---and
asks it to make a calculation.

@need 800
Eventually, the full addition is set up and performed:

@smallexample
(+ 7 6 5 4 3 2 1)
@end smallexample

This design for the function defers the calculation of the first step
until the second can be done, and defers that until the third can be
done, and so on.  Each deferment means the computer must remember what
is being waited on.  This is not a problem when there are only a few
steps, as in this example.  But it can be a problem when there are
more steps.

@node No deferment solution
@subsection No Deferment Solution
@cindex No deferment solution
@cindex Defermentless solution
@cindex Solution without deferment

The solution to the problem of deferred operations is to write in a
manner that does not defer operations@footnote{The phrase @dfn{tail
recursive} is used to describe such a process, one that uses
`constant space'.}.  This requires
writing to a different pattern, often one that involves writing two
function definitions, an `initialization' function and a `helper'
function.

The `initialization' function sets up the job; the `helper' function
does the work.

@need 1200
Here are the two function definitions for adding up numbers.  They are
so simple, I find them hard to understand.

@smallexample
@group
(defun triangle-initialization (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
This is the `initialization' component of a two function
duo that uses recursion."
  (triangle-recursive-helper 0 0 number))
@end group
@end smallexample

@smallexample
@group
(defun triangle-recursive-helper (sum counter number)
  "Return SUM, using COUNTER, through NUMBER inclusive.
This is the `helper' component of a two function duo
that uses recursion."
  (if (> counter number)
      sum
    (triangle-recursive-helper (+ sum counter)  ; @r{sum}
                               (1+ counter)     ; @r{counter}
                               number)))        ; @r{number}
@end group
@end smallexample

@need 1250
Install both function definitions by evaluating them, then call
@code{triangle-initialization} with 2 rows:

@smallexample
@group
(triangle-initialization 2)
    @result{} 3
@end group
@end smallexample

The `initialization' function calls the first instance of the `helper'
function with three arguments: zero, zero, and a number which is the
number of rows in the triangle.

The first two arguments passed to the `helper' function are
initialization values.  These values are changed when
@code{triangle-recursive-helper} invokes new instances.@footnote{The
jargon is mildly confusing:  @code{triangle-recursive-helper} uses a
process that is iterative in a procedure that is recursive.  The
process is called iterative because the computer need only record the
three values, @code{sum}, @code{counter}, and @code{number}; the
procedure is recursive because the function `calls itself'.  On the
other hand, both the process and the procedure used by
@code{triangle-recursively} are called recursive.  The word
`recursive' has different meanings in the two contexts.}

Let's see what happens when we have a triangle that has one row.  (This
triangle will have one pebble in it!)

@need 1200
@code{triangle-initialization} will call its helper with
the arguments @w{@code{0 0 1}}.  That function will run the conditional
test whether @code{(> counter number)}:

@smallexample
(> 0 1)
@end smallexample

@need 1200
@noindent
and find that the result is false, so it will invoke
the else-part of the @code{if} clause:

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum plus counter} @result{} @r{sum}
     (1+ counter)     ; @r{increment counter} @result{} @r{counter}
     number)          ; @r{number stays the same}
@end group
@end smallexample

@need 800
@noindent
which will first compute:

@smallexample
@group
(triangle-recursive-helper (+ 0 0)  ; @r{sum}
                           (1+ 0)   ; @r{counter}
                           1)       ; @r{number}
@exdent which is:

(triangle-recursive-helper 0 1 1)
@end group
@end smallexample

Again, @code{(> counter number)} will be false, so again, the Lisp
interpreter will evaluate @code{triangle-recursive-helper}, creating a
new instance with new arguments.

@need 800
This new instance will be;

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum plus counter} @result{} @r{sum}
     (1+ counter)     ; @r{increment counter} @result{} @r{counter}
     number)          ; @r{number stays the same}

@exdent which is:

(triangle-recursive-helper 1 2 1)
@end group
@end smallexample

In this case, the @code{(> counter number)} test will be true!  So the
instance will return the value of the sum, which will be 1, as
expected.

Now, let's pass @code{triangle-initialization} an argument
of 2, to find out how many pebbles there are in a triangle with two rows.

That function calls @code{(triangle-recursive-helper 0 0 2)}.

@need 800
In stages, the instances called will be:

@smallexample
@group
                          @r{sum counter number}
(triangle-recursive-helper 0    1       2)

(triangle-recursive-helper 1    2       2)

(triangle-recursive-helper 3    3       2)
@end group
@end smallexample

When the last instance is called, the @code{(> counter number)} test
will be true, so the instance will return the value of @code{sum},
which will be 3.

This kind of pattern helps when you are writing functions that can use
many resources in a computer.

@need 1500
@node Looping exercise
@section ループについての練習問題

@itemize @bullet
@item
各々の行の値が行番号の自乗であるような場合に、@code{triangle} 関数と同様
な関数を書きなさい。ただし、@code{while} ループを使うこと。

@item
@code{triangle} 関数と同様だが、各々の行の値を足すのでは無く、掛けていく
ような関数を書きなさい。

@item
上の二つの関数を再帰的な関数に書き直しなさい。また、@code{cond} を使って
書き直しなさい。

@c comma in printed title causes problem in Info cross reference
@item
Texinfo モードのために、パラグラフの中に含まれる全ての @samp{@@dfn} に対
する索引の項目をそのパラグラフの最初に作成するような関数を書きなさい。
(Texinfo ファイルでは、@samp{@@dfn} が定義の印になっている。本書は
Texinfo で書かれている。)

（未訳）Many of the functions you will need are described in two of the
previous chapters, @ref{Cutting & Storing Text, , Cutting and Storing
Text}, and @ref{Yanking, , Yanking Text Back}.  If you use
@code{forward-paragraph} to put the index entry at the beginning of
the paragraph, you will have to use @w{@kbd{C-h f}}
(@code{describe-function}) to find out how to make the command go
backwards.

（未訳）For more information, see
@ifinfo
@ref{Indicating, , Indicating Definitions, texinfo}.
@end ifinfo
@ifhtml
@ref{Indicating, , Indicating, texinfo, Texinfo Manual}, which goes to
a Texinfo manual in the current directory.  Or, if you are on the
Internet, see
@uref{http://www.gnu.org/software/texinfo/manual/texinfo/}
@end ifhtml
@iftex
``Indicating Definitions, Commands, etc.'' in @cite{Texinfo, The GNU
Documentation Format}.
@end iftex
@end itemize

@node Regexp Search
@chapter 正規表現の検索
@cindex Searches, illustrating
@cindex Regular expression searches
@cindex Patterns, searching for
@cindex Motion by sentence and paragraph
@cindex Sentences, movement by
@cindex Paragraphs, movement by

GNU Emacs の中では、正規表現の検索が徹底的に活用されている。例えば、
@code{forward-sentence} とか @code{forward-paragraph} といった関数を調
べてみれば、こういった検索についてよく理解出来るだろう。

正規表現の検索は @ref{Regexp Search, , Regular Expression Search, emacs,
The GNU Emacs Manual}, の中や @ref{Regular Expressions, , , elisp, The
GNU Emacs Lisp Reference Manual}, の中で説明されている。この章を書く際に
も、私は読者が少なくともこれらをある程度は知っていることを想定している。
大事な点は、正規表現を使うことで具体的な文字列そのものだけではなく、パター
ンをも検索出来るということである。例えば @code{forward-sentence} のコー
ドは文 (sentence) の終わりを示すパターンを検索し、その場所にポイントを移
動する。

実際に @code{forward-sentence} 関数のコードを見る前に、文の終わりを示すパ
ターンがどんなものであるべきかを考えておいた方が良いだろう。このパターン
については次のセクションで議論することにする。その次に、正規表現の検索を
行う関数である @code{re-search-forward} の説明をする。
@code{forward-sentence} 関数の説明はその後である。この章の最後の節では、
@code{forward-paragraph} 関数の説明をする。@code{forward-paragraph} は複雑
な関数なので、幾つか新しい特徴を紹介することになる。

@menu
* sentence-end::                @code{sentence-end} の正規表現
* re-search-forward::           @code{search-forward} とほぼ同じ
* forward-sentence::            正規表現検索の単純な例
* forward-paragraph::           もうちょっと複雑な例
* etags::                       @file{TAGS} テーブルの作り方
* Regexp Review::               正規表現の復習
* re-search Exercises::         正規表現の練習問題
@end menu

@node sentence-end
@section @code{sentence-end} の正規表現
@findex sentence-end

シンボル @code{sentence-end} は文末 (訳註：ここでは勿論英語の文章を想定
している。) を示すあるパターンにバインドされている。この正規表現はどうあ
るべきだろうか？

明らかに、文末には終止符か疑問符、もしくは感嘆符が来る。実際、この三つの
文字の中の一つで終了する文節だけが文末と見倣されるべきである。これはパター
ンの中に次の文字集合が含まれるということだ。

@smallexample
[.?!]
@end smallexample

しかしながら、@code{forward-sentence} が単に終止符や疑問符、感嘆符に移動
するというだけではまずい。というのも、これらの文字は文中にも使われること
があるからである。例えば終止符は略語の後にも使われる。従って、他の情報も
必要になる。

慣習的に、普通文末には二つの空白を打つが、文中の終止符、疑問符、感嘆符の
の後には一つの空白しか打たない。従って、終止符、疑問符、感嘆符に続いて二
つの空白というのが文末の良い目印になるだろう。ただし、ファイルの中では二
つの空白はタブや行末であっても良い。つまり、正規表現の中には、これら三つ
のどれかというものが含まれる。

@need 800
この部分は次のように書ける。

@smallexample
@group
\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
@end group
@end smallexample

@noindent
ここで @samp{$} は行末を表わす。それと、タブと二つの空白がこの表現の中に
入っていることを指摘しておく。両方とも、この表現の中に実際の文字が挿入さ
れている。

括弧や縦棒の前には二つのバックスラッシュ @samp{\\} が必要になる。最初の
バックスラッシュは、Emacs の中でその後に続くバックスラッシュを quote
するためのものであり、二番目のバックスラッシュは、その後に続く括弧や縦棒
が特殊文字であることを示すものである。

@need 1000
また、文の後には次のように一つ以上の復帰コードが続くこともある。

@smallexample
@group
[
]*
@end group
@end smallexample

@noindent
タブや空白と同様、復帰コードも実際のコードを埋め込むことで正規表現の中に
挿入される。末尾のアスタリスクは、@key{RET} が零回以上繰り返すことを示す。

ただ、文末が必ずしも終止符や疑問符、ないしは感嘆符に続いて空白で終ってい
るとは限らない。閉引用符や何らかの閉括弧が空白の前に来るかもしれない。実
際の所、このような記号が空白の前に二つ以上続くこともある。これらのために、
次のような表現が必要になる。

@smallexample
[]\"')@}]*
@end smallexample

この表現の中で、最初の @samp{]} が最初に来ていることに注意しよう。(訳註：
@samp{[} と @samp{]} で狭んで定める文字集合の中に @samp{]} を含めるには、
このように文字集合の最初に @samp{]} を記述する。) また、二番目の文字は
@samp{"} である。前の @samp{\} は Emacs にこれが特殊文字ではなく文字列の
一部だと伝えるためのものである。残りの三文字は、@samp{'}、@samp{)}、
@samp{@}} そのものを表わす。これらの文字が零回以上現れるということになる。

これら全てを合せたものが、あるべき文末の正規表現を形成している。そして、
実際に @code{sentence-end} を評価してみると、次のような値が返される。

@smallexample
@group
sentence-end
     @result{} "[.?!][]\"')@}]*\\($\\|     \\|  \\)[
]*"
@end group
@end smallexample

@noindent
（未訳）(Well, not in GNU Emacs 22; that is because of an effort to make the
process simpler and to handle more glyphs and languages.  When the
value of @code{sentence-end} is @code{nil}, then use the value defined
by the function @code{sentence-end}.  (Here is a use of the difference
between a value and a function in Emacs Lisp.)  The function returns a
value constructed from the variables @code{sentence-end-base},
@code{sentence-end-double-space}, @code{sentence-end-without-period},
and @code{sentence-end-without-space}.  The critical variable is
@code{sentence-end-base}; its global value is similar to the one
described above but it also contains two additional quotation marks.
These have differing degrees of curliness.  The
@code{sentence-end-without-period} variable, when true, tells Emacs
that a sentence may end without a period, such as text in Thai.)

@ignore
@noindent
(ここで、@kbd{TAB}、二つの空白、そして @kbd{RET} は表現の中に文字そのも
のが埋め込まれている。)

この正規表現は次のように解読出来る。

@table @code
@item [.?!]
表現の最初の部分は角括弧の中の終止符、疑問符、感嘆符の三つの文字である。
パターンはこれらの三つの文字の内、いずれかで始まっていなければならない。

@item []\"')@}]*
表現の二番目は、閉括弧や閉引用符のグループである。これらは零回以上続いて
良い。また、これらは終止符や疑問符、感嘆符の後に来る。正規表現の中では、
バックスラッシュ @samp{\} に続く二重引用符 @samp{"} は文字列引用文字のク
ラスを表わす。普通、このクラスに属するのは二重引用符だけである。アスタリ
スク @samp{*} は直前のグループ (角括弧 @samp{[]} で囲まれたグループ) が
零回以上続くことを示す。

@item \\($\\|   \\|  \\)
三番目のパターンは、行末か、タブか、二つの空白かのいずれかであるという意
味になる。二重のバックスラッシュは、Emacs にこの括弧や縦棒が検索パターン
の一部ではないことを伝えるためのものである。括弧はグループを作るためのも
ので、縦棒はそれによって区切られたどのパターンであっても良いことを示す。
ドルマークは行末を表し、タブと二つの空白はそのものが挿入されている。

@item [@key{RET}]*
最後に、一番後のパターンは行末や終止符、疑問符、感嘆符に続く空白の後に復
帰コードが来てもよいことを示している。実際のパターンの中では本当の復帰コー
ドが挿入されているのだが、ここでは @kbd{RET} として表示している。
@end table
@end ignore

@node re-search-forward
@section 関数 @code{re-search-forward}
@findex re-search-forward

@code{re-search-forward} 関数は、@code{search-forward} 関数と非常によく
似ている。(後者については、@ref{search-forward, , 関数
@code{search-forward}}, 参照。)

@code{re-search-forward} は正規表現を検索するためのものである。もし検索
が成功すれば、ただちに目的とする文字の後にポイントを移動する。後方検索の
場合は目的の文字の直後に移動する。検索成功時には
@code{re-search-forward} は @code{t} を返す。(訳註：Emacs version 19 で
はポイントの位置を返す。) (従って、ポイントの移動は「副作用」である。)

@code{search-forward} と同じく @code{re-search-forward} 関数も四つの引数
を持つ。

@enumerate
@item
最初の引数は、検索する正規表現である。正規表現は引用符に囲まれた文字列で
なければならない。

@item
二番目の引数は省略可能であり、関数が検索する範囲を制限するために用いる。
これはバッファの中の位置として指定される。

@item
三番目の引数も省略可能で、検索に失敗した場合の挙動を決めるためのものであ
る。もし引数が @code{nil} なら失敗時にはエラーが返され、メッセージが表示
される。他の値の場合は失敗時には @code{nil} が返り、成功時には @code{t}
が返される。(訳註：Emacs version 19 ではポイントの位置が返される。)

@item
四番目の引数は繰り返しの回数である。負の引数を与えると、後方検索になる。
@end enumerate

@need 800
@code{re-search-forward} のテンプレートは次の通りである。

@smallexample
@group
(re-search-forward "@var{正規表現}"
                @var{検索範囲の限界}
                @var{検索失敗時の動作}
                @var{繰り返しの回数})
@end group
@end smallexample

二番目から四番目までの引数は省略可能である。しかし、最後の二つの片方ない
しは両方に値を渡したい場合は、それ以前の全ての引数を与えなければならない。
そうしないと Lisp インタプリタはどの引数を何処へ渡すかを間違えてしまう。

@need 1200
@code{forward-sentence} 関数では、正規表現は変数 @code{sentence-end} の
値である。つまり、次の通りである。

@smallexample
@group
"[.?!][]\"')@}]*\\($\\|  \\|  \\)[
]*"
@end group
@end smallexample

@noindent
検索の限界はパラグラフの終わりまでである (文がパラグラフを越えて続くこと
はないので)。検索に失敗した場合は @code{nil} が返される。また、繰り返し
の回数は @code{forward-sentence} の引数として与えられる。

@node forward-sentence
@section @code{forward-sentence}
@findex forward-sentence

カーソルを文の前方に移動するコマンドは、Emacs Lisp での正規表現検索の使
い方をストレートに説明してくれる。この関数は、実際以上に長くて複雑そうに
見えるが、それは、前方に検索するだけではなく後方にも検索出来るようになっ
ていたり、オプションとして複数の文を移動することが出来るようになっている
ためである。この関数は通常は @kbd{M-e} というキーにバインドされている。

@menu
* Complete forward-sentence::
* fwd-sentence while loops::    二つの @code{while} ループ
* fwd-sentence re-search::      正規表現検索
@end menu

@ifnottex
@node Complete forward-sentence
@unnumberedsubsec Complete @code{forward-sentence} function definition
@end ifnottex

@need 1250
以下が @code{forward-sentence} のコードである。

@c in GNU Emacs 22
@smallexample
@group
(defun forward-sentence (&optional arg)
  "Move forward to next `sentence-end'.  With argument, repeat.
With negative argument, move backward repeatedly to `sentence-beginning'.

The variable `sentence-end' is a regular expression that matches ends of
sentences.  Also, every paragraph boundary terminates sentences as well."
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point))
        (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       (if (and (re-search-backward sentence-end par-beg t)
                (or (< (match-end 0) pos)
                    (re-search-backward sentence-end par-beg t)))
           (goto-char (match-end 0))
         (goto-char par-beg)))
      (setq arg (1+ arg)))
@end group
@group
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       (if (re-search-forward sentence-end par-end t)
           (skip-chars-backward " \t\n")
         (goto-char par-end)))
      (setq arg (1- arg)))
    (constrain-to-field nil opoint t)))
@end group
@end smallexample

@ignore
GNU Emacs 21
@smallexample
@group
(defun forward-sentence (&optional arg)
  "Move forward to next sentence-end.  With argument, repeat.
With negative argument, move backward repeatedly to sentence-beginning.
Sentence ends are identified by the value of sentence-end
treated as a regular expression.  Also, every paragraph boundary
terminates sentences as well."
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (while (< arg 0)
    (let ((par-beg
           (save-excursion (start-of-paragraph-text) (point))))
      (if (re-search-backward
           (concat sentence-end "[^ \t\n]") par-beg t)
          (goto-char (1- (match-end 0)))
        (goto-char par-beg)))
    (setq arg (1+ arg)))
  (while (> arg 0)
    (let ((par-end
           (save-excursion (end-of-paragraph-text) (point))))
      (if (re-search-forward sentence-end par-end t)
          (skip-chars-backward " \t\n")
        (goto-char par-end)))
    (setq arg (1- arg))))
@end group
@end smallexample
@end ignore

ぱっと見ただけだと、この関数は長く感じてしまう。まずは骨組みを見て、それ
から肉の部分を見ていくのが賢明だろう。骨組みを見るには、桁が左にあるもの
から見て行けば良い。

@smallexample
@group
(defun forward-sentence (&optional arg)
  "@var{説明文字列}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point)) (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       @var{rest-of-body-of-while-loop-when-going-backwards}
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       @var{rest-of-body-of-while-loop-when-going-forwards}
    @var{handle-forms-and-equivalent}
@end group
@end smallexample

こう書き直すとぐっと解りやすくなる。この関数定義は説明文字列と
@code{interactive} 式、そして @code{or} 式と @code{while} ループからなっ
ているのである。

では順に各々の部分を見ていくことにしよう。

まず、説明文字列が過不足なくかつ理解しやすく書かれていることに注意しよう。

この関数は @code{interactive "p"} 宣言を持っている。これは、(もし与えら
れたなら) 処理された前置引数が引数としてこの関数に渡されることを意味する。
(これは数値である。) もしこの関数が引数を渡されなければ (引数は省略可能
である) その場合、引数 @code{arg} は1にバインドされる。また、
@code{forward-sentence} が非インタラクティブに引数無しで呼ばれた場合には、
@code{arg} は @code{nil} にバインドされる。

前置引数を扱うのは @code{or} 式である。この式では、@code{arg} の値がある
値にバインドされている場合はそのままにしておき、もし @code{nil} にバイン
ドされていた場合は1にセットしている。

When @code{forward-sentence} is called non-interactively without an
argument, @code{arg} is bound to @code{nil}.  The @code{or} expression
handles this.  What it does is either leave the value of @code{arg} as
it is, but only if @code{arg} is bound to a value; or it sets the
value of @code{arg} to 1, in the case when @code{arg} is bound to
@code{nil}.

Next is a @code{let}.  That specifies the values of two local
variables, @code{point} and @code{sentence-end}.  The local value of
point, from before the search, is used in the
@code{constrain-to-field} function which handles forms and
equivalents.  The @code{sentence-end} variable is set by the

@node fwd-sentence while loops
@unnumberedsubsec @code{while} ループ

@code{or} 式の後には、二つの @code{while} ループが続く。最初の
@code{while} ループには、前置引数が負の値ならば真を返すような真偽テスト
が含まれている。これは後方検索のためのものである。このループの本体は二番
目の @code{while} ループの本体とそっくりであるが全く同じではない。取り敢
えずこちらの方はとばして、二番目のループの方に集中することにしよう。

@need 1500
二番目の @code{while} ループはポイントを前方に移動するものである。骨組み
は次の通りである。

@smallexample
@group
(while (> arg 0)            ; @r{真偽テスト}
  (let @var{変数リスト}
    (if (@var{真偽テスト})
        @var{then-part}
      @var{else-part}
  (setq arg (1- arg))))     ; @code{while} @r{ループのデクリメンタ}
@end group
@end smallexample

この @code{while} ループはデクリメントタイプの物である
(@ref{Decrementing Loop, , 減少カウンタを使ったループ}, 参照)。
この中にはカウンタ (今の場合は変数 @code{arg}) が零よりも大きい間は真を
返すような真偽テストが含まれている。そして、ループを繰り返すごとにカウン
タの値を1減らすようなデクリメンタが含まれている。

もし @code{forward-sentence} に前置引数が与えられなかったなら、といって
もこれが普通の使い方だが、その場合 @code{while} ループは一度だけ繰り返す。
これは @code{arg} の値が1だからである。

@code{while} ループの本体は @code{let} 式からなる。これは局所変数を作成
する。また、その本体として @code{if} 式を持っている。

@need 1250
@code{while} ループの本体は次のようである。

@smallexample
@group
(let ((par-end
       (save-excursion (end-of-paragraph-text) (point))))
  (if (re-search-forward sentence-end par-end t)
      (skip-chars-backward " \t\n")
    (goto-char par-end)))
@end group
@end smallexample

ここで @code{let} 式は局所変数 @code{par-end} を生成、バインドしている。
この後見るように、この局所変数は正規表現検索に限界ないしは制限を与えるた
めに用いられている。もしこの検索でパラグラフ内に適切な文末が見つからなけ
ればパラグラフの終端で検索をやめる。

が、その前にまずどうやって @code{par-end} がパラグラフの終端の値にバイン
ドされるかを見てみよう。ここでは @code{let} 式を使って、次のＳ式を Lisp
インタプリタが評価した際に返される値に @code{par-end} の値をセットしてい
る。

@smallexample
@group
(save-excursion (end-of-paragraph-text) (point))
@end group
@end smallexample

@noindent
この式では @code{(end-of-paragraph-text)} によってポイントがパラグラフ終
端に移動し、@code{(point)} によってそのポイントの値が返される。そして、
@code{save-excursion} によって元の位置にポイントが戻されるというわけであ
る。このようにして @code{let} は @code{par-end} に @code{save-excursion}
式が返す値、つまりパラグラフの終端の位置をバインドする。
(@code{end-of-paragraph-text} 関数は @code{forward-paragraph} を使ってい
る。これについては後で簡単に触れる。)

@need 1200
Emacs は次に @code{let} 式の本体を評価する。これは次のような
@code{if} 式である。

@smallexample
@group
(if (re-search-forward sentence-end par-end t) ; @r{if-part}
    (skip-chars-backward " \t\n")              ; @r{then-part}
  (goto-char par-end)))                        ; @r{else-part}
@end group
@end smallexample

@code{if} は最初の引数が真かどうかテストし、もし真なら then-part を評価
し、そうでなければ else-part を評価する。今の場合 @code{if} の真偽テスト
は正規表現検索である。

@code{forward-sentence} のような関数の実際の動作は奇妙に感じられるかもし
れない。しかし Lisp ではこのような操作が行われるのは、ごく一般的なことで
ある。
@c 何か変かなあ。原文は以下の通り
@c It may seem odd to have what looks like the `real work' of
@c the @code{forward-sentence} function buried here, but this is a common
@c way this kind of operation is carried out in Lisp.

@node fwd-sentence re-search
@unnumberedsubsec 正規表現の検索

@code{re-search-forward} 関数は文末、つまり正規表現 @code{sentence-end}
で定義されたパターンを検索する。もしパターンが見つかったなら---即ち文末
が見つかったなら---その時は @code{re-search-forward} 関数は二つのことを
行う。

@enumerate
@item
@code{re-search-forward} 関数は副作用を実行する。即ち、ポイントを見つけ
た文末まで移動する。

@item
@code{re-search-forward} 関数は真の値を返す。これは @code{if} によって返
される値であり、検索が成功したことを意味する。
@end enumerate

@noindent
副作用としてのポイントの移動は @code{if} 関数が検索成功の結果として値を
返すよりも前の時点に行われる。

@code{if} 関数が検索に成功した @code{re-search-forward} から呼び出されて
真の値を返す際には @code{if} は then-part、即ち@
@code{(skip-chars-backward "\t\n")} の評価も行う。このＳ式はタブや改行
などを含む全ての種類の空白文字を越えて、表示される文字 (printed
character) の所まで前に戻り、その文字の直後にポイントを置く。ポイントは
既に文末のパターンの所まで移動しているので、この動作で文が目に見える文字
で終わっている部分の直後に来ることになる。通常はピリオドだろう。

一方、もし @code{re-search-forward} 関数が文末パターンを見つけられなかっ
た場合には、関数は偽を返す。この場合は @code{if} は三番目の引数を評価す
る。これは @code{(goto-char par-end)} である。これはパラグラフの終わりに
までポイントを移動する関数である。

正規表現検索は極めて便利なものであり、@code{forward-sentence}---その中
では検索は @code{if} 式のテストになっている---で説明されたパターンは手軽
に使えるものである。あなたもこのパターンを取り入れたコードを見たり書いた
りするであろう。

@node forward-paragraph
@section @code{forward-paragraph}：関数の金脈
@findex forward-paragraph

@ignore
@c in GNU Emacs 22
(defun forward-paragraph (&optional arg)
  "Move forward to end of paragraph.
With argument ARG, do it ARG times;
a negative argument ARG = -N means move backward N paragraphs.

A line which `paragraph-start' matches either separates paragraphs
\(if `paragraph-separate' matches it also) or is the first line of a paragraph.
A paragraph end is the beginning of a line which is not part of the paragraph
to which the end of the previous line belongs, or the end of the buffer.
Returns the count of paragraphs left to move."
  (interactive "p")
  (or arg (setq arg 1))
  (let* ((opoint (point))
         (fill-prefix-regexp
          (and fill-prefix (not (equal fill-prefix ""))
               (not paragraph-ignore-fill-prefix)
               (regexp-quote fill-prefix)))
         ;; Remove ^ from paragraph-start and paragraph-sep if they are there.
         ;; These regexps shouldn't be anchored, because we look for them
         ;; starting at the left-margin.  This allows paragraph commands to
         ;; work normally with indented text.
         ;; This hack will not find problem cases like "whatever\\|^something".
         (parstart (if (and (not (equal "" paragraph-start))
                            (equal ?^ (aref paragraph-start 0)))
                       (substring paragraph-start 1)
                     paragraph-start))
         (parsep (if (and (not (equal "" paragraph-separate))
                          (equal ?^ (aref paragraph-separate 0)))
                     (substring paragraph-separate 1)
                   paragraph-separate))
         (parsep
          (if fill-prefix-regexp
              (concat parsep "\\|"
                      fill-prefix-regexp "[ \t]*$")
            parsep))
         ;; This is used for searching.
         (sp-parstart (concat "^[ \t]*\\(?:" parstart "\\|" parsep "\\)"))
         start found-start)
    (while (and (< arg 0) (not (bobp)))
      (if (and (not (looking-at parsep))
               (re-search-backward "^\n" (max (1- (point)) (point-min)) t)
               (looking-at parsep))
          (setq arg (1+ arg))
        (setq start (point))
        ;; Move back over paragraph-separating lines.
        (forward-char -1) (beginning-of-line)
        (while (and (not (bobp))
                    (progn (move-to-left-margin)
                           (looking-at parsep)))
          (forward-line -1))
        (if (bobp)
            nil
          (setq arg (1+ arg))
          ;; Go to end of the previous (non-separating) line.
          (end-of-line)
          ;; Search back for line that starts or separates paragraphs.
          (if (if fill-prefix-regexp
                  ;; There is a fill prefix; it overrides parstart.
                  (let (multiple-lines)
                    (while (and (progn (beginning-of-line) (not (bobp)))
                                (progn (move-to-left-margin)
                                       (not (looking-at parsep)))
                                (looking-at fill-prefix-regexp))
                      (unless (= (point) start)
                        (setq multiple-lines t))
                      (forward-line -1))
                    (move-to-left-margin)
                    ;; This deleted code caused a long hanging-indent line
                    ;; not to be filled together with the following lines.
                    ;; ;; Don't move back over a line before the paragraph
                    ;; ;; which doesn't start with fill-prefix
                    ;; ;; unless that is the only line we've moved over.
                    ;; (and (not (looking-at fill-prefix-regexp))
                    ;;      multiple-lines
                    ;;      (forward-line 1))
                    (not (bobp)))
                (while (and (re-search-backward sp-parstart nil 1)
                            (setq found-start t)
                            ;; Found a candidate, but need to check if it is a
                            ;; REAL parstart.
                            (progn (setq start (point))
                                   (move-to-left-margin)
                                   (not (looking-at parsep)))
                            (not (and (looking-at parstart)
                                      (or (not use-hard-newlines)
                                          (bobp)
                                          (get-text-property
                                           (1- start) 'hard)))))
                  (setq found-start nil)
                  (goto-char start))
                found-start)
              ;; Found one.
              (progn
                ;; Move forward over paragraph separators.
                ;; We know this cannot reach the place we started
                ;; because we know we moved back over a non-separator.
                (while (and (not (eobp))
                            (progn (move-to-left-margin)
                                   (looking-at parsep)))
                  (forward-line 1))
                ;; If line before paragraph is just margin, back up to there.
                (end-of-line 0)
                (if (> (current-column) (current-left-margin))
                    (forward-char 1)
                  (skip-chars-backward " \t")
                  (if (not (bolp))
                      (forward-line 1))))
            ;; No starter or separator line => use buffer beg.
            (goto-char (point-min))))))

    (while (and (> arg 0) (not (eobp)))
      ;; Move forward over separator lines...
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (looking-at parsep))
        (forward-line 1))
      (unless (eobp) (setq arg (1- arg)))
      ;; ... and one more line.
      (forward-line 1)
      (if fill-prefix-regexp
          ;; There is a fill prefix; it overrides parstart.
          (while (and (not (eobp))
                      (progn (move-to-left-margin) (not (eobp)))
                      (not (looking-at parsep))
                      (looking-at fill-prefix-regexp))
            (forward-line 1))
        (while (and (re-search-forward sp-parstart nil 1)
                    (progn (setq start (match-beginning 0))
                           (goto-char start)
                           (not (eobp)))
                    (progn (move-to-left-margin)
                           (not (looking-at parsep)))
                    (or (not (looking-at parstart))
                        (and use-hard-newlines
                             (not (get-text-property (1- start) 'hard)))))
          (forward-char 1))
        (if (< (point) (point-max))
            (goto-char start))))
    (constrain-to-field nil opoint t)
    ;; Return the number of steps that could not be done.
    arg))
@end ignore

@code{forward-paragraph} 関数はポイントをパラグラフの終わりまで移動する。
これは通常 @kbd{M-@}} にバインドされており、例えば @code{let*}、
@code{match-beginning}、@code{looking-at} のようなそれ自身も重要であるよ
うな他の幾つかの関数を利用している。

@code{forward-paragraph} 関数の定義は @code{forward-sentence} 関数の定義
に比べてかなり長い。これは各々の行が fill-prefix (行詰め接頭辞) で始まる
ようなパラグラフも相手にしなければならないためである。

Fill prefix は 各々の行の先頭に繰り返し現れる文字列からなる。例えば
Lisp コードでは便宜上パラグラフの各々の行が @samp{;;; } から始まる。また
テキストモードでは四つの空白文字インデントされたパラグラフの fill prefix
としてよく使われる。(Fill prefix についてのより詳しい情報は @ref{Fill
Prefix, , , emacs, The GNU Emacs Manual}, を参照せよ。)

Fill prefix があるということは、@code{forward-paragraph} 関数は、中の行
が左端から始まっているようなパラグラフの終わりを見つけるだけではなく、そ
のバッファの全て、ないしは多くの行がある fill prefix で始まっているよう
場合にもパラグラフの終わりを見つけなければならないということを意味する。

更に、時には fill prefix があっても無視した方が良い場合だってある。特に
空行でパラグラフが区切られているような場合などがそうだ。これにより、更に
複雑さが増す。

@menu
* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The @code{let*} expression.
* fwd-para while::              The forward motion @code{while} loop.
@end menu

@ifnottex
@node forward-paragraph in brief
@unnumberedsubsec Shortened @code{forward-paragraph} function definition
@end ifnottex

ここでは @code{forward-paragraph} 関数を全て書き出すのはやめて、その中の
一部だけを見ることにする。準備なしに読もうとすると、ちょっと臆してしまう
かもしれない。

@need 800
この関数のアウトラインは次のようである。

@smallexample
@group
(defun forward-paragraph (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let*
      @var{変数リスト}
    (while (and (< arg 0) (not (bobp)))        ; @r{後方に戻る場合のコード}
      @dots{}
    (while (and (> arg 0) (not (eobp)))       ; @r{前方に進む場合のコード}
      @dots{}
@end group
@end smallexample

関数の最初の部分はいつもの通りである。引数のリストには一つ省略可能な引数
があるだけである。次に説明文字列が続く。

インタラクティブ宣言の中の小文字の @samp{p} はもし前置引数があれば、それ
を処理してから関数に渡すことを意味する。これは数値であり、いくつ分のパラ
グラフを移動するかを表わす。次の行の @code{or} 式は関数に一つも引数が与
えられなかった場合を扱うための物である。これはこの関数がインタラクティブ
ではなく他のコードから呼び出された場合に起きる。これについては以前説明し
た。(@ref{forward-sentence, 関数 @code{forward-sentence}}, 参照。) ここ
までは、今まで慣れ親しんできた部分である。

@node fwd-para let
@unnumberedsubsec @code{let*} 式

@code{forward-paragraph} の次の行は @code{let*} 式で始まる。これは以前に
出てた式とは異なる。このシンボルは @code{let*} であって @code{let} では
ない。

特殊形式 @code{let*} は基本的に @code{let} と同じなのだが、Emacs が変数
を順にセットしていくため、変数リストの中で後に出てくる変数がそれ以前に出
てきた変数の値を参照することが出来る、という点のみが異なっている。

@ignore
( refappend save-excursion, , code save-excursion in code append-to-buffer .)
@end ignore

(@ref{append save-excursion, , @code{save-excursion} in @code{append-to-buffer}}.)

この関数の @code{let*} 式の中では Emacs は二つの変数
@code{fill-prefix-regexp} と @code{paragraph-separate} をバインドしてい
るのだが、@code{paragraph-separate} がバインドされる値は
@code{fill-prefix-regexp} の値に依存しているのである。

The variable @code{parsep} appears twice, first, to remove instances
of @samp{^}, and second, to handle fill prefixes.

The variable @code{opoint} is just the value of @code{point}.  As you
can guess, it is used in a @code{constrain-to-field} expression, just
as in @code{forward-sentence}.

シンボル @code{fill-prefix-regexp} は次のリストを
評価した値にセットされる。

@smallexample
@group
(and fill-prefix
     (not (equal fill-prefix ""))
     (not paragraph-ignore-fill-prefix)
     (regexp-quote fill-prefix))
@end group
@end smallexample

@noindent
これは最初の要素が関数 @code{and} であるようなＳ式である。

関数 @code{and} は各々の引数をそのどれかが @code{nil} を返すまで評価して
いく。どれかが @code{nil} を返した場合は @code{and} は @code{nil} を返す。
しかし、もしどの引数も @code{nil} を返さなければ、最後の引数を評価して返
された値を返す。(この場合、その値は nil ではないので、Lisp では真と見な
される。) 別の言い方をすれば、@code{and} は引数全てが真である場合にのみ
真を返すわけである。
@findex and

今の場合なら、@code{fill-prefix-regexp} は後に続く四つのＳ式を評価して全
て真 (即ち、非 @code{nil}) が返された場合にのみ、非@code{nil} の値を返す。
そうでない場合は @code{fill-prefix-regexp} は @code{nil} にバインドされる。

@table @code
@item fill-prefix
この変数を評価すると、もしあれば fill prefix の値が返される。fill prefix
が無い場合は @code{nil} が返る。

@item (not (equal fill-prefix "")
このＳ式は fill prefix があった場合にそれが空文字列、つまり文字を一つも
含まない文字列かどうかを判定する。空文字列は fill prefix としての役には
立たない。

@item (not paragraph-ignore-fill-prefix)
このＳ式は、もし変数 @code{paragraph-ignore-fill-prefix} が @code{t} 等
の真の値にセットされている場合に @code{nil} を返す。

@item (regexp-quote fill-prefix)
これは @code{and} 関数の最後の引数になる。もし @code{and} の全ての引数が
真であれば、@code{and} の値としてはこのＳ式を評価して返された値が返され
ることになる。そしてそれが fill-prefix-regexp の値になる。
@end table

@findex regexp-quote
@noindent
この @code{and} 式を評価して真が返された場合、@code{fill-prefix-regexp}
は @code{regexp-quote} によって修正された @code{fill-prefix} の値にバイ
ンドされる。@code{regexp-quote} は、文字列を読み取り、それのみにマッチし、
その他の文字列にはマッチしないような正規表現を返す。結局、fill prefix が
存在する場合、@code{fill-prefix-regexp} はその fill prefix の値にちょう
どマッチする値にセットされ、そうでなければ @code{nil} にセットされる。

The next two local variables in the @code{let*} expression are
designed to remove instances of @samp{^} from @code{parstart} and
@code{parsep}, the local variables which indicate the paragraph start
and the paragraph separator.  The next expression sets @code{parsep}
again.  That is to handle fill prefixes.

（旧訳）@code{let*} 式の二番目の局所変数は @code{paragraph-separate} である。こ
れは次のＳ式を評価して返された値にバインドされる。

This is the setting that requires the definition call @code{let*}
rather than @code{let}.  The true-or-false-test for the @code{if}
depends on whether the variable @code{fill-prefix-regexp} evaluates to
@code{nil} or some other value.

If @code{fill-prefix-regexp} does not have a value, Emacs evaluates
the else-part of the @code{if} expression and binds @code{parsep} to
its local value.  (@code{parsep} is a regular expression that matches
what separates paragraphs.)

（旧訳）もし @code{fill-prefix-regexp} が値を持たなかったなら、(訳註: つまり
@code{nil} であれば) Emacs は @code{if} 式の else-part を評価し、
@code{paragraph-separate} を現在の局所的な値にバインドする。
(@code{paragraph-separate} はパラグラフの区切りにマッチする正規表現であ
る。)

But if @code{fill-prefix-regexp} does have a value, Emacs evaluates
the then-part of the @code{if} expression and binds @code{parsep} to a
regular expression that includes the @code{fill-prefix-regexp} as part
of the pattern.

（旧訳）しかし、もし @code{fill-prefix-regexp} が値を持てば、(訳註: 真の値を持て
ば) Emacs は @code{if} 式の then-part を評価し、
@code{paragraph-separate} の値を @code{fill-prefix-regexp} をパターンの
一部として含むような正規表現にバインドする。

Specifically, @code{parsep} is set to the original value of the
paragraph separate regular expression concatenated with an alternative
expression that consists of the @code{fill-prefix-regexp} followed by
optional whitespace to the end of the line.  The whitespace is defined
by @w{@code{"[ \t]*$"}}.)  The @samp{\\|} defines this portion of the
regexp as an alternative to @code{parsep}.

（旧訳）より詳しく言うと @code{paragraph-separate} は、元々の
@code{paragraph-separate} の値を @code{fill-prefix-regexp} に空行を加え
た表現を連結した値にセットされることになる。@samp{^} は
@code{fill-prefix-regexp} が行頭に来なければならないことを意味し、その後
に空白が来ても良いことが、@w{@code{"[ \t]*$"}} で定義されている。
@samp{\\|} は、この正規表現か元の @code{paragraph-separate} かどちらかが
マッチしなければならないことを示すものである。

（未訳）According to a comment in the code, the next local variable,
@code{sp-parstart}, is used for searching, and then the final two,
@code{start} and @code{found-start}, are set to @code{nil}.

Now we get into the body of the @code{let*}.  The first part of the body
of the @code{let*} deals with the case when the function is given a
negative argument and is therefore moving backwards.  We will skip this
section.

（旧訳）では @code{let*} 式の本体部分に入ろう。本体の最初の部分では、この関数に
負の引数が与えらた場合、即ち後方に戻る場合を扱っている。この部分は省略す
ることにする。

@node fwd-para while
@unnumberedsubsec 前方に移動する場合の @code{while} ループ

The second part of the body of the @code{let*} deals with forward
motion.  It is a @code{while} loop that repeats itself so long as the
value of @code{arg} is greater than zero.  In the most common use of
the function, the value of the argument is 1, so the body of the
@code{while} loop is evaluated exactly once, and the cursor moves
forward one paragraph.

（旧訳）@code{let*} 式の本体の二番目の部分は前方に進む場合を扱っている。これは
@code{arg} が零よりも大きい間は繰り返すような @code{while} ループである。
この関数を使う場合、大抵この引数は1である。従って @code{while} ループの
本体はちょうど一度だけ実行され、それによりカーソルはパラグラフ一つ分だけ
移動する。

@ignore
(while (and (> arg 0) (not (eobp)))

  ;; Move forward over separator lines...
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  (unless (eobp) (setq arg (1- arg)))
  ;; ... and one more line.
  (forward-line 1)

  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart.
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))

    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))

    (if (< (point) (point-max))
        (goto-char start))))
@end ignore

This part handles three situations: when point is between paragraphs,
when there is a fill prefix and when there is no fill prefix.

@need 800
@code{while} ループは次のような形をしている。

@smallexample
@group
;; @r{going forwards and not at the end of the buffer}
(while (and (> arg 0) (not (eobp)))

  ;; @r{パラグラフとパラグラフの間に居る場合}
  ;; Move forward over separator lines...
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  ;;  @r{This decrements the loop}
  (unless (eobp) (setq arg (1- arg)))
  ;; ... and one more line.
  (forward-line 1)
@end group

@group
  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart;
      ;; we go forward line by line
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group

@group
    ;; There is no fill prefix;
    ;; we go forward character by character
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group

@group
    ;; and if there is no fill prefix and if we are not at the end,
    ;;     go to whatever was found in the regular expression search
    ;;     for sp-parstart
    (if (< (point) (point-max))
        (goto-char start))))
@end group
@end smallexample

@findex eobp

We can see that this is a decrementing counter @code{while} loop,
using the expression @code{(setq arg (1- arg))} as the decrementer.
That expression is not far from the @code{while}, but is hidden in
another Lisp macro, an @code{unless} macro.  Unless we are at the end
of the buffer---that is what the @code{eobp} function determines; it
is an abbreviation of @samp{End Of Buffer P}---we decrease the value
of @code{arg} by one.

（旧訳）分ることは、これは減少カウンタの @code{while} ループであり、デ
クリメンタとして @code{(setq (1- arg))} というＳ式を使っているということ
である。

（未訳）(If we are at the end of the buffer, we cannot go forward any more and
the next loop of the @code{while} expression will test false since the
test is an @code{and} with @code{(not (eobp))}.  The @code{not}
function means exactly as you expect; it is another name for
@code{null}, a function that returns true when its argument is false.)

（未訳）Interestingly, the loop count is not decremented until we leave the
space between paragraphs, unless we come to the end of buffer or stop
seeing the local value of the paragraph separator.

（未訳）That second @code{while} also has a @code{(move-to-left-margin)}
expression.  The function is self-explanatory.  It is inside a
@code{progn} expression and not the last element of its body, so it is
only invoked for its side effect, which is to move point to the left
margin of the current line.

@findex looking-at
The @code{looking-at} function is also self-explanatory; it returns
true if the text after point matches the regular expression given as
its argument.

（旧訳）@code{looking-at} は、ポイントの後に続くテキストが @code{looking-at} の
引数として与えられた正規表現にマッチする場合に真を返す関数である。


The rest of the body of the loop looks difficult at first, but makes
sense as you come to understand it.

@need 800
First consider what happens if there is a fill prefix:

@smallexample
@group
  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart;
      ;; we go forward line by line
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group
@end smallexample

@noindent
This expression moves point forward line by line so long
as four conditions are true:

@enumerate
@item
ポイントはバッファの最後ではない。

@item
We can move to the left margin of the text and are
not at the end of the buffer.

@item
ポイントに続くテキストはパラグラフの区切りではない。

@item
ポイントに続くパターンは fill prefix を表わす正規表現である。
@end enumerate

最後の条件はちょっと戸惑うかもしれないが、ポイントが
@code{forward-paragraph} 関数によって既に行頭に移動していることを思い出
せば納得出来るだろう。つまり、テキストに fill prefix があれば、
@code{looking-at} 関数がそれを見ることになるのである。

@need 1250
fill prefix がない場合に何が起こるかを考えてみる。

@smallexample
@group
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group
@end smallexample

@noindent
This @code{while} loop has us searching forward for
@code{sp-parstart}, which is the combination of possible whitespace
with a the local value of the start of a paragraph or of a paragraph
separator.  (The latter two are within an expression starting
@code{\(?:} so that they are not referenced by the
@code{match-beginning} function.)

@need 800
The two expressions,

@smallexample
@group
(setq start (match-beginning 0))
(goto-char start)
@end group
@end smallexample

@noindent
mean go to the start of the text matched by the regular expression
search.

The @code{(match-beginning 0)} expression is new.  It returns a number
specifying the location of the start of the text that was matched by
the last search.

（旧訳）
この中で、これまでで慣れ親しんでいない部分は @code{match-beginning} の使
い方だけである。この関数自体も初めて出てくるものだ。
@code{match-beginning} 関数は、最後に行った正規表現検索でマッチしたテキ
ストの始まりの位置を表わす数値を返す関数である。

The @code{match-beginning} function is used here because of a
characteristic of a forward search: a successful forward search,
regardless of whether it is a plain search or a regular expression
search, moves point to the end of the text that is found.  In this
case, a successful search moves point to the end of the pattern for
@code{sp-parstart}.

（旧訳）
ここで @code{match-beginning} 関数が使われているのは前方検索の性質のため
である。つまり、前方検索が成功した場合、通常の検索か正規表現の検索かどう
かにかかわらず、ポイントを見つけたテキストの位置にまで移動してしまう。今
の場合なら、検索に成功した場合はポイントは @code{paragraph-start} のパター
ンの終わりにまで移動するのだが、これは現在のパラグラフの終わりではなく、
次のパラグラフの始まりである。


However, we want to put point at the end of the current paragraph, not
somewhere else.  Indeed, since the search possibly includes the
paragraph separator, point may end up at the beginning of the next one
unless we use an expression that includes @code{match-beginning}.

（旧訳）
しかしながら、我々の目的はポイントを次のパラグラフの先頭ではなく現在のパ
ラグラフの終わりにまで移動することである。この二つの位置は、パラグラフと
パラグラフの間に幾つかの空行がある場合などでは、当然異なる。


@findex match-beginning
When given an argument of 0, @code{match-beginning} returns the
position that is the start of the text matched by the most recent
search.  In this case, the most recent search looks for
@code{sp-parstart}.  The @code{(match-beginning 0)} expression returns
the beginning position of that pattern, rather than the end position
of that pattern.

（旧訳）引数0で呼ばれた場合、 @code{match-beginning} は最も最近、正規表現の検索
に成功した位置を返す。今の場合、最も最近の正規表現の検索は
@code{paragraph-start} を探すものなので、@code{match-beginning} はそのパ
ターンの開始位置を返す。(終了位置ではない。) この開始位置は現在のパラグ
ラフの最後である。

(Incidentally, when passed a positive number as an argument, the
@code{match-beginning} function returns the location of point at that
parenthesized expression in the last search unless that parenthesized
expression begins with @code{\(?:}.  I don't know why @code{\(?:}
appears here since the argument is 0.)

（旧訳）
(ついでにいうと、引数として正の数が渡された場合、
@code{match-beginning} 関数は最後の正規表現の中の括弧でくくられた部分の表
現の開始位置を返す。これは便利な機能である。)

@need 1250
The last expression when there is no fill prefix is

@smallexample
@group
(if (< (point) (point-max))
    (goto-char start))))
@end group
@end smallexample

@noindent
This says that if there is no fill prefix and if we are not at the
end, point should move to the beginning of whatever was found by the
regular expression search for @code{sp-parstart}.

@code{forward-paragraph} 関数の完全な定義は、上に挙げた前方に進むコード
だけでなく、後方に戻るコードも含んでいる。

もし、この文書を GNU Emacs の中で読んでいるなら、この関数全体のコードを
見たい場合には @kbd{C-h f} (@code{describe-function}) とタイプし、
プロンプトが出たら関数名をタイプすれば良い。
（未訳）This gives you the function
documentation and the name of the library containing the function's
source.  Place point over the name of the library and press the RET
key; you will be taken directly to the source.  (Be sure to install
your sources!  Without them, you are like a person who tries to drive
a car with his eyes shut!)

@node etags
@section 自分自身の @file{TAGS} ファイルの作成
@findex etags
@cindex @file{TAGS} file, create own

簡単にソースの場所までジャンプ出来るように、あなた自身の @file{TAGS} ファ
イルを作成することが出来る。例えば、もしあなたの @file{~/emacs} ディレク
トリに沢山のファイルがあったとすると---何を隠そう、私もこの場所に137個の
@file{.el} ファイルがあり、その内17個をロードしているのだが---そのディレ
クトリに @file{TAGS} ファイルを作ることで、@code{grep} やその他の道具で
関数名を検索するよりはずっと簡単に、特定の関数の位置にジャンプすることが
出来るようになる。

If the @code{find-tag} function first asks you for the name of a
@file{TAGS} table, give it the name of a @file{TAGS} file such as
@file{/usr/local/src/emacs/src/TAGS}.  (The exact path to your
@file{TAGS} file depends on how your copy of Emacs was installed.  I
just told you the location that provides both my C and my Emacs Lisp
sources.)

@code{TAGS} ファイルは、Emacs の配布に含まれる @code{etags} プログラムを
使って作成出来る。普通、@code{etags} は Emacs が構築された時に一緒にコン
パイルされインストールされる。(ただし、@code{etags} は Emacs Lisp 関数や
Emacs の一部分ではない。これは C のプログラムである。)

You can also create your own @file{TAGS} file for directories that
lack one.

You often need to build and install tags tables yourself.  They are
not built automatically.  A tags table is called a @file{TAGS} file;
the name is in upper case letters.

You can create a @file{TAGS} file by calling the @code{etags} program
that comes as a part of the Emacs distribution.  Usually, @code{etags}
is compiled and installed when Emacs is built.  (@code{etags} is not
an Emacs Lisp function or a part of Emacs; it is a C program.)

@need 1250
@file{TAGS} ファイルを作成するには、まずこのファイルを作成したいディレク
トリに移動する。Emacs の中だと、@kbd{M-x cd} コマンドを使うか、そのディ
レクトリにあるファイルをビジットするか、あるいは @kbd{C-x d}
(@code{dired}) を使うことで移動することが出来る。そして

@smallexample
M-x compile RET etags *.el RET
@end smallexample

@noindent
とタイプしてやれば良い。

For example, if you have a large number of files in your
@file{~/emacs} directory, as I do---I have 137 @file{.el} files in it,
of which I load 12---you can create a @file{TAGS} file for the Emacs
Lisp files in that directory.

@need 1250
@code{etags} プログラムは普通のシェルで使える全
てのワイルドカードを理解出来る。例えば、もし二つのディレクトリに対して一
つの @file{TAGS} ファイルを作りたい場合は、二番目のディレクトリを
@file{../elisp/} だとして、次のようにタイプすればよい。

@smallexample
M-x compile RET etags *.el ../elisp/*.el RET
@end smallexample

@need 1250
また、@code{etags} が受け付けるオプションのリストを見たい場合には

@smallexample
M-x compile RET etags --help RET
@end smallexample

@noindent
とタイプする。

The @code{etags} program handles more than 20 languages, including
Emacs Lisp, Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java,
LaTeX, Pascal, Perl, PostScript, Python, TeX, Texinfo, makefiles, and
most assemblers.  The program has no switches for specifying the
language; it recognizes the language in an input file according to its
file name and contents.

（旧訳）@code{etags} プログラムは Emacs Lisp, Common Lisp, Scheme, C, Fortran,
Pascal, LaTeX, そして大抵のアセンブラを扱うことが出来る。このプログラム
には言語を特定するためのスィッチはない。その代わりにファイル名や中身から
そのファイルの言語を認識するのである。

また @file{etags} は、自分自身でコードを書いたり、既に書いた関数を後から
参照したりするのにも大変便利である。新しい関数を書いたら、ときおり
@code{etags} プログラムを走らせよう。そうすることでそれらの関数が
@file{TAGS} ファイルに付け加わる。

（未訳）If you think an appropriate @file{TAGS} file already exists for what
you want, but do not know where it is, you can use the @code{locate}
program to attempt to find it.

（未訳）Type @w{@kbd{M-x locate @key{RET} TAGS @key{RET}}} and Emacs will list
for you the full path names of all your @file{TAGS} files.  On my
system, this command lists 34 @file{TAGS} files.  On the other hand, a
`plain vanilla' system I recently installed did not contain any
@file{TAGS} files.

（未訳）If the tags table you want has been created, you can use the @code{M-x
visit-tags-table} command to specify it.  Otherwise, you will need to
create the tag table yourself and then use @code{M-x
visit-tags-table}.

@subsubheading Building Tags in the Emacs sources
@cindex Building Tags in the Emacs sources
@cindex Tags in the Emacs sources
@findex make tags

（未訳）The GNU Emacs sources come with a @file{Makefile} that contains a
sophisticated @code{etags} command that creates, collects, and merges
tags tables from all over the Emacs sources and puts the information
into one @file{TAGS} file in the @file{src/} directory. (The
@file{src/} directory is below the top level of your Emacs directory.)

@need 1250
（未訳）To build this @file{TAGS} file, go to the top level of your Emacs
source directory and run the compile command @code{make tags}:

@smallexample
M-x compile RET make tags RET
@end smallexample

@noindent
(The @code{make tags} command works well with the GNU Emacs sources,
as well as with some other source packages.)

For more information, see @ref{Tags, , Tag Tables, emacs, The GNU Emacs
Manual}.

@node Regexp Review
@section 復習

ここでは最近導入した関数の簡単なまとめを載せておく。

@table @code
@item while
本体部分のＳ式を、本体の最初の要素が真を返す間だけ繰り返し評価する。最後
は @code{nil} を返す。(つまり、この式は副作用のためだけに評価される。)

@need 1250
例）

@smallexample
@group
(let ((foo 2))
  (while (> foo 0)
    (insert (format "foo is %d.\n" foo))
    (setq foo (1- foo))))

     @result{}      foo is 2.
             foo is 1.
             nil
@end group
@end smallexample

@noindent
(@code{insert} 関数は引数をポイントに挿入する。また @code{format} 関数
は引数を @code{message} 関数が整形するのと同様に整形して出来たストリン
グを返す。@code{\n} は改行である。

@item re-search-forward
パターンを検索し、発見した場合はその直後にポイントを移動する。

@noindent
@code{search-forward} と同様、四つの引数を取る。

@enumerate
@item
検索パターンを表わす正規表現。

@item
省略可能。検索の限界。

@item
省略可能。検索が失敗した場合にどうするか。@code{nil} を返すかエラーメッ
セージを出すか。

@item
省略可能。検索を何回繰り返すか。負の数の場合は後方に検索する。
@end enumerate

@item let*
幾つかの変数を特定の値に局所的にバインドし、残りの引数を評価する。値
としては最後の引数の値を返す。局所変数をバインドする際、より先にバイン
ドした変数があれば、その値を利用出来る。

@need 1250
例）

@smallexample
@group
(let* ((foo 7)
      (bar (* 3 foo)))
  (message "`bar' is %d." bar))
     @result{} `bar' is 21.
@end group
@end smallexample

@item match-beginning
最後の正規表現で見つかったテキストの始まりの位置を返す。

@item looking-at
ポイントに続くテキストが引数の正規表現にマッチした場合に真として
@code{t} を返す。

@item eobp
ポイントがそのバッファのアクセス可能な最大位置にある場合に真として
@code{t} を返す。アクセス可能な範囲というのは、もしナローイングがかかっ
ていない場合はバッファの最後の位置であり、ナローイングがかかっている場合
は、その部分の最後である。
@end table

@need 1500
@node re-search Exercises
@section @code{re-search-forward} についての練習問題

@itemize @bullet
@item
二行以上続く空行にマッチする正規表現を検索する関数を書きなさい。

@item
`the the' のように二度続く単語を検索する関数を書きなさい。二つの同じ部分
からなる文字列にマッチする regexp (regular expression = 正規表現) の書き
方については @ref{Regexps, , Syntax of Regular Expression, emacs, The
GNU Emacs Manual}, を参考にしなさい。regexp の書き方はいく通りもある。そ
の内の幾つかは残りのものよりも良い。私が利用している関数は、幾つかの正規
表現と一緒に次の所に記されている。@ref{the-the, , 関数 @code{the-the}}.
@end itemize

@node Counting Words
@chapter カウント：繰り返しと正規表現
@cindex Repetition for word counting
@cindex Regular expressions for word counting

繰り返しと正規表現の検索は、Emacs Lisp でコードを書く際によく使われる大
変強力な道具である。この章では、正規表現の検索の利用の仕方を、
@code{while} ループないしは再帰を利用した単語を数えるコマンドの作成を通
して説明していくことにする。

@menu
* Why Count Words::             Emacs には単語を数えるコマンドが欠けている
* @value{COUNT-WORDS}::         正規表現を使う。でも問題が...
* recursive-count-words::       リージョンに単語が一つも無い場合には
* Counting Exercise::           カウントに関する練習問題
@end menu

@ifnottex
@node Why Count Words
@unnumberedsec 単語のカウント
@end ifnottex

標準的な Emacs の配布にはリージョン内の行数を数える関数が含まれている。
しかし同じことを単語について行う関数はない。

文章の種類によっては単語の数を数えなければならないようなことがある。エッ
セイを書く場合は800単語以内に制限した方がよいであろうし、小説を書く場合
など、一日1000単語は書くぞと決心することもあるだろう。個人的には Emacs
に単語を数えるコマンドがないのは変だと思う。多分 Emacs を使う人は大抵コー
ドとかドキュメントを書いていて、単語の数を数える必要などないのだろう。あ
るいは Operating system 附属の単語数を数えるコマンドである @code{wc} し
か使わなかったりするのかもしれない。はたまた編集者の都合に合わせて、文書
の中の単語の数を文字数を5で割ったものとして数えている人もいるかもしれな
い。何はともあれ、以下で単語数を数えるコマンドを紹介することにする。

（未訳）There are many ways to implement a command to count words.  Here are
some examples, which you may wish to compare with the standard Emacs
command, @code{count-words-region}.

@node @value{COUNT-WORDS}
@section 関数 @code{@value{COUNT-WORDS}}
@findex @value{COUNT-WORDS}

単語数を数えるコマンドとしては、行、パラグラフ、あるいはリージョンやバッ
ファなどの中に含まれる単語の数を数えるものが考えられる。コマンドとしては
どんなことまで出来ればよいだろうか。コマンドをバッファ全体の単語を数える
ように設計することも出来るが、Emacs の伝統からいって、もっと柔軟性を持た
せた方がよいだろう。例えばバッファ全体ではなく、あるセクションの中の単語
の数を教えるようなコマンドが欲しい場合も出てくるかもしれない。従って、リー
ジョンの中の単語数を数えるように設計した方が合理的だろう。一度、このよう
な @code{count-words-region} というコマンドを作ってしまえば、@kbd{C-x h}
(@code{mark-whole-buffer}) を使ってバッファ全体をマークすることで、バッ
ファ全体の単語を数えることだって出来る。

単語を数えることは、明らかに繰り返しを伴う動作だ。リージョンの始まりから
スタートして最初の単語を数え、次に二番目に行き、三番目に行き、というふう
にしてリージョンの最後に来るまで続けるわけである。これは単語を数えるとい
う行為が、もともと再帰や @code{while} ループに適しているということを意味
する。

@menu
* Design @value{COUNT-WORDS}::  The definition using a @code{while} loop.
* Whitespace Bug::              @code{count-words-region} の空白についてのバグ
@end menu

@ifnottex
@node Design @value{COUNT-WORDS}
@unnumberedsubsec Designing @code{@value{COUNT-WORDS}}
@end ifnottex

まずは、@code{while} ループを使って、次に再帰を使って、単語を数えるコマ
ンドを実際に作ってみることにする。これらのコマンドは勿論インタラクティブ
であるべきである。

@need 800
これまでにも何度も見たように、インタラクティブな関数の定義のテンプレート
は次のようになっている。

@smallexample
@group
(defun @var{関数名} (@var{引数リスト})
  "@var{説明文字列}@dots{}"
  (@var{インタラクティブ式}@dots{})
  @var{本体}@dots{})
@end group
@end smallexample

このスロットを埋めればよい。

関数の名前はそれ自体で意味が通じ、かつ既にある
関数 @code{count-lines-region} の名前と似たものであるべきである。これは
名前を覚えやすくするためだ。@code{count-words-region} なんかが良いだろう。

この関数はリージョン内の単語の数を数える。従って引数リストには、リージョ
ンの始まりと終わりの二つの位置各々にバインドされるシンボルが含まれていな
ければならない。これらの二つの位置は @samp{beginning} と @samp{end} と呼
べばいいだろう。説明文字列の最初の行は一つの文であるべきである。というの
は @code{apropos} のようなコマンドで表示される部分は一行目が全てであるか
らである。インタラクティブ式は @samp{(interactive "r")} という形になる。
こうすることで、リージョンの始まりと終わりの位置をこの関数の引数リストに
渡すことが出来る。ここまではルーティーンワークである。

関数の本体は、三つの仕事をするように書かれなければならない。一番目は
@code{while} ループが単語を数える時の条件を設定すること、二番目は
@code{while} ループを走らせること、そして三番目はユーザにメッセージを送
ることである。

ユーザが @code{count-words-region} を呼び出した時点では、ポイントはリー
ジョンの始まり、もしくは終わりにある。しかし、カウントは常にリージョンの
始まりの位置から開始しなければならない。従って、そうでない場合はまずその
位置までポイントを移動しておいて欲しい。@code{(goto-char beginning)} を
実行することで、このことが保証される。勿論、関数が仕事を終えたらポイント
の位置は元の位置に戻っていて欲しい。このために、本体部分は
@code{save-excursion} 式で囲む必要がある。

本体の中心部分は、あるＳ式で次の単語に一つずつジャンプし、もう一つのＳ式
でジャンプの回数を数える @code{while} ループからなる。@code{while} ルー
プの真偽テストはポイントがもう先へは進めなくなるまでは真を返し、リージョ
ンの最後まできたら偽を返すようなものでなければならない。

ポイントを単語ごとに移動するＳ式としては @code{(forward-word 1)} を使っ
てもよい。しかし、正規表現の検索を使うなら、Emacs が何を単語と見倣すかを
見る方が簡単である。

単語のパターンを検索する正規表現の検索では、ポイントはマッチしたパターン
の最後の文字の位置に移動する。従って、続けて検索が成功している間はポイン
トは単語を一つずつ移動していくことになる。

現実問題として、正規表現の検索では、単語だけではなく単語間の空白や句読点
をジャンプするようになっていて欲しい。実際、単語間の空白を越えて進まない
ような正規表現では二単語以上先には進めなくなってしまう。つまり、正規表現
の中には単語だけでなく、その後に続く空白や句読点等も含まれていなければな
らないわけである。(単語はバッファの最後に来るかもしれないので、後に必ずし
も空白がくるとは限らない。従って、空白等の部分の正規表現はオプションに
なる。)

というわけで、我々が求めている正規表現は、まず幾つかの単語構成文字が続き、
オプションとして単語の構成要素以外の文字が一つ以上の続くようなパターンで
ある。このような正規表現は次のように書ける。

@smallexample
\w+\W*
@end smallexample

@noindent
どの文字が単語構成文字であり、どの文字がそうでないかは、そのバッファのシ
ンタックステーブルによる。
(詳しくは @ref{Syntax, , 単語やシンボルは何から構成されているか}, あるいは
@ref{Syntax, Syntax, The Syntax Table, emacs, The GNU Emacs Manual}, や
@ref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp Reference
Manual}, を参照。)

@need 800
検索のためのＳ式は次の通りである。

@smallexample
(re-search-forward "\\w+\\W*")
@end smallexample

@noindent
(@samp{w} や @samp{W} の前にはバックスラッシュが二つずつ組になっているこ
とに注意しよう。単独のバックスラッシュは Emacs インタプリタにとって特殊
な意味を持っている。つまり、後に続く文字が普通とは異なる意味に解釈される
のである。例えば、@samp{\n} という二つの文字は、バックスラッシュに続く
@samp{n} ではなく、改行コードを表わす。バックスラッシュが二つ続いて初め
て通常の「特殊でない」バックスラッシュを表わすのである。)

(訳註：つまり、バックスラッシュが二つ要るのは、それが一度 Emacs の Lisp
リーダによって一つのバックスラッシュに解釈された後の結果が正規表現として
解釈されるためである。ここは混乱しやすいので注意しよう。)

いくつ単語があったかを数えるためのカウンタも必要である。この変数は最初は0
にセットされ、while ループを一つ繰り返す度に一つずつ増えていく。この一つ
増やすためのＳ式は単に

@smallexample
(setq count (1+ count))
@end smallexample

@noindent
だけでよい。さて、最後にユーザに対してリージョンにいくつ単語があったかを
知らせたい。このようにユーザに情報を表示する目的には、@code{message} 関
数が用意されている。今の場合、メッセージは単語の数がいくつあった場合でも
きちんとした文章になっていなければならない。例えば、``there are 1 words
in the region'' というふうになっては困る。単語が一つなのに複数形が使われ
るのは文法的に正しくないからである。この問題は、条件分岐式を用いて単語数
によってメッセージを変えるようにすれば回避出来る。可能性は三つある。一つ
はリージョン内には全く単語が無い場合、もう一つは一個だけある場合、そして、
複数の単語がある場合である。このような場合には @code{cond} を使うとよい
のであった。

@need 1500
以上を総合すると、次のような関数定義になる。

@smallexample
@group
;;; @r{最初のバージョン: バグあり！}
(defun count-words-region (beginning end)
  "Print number of words in the region.
Words are defined as at least one word-constituent
character followed by at least one character that
is not a word-constituent.  The buffer's syntax
table determines which characters these are."
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. 適切な状況の設定。}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. } while @r{loop を走らせる。}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. ユーザにメッセージを送る。}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

@noindent
が、以下に書かれている通り、この関数は全ての状況できちんと動作するわけでは
ない。

@node Whitespace Bug
@subsection @code{count-words-region} の空白文字に関するバグ

前節で説明した @code{count-words-region} コマンドには、二つのバグ、とい
うか二つの現れ方をする一つのバグがある。まず、たとえリージョンがある文章
の途中にある空白文字しか含まない場合でも、@code{count-words-region} は単
語が一つあると言ってくる。また、バッファないしはアクセス可能な部分の最後
にある空白文字しか含まない場合は、

@smallexample
Search failed: "\\w+\\W*"
@end smallexample

@noindent
というエラーメッセージが返ってしまう。この文を GNU Emacs の Info で読ん
でいるなら、このバグを実際に自分で確かめることが出来る。

まずはこの関数をいつも通り評価してインストールしよう。
@ifinfo
ここに定義のコピーを書いておく。最後の閉じ括弧の直後にカーソルを持っていっ
て @kbd{C-x C-e} とタイプすればインストールされる。

@smallexample
@group
;; @r{最初のバージョン; バグあり！}
(defun count-words-region (beginning end)
  "Print number of words in the region.
Words are defined as at least one word-constituent character followed
by at least one character that is not a word-constituent.  The buffer's
syntax table determines which characters these are."
@end group
@group
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. 適切な状況の設定。}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. } while @r{loop を走らせる。}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. ユーザにメッセージを送る。}
      (cond ((zerop count)
             (message "The region does NOT have any words."))
            ((= 1 count) (message "The region has 1 word."))
            (t (message "The region has %d words." count))))))
@end group
@end smallexample
@end ifinfo

お望みなら、次の式を評価することでこのコマンドのためのキーバインディン
グもインストール出来る。

@smallexample
(global-set-key "\C-c=" '@value{COUNT-WORDS})
@end smallexample

最初のテストをするために、次の行の最初と最後にマークとポイントを設定して
@kbd{C-c =} (あるいは @kbd{C-c =} というキーバインディングをインストール
していなければ @kbd{M-x count-words-region}) とタイプしよう。

@smallexample
    one   two  three
@end smallexample

@noindent
Emacs はリージョンには三つの単語があると正しく答えるはずだ。

次に、マークを行頭にセットして、ポイントをちょうど @samp{one} という単語
の@emph{前}に置いて同じテストをしてみよう。@kbd{C-c =} (あるいは
@kbd{M-x count-words-region}) とタイプした場合、Emacs はリージョンには一
つも単語がないと答えるべきである。リージョンには行頭の空白文字だけしか含
まれないからだ。しかし実際は Emacs はリージョンには一つの単語があると答
えてくる！

三番目に、サンプルの行を @file{*scratch*} バッファの最後にコピーして行の
終わりに幾つか空白文字をタイプしてから、マークを @samp{three} の直後に、
ポイントを行末に設定する。(即ち、行末をバッファの最後にする。) ここでさっ
きと同じく @kbd{C-c =} (あるいは @kbd{M-x count-words-region}) とタイプ
しよう。空白文字しかないのだから、今回も Emacs は単語は一つもないと答え
るべきである。しかし、Emacs は @samp{Search failed} というエラーメッセー
ジを表示する。

この二つのバグは共通する問題から生じたものだ。

最初のバグを考えてみよう。コマンドを実行すると、空白だけしかないはずの行
頭部分に一つの単語が含まれていると言ってきたのであった。これは何故だろう
か？ @code{M-x count-words-region} コマンドは、まずポイントをリージョン
の最初に移動させる。@code{while} テストは @code{point} の値が @code{end}
の値よりも小さいかどうかテストする。これは正しいので、結果として最初の単
語を見つける正規表現の検索が実行され、最初の単語が見つかる。ポイントは単
語の後ろに移され、@code{count} は1にセットされる。@code{while} ループは
もう一度実行されるが、今度はポイントの値が @code{end} の値よりも大きくな
るので、ループはそこで終了する。そしてこの関数は、リージョン内の単語は一
つだと言うメッセージを表示するというわけである。手短にいうと、正規表現の
検索では、単語がリージョンの外にあるにも関わらず、単語を発見してしまうの
である。

二番目のバグの場合、リージョン内にはバッファの最後の空白文字だけしかなかっ
た。Emacs は @samp{Search failed} と言う。これは何故か？ まず最初の
@code{while} ループでは真偽テストは真になるので、検索が実行される。しか
し、バッファの最後には単語は一つもないので、検索は失敗するというわけである。

どちらの現象も、検索がリージョンを越えて実行される所に問題があった。

解決法は、検索をリージョンに制限することである---これはかなり単純な動作
に思えるが、実際に考えてみると、思った程簡単にはいかないことが分る。

今まで見てきたように、@code{re-search-forward} 関数は最初の引数を検索
パターンとする。しかし、この最初の必須の引数の他に、三つの省略可能な引
き数を取ることが出来る。省略可能である二番目の引数は検索の限界である。
オプションである三番目の引数は、もし @code{t} なら検索に失敗した場合に
エラーを出さずに @code{nil} を返す。オプションである四番目の引数には繰
り返しの回数を指定する。(Emacs では、関数定義の説明文字列を見るには
@kbd{C-h f} に続けて関数名をタイプして @kbd{RET} キーを押せばよい。)

@code{count-words-region} の定義内では、変数 @code{end} にリージョンの
最後の値がこの関数の引数として渡され保持される。そこで、正規表現の検索の
引数として、この @code{end} の値を与えてみよう。

@smallexample
(re-search-forward "\\w+\\W*" end)
@end smallexample

しかし、もし @code{count-words-region} の値にこの変更だけしか加えずに、
新しいバージョンの関数を、空白だけの場所でテストすると、@samp{Search
failed} というメッセージが返される。

これはどうしてかというと、リージョン内には単語を構成する文字が無いために、
検索をそこに制限すると、検索が失敗してしまうためである。そのためにエラー
メッセージが返される。しかし、この場合にエラーメッセージは受け取りたくな
い。期待されるのは "The region does NOT have any words." というメッセー
ジである。

この問題を回避するには @code{re-search-forward} に三番目の引数として
@code{t} を与えれば良い。すると関数はエラーメッセージの代わりに
@code{nil} を返す。

しかし、この変更を加えてからもう一度テストしてみると、
``Counting words in region ... '' というメッセージが表示された後いくら待っ
ても何も表示されない。結局 @kbd{C-g} (@code{keyboard-quit}) とタイプする
までずっとこのメッセージを見続けることになる。

どうしてこうなるかだが、検索はリージョンに制限されているのでさっきと同じ
ように失敗する。これはリージョンには単語を構成する文字が含まれないのだか
ら期待通りである。結果として @code{re-search-forward} 式は @code{nil} を
返す。そして他のことは何もしない。特に、ポイントを動したりもしない。これ
は検索に成功した場合の副作用だからだ。@code{re-search-forward} が
@code{nil} を返した後、@code{while} ループの次のＳ式が評価される。これは
カウンタを一つ増やす。そして、次のループに移る。@code{re-search-forward}
式でポイントが移動しないために、ポイントの値は @code{end} の値よりも小さ
いままであり、真偽テストは真になる。そしてループが繰り返される。これがずっ
と続く @dots{}

検索が失敗した場合は @code{while} ループの真偽テストが偽を返すようにする
ために、またもや @code{count-words-region} の定義に変更を加える必要があ
る。即ち、カウンタを一つ増やす前に行う真偽テストでは二つの条件が満たされ
なければならないのだ。一つはポイントがリージョン内にあること、もう一つは
検索によって単語が見つかることである。

最初の条件も二番目の条件も同時に真にならなければいけないので、次のように
リージョンテストを行うＳ式と検索を行うＳ式の二つのＳ式を @code{and} 関数
で連結して @code{while} ループの真偽テストに埋め込むことにしよう。

@smallexample
(and (< (point) end) (re-search-forward "\\w+\\W*" end t))
@end smallexample

@c colon in printed section title causes problem in Info cross reference
@c also trouble with an overfull hbox
@iftex
@noindent
(@code{and} 関数についての詳細は、
@ref{kill-new function, , The @code{kill-new} 関数}, を参照。)
@end iftex
@ifinfo
@noindent
(@code{and} についての詳細は @ref{forward-paragraph}, を参照。)
@end ifinfo

@code{re-search-forward} 式は、もし検索が成功した場合は真を返し、副作用
としてポイントを移動する。結果として、単語が見つかった場合にはポイントは
リージョンを越えてしまうことがある。検索が失敗した場合やポイントがリージョ
ンの終わりに来てしまった場合は、真偽テストは偽を返し、@code{while} ルー
プが終了して、メッセージが表示される。

これらの最終的な変更を加えると、@code{count-words-region} は (少なくとも
私が見た範囲では！) バグ無しに動作するようになる。コードは次の通りである。

@smallexample
@group
;;; @r{最終バージョン:} @code{while}
(defun count-words-region (beginning end)
  "Print number of words in the region."
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. 適切な状況の設定}
  (save-excursion
    (let ((count 0))
      (goto-char beginning)
@end group

@group
;;; @r{2. } while @r{loop を走らせる。}
      (while (and (< (point) end)
                  (re-search-forward "\\w+\\W*" end t))
        (setq count (1+ count)))
@end group

@group
;;; @r{3. ユーザにメッセージを送る}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

@node recursive-count-words
@section 再帰を使った単語数のカウント
@cindex Count words recursively
@cindex Recursively counting words
@cindex Words, counted recursively

単語を数える関数は @code{while} ループではなく再帰を使っても書くことが出
来る。実際にどのようになるかを見てみよう。

まず、@code{count-words-region} 関数は三つの仕事をするということをはっき
り認識しておこう。初めに、カウントを行う際の適当な条件を整え、次にリージョ
ン内の単語を数え、最後に単語の数を知らせるメッセージをユーザに対し表示す
るというわけである。

これらの仕事を全て一つの再帰関数でやらせようとすると、全ての再帰呼び出し
でメッセージを受け取ってしまうことになる。例えばリージョンに13の単語があっ
た場合、13個のメッセージが並んでしまうのだ。これでは困る。そこで、これら
の仕事を二つの関数に分けてやらせることにする。一つを再帰関数にして、それ
をもう一方で呼び出すのである。片方は条件を整え、メッセージを表示するもの
であり、もう片方は、単語を数えるものである。

まずはメッセージを表示する方の関数から始めよう。今回も関数の名前は
@code{count-words-region} を使うことにする。

こちらはユーザが呼び出す方の関数であり、インタラクティブなものになる。実
の所、これはこの関数の前回のバージョンにそっくりである。ただし、リージョ
ン内の単語を数えるために、途中で @code{recursive-count-words} を呼び出し
ている所だけが違う。

@need 1250
前回の関数を参考にすれば、簡単にこの関数のテンプレートを作ることが出来る。

@smallexample
@group
;; @r{再帰バージョン; 正規表現検索を利用}
(defun count-words-region (beginning end)
  "@var{説明文字列}@dots{}"
  (@var{インタラクティブ式}@dots{})
@end group
@group

;;; @r{1. 適切な状況の設定}
  (@var{状況説明のメーセージ})
  (@var{初期設定のための関数}@dots{}
@end group
@group

;;; @r{2. 単語数のカウント}
    @var{再帰呼び出し}
@end group
@group

;;; @r{3. ユーザにメッセージを送る。}
    @var{単語数を伝えるメッセージ}))
@end group
@end smallexample

この定義は非常に素直に書かれているが、再帰呼び出しで返されたカウントを単
語の数を表示するメッセージに渡す所が、幾分ややこしいかもしれない。これは、
ちょっと考えれば、@code{let} 関数を使えばよいと気付く。つまり、
@code{let} 式の変数リストの変数に、再帰関数から返されたリージョン内の単
語数をバインドすればよいのである。その後、@code{cond} 式を利用してその値
をユーザに表示する。

@code{let} 式の中での変数のバインドというと、何か関数の二義的な仕事に思
われることも多い。しかし、今の場合には、関数の主な仕事だと思われる単語を
数えるということが、@code{let} 式の中で行われることになる。

@need 1250
@code{let} を使うと、関数定義は次のようになる。

@smallexample
@group
(defun count-words-region (beginning end)
  "Print number of words in the region."
  (interactive "r")
@end group

@group
;;; @r{1. 適切な状況の設定}
  (message "Counting words in region ... ")
  (save-excursion
    (goto-char beginning)
@end group

@group
;;; @r{2. 単語数のカウント}
    (let ((count (recursive-count-words end)))
@end group

@group
;;; @r{3. ユーザに対しメッセージを送る}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

次に、再帰関数の方に移ろう。

再帰関数は少なくとも三つの部分を持たねばならない。`do-again-test'、
`next-step-expression'、そして、再帰呼び出しである。

do-again-test は関数が自分自身をもう一度呼ぶかどうかを決定するものである。
ここではリージョン内の単語を数え、その中の単語の分だけ前に移動するのであ
るから、do-again-test ではポイントがまだリージョンの内部にあるかどうかを
チェックすれば良い。つまり、ポイントの値を調べて、それがリージョンの終わ
りの値よりも小さいか大きいかを比べるわけである。ポイントの値を調べるには
@code{point} 関数を使えばよい。リージョンの終わりの値は、勿論、この再帰
関数の引数として渡す必要がある。

更に do-again-test では検索で単語が見つかったかどうかもテストしなければ
ならない。無かった場合は再帰呼び出しをすべきではない。

next-step-expression は再帰関数が自分自身の呼び出しを止めるべき時に止め
るように値を変化させるものである。より正確に言うと、next-step-expression
は適切な時に do-again-test が再帰呼び出しを繰り返すのを止めるように、値
を変化させていく。今の場合なら、next-step-expression はポイントを単語ご
とに移動させていくＳ式になる。

再帰関数の三つ目の部分は、再帰呼び出しである。

また、どこかにこの関数の実際の「仕事」をする部分、つまり単語数を数える部
分を書く必要がある。これが一番重要な部分だ！

@need 1250
が、ともかく、再帰関数のアウトラインは出来た。

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{説明文字列}@dots{}"
   @var{do-again-test}
   @var{next-step-expression}
   @var{再帰呼び出し})
@end group
@end smallexample

このスロットを埋めていけばよい。まずは、一番単純な場合から始めよう。もし
ポイントがリージョンの終わりもしくはそれ以降の位置にあった場合は、リージョ
ン内には単語はない。従って、関数は0を返すべきである。同様に検索が失敗
した場合も単語はないので、0を返すべきである。

一方、もしポイントがリージョンの中にあって検索が成功した場合には、関数は
自分自身を再度呼び出すべきである。

@need 800
というわけで、do-again-test は次のようになる。

@smallexample
@group
(and (< (point) region-end)
     (re-search-forward "\\w+\\W*" region-end t))
@end group
@end smallexample

（旧訳）検索をするＳ式も do-again-test の一部であることに注意しよう。この関数は
検索が成功すれば @code{t} を返し、失敗すれば @code{nil} を返す。
(@ref{Whitespace Bug, , @code{count-words-region} の空白文字に関するバグ},
を見れば、@code{re-search-forward} がどのように動作するかが分る。)

do-again-test は @code{if} 式の真偽テストである。明らかに、もし真偽テス
トが真だった場合には、@code{if} 式はこの関数を再度呼び出さなければならない。
が、もし偽だった場合には、else-part によって零が返されるべきである。何故
なら、単語が見つからなかったということは、ポイントがリージョンの外だった
り検索に失敗したということだからだ。

しかし、再帰呼び出しについて考える前に、next-step-expression について考
える必要があるのだった。これは今の場合何か？ 興味深いことに、これは
do-again-test の検索部分なのである。

do-again-test で @code{t} や @code{nil} を返すことに加えて、
@code{re-search-forward} は検索成功時には副作用としてポイントを前方に移
動する。これこそが、ポイントがリージョン内を移動しきった場合に、再帰関数
が自分自身を呼び出すのを止めるようにポイントの値を変化させていく動作なの
である。というわけで、@code{re-search-forward} 式が next-step-expression
になっているのである。

@need 1200
従って @code{recursive-count-words} のアウトラインは次のようになる。

@smallexample
@group
(if @var{do-again-test-and-next-step-combined}
    ;; @r{then}
    @var{再帰呼び出しをしてカウントを返す}
  ;; @r{else}
  @var{ゼロを返す})
@end group
@end smallexample

これにカウントを数えさせるような機構を組み込むには、どうしたらよいだろう
か。

If you are not used to writing recursive functions, a question like
this can be troublesome.  But it can and should be approached
systematically.

next-step-expression では一単語ごとに前方に進み、従って再帰呼び出し
は一つ単語を進むごとに行われるわけだから、カウントの仕組は
@code{recursive-count-words} が呼ばれるごとに数を一つ増やすようなもので
なければならない。

@need 800
幾つかの場合を考えてみよう。

@itemize @bullet
@item
リージョン内に二つの単語があった場合、この関数は、最初の単語を数える時に
返した値にリージョンの残りの単語数、今の場合なら1、を足した数に1を加えた
値を返さなければならない。

@item
リージョン内に一つだけ単語があった場合、この関数は、最初の単語を数える時
に返した値にリージョンの残りの単語数、今の場合なら0、を足した数に1を加え
た値を返さなければならない。

@item
リージョン内に一つも単語がなければ、この関数は0を返すべきである。
@end itemize

以上のことから、@code{if} 式の else-part では、単語が一つもなかった場合
のために0を返せばよいことが分る。これは、@code{if} 式の then-part では残
りの単語の合計の値に1加えた値を返すべきだということを意味する。

@need 1200
実際のＳ式は次のようになる。ここで、@code{1+} は引数に1加える関数である。

@smallexample
(1+ (recursive-count-words region-end))
@end smallexample

@need 1200
以上から @code{recursive-count-words} 関数全体は次のようになる。

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{説明文字列}@dots{}"

;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: 再帰呼び出し}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 1250
実際にどのような動作をするかを見てみよう。

もし、リージョンに単語が一つもなければ、@code{if} 式の else-part が評価
され、結果としてこの関数は0を返す。

もし、リージョンに単語が一つあれば、ポイントの値は @code{region-end} の
値よりも小さく、検索は成功する。この場合、@code{if} 式の真偽テストは真を
返し、then-part が評価され、カウント式が評価される。この式が返す値が関数
全体の返す値になるのだが、これは、再帰呼び出しで返された値に1加えた値で
ある。

ところで、この時同時に next-step-expression によってポイントがリージョン
内の最初の単語 (といっても今はこの一個だけだが) を越えて移動する。つまり、
@code{(recursive-count-words region-end)} が二回目に評価された時には、ポ
イントの位置はリージョンの終わり以降の位置にあることになる。従って、今度
は @code{recursive-count-words} は0を返す。これにさっきの1が加えられ、結
果として元の @code{recursive-count-words} は0足す1、つまり、1を返すこと
になる。これは正しい数である。

ここまでくれば後はもうお分りだと思うが、リージョンの中に単語が二つある場
合には、最初に呼び出された @code{recursive-count-words} は次に残りの単語
を含むリージョンで呼び出された @code{recursive-count-words} の値に1加え
た値、つまり、1 + 1 = 2 という値を返す。これも正しい数である。

同様にして、もしリージョンの中に単語が三つある場合も、最初に呼び出された
@code{recursive-count-words} は残りのリージョンで呼び出された
@code{recursive-count-words} の値に1加えた値を返す。このような感じで、単
語が沢山ある場合も正しい数を返してくれる。

@need 1250
@noindent
説明文字列も完全につけると、二つの関数は次のようになる。

@need 1250
@noindent
再帰関数:

@findex recursive-count-words
@smallexample
@group
(defun recursive-count-words (region-end)
  "Number of words between point and REGION-END."
@end group

@group
;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: 再帰呼び出し}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 800
@noindent
外側の関数 (wrapper):

@smallexample
@group
;;; @r{再帰バージョン}
(defun count-words-region (beginning end)
  "Print number of words in the region.
@end group

@group
Words are defined as at least one word-constituent
character followed by at least one character that is
not a word-constituent.  The buffer's syntax table
determines which characters these are."
@end group
@group
  (interactive "r")
  (message "Counting words in region ... ")
  (save-excursion
    (goto-char beginning)
    (let ((count (recursive-count-words end)))
@end group
@group
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
@end group
@group
            ((= 1 count)
             (message "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

@node Counting Exercise
@section 練習問題：句読点のカウント

@code{while} ループを使って、リージョン内の句読点---終止符、カンマ、セ
ミコロン、コロン、感嘆符、疑問符---の数を数える関数を書きなさい。同じ関
数を再帰関数を使って書きなさい。

@node Words in a defun
@chapter @code{defun} 内の単語のカウント
@cindex Counting words in a @code{defun}
@cindex Word counting in a @code{defun}

次の計画の目標は、関数定義の中の単語の数を数えることである。当たり前のこ
とだが、これは @code{count-words-region} の使い方をちょっと工夫すれば出
来てしまう。@ref{Counting Words, , カウント：繰り返しと正規表現}, を参照
のこと。例えば、ある一つの定義の中の単語数を数えたければ、@kbd{C-M-h}
(@code{mark-defun}) コマンドを使って定義部分をマークしてから
@code{count-words-region} を呼び出せばよい。

しかしながら、ここではもっと大きなことをやってみたいと思う。Emacs のソー
スの中の全ての定義の中の単語とシンボルの数を数えて、そこにどれだけの関数
があり、各々がどのくらいの長さかをグラフにして出力するとか、40個から49個
までの単語とシンボルを関数がどれだけあるか、50個から59個までではどうか、
といったことを調べるのである。私はしばしば典型的な関数というのがどのくら
いの長さかを知りたくなる。これは、そういったことを教えてくれるものである。

@menu
* Divide and Conquer::          遠大な計画は分割しよう
* Words and Symbols::           何を数えればよいか？
* Syntax::                      単語やシンボルは何から構成されているか
* count-words-in-defun::        @code{count-words} とほぼ同じ
* Several defuns::              一つのファイルにある複数の defun を数える
* Find a File::                 ファイルを見つける
* lengths-list-file::           沢山の定義の長さのリスト
* Several files::               異なるファイルの中の定義を数える
* Several files recursively::   異なるファイルの定義を再帰を使って数える
* Prepare the data::            データをグラフに表示するための準備
@end menu

@ifnottex
@node Divide and Conquer
@unnumberedsec 分割による困難の克服
@end ifnottex

はっきり言って、このヒストグラムを書く計画は人をひるませる類のものである。
しかし、これをいくつもの細かいステップに分けて、各々を一つずつ見ていくこ
とにすれば、それほど恐れるほどのものではない。そこで、どんなステップに分
けるべきかを書いてみることにする。

@itemize @bullet
@item
まず最初に、一つの定義の中に単語がどれだけあるかを数える関数を書く。ここ
では、単語と同じくシンボルをどう扱うかが問題になる。

@item
二番目に各々の関数の中の単語数をリストにする関数を書く。この関数では
@code{count-words-in-defun} を使うことが出来る。

@item
三番目に、各ファイルの中の各関数の中の単語数をリストにする関数を書く。こ
れをやろうとすると、必然的に、自動的に様々なファイルを見つけてそれらに移
り、それに含まれる関数定義の中の単語数を数えるということをしなければなら
なくなる。

@item
四番目に、三番目のステップで作成した数のリストをグラフとして出力するのに
適した形に変換する関数を書く。

@item
五番目に結果をグラフとして表示する関数を書く。
@end itemize

これはかなりの大計画である。しかし、各々のステップをゆっくりと進んでいけ
ば、それ程困難なものではない。

@node Words and Symbols
@section 何を数えればよいか？
@cindex Words and symbols in defun

関数定義の中の単語数を数えるにはどうしたらよいか、を最初に考え始めた時に、
まず疑問に思うこと (あるいは、考えるべきこと) は、我々は何を数えればよい
かということである。Lisp の関数定義に関して単語のことを話す場合、実際に
は大抵シンボルのことを言っている。例えば、次の @code{multiply-by-seven}
関数は、@code{defun}、@code{multiply-by-seven}、@code{number}、@code{*}、
そして@code{7}という5個のシンボルを含んでいる。これに加えて説明文字列の
中に @samp{Multiply}、@samp{NUMBER}、@samp{by}、そして @samp{seven} とい
う単語が含まれている。@samp{number} は繰り返して使われているので、関数定
義の中には合計10個の単語とシンボルが含まれていることになる。

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

@noindent
ところが、もし @code{multiply-by-seven} の定義を @kbd{C-M-h}
(@code{mark-defun}) でマークして、そこで @code{count-words-region} を呼
び出してみると、10個ではなく11個の単語があるという答えが帰ってくる。何かが
おかしい！

実は、問題は二重になっている。@code{count-words-region} は @samp{*} を単
語とは数えないが、逆に、一つのシンボル @code{multiply-by-seven} を三つの
単語だと数えてしまうのである。これはハイフンが一つの単語内でのつながりを
示すものとしてではなく、単語間の間の空白と同じように扱われるためのである。
従って、@samp{multiply-by-seven} は @samp{multiply by seven} と書かれて
いるように扱われることになる。

このような混乱の原因は、
@code{count-words-region} の定義内で一つの単語ずつ移動する際に使っている
正規表現にある。標準的な @code{count-words-region} のバージョンで使われ
ている正規表現は

@smallexample
"\\w+\\W*"
@end smallexample

@noindent
である。この正規表現は一つ以上単語構成文字が続いた後に0個以上の非単語構
成文字が続くというパターンである。「単語構成文字」によって何が意味される
かという問題は、構文 (syntax) の問題になる。これには一つのセクションを割
当てて論じる価値がある。

@node Syntax
@section 単語やシンボルは何から構成されているか
@cindex Syntax categories and tables

Emacs では、各々の文字はある@dfn{構文カテゴリ} (@dfn{syntax categories})
に属するものとして扱われる。例えば正規表現 @samp{\\w+} は一つ以上の「単
語構成文字」(@emph{word constituent}) が続くパターンを表している。単語構
成文字というのは、ある一つの構文カテゴリーの要素のことである。他の構文カ
テゴリーの要素は、例えば終止符やカンマ等の句読点文字のクラス、スペースや
タブ等の空白文字のクラスを含んでいる。(より詳しいことについては
@ref{Syntax, Syntax, The Syntax Table, emacs, The GNU Emacs Manual}, 及
び @ref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp
Reference Manual},を参照のこと。)

構文テーブルとはどの文字がどのカテゴリーに属するかを定めるものである。普
通、ハイフンは「単語構成文字」には分類されない。そうではなく「シンボルの
名前ではあるが、単語ではないものの一部をなす文字のクラス」に分類される。
これは @code{count-words-region} 関数がハイフンを単語間の空白文字と同じ
扱いをすることを意味する。これが @code{count-words-region} が
@samp{multiply-by-seven} を三つの単語だと数える理由である。

Emacs に @code{multiply-by-seven} を一つの単語だと数えさせるには二つの方
法がある。一つは構文テーブルを書き換える方法、もう一つは正規表現を書き直
す方法である。

Emacs が各々のモードに対して持つ構文テーブルを書き換えることで、ハイフン
を単語構成文字だと再定義することが出来る。この動作は我々の目的に殆ど合う
のだが、ハイフンだけが単語の中には現れずシンボルの中には出てくる文字とい
うわけではない。似たような文字は他にもある。

代わりに、@code{count-words} の定義中の正規表現の方を書き直してシンボル
を含むようにすることも出来る。こちらの方法の方がより簡明である。ただし、
実際にやることは少々トリッキーだ。

@need 1200
最初の部分は十分に単純である。パターンとしては「少なくとも一つ以上続く、
単語ないしはシンボルの構成要素」にマッチするもの、つまり、

@smallexample
"\\(\\w\\|\\s_\\)+"
@end smallexample

@noindent
になる。@samp{\\(} は @samp{\\w} と @samp{\\s_} のいずれかを表わす正規表
現のグループの開始を示す部分である。対象となる二つの部分は @samp{\\|} で
区切られている。@samp{\\w} は任意の単語構成文字にマッチし、@samp{\\s_}
はシンボル名の一部になり得るが、単語構成文字ではないような任意の文字にマッ
チする。後に続く @samp{+} は、このグループに属する文字、即ち単語かシンボ
ルの構成文字が少くとも一回はマッチしなければならないことを意味する。

しかしながら、正規表現の二番目の部分はもっと難しい。欲しいものは、一番目
の正規表現に続けて「単語の一部にもシンボルの一部にもならない文字が一つ以
上続いてもかまわない」ことを表わす表現である。まず思い浮んだのは次のよう
なものである。

@smallexample
"\\(\\W\\|\\S_\\)*"
@end smallexample

@noindent
上の大文字の @samp{W} と @samp{S} は各々単語、あるいはシンボルの構成文字
では@emph{ない}ような文字にマッチする。しかし、この表現では、単語構成文
字ではないか、もしくはシンボル構成文字ではない文字に一致してしまう。これ
ではどんな文字にもマッチしてしまう。

次に私は、テストしているリージョン内の全ての単語やシンボルの後には空白文
字 (スペース、タブ、もしくは改行) があることに気がついた。そこで、単語か
シンボルの構成文字が一つ以上続くというパターンの後に、一つ以上の空白文字
が続くというパターンを置いてみた。しかし、これも失敗した。通常は単語やシ
ンボルは空白で終わるのだが、実際のコードでは、シンボルの後に括弧が来たり、
単語の後に句読点が来たりすることだってある。というわけで、結局、単語かシ
ンボルの構成文字の後に0個以上の空白文字以外の文字が続き、その後に0個以上
の空白文字が来る、というパターンにすることにした。

@need 800
次がその正規表現である。

@smallexample
"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
@end smallexample

@node count-words-in-defun
@section 関数 @code{count-words-in-defun}
@cindex Counting words in a @code{defun}

以前見たように、@code{count-words-region} 関数を書く方法は幾つかあった。
が、今回 @code{count-words-in-defun} を書く際には、この内の一つの方法だ
けを採用することにする。

方法としては @code{while} ループを使う方法が理解しやすいだろうから、こち
らを採用することにする。@code{count-words-in-defun} は、より複雑なプログ
ラムの一部になるので、インタラクティブである必要も、メッセージを出す必要
もなく、ただカウントを返しさえすればよい。これらのことを考慮すると、定義
は少し単純になる。

一方、@code{count-words-in-defun} は関数定義を含むバッファの中で使われる。
従って、現在ポイントが関数定義内にあるか判定し、もしそうであればその定義
内の単語を数えるというふうにするのが合理的であろう。こうすると、ちょっと
コードが複雑にはなるが、関数に引数を与える手間は省ける。

@need 1250
以上のことを考慮すると、テンプレートは次のようになる。

@smallexample
@group
(defun count-words-in-defun ()
  "@var{説明文字列}@dots{}"
  (@var{初期設定}@dots{}
     (@var{while ループ}@dots{})
   @var{カウントを返す})
@end group
@end smallexample

@noindent
いつも通り、やるべきことはこの中の空きスロットを埋めていくことである。

まずは初期設定から。

この関数は、関数定義が含まれるバッファの中で呼び出されることを想定されて
いる。現在のポイントは関数定義の中にあるか、外にあるかどちらかである。
@code{count-words-in-defun} が動作してくれるためには、ポイントが関数定義
の先頭に移動し、カウンタがゼロから始まり、ポイントが関数定義の最後に来た
らループが終了するようになっていてくれなければならない。

@code{beginning-of-defun} 関数は後方に向かって行頭の @samp{(} などの開き
括弧を検索し、そこにポイントを移動するか、検索の限界まで移動する。実際に
は、@code{beginning-of-defun} はポイントを現在ポイントが含まれている関数
定義もしくはポイント以前のポイントに最も近い関数定義の開始位置、あるいは
バッファの先頭まで移動することになる。従って、@code{beginning-of-defun}
を使うことで望みの位置までポイントを移動することが出来る。

@code{while} ループでは、数えた単語やシンボルの数を保持しておくカウンタ
が必要である。@code{let} 式によって、この目的のための変数を作り、その値
をゼロに初期化することが出来る。

@code{end-of-defun} 関数は @code{beginning-of-defun} と同じような働きを
するのだが、ポイントを関数定義の終了位置に移動する点だけが異なっている。
@code{end-of-defun} は関数定義の終了位置を決定するＳ式の一部として使う
ことが出来る。

ということで、@code{count-words-in-defun} の初期設定部分はあっさり書けて
しまう。まずは、関数定義の最初にポイントを移動し、次にカウンタのための局
所変数を用意し、最後に @code{while} ループが止まるべき所で止まれるように
関数定義の終了位置を記録しておくのである。

@need 1250
コードは次の通りである。

@smallexample
@group
(beginning-of-defun)
(let ((count 0)
      (end (save-excursion (end-of-defun) (point))))
@end group
@end smallexample

@noindent
このコードは単純である。ちょっとややこしいのは @code{end} に関するところ
だろう。これには、関数定義の終了位置がバインドされる。その際、
@code{save-excursion} 式の中で一時的に @code{end-of-defun} で関数定義の
終了位置に移動した後にポイントの位置を返すという方法を用いている。

さて、@code{count-words-in-defun} の初期設定に続く二番目の部分は
@code{while} ループである。

このループでは、ポイントを単語やシンボルごとに移動するＳ式、及びジャンプ
の回数を数えるＳ式が必要である。また、@code{while} ループの真偽テストで
は、ポイントがまだジャンプすべきなら真を返し、定義の終了位置まで到達した
なら偽を返すようなものであるべきである。目的のための正規表現は既に再定義
してしまっているので、(@ref{Syntax, , 単語やシンボルは何から構成されてい
るか}, 参照) ループは簡単に書ける。

@smallexample
@group
(while (and (< (point) end)
            (re-search-forward
             "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t))
  (setq count (1+ count)))
@end group
@end smallexample

関数定義の三番目の部分は単語やシンボルの数を返す部分である。この部分は
@code{let} 式の本体部分の最後の部分だが、極めて単純に局所変数
@code{count} を書いておくだけでよい。これを評価すると数が返るわけである。

以上をまとめると、@code{count-words-in-defun} は次のようになる。

@findex count-words-in-defun
@smallexample
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group
@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

これをテストするにはどうしたらよいだろうか。この関数はインタラクティブで
はないが、ちょっとＳ式をかぶせることで簡単にインタラクティブにすることが
出来る。これには @code{count-words-region} の再帰関数版とほぼ同じコード
が使える。

@smallexample
@group
;;; @r{インタラクティブバージョン}
(defun count-words-defun ()
  "Number of words and symbols in a function definition."
  (interactive)
  (message
   "Counting words and symbols in function definition ... ")
@end group
@group
  (let ((count (count-words-in-defun)))
    (cond
     ((zerop count)
      (message
       "The definition does NOT have any words or symbols."))
@end group
@group
     ((= 1 count)
      (message
       "The definition has 1 word or symbol."))
     (t
      (message
       "The definition has %d words or symbols." count)))))
@end group
@end smallexample

@need 800
@noindent
便宜上 @kbd{C-c =} というキーバインディングをもう一度使うことにしよう。

@smallexample
(global-set-key "\C-c=" 'count-words-defun)
@end smallexample

以上で、@code{count-words-defun} をテストするための準備が整った。まずは、
@code{count-words-in-defun} 及び @code{count-words-defun} を両方ともインス
トールして、キーバインディングの設定もしてしまおう。そして、カーソルを次
の定義の中に移動して実験してみる。
@ifinfo
(訳註：原文とは異なり、インデントはしていない。@code{(defun} が行頭から
始まっていないと @code{beginning-of-defun} 等がうまく働かないからである。)
@end ifinfo

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
     @result{} 10
@end group
@end smallexample

@noindent
成功だ！ この定義の中には確かに10個の単語とシンボルがある。

次の問題は、一つのファイルの中の幾つかの定義にある単語とシンボルの数を
数えることである。

@node Several defuns
@section 一つのファイルにある複数の defun を数える

@file{simple.el} のようなファイルの中には80以上の関数定義が含まれていた
りする。我々の最終的な目標は沢山のファイルについての統計を取ることである
が、その最初のステップとして、まずは一つのファイルについての統計を取るこ
とを目標にしよう。

情報は数の列の形で与えられ、各々の数は関数定義の長さになる。これらの数は
リストの中に保持しておくことが出来る。

一つのファイルについての情報は最終的には多くのファイルについての情報の形
に統合されることになる。従って、ここで作成する一つのファイル内の関数定義
の長さを数える関数は単に「長さ」のリストを返すだけでよく、特にメッセージ
とかを表示する必要はない。

単語を数えるコマンドには、単語ごとにポイントを前方に進めるＳ式とジャンプ
の回数を数えるＳ式が含まれていた。定義の長さを測る関数も、同じように設計
することが出来る。この場合は定義ごとにポイントを進めるＳ式と長さのリスト
を作成するようなＳ式が含まれることになる。

問題をこのように言い替えてしまえば、関数定義を書くのは簡単なことである。
明らかに、カウントはファイルの先頭から始めなければならない。従って、最初
のコマンドは @code{(goto-char (point-min))} である。次に @code{while} ルー
プに入る。ここでは、ループの真偽テストは次の関数定義を探す正規表現に取れ
る---検索が成功している間はポイントを進め、本体を評価するわけである。本
体内には長さのリストを作成するＳ式が必要である。これには @code{cons} と
いうリストを構成するコマンドが使える。やるべきことの殆どは、以上で終わっ
ている。

@need 800
部分的にコードを書くと次のようになる。

@smallexample
@group
(goto-char (point-min))
(while (re-search-forward "^(defun" nil t)
  (setq lengths-list
        (cons (count-words-in-defun) lengths-list)))
@end group
@end smallexample

この他にやることは、関数定義を含むファイルを見つけることである。

今までの例では、この Info file を使うか、@file{*scratch*} バッファなどの
他のバッファに一旦戻って、また帰ってくるということしかしていなかった。

ファイルを見つける (find) ことは、この文書では初めて出てくるプロセスであ
る。

@node Find a File
@section ファイルを見つける
@cindex Find a File

To find a file in Emacs, you use the @kbd{C-x C-f} (@code{find-file})
command.  This command is almost, but not quite right for the lengths
problem.

@need 1200
まずは、@code{find-file} のソースを見てみよう。

@smallexample
@group
(defun find-file (filename)
  "Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists."
  (interactive "FFind file: ")
  (switch-to-buffer (find-file-noselect filename)))
@end group
@end smallexample

@noindent
(The most recent version of the @code{find-file} function definition
permits you to specify optional wildcards to visit multiple files; that
makes the definition more complex and we will not discuss it here,
since it is not relevant.  You can see its source using either
@kbd{M-.} (@code{find-tag}) or @kbd{C-h f} (@code{describe-function}).)

@ignore
In Emacs 22
(defun find-file (filename &optional wildcards)
  "Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists.
Interactively, the default if you just type RET is the current directory,
but the visited file name is available through the minibuffer history:
type M-n to pull it into the minibuffer.

Interactively, or if WILDCARDS is non-nil in a call from Lisp,
expand wildcards (if any) and visit multiple files.  You can
suppress wildcard expansion by setting `find-file-wildcards' to nil.

To visit a file without any kind of conversion and without
automatically choosing a major mode, use \\[find-file-literally]."
  (interactive (find-file-read-args "Find file: " nil))
  (let ((value (find-file-noselect filename nil nil wildcards)))
    (if (listp value)
        (mapcar 'switch-to-buffer (nreverse value))
      (switch-to-buffer value))))
@end ignore

定義には、簡潔な説明文字列が付いており、インタラクティブ式では対話的に用
いた時のプロンプトが指定されている。で、定義の本体を見ると、
@code{find-file-noselect} 及び @code{switch-to-buffer} という二つの関
数が使われている。

@kbd{C-h f} (@code{describe-function} コマンド) で表示される説明によると、
@code{find-file-noselect} は指定されたファイルをバッファに読み込み、その
バッファを返す。しかしながらバッファは選択されない、つまり Emacs は注意
をそのバッファには向けない。(あるいは @code{find-file-noselect} を名前の
ついたバッファに対し使った場合は、あなたの注意も引かない。) 

この仕事は
@code{switch-to-buffer} がやってくれる。この関数は、Emacs が注目するバッ
ファを指定するものである。更にこの関数は、ウィンドウに表示されているバッ
ファを新しいバッファに切り替える。バッファの切り替えについては、また別の
場所で議論することにしよう。(@ref{Switching Buffers, , バッファ間の移動},
参照。)

今やろうとしているヒストグラム計画では、定義の長さを調べる際にいちいち一
つ一つのファイルをスクリーンに表示する必要はない。というわけで
@code{switch-to-buffer} ではなく @code{set-buffer} を使うことにしよう。
これも Emacs が注目するバッファを切り替えるのだが、スクリーンに表示する
バッファはそのままである。従って、我々の目的のためには @code{find-file}
は使えず、そのためのコードを書くことになる。

といっても、やることは簡単だ。単に @code{find-file-noselect} と
@code{set-buffer} を使えばよいのである。

@node lengths-list-file
@section @code{lengths-list-file} についての詳細

@code{lengths-list-file} 関数の核心部分は、defun から defun へ移動してい
く関数を含む @code{while} ループと、各々の defun の中に含まれる単語やシ
ンボルの数を数える関数である。そしてその周辺に、例えば、ファイルを見つけ
たり、ポイントが必ずファイルの先頭部分からスタートするようにしたりする、
といった他の様々な仕事をする関数が来る。結局、定義は次のようになる。

@smallexample
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group
@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@noindent
この関数は一つの引数を取る。これは作業対象となるファイルの名前である。
説明文字列は四行あるが、インタラクティブ宣言はされていない。本体の一行目
では、使った人が計算機が壊れたのではないかと心配しないように、最初に何を
やっているかを表示するようにしている。

次の行で @code{save-excursion} が使われているので、Emacs は仕事が終わっ
た後、ちゃんと元のバッファに注意を戻してくれる。こうすると、この関数を他
の関数の中に埋め込んでいる場合などにも、ポイントを元の位置に戻してくれる
ので便利である。

@code{let} 式の変数リストの所で、Emacs はファイルを見つけて局所変数
@code{buffer} をそのファイルを中身とするバッファにバインドする。同時に
Emacs は @code{lengths-list} を局所変数として生成する。

次に Emacs は注意をそのバッファに向ける。

次の行では Emacs はバッファを書き込み不可にしている。理論上は、この行は
不要である。関数定義内の単語やシンボルの数を数える関数の中で、バッファを
書き換えたりするようなものはないし、たとえそのバッファが変更されたとして
も保存されたりはしない。こういう警戒をするのは、これらの関数が Emacs の
ソース上で作業するために、万が一にでもファイルを修正してしまったりすると
非常に不都合であるという理由のためである。言うまでもないが、私自身は実験
が失敗して私の Emacs のソースファイルが修正されるなんていう事態に会わな
い限り、この行が必要だと思うことはないだろう。

次に、バッファがナローイングされている場合には、それを広げるということを
やっている。これは普通は必要ない---Emacs はそのファイルに対応するバッファ
が無い場合は新規にバッファを開くからだ。しかし、既にある場合には Emacs
はそのバッファを返す。この場合、もしそのバッファがナローイングされていた
なら、それを解除する必要がある。真にユーザーフレンドリーな関数にしたい場
合には、ナローイングやポイントの位置なんかを保存しておくべきだろうが、こ
こでは何もしないことにする。

@code{(goto-char (point-min))} 式でポイントをバッファの先頭に移動する。

そして @code{while} ループが来る。ここで、この関数の仕事が実行されること
になる。このループでは、Emacs は各々の定義の長さを調べ、その長さのリスト
を作っていく。

あるバッファでの作業が終わると Emacs はそのバッファを kill する。これは、
Emacs 内部でのスペースの節約のためである。私が使っている Emacs 19 のバー
ジョンには300以上ものソースファイルが含まれており、これらに
@code{lengths-list-file} が適用される。もし Emacs がこれら全てを読み込ん
で一つも kill しなかったら、私の計算機は仮想記憶を使い切ってしまうだろう。

終りまで来ると、@code{let} 式の中の最後のＳ式である @code{lengths-list}
という変数が評価される。この値が関数全体の値となる。

この関数をいつも通りインストールして試してみることが出来る。インストール
が終わったら、カーソルを次のＳ式の直後に持っていってから @kbd{C-x C-e}
(@code{eval-last-sexp}) とタイプして、評価してみよう。

@c !!! 22.1.1 lisp sources location here
@smallexample
(lengths-list-file
 "/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el")
@end smallexample

@c (lengths-list-file "/usr/local/emacs/lisp/debug.el")

@noindent
(多分、ファイルのパス名を変更する必要があるだろう。上に挙げたものは、こ
の Info ファイルのあるディレクトリと Emacs のソースがあるディレクトリが
@code{/usr/local/emacs/info} と @code{/usr/local/emacs/lisp} の
ように隣同士にある場合だけである。変更する場合は、このＳ式を一旦
@file{*scratch*} バッファにコピーしてから、それを修正して評価する。)

@need 1200
@noindent
(Also, to see the full length of the list, rather than a truncated
version, you may have to evaluate the following:

@smallexample
(custom-set-variables '(eval-expression-print-length nil))
@end smallexample

@noindent
(@xref{defcustom, , Specifying Variables using @code{defcustom}}.
Then evaluate the @code{lengths-list-file} expression.)

@need 1200
The lengths' list for @file{debug.el} takes less than a second to
produce and looks like this in GNU Emacs 22:

私が使っているバージョンの Emacs では、@file{debug.el} に対する長さのリ
ストを生成するのに7秒かかり、結果は次のようになった。

@smallexample
(83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
@end smallexample

@need 1500
(Using my old machine, the version 19 lengths' list for @file{debug.el}
took seven seconds to produce and looked like this:

@smallexample
(75 41 80 62 20 45 44 68 45 12 34 235)
@end smallexample

(The newer version of @file{debug.el} contains more defuns than the
earlier one; and my new machine is much faster than the old one.)

ファイルの中の最後の定義の長さは、リストの最初に現れることに注意しよう。

Note that the length of the last definition in the file is first in
the list.

@node Several files
@section 異なるファイルの中の定義を数える

前節では、各ファイルの中に含まれる各関数の長さのリストを返すような関数を
作成したのだった。今度は、ファイルのリストが与えられた時に、それらのファ
イルの中の関数の長さのマスターリストを返すような関数を定義してみたい。

リストの中の各ファイルに対する作業は繰り返しの動作なので、@code{while}
ループや再帰を使って行うことが出来る。

@menu
* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      あるリストを別のリストに追加する
@end menu

@ifnottex
@node lengths-list-many-files
@unnumberedsubsec Determine the lengths of @code{defuns}
@end ifnottex

@code{while} ループを使った方法はルーティーンワークである。関数に渡す引
き数はファイルのリストになる。以前見たように
(@ref{Loop Example, , ループの例}, 参照)、
このリストが要素を含んでいる時のみループの本体を実行し、要素が無くなった
ら抜けるようにすることが出来るのであった。これがうまく動作するためには、
本体部分で、本体が一回評価されるごとにこのリストを短くしていき、結果とし
て最後にはリストが空になるように、Ｓ式を書いておく必要がある。このために
は、本体が評価されるごとに、リストにそのリストの @sc{cdr} の値をセットす
るという技法を用いるのが普通である。

@need 800
テンプレートは次のようになる。

@smallexample
@group
(while @var{リストが空かどうかのテスト}
  @var{本体}@dots{}
  @var{リストを自分自身の cdr にセット})
@end group
@end smallexample

さて、@code{while} ループは常に (真偽テストの結果として) @code{nil} を返
し、本体内のＳ式の値を返したりすることはないのだった。(従って、ループの
本体のＳ式は副作用として評価される。)  しかしながら、長さのリストをセッ
トするＳ式は本体の一部である---にもかかわらず、その関数全体の値として返
して欲しいのもこの値である。そこで、@code{while} ループを @code{let} 式
で包んで、@code{let} 式の最後の要素が長さのリストの値を含むようにする。
(@ref{Incrementing Example, , 増加するカウンタを使ったループの例}, を参
照。)

@findex lengths-list-many-files
@need 1250
以上のことを考えれば、目的の関数が殆ど書けてしまう。

@smallexample
@group
;;; @r{@code{while} ループ を使う。}
(defun lengths-list-many-files (list-of-files)
  "Return list of lengths of defuns in LIST-OF-FILES."
@end group
@group
  (let (lengths-list)

;;; @r{真偽テスト}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list

;;; @r{長さのリストの生成}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
@end group

@group
;;; @r{ファイルのリストを短くする。}
      (setq list-of-files (cdr list-of-files)))

;;; @r{リストの長さの最終的な値を返す。}
    lengths-list))
@end group
@end smallexample

@code{expand-file-name} は組み込み関数であり、ファイル名を絶対パスも含
めた省略無しの形に戻すものである。従って、例えば

@c !!! 22.1.1 lisp sources location here
@need 1500
Thus, if @code{expand-file-name} is called on @code{debug.el} when
Emacs is visiting the
@file{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/} directory,

@smallexample
debug.el
@end smallexample

@need 800
@noindent
は

@c !!! 22.1.1 lisp sources location here
@smallexample
/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
@end smallexample

The only other new element of this function definition is the as yet
unstudied function @code{append}, which merits a short section for
itself.

@node append
@subsection 関数 @code{append}

@need 800
@code{append} 関数は、あるリストを、もう一つのリストに追加するものである。
例えば、

@smallexample
(append '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 800
@noindent
の結果は次のようになる。

@smallexample
(1 2 3 4 5 6 7 8)
@end smallexample

@code{lengths-list-file} によって作成された二つの長さのリストを一つにま
とめる際は、このような形になって欲しいのだった。@code{cons} を使った場合
と比較してみよう。

@smallexample
(cons '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 1250
@noindent
こっちだと、@code{cons} の最初の引数が出来たリストの最初の要素になって
しまう。

@smallexample
((1 2 3 4) 5 6 7 8)
@end smallexample

@node Several files recursively
@section 異なるファイルの定義を再帰を使って数える

@code{while} ループではなく再帰を使っても各々のファイルのリストに対して
作業することが出来る。再帰を使った @code{lengths-list-many-files} は短く
て単純な形をしている。

再帰関数は、普通は `do-again-test'、`next-step-expression'、そして再帰呼
び出しの部分からなっている。`do-again-test' では、この関数が自分自身をも
う一度呼び出すかどうかを決定する。今の場合は @code{list-of-files} がまだ
残りの要素を持っているかどうかを調べることになる。`next-step-expression'
では、@code{list-of-files} をそれ自身の @sc{cdr} で置き換える。結果とし
て最後にはリストは空になる。実際の完全なコードは、この説明よりも短い！
@findex recursive-lengths-list-many-files

@smallexample
@group
(defun recursive-lengths-list-many-files (list-of-files)
  "Return list of lengths of each defun in LIST-OF-FILES."
  (if list-of-files                     ; @r{do-again-test}
      (append
       (lengths-list-file
        (expand-file-name (car list-of-files)))
       (recursive-lengths-list-many-files
        (cdr list-of-files)))))
@end group
@end smallexample

@noindent
一言で言うと、この関数は @code{list-of-files} の最初のファイルについての
長さのリストを、@code{list-of-files} の残りを引数に自分自身を呼び出した
結果に追加している。

実際に、各ファイルに対して @code{lengths-list-file} を走らせながら
@code{recursive-lengths-list-many-files} をテストしてみるには、次のよう
にする。

まず、まだやっていなければ @code{recursive-lengths-list-many-files} と
@code{lengths-list-files} をインストールし (訳註：
@code{count-words-in-defun} もインストールする必要がある)、その後、次に
挙げるＳ式を評価する。ただし、ファイルのパス名は変更する必要があるかもし
れない。以下の式では、Info ファイルと Emacs のソースファイルが通常の位置
に置いてある場合に有効である。これを変更したい場合は、これらの
式を @file{*scratch*} バッファにコピーして、それらを編集した後、評価すれ
ばよい。

結果は @samp{@result{}} の後に示されている。(これらの結果は Emacs
version 21.1.1 についてのものである。他のバージョンの Emacs については、
また別の結果が出ることだろう。)

@c !!! 22.1.1 lisp sources location here
@smallexample
@group
(cd "/usr/local/share/emacs/22.1.1/")

(lengths-list-file "./lisp/macros.el")
     @result{} (283 263 480 90)
@end group

@group
(lengths-list-file "./lisp/mail/mailalias.el")
     @result{} (38 32 29 95 178 180 321 218 324)
@end group

@group
(lengths-list-file "./lisp/makesum.el")
     @result{} (85 181)
@end group

@group
  (recursive-lengths-list-many-files
   '("./lisp/macros.el"
     "./lisp/mail/mailalias.el"
     "./lisp/makesum.el"))
       @result{} (283 263 480 90 38 32 29 95 178 180 321 218 324 85 181)
@end group
@end smallexample

このように @code{recursive-lengths-list-many-files} は期待した結果を返し
てくれるはずだ。

次のステップは、結果をグラフに表示するためのデータのリストを準備すること
である。

@node Prepare the data
@section データをグラフに表示するための準備

@code{recursive-lengths-list-many-files} 関数は、数のリストを返す。各々
の数は関数定義の長さの記録である。我々がこれからやらねばならないのは、こ
のデータをグラフの表示に適した形の数値のデータに変換することである。新し
く出来るリストからは、10より少ない単語やシンボルしか含まない関数定義がど
れだけあるかとか、10から19や、20から29までではどうか等ということが分るよ
うになる。

手短に言うと、@code{recursive-lengths-list-many-files} 関数が生成したリ
ストを見ていって、各々の範囲に入る関数がどれだけあるかを数えて、それらの
数のリストを作ろうというのである。

@menu
* Data for Display in Detail::
* Sorting::                     リストをソートする
* Files List::                  ファイルのリストを作る
* Counting function definitions::
@end menu

@ifnottex
@node Data for Display in Detail
@unnumberedsubsec The Data for Display in Detail
@end ifnottex

これまでの経験から、長さのリストを `@sc{cdr}' しつつ各々の値を見ていき、
それがどの範囲に入るのかを調べてその範囲についてのカウンタを増やす関数を
書くことは、特に難しくはないものと察しがつくだろう。

しかしながら、実際に関数を書き下す前に、長さのリストをまずソートして、少
ない方から大きい方に並べることによって得られるメリットについて考えるべき
である。まず、ソートすることで、各々の範囲に属する関数の数を数えるのが楽
になる。これは隣同士の数は同じ範囲に属するか隣同士の範囲に属するかどちら
かになるからである。また、リストをソートしてしまえば最大の数と最小の数を
簡単に見つけることが出来る。またそこから、後で必要となる最大と最小の差も
決定出来ることになる。

@node Sorting
@subsection リストのソート
@findex sort

Emacs は  @code{sort} と呼ばれるリストをソートするための関数を持っている。
@code{sort} 関数は二つの引数を持つ。ソートされるべきリストと、二つの要
素の大小を比較する際の述語 (predicate) である。

以前説明したように (@ref{Wrong Type of Argument, , 関数に間違ったタイプ
の引数を与えると}, 参照)、述語とは、ある性質が真か偽かを判断する関数のこ
とである。@code{sort} 関数は、リストの要素を述語が使用する性質に従って並
べ換える。これは、数値以外のリストも、数値以外の基準で---例えばアルファ
ベットの順番で--- @code{sort} を利用して並べ換えることが出来ることを示し
ている。

@need 1250
数値で比較する際には @code{<} 関数が使われる。例えば、

@smallexample
(sort '(4 8 21 17 33 7 21 7) '<)
@end smallexample

@need 800
@noindent
の結果は次のようになる。

@smallexample
(4 7 7 8 17 21 21 33)
@end smallexample

@noindent
(この例では、引数が @code{sort} に渡される際に評価されないように、どち
らのシンボルにも引用符が付いていることに注意しよう。)

@code{recursive-lengths-list-many-files} 関数によって返されたリストをソー
トするのは簡単である。

@ignore
2006 Oct 29
In GNU Emacs 22,  eval
(progn
  (cd "/usr/local/share/emacs/22.0.50/")
  (sort
   (recursive-lengths-list-many-files
    '("./lisp/macros.el"
      "./lisp/mail/mailalias.el"
      "./lisp/makesum.el"))
   '<))

@end ignore

@smallexample
@group
(sort
 (recursive-lengths-list-many-files
  '("./lisp/macros.el"
    "./lisp/mailalias.el"
    "./lisp/makesum.el"))
 '<)
@end group
@end smallexample

@need 800
@noindent
とするだけだ。結果は次のようになる。

@smallexample
(29 32 38 85 90 95 178 180 181 218 263 283 321 324 480)
@end smallexample

@noindent
(この例では @code{sort} の最初の引数には引用符がついていない。これは、
@code{sort} に渡される前にこのＳ式を評価して、リストを生成する必要がある
からである。)

@node Files List
@subsection ファイルのリストの作成

@code{recursive-lengths-list-many-files} 関数は引数としてファイルのリ
ストを必要とする。これまで実験した例では、これらのリストは手で作っていた。
しかし、Emacs Lisp のソースディレクトリは大変大きいので、これらを一々手
で書いているわけにはいかない。そこで、代わりに @code{directory-files} 関数
を作って、このようなリストを作成する必要がある。

@findex directory-files
We did not have to write a function like this for older versions of
GNU Emacs, since they placed all the @samp{.el} files in one
directory.  Instead, we were able to use the @code{directory-files}
function, which lists the names of files that match a specified
pattern within a single directory.

However, recent versions of Emacs place Emacs Lisp files in
sub-directories of the top level @file{lisp} directory.  This
re-arrangement eases navigation.  For example, all the mail related
files are in a @file{lisp} sub-directory called @file{mail}.  But at
the same time, this arrangement forces us to create a file listing
function that descends into the sub-directories.

@findex files-in-below-directory
We can create this function, called @code{files-in-below-directory},
using familiar functions such as @code{car}, @code{nthcdr}, and
@code{substring} in conjunction with an existing function called
@code{directory-files-and-attributes}.  This latter function not only
lists all the filenames in a directory, including the names
of sub-directories, but also their attributes.

To restate our goal: to create a function that will enable us
to feed filenames to @code{recursive-lengths-list-many-files}
as a list that looks like this (but with more elements):

@smallexample
@group
("./lisp/macros.el"
 "./lisp/mail/rmail.el"
 "./lisp/makesum.el")
@end group
@end smallexample

The @code{directory-files-and-attributes} function returns a list of
lists.  Each of the lists within the main list consists of 13
elements.  The first element is a string that contains the name of the
file---which, in GNU/Linux, may be a `directory file', that is to
say, a file with the special attributes of a directory.  The second
element of the list is @code{t} for a directory, a string
for symbolic link (the string is the name linked to), or @code{nil}.

For example, the first @samp{.el} file in the @file{lisp/} directory
is @file{abbrev.el}.  Its name is
@file{/usr/local/share/emacs/22.1.1/lisp/abbrev.el} and it is not a
directory or a symbolic link.

@need 1000
This is how @code{directory-files-and-attributes} lists that file and
its attributes:

@smallexample
@group
("abbrev.el"
nil
1
1000
100
@end group
@group
(20615 27034 579989 697000)
(17905 55681 0 0)
(20615 26327 734791 805000)
13188
"-rw-r--r--"
@end group
@group
t
2971624
773)
@end group
@end smallexample

@need 1200
On the other hand, @file{mail/} is a directory within the @file{lisp/}
directory.  The beginning of its listing looks like this:

@smallexample
@group
("mail"
t
@dots{}
)
@end group
@end smallexample

(To learn about the different attributes, look at the documentation of
@code{file-attributes}.  Bear in mind that the @code{file-attributes}
function does not list the filename, so its first element is
@code{directory-files-and-attributes}'s second element.)

We will want our new function, @code{files-in-below-directory}, to
list the @samp{.el} files in the directory it is told to check, and in
any directories below that directory.

This gives us a hint on how to construct
@code{files-in-below-directory}:  within a directory, the function
should add @samp{.el} filenames to a list; and if, within a directory,
the function comes upon a sub-directory, it should go into that
sub-directory and repeat its actions.

However, we should note that every directory contains a name that
refers to itself, called @file{.}, (``dot'') and a name that refers to
its parent directory, called @file{..} (``double dot'').  (In
@file{/}, the root directory, @file{..} refers to itself, since
@file{/} has no parent.)  Clearly, we do not want our
@code{files-in-below-directory} function to enter those directories,
since they always lead us, directly or indirectly, to the current
directory.

Consequently, our @code{files-in-below-directory} function must do
several tasks:

@itemize @bullet
@item
Check to see whether it is looking at a filename that ends in
@samp{.el}; and if so, add its name to a list.

@item
Check to see whether it is looking at a filename that is the name of a
directory; and if so,

@itemize @minus
@item
Check to see whether it is looking at @file{.}  or @file{..}; and if
so skip it.

@item
Or else, go into that directory and repeat the process.
@end itemize
@end itemize

Let's write a function definition to do these tasks.  We will use a
@code{while} loop to move from one filename to another within a
directory, checking what needs to be done; and we will use a recursive
call to repeat the actions on each sub-directory.  The recursive
pattern is `accumulate'
(@pxref{Accumulate, , Recursive Pattern: @emph{accumulate}}),
using @code{append} as the combiner.

@ignore
(directory-files "/usr/local/src/emacs/lisp/" t "\\.el$")
(shell-command "find /usr/local/src/emacs/lisp/ -name '*.el'")

(directory-files "/usr/local/share/emacs/22.1.1/lisp/" t "\\.el$")
(shell-command "find /usr/local/share/emacs/22.1.1/lisp/ -name '*.el'")
@end ignore

@c  /usr/local/share/emacs/22.1.1/lisp/

@need 800
Here is the function:

@smallexample
@group
(defun files-in-below-directory (directory)
  "List the .el files in DIRECTORY and in its sub-directories."
  ;; Although the function will be used non-interactively,
  ;; it will be easier to test if we make it interactive.
  ;; The directory will have a name such as
  ;;  "/usr/local/share/emacs/22.1.1/lisp/"
  (interactive "DDirectory name: ")
@end group
@group
  (let (el-files-list
        (current-directory-list
         (directory-files-and-attributes directory t)))
    ;; while we are in the current directory
    (while current-directory-list
@end group
@group
      (cond
       ;; check to see whether filename ends in `.el'
       ;; and if so, append its name to a list.
       ((equal ".el" (substring (car (car current-directory-list)) -3))
        (setq el-files-list
              (cons (car (car current-directory-list)) el-files-list)))
@end group
@group
       ;; check whether filename is that of a directory
       ((eq t (car (cdr (car current-directory-list))))
        ;; decide whether to skip or recurse
        (if
            (equal "."
                   (substring (car (car current-directory-list)) -1))
            ;; then do nothing since filename is that of
            ;;   current directory or parent, "." or ".."
            ()
@end group
@group
          ;; else descend into the directory and repeat the process
          (setq el-files-list
                (append
                 (files-in-below-directory
                  (car (car current-directory-list)))
                 el-files-list)))))
      ;; move to the next filename in the list; this also
      ;; shortens the list so the while loop eventually comes to an end
      (setq current-directory-list (cdr current-directory-list)))
    ;; return the filenames
    el-files-list))
@end group
@end smallexample

@c (files-in-below-directory "/usr/local/src/emacs/lisp/")
@c (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")

@code{files-in-below-directory} @code{directory-files} 関数は、一つの引数
（ディレクトリ名）を取る。

@need 1250
従って、例えば私のシステムで

@c (length (files-in-below-directory "/usr/local/src/emacs/lisp/"))

@c !!! 22.1.1 lisp sources location here
@smallexample
@group
(length
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))
@end group
@end smallexample

@noindent
とやると、私の Lisp のソースディレクトリには1031の
@samp{.el} ファイルがあることが分る。

@code{recursive-lengths-list-many-files} が返すリストをソートするための
Ｓ式は次のようになる。

@smallexample
@group
(sort
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
 'string-lessp)
@end group
@end smallexample

@ignore
(defun test ()
  "Test how long it takes to find lengths of all sorted elisp defuns."
  (insert "\n" (current-time-string) "\n")
  (sit-for 0)
  (sort
   (recursive-lengths-list-many-files
    (files-in-below-directory "/usr/local/src/emacs/lisp/"))
   '<)
  (insert (format "%s" (current-time-string))))
@end ignore

@node Counting function definitions
@subsection Counting function definitions

我々の取り敢えずの目標は、10未満の単語やシンボルしか含まない関数定義の数
はどれだけか、10以上、20未満ではどうか、20以上、30未満ではどうか、といっ
たことを調べることである。

ソートされた数のリストを使うと、これは簡単であ
る。まずは、10未満の要素がどれだけあるかを数え、ついで、その次の要素から
20 未満の要素がどれだけか数え、また次の数から 30未満の要素がどれだけか数
える、というふうに続けていく。10、20、30、40等の数は、その範囲の数の最大
よりも大きい数になる。これらの数からなるリストは、@code{top-of-ranges}
リストと呼べばよいだろう。

@need 1200
しようと思えば、このようなリストを自動的に生成することも可能である。が、
今回は手で書いた方が早いだろう。次のような感じである。
@vindex top-of-ranges

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
 "List specifying ranges for `defuns-per-range'.")
@end group
@end smallexample

範囲を変更するには、このリストを編集すればよい。

次に、この各々の範囲に属する定義の数のリストを作る関数を書く必要がある。
明らかに、この関数は引数として @code{sorted-lengths} と
@code{top-of-ranges} リストを取ることになる。

@code{defuns-per-range} 関数は、二つの作業を何回も繰り返すことになる。一
つは現在の top-of-range の値によって特定される範囲の定義の数を数えること、
もう一つはその範囲の数を数え終わったら次に大きな @code{top-of-ranges} の
値に移ることである。これらの動作は繰り返しなので、@code{while} ループを
使うことが出来る。片方のループで現在の top-of-range の値で決まる範囲の定
義の数をカウントし、もう片方のループでは順に top-of-range の値を選択して
いく。

各々の範囲について、@code{sorted-lengths} リストの中の幾つかのエントリ
がカウントされる。従って、@code{sorted-lengths} リストについてのループは
@code{top-of-ranges} リストのループの中に置かれることになる。大きなギヤの
なかの小さなギヤみたいな感じだ。

内部のループでは、該当する範囲の定義の数がカウントされる。これは、今まで
に何回も見たような単純なループである。
(@ref{Incrementing Loop, , 増加するカウンタを使ったループ}, を参照。) ルー
プの真偽テストは @code{sorted-lengths} リストの中の数が現在の
top-of-range の値よりも小さいかどうかを見ることになる。もしそうなら、カ
ウンタを一つ増やして、次の @code{sorted-lengths} のエントリに移動する。

@need 1250
結局、内部のループは次のようになる。

@smallexample
@group
(while @var{長さの要素が top-of-range より小さい}
  (setq number-within-range (1+ number-within-range))
  (setq sorted-lengths (cdr sorted-lengths)))
@end group
@end smallexample

外部のループは @code{top-of-ranges} リストの最小値から始まって、順に大き
な値に移っていくことになる。そのためには、次のようにすればよい。

@smallexample
@group
(while top-of-ranges
  @var{ループの本体}@dots{}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

これらを合わせると、二つのループは次のようになる。

@smallexample
@group
(while top-of-ranges

  ;; @r{現在の範囲にある要素の数のカウント}
  (while @var{長さの要素が top-of-range より小さい}
    (setq number-within-range (1+ number-within-range))
    (setq sorted-lengths (cdr sorted-lengths)))

  ;; @r{次の範囲に移動}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

更に、一回の外部ループごとに、Emacs にその範囲に属する定義の数を記録させ
る必要がある。(リストの中の @code{number-within-range} の値である。この
目的には、@code{cons} が使える。(@ref{cons, , @code{cons}}, を参照。)

@code{cons} 関数はほぼうまく動作するのだが、一つ難点がある。出来るリスト
では最初に大きい方の範囲に入る定義の数がきて、最後に小さい方の範囲の数が
きてしまうのだ。これは、@code{cons} が新しい要素をリストの先頭に加えてい
くことと、上の二つのループは小さい方から大きい方へ長さのリストを作成して
いくために、@code{defuns-per-range-list} が最大の数で終わることからの当
然の帰結である。しかし、グラフを表示する際には小さい値の方を先に表示した
い。この問題を解決するには、@code{defuns-per-range-list} の順序を逆にし
てしまえばよい。これは、@code{nreverse} というリストの順序を逆にする関数
を使うとあっさり解決する。
@findex nreverse

例えば、

@smallexample
(nreverse '(1 2 3 4))
@end smallexample

@noindent
とすると、

@smallexample
(4 3 2 1)
@end smallexample

@noindent
が返る。

注意して欲しいのは、@code{nreverse} は「破壊的」であるということである。
これは、作用させたリストを変更してしまうことを意味している。(訳註：これ
は逆の順のリストに設定されるということではなくて、文字通り破壊されてしま
うということである。) 今の場合、元の @code{defuns-per-range-list} は必要
ないので、これが破壊されても何の問題もない。(一方、@code{reverse} 関数は
元のリストを逆に並べ換えた新しいリストを返す。この場合は元のリストは変化
しない。)
@findex reverse

@need 1250
以上を全て組み合わせると、@code{defuns-per-range} は次のようになる。

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{外部のループ}
    (while top-of-ranges
@end group

@group
      ;; @r{内部のループ}
      (while (and
              ;; @r{数値引数として数が必要}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))
@end group

@group
        ;; @r{現在の範囲に入る関数の数を数える}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))

      ;; @r{内部のループは抜けるが、外部のループには入ったまま}
@end group

@group
      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{カウンタを 0 にリセット}
@end group

@group
      ;; @r{次の範囲に移動}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{次の範囲のトップを特定}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{外部のループを抜けて最も大きいの範囲に属する関数定義の数}
    ;; @r{を数える}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))
@end group

@group
    ;; @r{昇順で並ぶ関数定義の長さのリストを返す。}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@noindent
この関数は次のちょっとした点を除いては、非常に単純である。内部のループの真
偽テストは、

@smallexample
@group
(and (car sorted-lengths)
     (< (car sorted-lengths) top-of-range))
@end group
@end smallexample

@noindent
であって、

@smallexample
(< (car sorted-lengths) top-of-range)
@end smallexample

ではない。このテストの目的は @code{sorted-lengths} リストの最初の要素が
その時点での top-of-range の値よりも小さいかどうかを決定することである。

後に挙げた単純な方のテストでも @code{sorted-lengths} リストが @code{nil}
になるまではうまく動作する。しかし、@code{nil} になると、@code{(car
sorted-lengths)} 式は @code{nil} を返す。@code{<} 関数は数値と
@code{nil}、即ち空リストとを比較できないため、Emacs はここでエラーを出し、
関数はそこで実行を止めてしまう。

@code{sorted-lengths} リストはカウンタがリストの最後まで辿りつけば常に
@code{nil} になる。従って、この @code{defuns-per-range} 関数の真偽テスト
の単純なバージョンの方は常に失敗することになる。

  この問題は、@code{(car sorted-lengths)} 式と @code{and} 式を組み合わせ
ることで解決することが出来る。@code{(car sorted-lengths)} 式はリストが最
低一つでも要素を持てば、non-@code{nil} を返す。そしてリストが空になった
時だけ @code{nil} を返す。@code{and} 式は最初に @code{(car
sorted-lengths)} 式を評価し、もしそれが @code{nil} なら @code{<} 式を評
価する前に偽を返す。しかし、もし @code{(car sorted-lengths)} 式が
non-@code{nil} な値を返せば、@code{<} 式も評価し、その値を @code{and} 式
全体の値を返す。

@c colon in printed section title causes problem in Info cross reference
こうしてエラーが回避出来ることになる。
@iftex
(For information about @code{and}, see
@ref{kill-new function, , The @code{kill-new} function}.)

（旧訳）@code{and} についての詳細は、@ref{forward-paragraph, ,
@code{forward-paragraph}：関数の金脈}, を参照のこと。
@end iftex
@ifinfo
@code{and} についての詳細は、@ref{forward-paragraph}, を参照のこと。
@end ifinfo

次に @code{defuns-per-range} についての簡単なテストを載せておく。最初に
(短縮した) リストを @code{top-of-ranges} にバインドするＳ式を評価し、次
に @code{sorted-lengths} リストをバインドするＳ式を評価し、最後に
@code{defuns-per-range} 関数を評価してみよう。

@smallexample
@group
;; @r{(後で使うものよりかは短いリスト)}
(setq top-of-ranges
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)
@end group
@end smallexample

@need 800
@noindent
次のようなリストが返されるはずである。

@smallexample
(2 2 2 0 0 1 0 2 0 0 4)
@end smallexample

@noindent
実際、@code{sorted-lengths} リストには、110未満の二つの要素が二つ、110か
ら119までの要素も二つ、120から129までも二つ、といった感じになっている。
また、200以上の値の要素は四つある。

@c The next step is to turn this numbers' list into a graph.

@node Readying a Graph
@chapter グラフを描く準備
@cindex Readying a graph
@cindex Graph prototype
@cindex Prototype graph
@cindex Body of graph

我々の目標は、Emacs のソースの中の様々な長さの関数定義の数をグラフにして
表示することであった。

実際には、グラフを生成するには @code{gnuplot} のようなプログラムを使って
いることだと思う。(@code{gnuplot} は GNU Emacs と相性がよい。)しかしなが
ら、今回は一からプログラムを書いていくことにする。そしてその過程で、今ま
で学んできた事柄を再度確認しつつ、新しいことも学んでいくことにしよう。

この章では、まずグラフを表示する単純な関数を書いてみる。最初の定義は
@dfn{雛型} (@dfn{prototype}) であり、グラフを作成するという未知の領域を
偵察するために取り敢えず書いてみるといった類のものである。我々はドラゴン
を発見するかもしれないし、あるいはそれが単なる神話であることが分るかもし
れない。ともかく地理感覚が掴めてしまえば、自信もつくし、関数を拡張して軸
に自動的にラベルをつけることも出来るようになるだろう。

@menu
* Columns of a graph::          縦のグラフはどうやって表示すればよいか
* graph-body-print::            グラフ本体の表示
* recursive-graph-body-print::  グラフ本体の表示を再帰的に行う
* Printed Axes::                軸の表示
* Line Graph Exercise::         棒グラフについての練習問題
@end menu

@ifnottex
@node Columns of a graph
@unnumberedsec 棒グラフの表示
@end ifnottex

Emacs はどんな種類のターミナルでも動作するよう柔軟に設計されている。その
中にはキャラクターだけしか表示出来ないターミナルも含まれているので、グラ
フは「タイプライタ」の文字から出来ている必要がある。取り敢えずはアスタリ
スクを使うのがよいだろう。後から関数を拡張して、この文字をユーザーが選択
出来るようにすることも可能だ。

この関数を、@code{graph-body-print} と呼ぶことにしよう。これは引数として
@code{numbers-list} を取る。現段階ではグラフのラベルは出力せず、本体部分
だけを表示することにする。

@code{graph-body-print} 関数は、@code{numbers-list} の各々の値に対して、
アスタリスクを垂直に並べて表示する。それぞれの高さは、
@code{numbers-list} の各要素の値によって決まる。

アスタリスクを垂直に並べる動作は繰り返しである。従って、@code{while} ルー
プか再帰を使って書くことが出来る。

最初の困難は、如何にしてアスタリスクを縦に並べたものを表示するかである。
普通、Emacs 上でタイプすると、文字はスクリーン上に水平に、行ごとに表示さ
れていく。解決への道は二通りある。一つは自分で垂直に挿入するような関数を
書くこと、もう一つは元々 Emacs にそのような関数がないか探すことである。

Emacs に特定の機能を持ったものがないか探す場合には、@kbd{M-x apropos} コ
マンドを使うことが出来る。このコマンドは、@kbd{C-h a} (command-apropos)
コマンドとほぼ同様なのだが、command-apropos の方はコマンドだけしか検索し
ない。@kbd{M-x apropos} の方は、インタラクティブでないものも含めて正規表
現にマッチするものは全てリストしてくれる。我々が探しているものは縦の文字
列 (column) を表示 (print) したり挿入 (insert) したりするコマンドである。
可能性としては、そのような関数は `print' とか `insert' とか `column' と
いった文字列を含んでいそうである。そこで、単純に @kbd{M-x apropos RET
print\|insert\|column RET} として、結果を見てみる。私のシステムでは、こ
のコマンドの実行には暫く時間がかかり、結局79個の関数及び変数のリストが表
示された。このリストを探してみると、我々の仕事に役立ちそうなのは、
@code{insert-rectangle} だけである。実際、これが我々の求めていた関数であ
る。説明を読んでみよう。

@smallexample
@group
insert-rectangle:
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE's first line is inserted at point,
its second line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
@end group
@end smallexample
@smallexample
@group
(日本語訳)
RECTANGLE のテキストを左上がポイントに来るような位置に挿入する。
つまり RECTANGLE の最初の行がポイントの位置に挿入され、
二行目はポイントの真下の位置に挿入され、というふうになる。
RECTANGLE は文字列のリストでなければならない。
@end group
@end smallexample

簡単なテストを行って、これが本当に求めるものかを確かめてみよう。

以下が、@code{insert-rectangle} 式の直後にカーソルを持っていって、
@kbd{C-u C-x C-e} (@code{eval-last-sexp}) とタイプしてみた結果である。
この関数は、@samp{"first"}, @samp{"second"} そして @samp{third"} をポイ
ントの下に表示する。関数全体としては、@code{nil} が返る。

@smallexample
@group
(insert-rectangle '("first" "second" "third"))first
                                              second
                                              thirdnil
@end group
@end smallexample

@noindent
(訳註：広く配布されている Mule 2.3 (Emacs version 19.28) では、この関数
にバグがある。これは、@file{lisp/rect.el} の最後の方にある
@code{move-to-column-strictly} の関数定義の中で、四行目の @code{clm} を
@code{(progn (if force (indent-to column)) column)} で置換えることで修正
出来る。)

@noindent
勿論、我々は @code{insert-rectangle} 式そのものをグラフを描くバッファに
挿入したいのではない。そうではなく、我々のプログラムからこの関数を呼び出
したいのである。ただその際、ポイントがバッファの中で、ちゃんと
@code{insert-rectangle} 関数で縦の文字列を挿入すべき位置にあるかどうかを
確かめなければならない。

もしこの文章を Info の中で読んでいるなら、まず @file{*scratch*} などの別
バッファに移り、ポイントをバッファのどこかに置きつつ typing @kbd{M-:}と
タイプしよう。(訳註：1998 年現在、日本でまだ使用が多いと思われる Emacs
19.28 ベースの Mule では @kbd{M-@key{ESC}} である。同様に多い Emacs
19.34 べースのものでは @kbd{M-:} で良い。@kbd{M-@key{ESC}} はプレフィク
スキーとして使われるようになった。) 続けてミニバッファで
@code{insert-rectangle} 式をタイプしてやれば、このような動作が可能である
ことが分る。ここでは、Ｓ式を評価するのはミニバッファの中だったのだが、そ
の際のポイントの値としては、@file{*scratch*} バッファの中のポイントの値
が使われたのであった。(@kbd{M-:} は @code{eval-expression} のキーバイン
ディングである。)

実際にやってみると、ポイントが直前に入力した行の最後にある状態で終わるこ
と---つまり、この関数は副作用として、ポイントを移動することが分る。この
コマンドを続けて実行すると、次の挿入は前回の位置から下方及び右方向に移動
した所から行われる。これでは困る。棒グラフを作成するには、縦の列が隣同士
に並ばなければならない。

というわけで、棒グラフを挿入する @code{while} ループの各々のサイクルで、
ポイントの位置を適切な位置に再配置する必要があることが分った。また、その
位置は縦の列の一番上であって底ではない。更に、このグラフを表示する際に、
個々の縦の列の長さが全て揃うことはまずない。つまり、各々の縦棒のてっぺん
の高さは、前のものと異なるのが普通である。従って、単に前と同じ行にポイン
トを移動していくだけでは駄目である。そうではなくて@dots{}

我々はグラフをアスタリスクで表示しようとしていたのであった。アスタリスク
の数は @code{numbers-list} の現在の要素で指定される。このアスタリスクを
要素とするリストを、@code{insert-rectangle} を呼び出すたびに作成する必要
がある。もし、このリストが単に必要な数のアスタリスクだけからなっていたと
すると、ポイントの位置をグラフの基準線から正しい行数だけ上の位置におかな
ければならない。しかし、これは難しい。

その代わり、もし @code{insert-rectangle} に対して常に一定の長さのリスト
を渡すことが出来れば、ポイントも常に同じ行の一つ右の桁に移動すればよくな
る。しかし、この場合には @code{insert-rectangle} に渡されるリストのいく
つかの要素はアスタリスクではなく空白になる。例えば、もしグラフの最大の高
さが5であり、現在の高さが3であったとすると、@code{insert-rectangle} は、
次のような引数を必要とする。

@smallexample
(" " " " "*" "*" "*")
@end smallexample

この最後の方法は、縦の列の高さを決定出来さえすれば、それほど難しくはない。
縦の列の高さを特定するには二つの方法がある。一つは我々が綺麗に表示される
ような高さを勝手に指定してしまうというもの、もう一つは、数のリストを検索
して、最大のものをグラフの最大の高さとして使うというものである。後者の方
法が難しい場合は、前者を採用するのが楽である。が、Emacs には、初めから引
数の中で最大のものを決定する関数が組み込まれている。この関数を使おう。関
数の名前は @code{max} で、全ての引数の中で最大のものを返す。引数は数でな
ければならない。従って、例えば、

@smallexample
(max  3 4 6 5 7 3)
@end smallexample

@noindent
は7を返す。(これに対して @code{min} という関数は、引数の中で最小のもの
を返す。)
@findex max
@findex min

しかしながら、単に @code{numbers-list} の上で @code{max} を呼び出すこと
は出来ない。@code{max} は数のリストではなく、数を引数として要求するから
だ。従って、

@smallexample
(max  '(3 4 6 5 7 3))
@end smallexample

@need 800
@noindent
とやると、次のようなエラーメッセージが返される。

@smallexample
Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)
@end smallexample

@findex apply
従って、リストの中身を引数として関数に渡すような関数が必要になる。
@code{apply} と呼ばれる関数がこの役目を果してくれる。この関数はその最初
の引数である関数に、残りの引数を適用 (apply) する。この時、最後の引数は
リストでなければならない。

@need 1250
例えば

@smallexample
(apply 'max 3 4 7 3 '(4 8 5))
@end smallexample

@noindent
は8を返す。

(ついでにいうと、私はこの関数をこの文書のようなものを使わずに見つけだす
方法を知らない。他の @code{search-forward} や @code{insert-rectangle} と
いった関数ならば、名前の一部分を推測して @code{apropos} を使えばよい。け
れども apply については、名前の元となるメタファ---最初の引数に残りを
`apply' する---は明らかであるにしても、初心者が @code{apropos} や他の助
けを借りてこのような特定な単語に辿り着けるとは思わない。勿論、私が間違っ
ているのかもしれない。結局は、関数はそれを作った人によって名付けられるも
のなのである。)

@code{apply} の二番目以降の引数は省略可能である。従って、@code{apply} を
使って、関数にリストの要素を引数として渡して呼び出すことも出来る。例えば、
次は8を返す。

@smallexample
(apply 'max '(4 8 5))
@end smallexample

この最後の例が我々の目的にあっている。
@code{recursive-lengths-list-many-files} 関数は、数のリストを返すが、こ
れを @code{max} に適用することが出来るわけである。(@code{max} にソートさ
れたリストを渡すことも出来るが、この場合はソートされていてもされていなく
ても関係ない。)

というわけで、グラフの最大の高さを求める操作は次の通りである。

@smallexample
(setq max-graph-height (apply 'max numbers-list))
@end smallexample

では、グラフの縦の列を描くための文字列のリストをどうやって作ればよいかと
いう問題に戻ろう。この関数はグラフの最大の高さと個々の縦の列の中のアスタ
リスクの数から、@code{insert-rectangle} コマンドが挿入する文字列のリスト
を返す必要がある。

各々の縦の列は空白とアスタリスクからなる。高さとアスタリスクの数が分れば、
空白の数はその差として求められる。そして空白とアスタリスクの数が分れば、
二つの @code{while} ループを使ってリストを作ることが出来る。

@smallexample
@group
;;; @r{最初のバージョン}
(defun column-of-graph (max-graph-height actual-height)
  "Return list of strings that is one column of a graph."
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{アスタリスクを詰める}
    (while (> actual-height 0)
      (setq insert-list (cons "*" insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{空白を詰める}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons " " insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))
@end group

@group
    ;; @r{リスト全体を返す}
    insert-list))
@end group
@end smallexample

この関数をインストールしてから次のＳ式を評価すると、求めるリストが得られ
るはずだ。

@smallexample
(column-of-graph 5 3)
@end smallexample

@noindent
を評価すると、

@smallexample
(" " " " "*" "*" "*")
@end smallexample

@noindent
が返されるというわけである。

前にも書いたが、@code{column-of-graph} には大きな欠陥がある。空白とグラ
フ本体の印のために用いられる記号はスペースとアスタリスクに「ハードコード」
されている。これは雛型としてはよい。が、あなたや他のユーザは他の記号を使
いたいと思うことも多いだろう。例えば、グラフ関数をテストしてみる際には、
@code{insert-rectangle} 関数が呼ばれた時にポイントの位置がきちんと移動さ
れているかどうかを見るために、スペースの代わりに終止符を使いたいと思うだ
ろう。また、アスタリスクの代わりに @samp{+} 等の記号を使ったりしたいと思
うこともあるに違いない。更に、グラフの桁数をディスプレイの一桁の幅よりも
広く取りたいと思うこともあるだろう。そういうわけでプログラムはもっと柔軟
であるべきである。そのための方法としては、スペースとアスタリスクを
@code{graph-blank} と @code{graph-symbol} という二つの変数で置き換えて、
これらの変数を別に定義することが考えられる。

また、説明文字列も解りやすいとは言えない。以上のことを考慮すると、次のよ
うな関数に辿り着く。

@smallexample
@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group
@end smallexample

@noindent
(@code{defvar} の説明については、@ref{defvar, , @code{defvar} を用いた変数の初期化},を参照。)

@smallexample
@group
;;; @r{二番目のバージョン}
(defun column-of-graph (max-graph-height actual-height)
  "Return list of MAX-GRAPH-HEIGHT strings;
ACTUAL-HEIGHT are graph-symbols.
@end group
@group
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{@code{graph-symbols} を詰める}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{@code{graph-blanks} を詰める}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{リスト全体を返す}
    insert-list))
@end group
@end smallexample

もし望むなら、@code{column-of-graph} も書き換えて、オプションとして棒グラ
フだけでなく、線グラフも書けるようにも出来る。これはそんなに難しいことで
はない。線グラフをどう描くかだが、例えば棒グラフにおいて、一番上の点から
下は全て空白にしてしまえば、それはもう棒グラフとは呼べないだろう。線グラ
フのための縦の文字列を作るには、まずは値よりも一つだけ少ない数の空白のリ
ストを作り、ついで @code{cons} を用いてリストにグラフ記号を追加し、最後
に、上の余白部分の数の空白を付け足せばよい。

こういう関数を実際に書くのも簡単だが、今の所は必要ないので、書かないでお
くことにする。が、ともかく書くことは出来るし、またこの関数を一度書いてし
まえば、@code{column-of-graph} で使うことも出来る。ここで大切なことは、
他の部分の書き換えは殆どしなくても良いということである。即ち、拡張しよう
と思えば簡単に出来るわけだ。

さて、やっと、はじめて実際のグラフを書いてみる所まで来た。ここではグラフ
の本体だけを表示し、縦軸や横軸のラベルは表示しない。そこで、この関数を
@code{graph-body-print} と呼ぶことにする。

@node graph-body-print
@section 関数 @code{graph-body-print}
@findex graph-body-print

前節までの準備の後では、@code{graph-body-print} 関数はあっというまに出来
てしまう。この関数は、数値のリストから各々の縦の列の中のアスタリスクの数
を決定し、一桁おきにアスタリスクを用いたグラフを表示する。これは繰り返し
の動作なので、減少 @code{while} ループか、再帰を使って書くことが出来る。
このセクションでは、@code{while} ループを用いて定義を書いてみよう。

@code{column-of-graph} 関数は、引数としてグラフの高さを必要とする。この
値を定めたなら、局所変数として記録しておくべきである。

これらのことから、このバージョンにおいては次のような @code{while} ループ
のテンプレートが出来る。

@smallexample
@group
(defun graph-body-print (numbers-list)
  "@var{説明文字列}@dots{}"
  (let ((height  @dots{}
         @dots{}))
@end group

@group
    (while numbers-list
      @var{縦の列を挿入し、ポイントを移動}
      (setq numbers-list (cdr numbers-list)))))
@end group
@end smallexample

@noindent
この中の空きスロットを埋めていくことになる。

当然、グラフの高さの決定には @code{(apply 'max numbers-list)} 式を使うこ
とが出来る。

@code{while} ループは @code{numbers-list} の各要素に対して一回ずつ回る。
このリストは @code{(setq numbers-list (cdr numbers-list))} 式によって短
くなっていき、各時点でのリストの @sc{car} が @code{column-of-graph} に引
数として渡される。

この @code{while} ループの各サイクルで、@code{column-of-graph} によって
返されたリストが @code{insert-rectangle} 関数に渡される。
@code{insert-rectangle} 関数はポイントを挿入された矩形の右下のポイントに
移動するので、それを矩形が挿入される前の位置に戻してから、次の位置に水平
方向に移動してやる必要がある。そこで次の @code{insert-rectangle} が呼ば
れるわけである。

単独の空白とアスタリスクを使った場合などのように、もし挿入される棒グラフ
が一桁の幅ならば、移動のためのコマンドは単に @code{(forward-char 1)} と
なる。しかし、この幅はもっと大きくなるかもしれない。従って、
@code{(forward-char symbol-width)} と書く方が良い。@code{symbol-width}
は @code{graph-blank} の長さであり、@code{(length graph-blank)} という式
で求めることが出来る。@code{symbol-width} という変数をグラフの幅にバイン
ドする一番良い位置は @code{let} 式の変数リストの中である。

@need 1250
以上のことを総合すると次のような関数定義になる。

@smallexample
@group
(defun graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."

  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
@end group

@group
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{各桁ごとのグラフの描写}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
@end group
@group
    ;; @r{X 軸のラベルのためにポイントを移動}
    (forward-line height)
    (insert "\n")
))
@end group
@end smallexample

@noindent
この関数では、ひとつ予期していなかったＳ式が出てくる。それは
@code{while} ループの中の @w{@code{(sit-for 0)}} 式である。この式を使う
ことで、グラフを表示する過程を見るのが楽しくなる。この式は Emacs に 0 時
間待ってから画面を再描画させるものである。これを上の位置に置くと棒グラフ
が一つずつ描かれていくことになる。逆に置かなければ、関数が仕事を全て終了
するまでグラフは描かれない。

次のようにすれば、この @code{graph-body-print} を短いリストに対してテス
トしてみることが出来る。

@enumerate
@item
まず @code{graph-symbol}、@code{graph-blank}、@code{column-of-graph} そ
して @code{graph-body-print} をインストールする。

@need 800
@item
次のＳ式をコピーする。

@smallexample
(graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
@end smallexample

@item
@file{*scratch*} バッファに移り、グラフを表示させたい位置にカーソルを置
く。

@item
@kbd{M-:} (@code{eval-expression}) とタイプする。(訳註：Emacs 19.28 ベー
スの Mule では、@kbd{M-@key{ESC}}.)

@item
@kbd{C-y} (@code{yank}) を使って @code{graph-body-print} 式をミニバッファ
に yank する。

@item
@kbd{RET} を押して、@code{graph-body-print} 式を評価する。
@end enumerate

@need 800
Emacs は次のようなグラフを表示するはずである。

@smallexample
@group
                    *
                *   **
                *  ****
               *** ****
              ********* *
             ************
            *************
@end group
@end smallexample

@node recursive-graph-body-print
@section 関数 @code{recursive-graph-body-print}
@findex recursive-graph-body-print

@code{graph-body-print} 関数は、再帰を使って書くことも出来る。この場合は、
二つの部分に分けて書くことになる。外側の関数 (wrapper) で @code{let} 式を
使って、グラフの最大の高さのように一度だけ決めればよいような幾つかの変数
の値を設定し、内側の関数で、再帰呼び出しを使ってグラフを表示するわけであ
る。

@need 1250
外側の関数 (wrapper) は特に複雑ではない。

@smallexample
@group
(defun recursive-graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."
  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
    (recursive-graph-body-print-internal
     numbers-list
     height
     symbol-width)))
@end group
@end smallexample

再帰関数の方は、ちょっとばかり難しい。これは `do-again-test'、グラフ表示
コード、再帰呼び出し、そして `next-step-expression' の四つの部分からなる。
`do-again-test' は @code{number-list} にまだ要素が残っているかを判定する@
@code{if} 式である。もし残っていれば、一本の棒グラフを書いてからまた自
分自身を呼び出す。関数が自分自身をもう一度呼び出すかどうかは、結局は
`next-step-expression' が返す値による。これは、短縮版の@
@code{number-list} に作用するような呼び出しを行う。

@smallexample
@group
(defun recursive-graph-body-print-internal
  (numbers-list height symbol-width)
  "Print a bar graph.
Used within recursive-graph-body-print function."
@end group

@group
  (when numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
@end group
@group
        (goto-char from-position)
        (forward-char symbol-width)
        (sit-for 0)     ; @r{各桁ごとのグラフの描写}
        (recursive-graph-body-print-internal
         (cdr numbers-list) height symbol-width)))
@end group
@end smallexample

@need 1250
これをインストールして実際にテストしてみることが出来る。次にサンプルを挙
げる。

@smallexample
(recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

これを評価すると、次のようなグラフが描かれる。

@smallexample
@group
                *
               **   *
              ****  *
              **** ***
            * *********
            ************
            *************
@end group
@end smallexample

@code{graph-body-print} も @code{recursive-graph-body-print} もグラフの
本体部分のみを描く関数である。

@node Printed Axes
@section 軸を表示する

グラフには、それが何を表わすかを示すために軸を表示する必要がある。一度だ
けしかグラフを描かないのならば、Emacs の Picture mode を利用して手で軸を
描くのも結構である。しかし、この関数は何度も利用するかもしれない。

というわけで、基本的な @code{print-graph-body} 関数を拡張して、自動的に
横軸と縦軸のラベルを表示するようにしてみた。この関数には特に新しい事柄は
含まれていないので、これについての説明は次の所ですることにする。
@ref{Full Graph, , ラベルと軸が付いたグラフ}.

@node Line Graph Exercise
@section 練習問題

上と同様なグラフを表示する関数で、横棒のグラフを描くバージョンを作りなさい。

@node Emacs Initialization
@chapter @file{.emacs} ファイル
@cindex @file{.emacs} file
@cindex Customizing your @file{.emacs} file
@cindex Initialization file

「Emacs を好きになるために Emacs を好きになる必要はない。」-- この、一見
パラドクスのように聞こえる格言こそが、GNU Emacs の秘密である。ただ箱を開
けて取り出したままの Emacs は一般的な道具でしかない。大抵の人は、それを
自分自身が使いやすいようにカスタマイズする。

GNU Emacs は多くの部分が Emacs Lisp で書かれている。これは、Emacs Lisp
の式を書くことで、変更したり拡張したり出来るということを意味する。

@menu
* Default Configuration::       Emacs のデフォルトは合理的である
* Site-wide Init::              サイトごとの初期化ファイルもある
* defcustom::                   Emacs will write code for you.
* Beginning init File::         @code{.emacs file} の書き方
* Text and Auto-fill::          自動的に行を折り返す
* Mail Aliases::                Email の短縮アドレス
* Indent Tabs Mode::            @TeX{} ではタブを使わないようにするには
* Keybindings::                 個人的なキーバインディングを設定するには
* Keymaps::                     キーバインディングについて更に詳しく
* Loading Files::               ファイルを自動的にロード(評価)する
* Autoload::                    Autoload: 関数をすぐ使える状態に
* Simple Extension::            関数を定義し、キーにバインドする
* X11 Colors::                  Version 19 の X 上でのカラー表示
* Miscellaneous::               雑多な設定
* Mode Line::                   モード行のカスタマイズ
@end menu

@ifnottex
@node Default Configuration
@unnumberedsec Emacs のデフォルトの設定
@end ifnottex

Emacs のデフォルトの設定を素直にありがたく使う人達もいる。それでも Emacs
は C のファイルを編集する際は C mode になるし、Fortran のファイルを編集
する際は Fortran mode になるし、特に設定されていないファイルについては
Fundamental mode になる。誰が Emacs を使うか分らない状況では、これは合理
的な設定である。人々がどのファイルに対して何をしたいかを把握出来る人など
何処にもいないだろう。Fundamental mode は把握出来ないようなファイルに対
しての正しいデフォルトである。ちょうど C mode が C のコードを編集する際
の正しいデフォルトであるのと同じである。

しかし、もし誰が Emacs を使おう
としているかが分る場合---例えば自分自身が使う場合---なら Emacs をカスタ
マイズするのが合理的である。

例えば私は、適当なモードが見つからないようなファイルに対しては
Fundamental mode にしたいことは殆どない。そういう場合には Text mode を使
うことが多い。そこで Emacs をカスタマイズする。結果として、私にとって使
いやすいものになる。

Emacs をカスタマイズしたり拡張したりするには @file{~/.emacs} ファイルを
書くことになる。これは個人用の初期化ファイルである。
@footnote{You
may also add @file{.el} to @file{~/.emacs} and call it a
@file{~/.emacs.el} file.  In the past, you were forbidden to type the
extra keystrokes that the name @file{~/.emacs.el} requires, but now
you may.  The new format is consistent with the Emacs Lisp file
naming conventions; the old format saves typing.}

中身は Emacs Lisp で書かれ、Emacs に何をするかを伝える。

A @file{~/.emacs} file contains Emacs Lisp code.  You can write this
code yourself; or you can use Emacs's @code{customize} feature to write
the code for you.  You can combine your own expressions and
auto-written Customize expressions in your @file{.emacs} file.

(I myself prefer to write my own expressions, except for those,
particularly fonts, that I find easier to manipulate using the
@code{customize} command.  I combine the two methods.)

この章では、簡単な @file{.emacs} の説明をする。より多くの情報については、
以下を参照して欲しい。@ref{Init File, , The Init File, emacs, The GNU
Emacs Manual}, @ref{Init File, , The Init File, elisp, The GNU Emacs
Lisp Reference Manual}.

@node Site-wide Init
@section サイトごとの初期化ファイル

@cindex @file{default.el} init file
@cindex @file{site-init.el} init file
@cindex @file{site-load.el} init file
Emacs は個人的な初期化ファイルに加えて、サイト用の初期化ファイルが存在す
れば、それも自動的にロードする。これらは @file{.emacs} と同様な形式で書
かれるが、全員に対してロードされる。

このサイト用の初期化ファイルの中の @file{site-load.el} と
@file{site-init.el} の二つは、Emacs が dump される際に、ロードされ、かつ
標準的なものとして `dump' される。(Dump することで、Emacs はより速くロー
ド出来る。しかしながら、一旦ファイルがロードされ dump されると、もう一度
自分でロードしたり再 dump したりしない限り、変更は Emacs に反映されない。
これについては @ref{Building Emacs, , Building Emacs, elisp, The GNU
Emacs Lisp Reference Manual}, 及び @file{INSTALL} ファイルを参照のこと。)

これら以外にも三つのサイト用の初期化ファイルがあり、それらは存在すれば
Emacs の起動時に自動的にロードされる。この三つのファイルというのは、
@file{.emacs} の@emph{前に}ロードされる @file{site-start.el}、及び
@file{.emacs} の@emph{後に}ロードされる @file{default.el} と端末タイプファ
イルである。

@file{.emacs} での設定や定義は、@file{site-start.el} での設定や定義を上
書きする。そして、@file{default.el} や端末タイプファイルが更にその設定や
定義を上書きすることになる。(端末タイプファイルによる上書きを防ぐには、
@code{term-file-prefix} を @code{nil} にする。@ref{Simple Extension, ,
ちょっとした拡張}, を参照。)

@c Rewritten to avoid overfull hbox.
配布の中に含まれる @file{INSTALL} ファイルには、@file{site-init.el} と
@file{site-load.el} についての説明がある。

@file{loadup.el}、@file{startup.el}、そして @file{loaddefs.el} ファイル
がロードをコントロールしている。これらのファイルは Emacs の配布の中の
@file{lisp} ディレクトリの中にあるので、読んでみると良い。

@file{loaddefs.el} ファイルには、何を個人的な @file{.emacs} ファイルの中
に書き、何をサイト用の初期化ファイルに書くべきなのかということについて多
くの有益な示唆が書かれている。

@node defcustom
@section @code{defcustom} による変数の設定
@findex defcustom

You can specify variables using @code{defcustom} so that you and
others can then use Emacs's @code{customize} feature to set their
values.  (You cannot use @code{customize} to write function
definitions; but you can write @code{defuns} in your @file{.emacs}
file.  Indeed, you can write any Lisp expression in your @file{.emacs}
file.)

The @code{customize} feature depends on the @code{defcustom} macro.
Although you can use @code{defvar} or @code{setq} for variables that
users set, the @code{defcustom} macro is designed for the job.

You can use your knowledge of @code{defvar} for writing the
first three arguments for @code{defcustom}.  The first argument to
@code{defcustom} is the name of the variable.  The second argument is
the variable's initial value, if any; and this value is set only if
the value has not already been set.  The third argument is the
documentation.

The fourth and subsequent arguments to @code{defcustom} specify types
and options; these are not featured in @code{defvar}.  (These
arguments are optional.)

Each of these arguments consists of a keyword followed by a value.
Each keyword starts with the colon character @samp{:}.

@need 1250
For example, the customizable user option variable
@code{text-mode-hook} looks like this:

@smallexample
@group
(defcustom text-mode-hook nil
  "Normal hook run when entering Text mode and many related modes."
  :type 'hook
  :options '(turn-on-auto-fill flyspell-mode)
  :group 'wp)
@end group
@end smallexample

@noindent
The name of the variable is @code{text-mode-hook}; it has no default
value; and its documentation string tells you what it does.

The @code{:type} keyword tells Emacs the kind of data to which
@code{text-mode-hook} should be set and how to display the value in a
Customization buffer.

The @code{:options} keyword specifies a suggested list of values for
the variable.  Usually, @code{:options} applies to a hook.
The list is only a suggestion; it is not exclusive; a person who sets
the variable may set it to other values; the list shown following the
@code{:options} keyword is intended to offer convenient choices to a
user.

Finally, the @code{:group} keyword tells the Emacs Customization
command in which group the variable is located.  This tells where to
find it.

The @code{defcustom} macro recognizes more than a dozen keywords.
For more information, see @ref{Customization, , Writing Customization
Definitions, elisp, The GNU Emacs Lisp Reference Manual}.

Consider @code{text-mode-hook} as an example.

There are two ways to customize this variable.  You can use the
customization command or write the appropriate expressions yourself.

@need 800
Using the customization command,  you can type:

@smallexample
M-x customize
@end smallexample

@noindent
and find that the group for editing files of data is called `data'.
Enter that group.  Text Mode Hook is the first member.  You can click
on its various options, such as @code{turn-on-auto-fill}, to set the
values.  After you click on the button to

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs will write an expression into your @file{.emacs} file.
It will look like this:

@smallexample
@group
(custom-set-variables
  ;; custom-set-variables was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(text-mode-hook (quote (turn-on-auto-fill text-mode-hook-identify))))
@end group
@end smallexample

@noindent
(The @code{text-mode-hook-identify} function tells
@code{toggle-text-mode-auto-fill} which buffers are in Text mode.
It comes on automatically.)

The @code{custom-set-variables} function works somewhat differently
than a @code{setq}.  While I have never learned the differences, I
modify the @code{custom-set-variables} expressions in my @file{.emacs}
file by hand:  I make the changes in what appears to me to be a
reasonable manner and have not had any problems.  Others prefer to use
the Customization command and let Emacs do the work for them.

Another @code{custom-set-@dots{}} function is @code{custom-set-faces}.
This function sets the various font faces.  Over time, I have set a
considerable number of faces.  Some of the time, I re-set them using
@code{customize}; other times, I simply edit the
@code{custom-set-faces} expression in my @file{.emacs} file itself.

The second way to customize your @code{text-mode-hook} is to set it
yourself in your @file{.emacs} file using code that has nothing to do
with the @code{custom-set-@dots{}} functions.

@need 800
When you do this, and later use @code{customize}, you will see a
message that says

@smallexample
CHANGED outside Customize; operating on it here may be unreliable.
@end smallexample

@need 800
This message is only a warning.  If you click on the button to

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs will write a @code{custom-set-@dots{}} expression near the end
of your @file{.emacs} file that will be evaluated after your
hand-written expression.  It will, therefore, overrule your
hand-written expression.  No harm will be done.  When you do this,
however, be careful to remember which expression is active; if you
forget, you may confuse yourself.

So long as you remember where the values are set, you will have no
trouble.  In any event, the values are always set in your
initialization file, which is usually called @file{.emacs}.

I myself use @code{customize} for hardly anything.  Mostly, I write
expressions myself.

@findex defsubst
@findex defconst
Incidentally, to be more complete concerning defines:  @code{defsubst}
defines an inline function.  The syntax is just like that of
@code{defun}.  @code{defconst} defines a symbol as a constant.  The
intent is that neither programs nor users should ever change a value
set by @code{defconst}.  (You can change it; the value set is a
variable; but please do not.)

@node Beginning init File
@section @file{.emacs} の書き方
@cindex @file{.emacs} file, beginning of

Emacs を起動すると、コマンドラインに @samp{-q} を指定して読み込まないよ
うにした場合を除き、@file{.emacs} ファイルがロードされる。
(@code{emacs -q} コマンドでは、素のままの Emacs が起動される。)

@file{.emacs} ファイルは Lisp 式を含んでいる。大抵は値を設定するだけだが、
時には関数定義が書かれていることもある。

初期化ファイルの簡単な説明については、次を参照。@xref{Init File, , The
Init File @file{~/.emacs}, emacs, The GNU Emacs Manual}.

この章でも同じようなことを説明するのだが、その際、私が長く使ってきた私
自身の @file{.emacs} を素材にすることにする。

ファイルの最初の部分はコメントからなる。これは個人的なメモとして利用して
いる。勿論、今はその内容を把握しているが、最初はそうではなかった。

@need 1200
@smallexample
@group
;;;; Bob's .emacs file
; Robert J. Chassell
; 26 September 1985
@end group
@end smallexample

@noindent
日付を見てみよう！ このファイルを使い初めたのは随分と昔だ。それ以来、
内容を追加してきたわけである。

@smallexample
@group
; Each section in this file is introduced by a
; line beginning with four semicolons; and each
; entry is introduced by a line beginning with
; three semicolons.
@end group
@end smallexample

@smallexample
@group
(日本語訳)
; このファイルの各セクションは行頭がセミコロンであるような
; 行から始まる。また、各項目は行頭が三つのセミコロンである
; ような行から始まる。
@end group
@end smallexample

@noindent
ここでは Emacs Lisp のコメントの通常の便宜上の慣習を説明している。セミ
コロンで始まる行は全てコメントである。二つ、三つ、ないしは四つのセミコロ
ンがセクションやサブセクションのために使われる。(コメントについての説明
は次を参照。@ref{Comments, ,, elisp, The GNU Emacs Lisp Reference
Manual}.)

@smallexample
@group
;;;; The Help Key
; Control-h is the help key;
; after typing control-h, type a letter to
; indicate the subject about which you want help.
; For an explanation of the help facility,
; type control-h two times in a row.
@end group
@end smallexample

@smallexample
@group
(日本語訳)
;;;; ヘルプキーについて
; Control-h がヘルプキーである。
; control-h をタイプした後、見たいヘルプの内容を示す
; 文字をタイプする。ヘルプ自体の簡単な説明を見るには
; control-h を二回タイプすればよい。
@end group
@end smallexample

@noindent
ここでは特に @kbd{C-h} を二回タイプすることでヘルプが表示されることを注
意しておく。

@smallexample
@group
; To find out about any mode, type control-h m
; while in that mode.  For example, to find out
; about mail mode, enter mail mode and then type
; control-h m.
@end group
@end smallexample

@smallexample
@group
(日本語訳)
; あるモードがどんなものか知りたい場合は、そのモードで
; control-h m とタイプする。例えば、mail mode について
; 知りたい場合は mail mode に入ってから control-h m と
; タイプする。
@end group
@end smallexample

@noindent
私はこれを「モードヘルプ (mode help)」と読んでいるのだが、大変便利である。
普通はこれを読むだけで必要なことが殆ど分ってしまう。

勿論、このようなコメントは @file{.emacs} ファイルに含める必要はない。私
がこれらを含めたのは、よくモードヘルプのことやコメントの書き方を忘れたた
めだ。で、これを見れば思い起こすことが出来たわけである。

@node Text and Auto-fill
@section Text モードと Auto Fill モード

さて、Text mode や Auto Fill mode をオンにする箇所まで来た。

@smallexample
@group
;;; Text mode and Auto Fill mode
;; The next two lines put Emacs into Text mode
;; and Auto Fill mode, and are for writers who
;; want to start writing prose rather than code.

(setq-default major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end group
@end smallexample

@smallexample
@group
(日本語訳)
;;; Text mode と Auto Fill mode
; 次の二つの行は、Emacs を Text mode や Auto Fill mode
; にするためのものである。コードを書くよりは普通の文章
; を書くことが多い人向けの設定である。
(setq-default major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end group
@end smallexample

これが、この @file{.emacs} の中で、どこかの忘れっぽい人間のための備忘録
以外のちゃんとした役目を果たす最初の部分である。

この括弧で挟まれた二行の内の最初の一行は、ファイルを読み込む際に、そのファ
イルに C mode のような特定のモードが設定されて@emph{いない}場合には Text
mode に入るようにするものである。

@cindex Per-buffer, local variables list
@cindex Local variables list, per-buffer,
@cindex Automatic mode selection
@cindex Mode selection, automatic
Emacs は、ファイルを読む際にその拡張子を見る。(拡張子というのは @samp{.}
の後に続く部分である。もしファイルが @samp{.c} や @samp{.h} という拡張子
で終わっていれば、Emacs は C mode になる。また、Emacs はファイルの最初の
空行でない行も見る。例えば最初の行に @w{@samp{-*- C -*-}} と書かれていれ
ば、Emacs は C mode になる。Emacs は自動判別のための拡張子とモード指定の
リストを持っている。更に Emacs は、そのバッファの最後のページ付近に
``local variable list'' があれば、それも見る。

@ifinfo
@xref{Choosing Modes, , How Major Modes are Chosen, emacs, The GNU
Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
これについては、@cite{The GNU Emacs Manual} の ``How Major Modes are
Chosen'' や ``Local Variables in Files'' 等のセクションを参照のこと。
@end iftex

さて、@file{.emacs} ファイルに戻ろう。

@need 800
もう一度、さっきの行を書いておく。これは何をするのものだろう？

@cindex Text Mode turned on
@smallexample
(setq major-mode 'text-mode)
@end smallexample

@noindent
この行は、短いながらも完全な Emacs Lisp の式である。

我々は既に @code{setq} には慣れ親しんでいる。これは、後に続く変数
@code{default-major-mode} をその後の @code{text-mode} という値にセットす
るものだ。@code{text-mode} の先頭の引用符は、Emacs に
@code{text-mode} がシンボルとして何を表しているかを見るのではなく、文字
通りそのまま扱うよう指示するものである。@code{setq} のより詳しい説明につ
いては次を参照。@ref{set & setq, , 変数の値の設定}.
大切なポイントは、@file{.emacs} で値をセットする手続きは、Emacs の他
の場所での手続きと全く違いはないということである。

@need 800
次は二行目である。

@cindex Auto Fill mode turned on
@findex add-hook
@smallexample
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end smallexample

@noindent
この行では、@code{add-hook} コマンドで @code{turn-on-auto-fill} を
@code{text-mode-hook} という変数に加えている。

@code{turn-on-auto-fill}
はプログラムの名前であり、名前から推察される通りのことを行う。Auto Fill
mode をオンにするのである。

Emacs は Text mode に入るたびに、Text mode にフック (hook) されたコマン
ドを実行する。従って、Emacs が Text mode になるごとに Auto Fill mode も
オンになるわけである。

まとめると、最初の行は、特に拡張子や最初の空でない行や局所変数からどのモー
ドにしてよいか分らない場合には Text mode になるよう設定するものである。

Text mode では、物書きには便利な構文テーブルが設定されたりする。例えば、
アポストロフィ @samp{'} は普通の文字ように単語の一部だと解釈するが、終止
符や空白は単語の一部だとは考えない。従って @kbd{M-f} では @samp{it's} 全
体を飛び越えて進む。一方、C mode では、@samp{it's} のちょうど @samp{t}
の直後の位置で止まる。

また二行目は、Text mode に入る際に同時に Auto Fill mode もオンにするため
のものである。Auto Fill mode では、Emacs は自動的に長い行を次の行に折り
返してくれる。その際は、単語を寸断したりせずちゃんと単語と単語の間を折り
返すようになっている。

Auto Fill mode がオフになっている場合は、行はあなたがタイプしていくとそ
のまま右に伸びていく。行が右端まで到達した場合、@code{truncate-lines} の
値をどう設定しているかによって、右の部分が見えなくなったり、あるいは汚い
形で表示されたりする。

@need 1250
In addition, in this part of my @file{.emacs} file, I tell the Emacs
fill commands to insert two spaces after a colon:

@smallexample
(setq colon-double-space t)
@end smallexample

@node Mail Aliases
@section メールのエイリアス

以下が mail aliases 等を使えるようにする @code{setq} 式、及びそれについ
ての備忘録である。

@smallexample
@group
;;; Mail mode
; To enter mail mode, type `C-x m'
; To enter RMAIL (for reading mail),
; type `M-x rmail'
(setq mail-aliases t)
@end group
@end smallexample

@smallexample
@group
(日本語訳)
;;; Mail mode
; Mail mode に入るには、`C-x m' とタイプする。
; (mail を読むために) RMAIL にはいるには、
; `M-x rmail' とタイプする。
(setq mail-aliases t)
@end group
@end smallexample

@cindex Mail aliases
@noindent
この @code{setq} コマンドは、変数 @code{mail-aliases} の値を @code{t} に
セットする。@code{t} は真を意味するので、この行は「どうぞ、mail aliases
を使って下さい」という意味になる。

Mail aliases というのは、長い電子メールアドレスや電子メールアドレスのリ
ストに対する便宜上の短い名前のことである。あなたの `aliases' を保存して
おくファイルは @file{~/.mailrc} である。alias は次のような形式で書けばよ
い。

@smallexample
alias geo george@@foobar.wiz.edu
@end smallexample

@noindent
George にメッセージを書く場合は、アドレスに @samp{geo} と書くだけでよい。
するとメイラーは自動的に @samp{geo} をフルアドレスに展開してくれる。

@node Indent Tabs Mode
@section Indent Tabs モード
@cindex Tabs, preventing
@findex indent-tabs-mode

Emacs はデフォルトでは、リージョンを整形する際に沢山の空白の連続にはタブ
を挿入する。(例えばあなたは、沢山の行を一度にインデントするために
@code{indent-region} を使ったりすることだろう。) タブは端末や普通の印刷
では綺麗に見える。しかし @TeX{} ではタブは無視されるために、@TeX{} や
Texinfo を使う際には出力が汚くなってしまう。

@need 1250
次のようにすれば、Indent Tabs mode をオフに出来る。

@smallexample
@group
;;; Prevent Extraneous Tabs
(setq-default indent-tabs-mode nil)
@end group
@end smallexample

この行では、今まで使ってきた @code{setq} ではなく @code{setq-default} を
使っていることに注意しよう。@code{setq-default} コマンドは、その変数に対
するバッファローカルな値がない場合に限り、その値をセットする。

@ifinfo
@xref{Just Spaces, , Tabs vs. Spaces, emacs, The GNU Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
@cite{The GNU Emacs Manual} の中の ``Tabs vs.@: Spaces'' や ``Local
Variables in Files'' を参照。
@end iftex

@need 1700
@node Keybindings
@section 幾つかのキーバインディング

次は、幾つかの個人的なキーバインディングの設定である。

@smallexample
@group
;;; Compare windows
(global-set-key "\C-cw" 'compare-windows)
@end group
@end smallexample

@findex compare-windows
@code{compare-windows} は、現在のウィンドウと次のウィンドウの中のテキス
トを比較してくれるという、洒落たコマンドである。これは、各々のウィンドウ
の中のポイントの位置から比較を開始して、両方が同じである所まで進む。私は
このコマンドをいつも利用している。

また、これを見れば、全てのモードに対する大域的なキーバインディングを設定
する方法が分る。

@cindex Setting a key globally
@cindex Global set key
@cindex Key setting globally
@findex global-set-key
コマンドは @code{global-set-key} だ。この後にキーバインディングが続く。
@file{.emacs} ファイルではキーバインディングは上に示した通りの方法で書か
れる。@code{\C-c} は `control-c', つまり、「control キーと @kbd{c} を同
時に押す」ことを表わす。また、@code{w} は「@kbd{w} を押す」ことを表わす。
説明の中では、@kbd{C-c w} のように書かれる。(@key{CTL} キーではなく
@kbd{M-c} のような @key{META} キーを使ったバインドをしたい場合は、
@code{\M-c} のように書く。詳しくは次を参照。@ref{Init Rebinding, ,
Rebinding Keys in Your Init File, emacs, The GNU Emacs Manual}.)

このキーで呼び出されるコマンドは @code{compare-windows} である。この時、
@code{compare-windows} の先頭に引用符を付けることに注意しよう。そうしな
いと、Emacs は最初にこのシンボルの値を評価しようとしてしまう。

二重引用符と、@samp{C} の前のバックスラッシュ、及び単独の引用符の三つは
キーバインディングには必須であるにもかかわらず、私はよく忘れてしまう。幸
いなことに、これらは @file{.emacs} を見れば思い出すことが出来る。

@kbd{C-c w} というキーバインディングそのものについても書いておく。これは、
@kbd{C-c} という前置キーと一文字---今の場合は @kbd{w}---からなっている。
このような @kbd{C-c} に続けて一文字というキー設定は、特に個人的な用途に
残されている。もしあなたが Emacs を拡張したい場合、これらのキーを公の
用途に使わないで欲しい。その代わり、@kbd{C-c C-w} のようなキーを使うべき
である。そうでないと個人用にバインドするキーがなくなってしまう。

@need 1250
以下にコメント付きで他のキーバインディングを書いておく。

@smallexample
@group
;;; Keybinding for `occur'
; I use occur a lot, so let's bind it to a key:
; (私は occur をよく使うので、キーにバインドしておく。)
(global-set-key "\C-co" 'occur)
@end group
@end smallexample

@findex occur
@code{occur} コマンドは、現在のバッファの中で正規表現にマッチする部分を
含む行を全て表示してくれるコマンドである。マッチした行は、@file{*Occur*}
というバッファに表示される。このバッファはその位置に簡単に飛ぶためにも使
われる。

@findex global-unset-key
@cindex Unbinding key
@cindex Key unbinding
@need 1250
次に、キーバインディングの解除の仕方を示す。特定のキーバインディングを使
えなくするわけである。

@smallexample
@group
;;; Unbind `C-x f'
(global-unset-key "\C-xf")
@end group
@end smallexample

このキーバインディングを解除するのには理由がある。私は、自分がよく
@kbd{C-x C-f} とタイプしようとして、間違って @w{@kbd{C-x f}} とタイプし
てしまうことに気が付いた。ファイルを読み込もうとして、偶然行詰めの幅を設
定してしまうわけである。結果的に大抵は変な幅が設定されてしまう。私はこの
幅を変更することは殆どないので、単にキーバインディングを解除することにし
たのだ。

@findex list-buffers, @r{rebound}
@findex buffer-menu, @r{bound to key}
@need 1250
次は現在のキーをバインドし直すものである。

@smallexample
@group
;;; Rebind `C-x C-b' for `buffer-menu'
(global-set-key "\C-x\C-b" 'buffer-menu)
@end group
@end smallexample

デフォルトでは、@kbd{C-x C-b} は @code{list-buffer} コマンドを起動するも
のである。このコマンドは現在のバッファのリストを@emph{別の}ウィンドウに
表示する。私は大抵はそのウィンドウで何かをしたいことが多いので
@code{buffer-menu} コマンドの方が好きである。これは単にバッファのリスト
を表示するだけでなく、ポイントをそのウィンドウに移動してくれる。

@node Keymaps
@section キーマップ
@cindex Keymaps
@cindex Rebinding keys

Emacs はどのキーをどのコマンドにバインドするかを @dfn{keymaps} を使って
記録する。
When you use @code{global-set-key} to set the keybinding for a single
command in all parts of Emacs, you are specifying the keybinding in
@code{current-global-map}.

C mode や Text mode のような特定のモードは、それ自身のキーマッ
プを持っている。モード独自のキーマップは、全てのバッファで共有される
global map を上書きする。

@code{global-set-key} 関数は global keymap のキーをバインドしたり再バイ
ンドしたりする。例えば次のＳ式は、キー @kbd{C-c C-l} を関数
@code{line-to-top-of-window} にバインドする。

@smallexample
(global-set-key "\C-x\C-b" 'buffer-menu)
@end smallexample

モード独自のキーマップは @code{define-key} 関数を使ってバインドされる。
これは、キーやコマンドと同時に特定のキーマップも引数に取る。例えば私の
@file{.emacs} ファイルでは、@code{texinfo-insert-@@group} コマンドを
@kbd{C-c C-c g} にバインドするために、次のようなＳ式が書かれている。

@smallexample
@group
(define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@@group)
@end group
@end smallexample

@noindent
@code{texinfo-insert-@@group} 関数そのものは、Texinfo ファイルに
@samp{@@group} をインサートするためのちょっとした Texinfo mode の拡張であ
る。私はこのコマンドをいつも使うので、六つのキーストローク @kbd{@@ g r o
u p} よりも三つのキーストロークである @kbd{C-c C-c g} を使う方がずっと便
利なのだ。(@samp{@@group} と対応する @samp{@@end group} は中のテキストを
一つのページに収めるためのコマンドである。この本の中の、沢山の複数行に
渡る例が @samp{@@group @dots{} @@end group} で囲まれている。)

@need 1250
以下が @code{texinfo-insert-@@group} の関数定義である。

@smallexample
@group
(defun texinfo-insert-@@group ()
  "Insert the string @@group in a Texinfo buffer."
  (interactive)
  (beginning-of-line)
  (insert "@@group\n"))
@end group
@end smallexample

(タイプ数を節約するためには、勿論、単語を挿入する関数を定義したりする代
わりに Abbrev mode を使うことも出来る。しかし、キーストロークが他の
Texinfo mode のキーバインディングと調和が取れているという意味で、私は上
の方法の方が好みである。)

@file{loaddefs.el} を見れば @file{c-mode.el} や @file{lisp-mode.el} のよ
うな様々なモードライブラリと同時に沢山の @dfn{define-key} 式が書かれてい
るのが分る。

キーマップについての詳細は次を参照のこと。
@ref{Key Bindings, , Customizing Key Bindings, emacs, The GNU Emacs
Manual}, 及び @ref{Keymaps, , Keymaps, elisp, The GNU Emacs Lisp
Reference Manual}.

@node Loading Files
@section ファイルのロード
@cindex Loading files
@c findex load

GNU Emacs のコミュニティの沢山の人々が Emacs の拡張を行ってきた。時が経
つにつれ、これらの拡張が新しいリリースに含まれることも多くなった。例えば
カレンダーや日記のパッケージは今や Emacs version 19 の配布の一部になって
いる。これらは標準の Emacs version 18 の配布には含まれていなかったものだ。

@code{load} コマンドを使うと、ファイルの中身全てを評価することが出来る。
従って、そのファイルの関数や変数を全て Emacs にインストールすることが可
能だ。例えば、

@c (auto-compression-mode t)

@smallexample
(load "~/emacs/slowsplit")
@end smallexample

というＳ式は、ホームディレクトリの @file{emacs} というサブディレクトリの
下の @file{slowsplit.el} ファイルを評価、即ちロードする。(もしバイトコンパイ
ルされた @file{slowsplit.elc} があれば、そちらがロードされる。こっちの方が速
くロード、実行出来る。)
The file contains
the function @code{split-window-quietly}, which John Robinson wrote in
1989.

The @code{split-window-quietly} function splits a window with the
minimum of redisplay.  I installed it in 1989 because it worked well
with the slow 1200 baud terminals I was then using.  Nowadays, I only
occasionally come across such a slow connection, but I continue to use
the function because I like the way it leaves the bottom half of a
buffer in the lower of the new windows and the top half in the upper
window.

@need 1250
To replace the key binding for the default
@code{split-window-vertically}, you must also unset that key and bind
the keys to @code{split-window-quietly}, like this:

@smallexample
@group
(global-unset-key "\C-x2")
(global-set-key "\C-x2" 'split-window-quietly)
@end group
@end smallexample

@vindex load-path
沢山の拡張パッケージをロードしたい場合は、上のようにそのファイルの位置を
正確に指定するのではなく、あるディレクトリを Emacs の @code{load-path}
に指定するとよい。私はそうしている。この場合には、Emacs はファイルをロー
ドする際にデフォルトのディレクトリのリストに加えてそのディレクトリも検索
してくれるようになる。(デフォルトのディレクトリは Emacs を作成する際に
@file{paths.h} で指定される。)

@need 1250
次のコマンドで、@file{~/emacs} ディレクトリを現在のロードパスに含めるこ
とが出来る。

@smallexample
@group
;;; Emacs Load Path
(setq load-path (cons "~/emacs" load-path))
@end group
@end smallexample

ついでに言っておくと、@code{load-library} は関数をロードする際のインタラ
クティブなインターフェースも提供してくれる。この関数の完全なコードは次の
ようになっている。

@findex load-library
@smallexample
@group
(defun load-library (library)
  "Load the library named LIBRARY.
This is an interface to the function `load'."
  (interactive
   (list (completing-read "Load library: "
                          (apply-partially 'locate-file-completion-table
                                           load-path
                                           (get-load-suffixes)))))
  (load library))
@end group
@end smallexample

@code{load-library} という関数の名前では `library' という言葉を便宜的に
`file' の同意語として見ている。@code{load-library} コマンドのソースは
@file{files.el} ライブラリにある。

これと若干違う動作をするインタラクティブなコマンドとして、
@code{load-file} がある。これが @code{load-library} とどう違うかについて
のより詳しい情報は次を参照。@ref{Lisp Libraries, , Libraries of Lisp
Code for Emacs, emacs, The GNU Emacs Manual}.

@node Autoload
@section オートロード
@findex autoload

その関数を含むファイルをロードしたり、関数定義を直接評価したりしてインス
トールする代わりに、その関数が実際に最初に使われるまではインストールはし
ないが、いつでも呼び出せる状態にはしておくということも出来る。これは
@dfn{オートロード} (@dfn{autoloading}) と呼ばれる。

オートロードされた関数を実行すると、Emacs は自動的にその定義を含むファイ
ルを評価して、その関数を呼び出す。

オートロード関数を使うと Emacs をより速く起動出来る。というのも起動時に
はそのライブラリはロードされないからだ。その代わり、最初にオートロードさ
れた関数を使う際には、それを含むファイルを評価する間ちょっと待たされるこ
とになる。

めったに使われない関数はしばしばオートロードされる。@file{loaddefs.el}
ライブラリには @code{bookmark-set} から @code{wordstar-mode} まで何百も
のオートロードされる関数が含まれている。勿論、個人的にこれらの「めったに
使わない」関数を頻繁に使うことになることもあるかもしれない。この場合は、
その関数のファイルを @code{load} 式を使って @code{.emacs} ファイルの中で
ロードしておくべきだろう。

私の Emacs version 19.23 用の @file{.emacs} ファイルでは、元々オートロー
ドされるような関数を含む17のライブラリがロードされている。(実際には、こ
れらの関数を「dump」した Emacs を作るべきなのだが、忘れていたのだ。dump
についての詳しい情報は、@ref{Building Emacs, , Building Emacs, elisp,
The GNU Emacs Lisp Reference Manual}, や @file{INSTALL} を見て欲しい。)

あるいはまた @file{.emacs} ファイルにオートロード式を書きたいこともある
だろう。@code{autoload} は五つの引数を取る組み込み関数であり、最後の三つ
の引数は省略可能である。最初の引数はオートロードする関数の名前、二番目の
引数はロードされるファイル名、三番目は関数の説明文、四番目はその関数をイ
ンタラクティブに呼び出せるかどうか、そして最後の五番目の引数は、オブジェ
クトのタイプ---@code{autoload} は関数だけでなく、キーマップやマクロも扱
えるので---である。(デフォルトは関数である。)

@need 800
以下に典型的な例を挙げる。

@smallexample
@group
(autoload 'html-helper-mode
  "html-helper-mode" "Edit HTML documents" t)
@end group
@end smallexample

@noindent
(@code{html-helper-mode} is an older alternative to @code{html-mode},
which is a standard part of the distribution.)

@noindent
この式は、@code{html-helper-mode} 関数をオートロードするものである。これ
は、@file{html-helper-mode.el} ファイルの中でロードされる。(あるいは、も
し @file{html-helper-mode.elc} があれば、そちらから読み込まれる。) この
ファイルは @code{load-path} で指定されたディレクトリに置かれていなければ
ならない。説明文を読むと、これは HyperText Markup Language で書かれた文
書を編集するためのモードであることが分る。このモードは @kbd{M-x
html-helper-mode} とタイプすることでインタラクティブに呼び出すことが出来
る。(この場合、オートロード式の説明文には正規の説明文をそのまま複写する
必要がある。正規の説明文はまだロードされていないので、まだ読めないわけで
ある。)

詳しくは、次を参照。@xref{Autoload, , Autoload, elisp, The GNU Emacs Lisp
Reference Manual}.

@node Simple Extension
@section ちょっとした拡張: @code{line-to-top-of-window}
@findex line-to-top-of-window
@cindex Simple extension in @file{.emacs} file

次に、ポイントのある行をウィンドウの最上段に移動する簡単な Emacs の拡張
を書いておく。これを使うとテキストを簡単に見ることが出来るので、私は普段
よく利用している。

次のコードを別ファイルにして、それを @file{.emacs} でロードしても良いし、
コードを直接 @file{.emacs} の中に含めてしまうことも出来る。

@need 1250
以下が定義である。

@smallexample
@group
;;; Line to top of window;
;;; replace three keystroke sequence  C-u 0 C-l
(defun line-to-top-of-window ()
  "Move the line point is on to top of window."
  (interactive)
  (recenter 0))
@end group
@end smallexample

@need 1250
次にキーバインディングである。

Nowadays, function keys as well as mouse button events and
non-@sc{ascii} characters are written within square brackets, without
quotation marks.  (In Emacs version 18 and before, you had to write
different function key bindings for each different make of terminal.)

I bind @code{line-to-top-of-window} to my @key{F6} function key like
this:

@smallexample
(global-set-key [f6] 'line-to-top-of-window)
@end smallexample

より詳しいことについては、次を見て欲しい。@ref{Init Rebinding, ,
Rebinding Keys in Your Init File, emacs, The GNU Emacs Manual}.

@cindex Conditional 'twixt two versions of Emacs
@cindex Version of Emacs, choosing
@cindex Emacs version, choosing
If you run two versions of GNU Emacs, such as versions 22 and 23, and
use one @file{.emacs} file, you can select which code to evaluate with
the following conditional:

@smallexample
@group
(cond
 ((= 22 emacs-major-version)
  ;; evaluate version 22 code
  ( @dots{} ))
 ((= 23 emacs-major-version)
  ;; evaluate version 23 code
  ( @dots{} )))
@end group
@end smallexample

For example, recent versions blink
their cursors by default.  I hate such blinking, as well as other
features, so I placed the following in my @file{.emacs}
file@footnote{When I start instances of Emacs that do not load my
@file{.emacs} file or any site file, I also turn off blinking:

@smallexample
emacs -q --no-site-file -eval '(blink-cursor-mode nil)'

@exdent Or nowadays, using an even more sophisticated set of options,

emacs -Q -D
@end smallexample
}:

@smallexample
@group
(when (>= emacs-major-version 21)
  (blink-cursor-mode 0)
  ;; Insert newline when you press `C-n' (next-line)
  ;; at the end of the buffer
  (setq next-line-add-newlines t)
@end group
@group
  ;; Turn on image viewing
  (auto-image-file-mode t)
@end group
@group
  ;; Turn on menu bar (this bar has text)
  ;; (Use numeric argument to turn on)
  (menu-bar-mode 1)
@end group
@group
  ;; Turn off tool bar (this bar has icons)
  ;; (Use numeric argument to turn on)
  (tool-bar-mode nil)
@end group
@group
  ;; Turn off tooltip mode for tool bar
  ;; (This mode causes icon explanations to pop up)
  ;; (Use numeric argument to turn on)
  (tooltip-mode nil)
  ;; If tooltips turned on, make tips appear promptly
  (setq tooltip-delay 0.1)  ; default is 0.7 second
   )
@end group
@end smallexample

@node X11 Colors
@section X11 でのカラー表示

X Window System を使うと、Emacs をカラーで使うことが出来る。

私はデフォルトのカラーが気に入らないので、自分独自の色を指定している。

@need 1250
Here are the expressions in my @file{.emacs}
file that set values:

@smallexample
@group
;; Set cursor color
(set-cursor-color "white")

;; Set mouse color
(set-mouse-color "white")

;; Set foreground and background
(set-foreground-color "white")
(set-background-color "darkblue")
@end group

@group
;;; Set highlighting colors for isearch and drag
(set-face-foreground 'highlight "white")
(set-face-background 'highlight "blue")
@end group

@group
(set-face-foreground 'region "cyan")
(set-face-background 'region "blue")
@end group

@group
(set-face-foreground 'secondary-selection "skyblue")
(set-face-background 'secondary-selection "darkblue")
@end group

@group
;; Set calendar highlighting colors
(setq calendar-load-hook
      (lambda ()
        (set-face-foreground 'diary-face   "skyblue")
        (set-face-background 'holiday-face "slate blue")
        (set-face-foreground 'holiday-face "white")))
@end group
@end smallexample

色々な色合いの青が、スクリーンのちらつきから私の眼を守り、そして癒してく
れる。

Alternatively, I could have set my specifications in various X
initialization files.  For example, I could set the foreground,
background, cursor, and pointer (i.e., mouse) colors in my
@file{~/.Xresources} file like this:

@smallexample
@group
Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
@end group
@end smallexample

In any event, since it is not part of Emacs, I set the root color of
my X window in my @file{~/.xinitrc} file, like this@footnote{I also
run more modern window managers, such as Enlightenment, Gnome, or KDE;
in those cases, I often specify an image rather than a plain color.}:

@smallexample
xsetroot -solid Navy -fg white &
@end smallexample

@need 1700
@node Miscellaneous
@section @file{.emacs} での雑多な設定

@need 1250
以下は、雑多な設定である。
@sp 1

@itemize @minus
@item
Set the shape and color of the mouse cursor:

@smallexample
@group
; Cursor shapes are defined in
; `/usr/include/X11/cursorfont.h';
; for example, the `target' cursor is number 128;
; the `top_left_arrow' cursor is number 132.
@end group

@group
(let ((mpointer (x-get-resource "*mpointer"
                                "*emacs*mpointer")))
  ;; If you have not set your mouse pointer
  ;;     then set it, otherwise leave as is:
  (if (eq mpointer nil)
      (setq mpointer "132")) ; top_left_arrow
@end group
@group
  (setq x-pointer-shape (string-to-int mpointer))
  (set-mouse-color "white"))
@end group
@end smallexample

@item
Or you can set the values of a variety of features in an alist, like
this:

@smallexample
@group
(setq-default
 default-frame-alist
 '((cursor-color . "white")
   (mouse-color . "white")
   (foreground-color . "white")
   (background-color . "DodgerBlue4")
   ;; (cursor-type . bar)
   (cursor-type . box)
@end group
@group
   (tool-bar-lines . 0)
   (menu-bar-lines . 1)
   (width . 80)
   (height . 58)
   (font .
         "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
   ))
@end group
@end smallexample

@item
Convert @kbd{@key{CTRL}-h} into @key{DEL} and @key{DEL}
into @kbd{@key{CTRL}-h}.@*
(Some older keyboards needed this, although I have not seen the
problem recently.)

@smallexample
@group
;; Translate `C-h' to <DEL>.
; (keyboard-translate ?\C-h ?\C-?)

;; Translate <DEL> to `C-h'.
(keyboard-translate ?\C-? ?\C-h)
@end group
@end smallexample

@item Turn off a blinking cursor!

@smallexample
@group
(if (fboundp 'blink-cursor-mode)
    (blink-cursor-mode -1))
@end group
@end smallexample

@noindent
or start GNU Emacs with the command @code{emacs -nbc}.

@need 1250
@item When using `grep'@*
@samp{-i}@w{  }   Ignore case distinctions@*
@samp{-n}@w{  }   Prefix each line of output with line number@*
@samp{-H}@w{  }   Print the filename for each match.@*
@samp{-e}@w{  }   Protect patterns beginning with a hyphen character, @samp{-}

@smallexample
(setq grep-command "grep -i -nH -e ")
@end smallexample

@ignore
@c Evidently, no longer needed in GNU Emacs 22

item Automatically uncompress compressed files when visiting them

smallexample
(load "uncompress")
end smallexample

@end ignore

@item Find an existing buffer, even if it has a different name@*
This avoids problems with symbolic links.

@smallexample
(setq find-file-existing-other-name t)
@end smallexample

@item Set your language environment and default input method

@smallexample
@group
(set-language-environment "latin-1")
;; Remember you can enable or disable multilingual text input
;; with the @code{toggle-input-method'} (@kbd{C-\}) command
(setq default-input-method "latin-1-prefix")
@end group
@end smallexample

If you want to write with Chinese `GB' characters, set this instead:

@smallexample
@group
(set-language-environment "Chinese-GB")
(setq default-input-method "chinese-tonepy")
@end group
@end smallexample
@end itemize

@subsubheading Fixing Unpleasant Key Bindings
@cindex Key bindings, fixing
@cindex Bindings, key, fixing unpleasant

Some systems bind keys unpleasantly.  Sometimes, for example, the
@key{CTRL} key appears in an awkward spot rather than at the far left
of the home row.

Usually, when people fix these sorts of keybindings, they do not
change their @file{~/.emacs} file.  Instead, they bind the proper keys
on their consoles with the @code{loadkeys} or @code{install-keymap}
commands in their boot script and then include @code{xmodmap} commands
in their @file{.xinitrc} or @file{.Xsession} file for X Windows.

@need 1250
@noindent
For a boot script:

@smallexample
@group
loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz
@exdent or
install-keymap emacs2
@end group
@end smallexample

@need 1250
@noindent
For a @file{.xinitrc} or @file{.Xsession} file when the @key{Caps
Lock} key is at the far left of the home row:

@smallexample
@group
# Bind the key labeled `Caps Lock' to `Control'
# (Such a broken user interface suggests that keyboard manufacturers
# think that computers are typewriters from 1885.)

xmodmap -e "clear Lock"
xmodmap -e "add Control = Caps_Lock"
@end group
@end smallexample

@need 1250
@noindent
In a @file{.xinitrc} or @file{.Xsession} file, to convert an @key{ALT}
key to a @key{META} key:

@smallexample
@group
# Some ill designed keyboards have a key labeled ALT and no Meta
xmodmap -e "keysym Alt_L = Meta_L Alt_L"
@end group
@end smallexample

@need 1700
@node Mode Line
@section モード行の修正
@vindex mode-line-format
@cindex Mode line format

最後に、モード行の修正について述べる。これが変更出来るようになっているの
は本当に嬉しい。

私は時々ネットワーク上で仕事をするので、私が現在
どのマシンの上で仕事をしているか忘れてしまうことがある。
Also,
I tend to I lose track of where I am, and which line point is on.

So I reset my mode line to look like this:

@smallexample
-:-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
@end smallexample

I am visiting a file called @file{foo.texi}, on my machine
@file{rattlesnake} in my @file{/home/bob} buffer.  I am on line 1, in
Texinfo mode, and am at the top of the buffer.

@need 1200
My @file{.emacs} file has a section that looks like this:

@smallexample
@group
;; Set a Mode Line that tells me which machine, which directory,
;; and which line I am on, plus the other customary information.
(setq-default mode-line-format
 (quote
  (#("-" 0 1
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   mode-line-mule-info
   mode-line-modified
   mode-line-frame-identification
   "    "
@end group
@group
   mode-line-buffer-identification
   "    "
   (:eval (substring
           (system-name) 0 (string-match "\\..+" (system-name))))
   ":"
   default-directory
   #(" " 0 1
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   (line-number-mode " Line %l ")
   global-mode-string
@end group
@group
   #("   %[(" 0 6
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   (:eval (mode-line-mode-name))
   mode-line-process
   minor-mode-alist
   #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
   ")%] "
   (-3 . "%P")
   ;;   "-%-"
   )))
@end group
@end smallexample

@noindent
Here, I redefine the default mode line.  Most of the parts are from
the original; but I make a few changes.  I set the @emph{default} mode
line format so as to permit various modes, such as Info, to override
it.

（旧訳）@emph{default} のモード行のフォーマットは Info のような様々なモードが上
書きすることを許すようにした。リストの中の多くの要素は、名前から役目が推
測出来るようになっている。例えば @code{mode-line-modified} はバッファが
修正された場合、それを教えてくれるようにする変数だし、@code{mode-name}
はモードの名前を教えてくれる、等々。

Many elements in the list are self-explanatory:
@code{mode-line-modified} is a variable that tells whether the buffer
has been modified, @code{mode-name} tells the name of the mode, and so
on.  However, the format looks complicated because of two features we
have not discussed.

（旧訳）@samp{"%14b"} は現在のバッファの名前を (お馴染みの @code{buffer-name} 関
数を使って) 表示する。`14' は表示する文字数の最大の指定である。それより
も文字数が少ない場合は空白文字で埋めてくれる。@samp{%[} と @samp{%]} は
各々の再帰編集レベルに応じて角括弧の組を表示するものである。
@samp{%n} はナローイングをしている時に `Narrow' と表示してくれる。
@samp{%P} はバッファ全体でウィンドウの最下段より上にある部分が何パーセン
トあるか、もしくは `Top' か `Bottom' かを表示してくれる。(小文字の
@samp{p} にすると、ウィンドウの最上段より上の部分がどのくらいかを表示す
る。) @samp{%-} は行の残りをダッシュ (訳註：`-' のこと) で埋めてくれる。

（旧訳）Emacs version 19.29 以降では、@code{frame-title-format} を使って Emacs
のフレームにタイトルを表示することが出来る。この変数は
@code{mode-line-format} と同じ構造をしている。

@cindex Properties, in mode line example
The first string in the mode line is a dash or hyphen, @samp{-}.  In
the old days, it would have been specified simply as @code{"-"}.  But
nowadays, Emacs can add properties to a string, such as highlighting
or, as in this case, a help feature.  If you place your mouse cursor
over the hyphen, some help information appears (By default, you must
wait seven-tenths of a second before the information appears.  You can
change that timing by changing the value of @code{tooltip-delay}.)

@need 1000
The new string format has a special syntax:

@smallexample
#("-" 0 1 (help-echo "mouse-1: select window, ..."))
@end smallexample

@noindent
The @code{#(} begins a list.  The first element of the list is the
string itself, just one @samp{-}.  The second and third
elements specify the range over which the fourth element applies.  A
range starts @emph{after} a character, so a zero means the range
starts just before the first character; a 1 means that the range ends
just after the first character.  The third element is the property for
the range.  It consists of a property list,  a
property name, in this case, @samp{help-echo}, followed by a value, in this
case, a string.  The second, third, and fourth elements of this new
string format can be repeated.

より詳細な情報については、
@xref{Text Properties, , Text Properties, elisp, The GNU Emacs Lisp
Reference Manual}, および@ref{Mode Line Format,
, Mode Line Format, elisp, The GNU Emacs Lisp Reference Manual}.
を参照されたい。

@code{mode-line-buffer-identification}
displays the current buffer name.  It is a list
beginning @code{(#("%12b" 0 4 @dots{}}.
The @code{#(} begins the list.

The @samp{"%12b"} displays the current buffer name, using the
@code{buffer-name} function with which we are familiar; the `12'
specifies the maximum number of characters that will be displayed.
When a name has fewer characters, whitespace is added to fill out to
this number.  (Buffer names can and often should be longer than 12
characters; this length works well in a typical 80 column wide
window.)

@code{:eval} says to evaluate the following form and use the result as
a string to display.  In this case, the expression displays the first
component of the full system name.  The end of the first component is
a @samp{.} (`period'), so I use the @code{string-match} function to
tell me the length of the first component.  The substring from the
zeroth character to that length is the name of the machine.

@need 1250
This is the expression:

@smallexample
@group
(:eval (substring
        (system-name) 0 (string-match "\\..+" (system-name))))
@end group
@end smallexample

@samp{%[} and @samp{%]} cause a pair of square brackets
to appear for each recursive editing level.  @samp{%n} says `Narrow'
when narrowing is in effect.  @samp{%P} tells you the percentage of
the buffer that is above the bottom of the window, or `Top', `Bottom',
or `All'.  (A lower case @samp{p} tell you the percentage above the
@emph{top} of the window.)  @samp{%-} inserts enough dashes to fill
out the line.

もう一度「Emacs を好きになるために Emacs を好きになる必要はない。」とい
う言葉を思い出して欲しい---あなた自身の Emacs はデフォルトの Emacs とは
異なる色や異なるコマンド、そして異なるキーマップを持つことが出来るのだ。

一方で、もし「箱から取り出したままの」カスタマイズされていない素の Emacs
を起動したい場合は、次のようにタイプしよう。

@smallexample
emacs -q
@end smallexample

@noindent
こうすると、Emacs はあなたの初期化ファイル @file{~/.emacs} をロードしな
いで起動する。これが素のままのデフォルトの Emacs である。

@node Debugging
@chapter デバッグ
@cindex debugging

GNU Emacs は二つのデバッガを持っている。@code{debug} と @code{edebug} で
ある。最初のものは、Emacs の内部に組み込まれていて、常に使える状態にある。
二番目のものは拡張機能として与えられているもので、version 19 では標準の
配布の中に含まれている。

これらのデバッガは共に、以下の所に非常に詳しく説明されている。
@ref{Debugging, , Debugging Lisp Program, elisp, The GNU Emacs Lisp
Reference Manual}. この章では、各々の簡単な例を見ていくことにする。

@menu
* debug::                       組み込みデバッガの使い方
* debug-on-entry::              関数呼び出し時にデバッガを起動する
* debug-on-quit::               @kbd{C-g} を押した時にデバッガを起動する
* edebug::                      ソースレベルのデバッガ Edebug
* Debugging Exercises::         デバッグについての練習問題
@end menu

@node debug
@section @code{debug}
@findex debug

例えばあなたが、1から与えられた数までの和を計算するための関数の定義を書
いたとしよう。(これは以前に説明した @code{triangle} 関数である。次の所で
詳しく議論されている。
@ref{Decrementing Loop, , 減少するカウンタを使ったループ}.)

しかしながら、あなたの関数にはバグがあったとしよう。例えば @samp{1-} と
書くべきところを @samp{1=} と書いてしまったとする。この間違いをしたプロ
グラムは以下の通りである。

@findex triangle-bugged
@smallexample
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1= number)))      ; @r{ここでエラー}
    total))
@end group
@end smallexample

もし、この文章を Info で読んでいるなら、この関数をいつものように評価する
ことが出来る。そうすると、エコー領域には @code{triangle-bugged} と表示さ
れるはずだ。

@need 1250
さて、@code{triangle-bugged} を引数 4 とともに評価してみよう。

@smallexample
(triangle-bugged 4)
@end smallexample

@noindent
In a recent GNU Emacs, you will create and enter a @file{*Backtrace*}
buffer that says:

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (> number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
@end group
@group
  eval((triangle-bugged 4))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
(I have reformatted this example slightly; the debugger does not fold
long lines.  As usual, you can quit the debugger by typing @kbd{q} in
the @file{*Backtrace*} buffer.)

実際は、このような単純なバグなら、エラーメッセージだけでどう修正すればよ
いか分るだろう。
The
function @code{1=} is `void'.

@ignore
@need 800
In GNU Emacs 20 and before, you will see:

@smallexample
Symbol's function definition is void:@: 1=
@end smallexample

@noindent
which has the same meaning as the @file{*Backtrace*} buffer line in
version 21.
@end ignore

しかし、分らない場合はどうすればよいか？
You can read the complete backtrace.

In this case, you need to run a recent GNU Emacs, which automatically
starts the debugger that puts you in the @file{*Backtrace*} buffer; or
else, you need to start the debugger manually as described below.

Read the @file{*Backtrace*} buffer from the bottom up; it tells you
what Emacs did that led to the error.  Emacs made an interactive call
to @kbd{C-x C-e} (@code{eval-last-sexp}), which led to the evaluation
of the @code{triangle-bugged} expression.  Each line above tells you
what the Lisp interpreter evaluated next.

@need 1250
上から三行目は

@smallexample
(setq number (1= number))
@end smallexample

@noindent
である。Emacs はこのＳ式を評価しようとした。そのために、内部のＳ式を評価
しようとした。それが上から二行目の式である。

@smallexample
(1= number)
@end smallexample

@need 1250
@noindent
エラーが生じたのは、ここである。一行目にはそう書かれている。

@smallexample
Debugger entered--Lisp error: (void-function 1=)
@end smallexample

@noindent
そこでエラーを修正し、再び関数定義を評価して、もう一度テストしてみること
になる。

@node debug-on-entry
@section @code{debug-on-entry}
@findex debug-on-entry

A recent GNU Emacs starts the debugger automatically when your
function has an error.

@ignore
GNU Emacs version 20 and before did not; it simply
presented you with an error message.  You had to start the debugger
manually.
@end ignore

Incidentally, you can start the debugger manually for all versions of
Emacs; the advantage is that the debugger runs even if you do not have
a bug in your code.  Sometimes your code will be free of bugs!

ある関数に対して @code{debug} を実行するには @code{debug-on-entry} を使う。

@need 1250
@noindent
まず、次のようにタイプしてみよう。

@smallexample
M-x debug-on-entry RET triangle-bugged RET
@end smallexample

@need 1250
@noindent
そして、次を評価する。

@smallexample
(triangle-bugged 5)
@end smallexample

@noindent
All versions of Emacs will create a @file{*Backtrace*} buffer and tell
you that it is beginning to evaluate the @code{triangle-bugged}
function:

（旧訳）Emacs は @file{*Backtrace*} バッファを作成し、@code{triangle-bugged} 関
数の評価の開始を知らせてくる。

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5))
@end group
@group
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@file{*Backtrace*} バッファの中で、@kbd{d} とタイプしてみよう。すると、
Emacs は @code{triangle-bugged} の最初のＳ式を評価する。このときバッファ
は次のようになる。

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Beginning evaluation of function call form:
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total))
  triangle-bugged(5)
* eval((triangle-bugged 5))
  eval-last-sexp(nil)
* call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
ここで、ゆっくりと、更に8回 @kbd{d} をタイプしてみよう。@kbd{d} をタイプ
するごとに、Emacs は関数定義の中の別のＳ式を評価していく。

@need 1750
結果として、このバッファは次のようになる。

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
@group
@end group
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
@group
@end group
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1500
@noindent
最後に、更に 2 回 @kbd{d} をタイプすると Emacs はエラーの箇所まで辿り着
く。その結果 @file{*Backtrace*} の上から二行は次のようになる。

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
@dots{}
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@kbd{d} をタイプすることで、関数を一つずつ実行していくことが出来る。

@file{*Backtrace*} バッファを抜けるには @kbd{q} をタイプする。こう
するとトレースは抜けるが、@code{debug-on-entry} はキャンセルしない。

@findex cancel-debug-on-entry
@code{debug-on-entry} そのものを無効にするには、
@code{cancel-debug-on-entry} に呼び出して関数名を入力すればよい。次のよ
うな感じだ。

@smallexample
M-x cancel-debug-on-entry RET triangle-bugged RET
@end smallexample

@noindent
(もしこれを Info で読んでいるなら、ここで @code{debug-on-entry} を無効に
しておこう。)

@node debug-on-quit
@section @code{debug-on-quit} と @code{(debug)}

@code{debug-on-error} をセットしたり @code{debug-on-entry} を呼び出したり
する以外にも二つ程、@code{debug} を開始する方法がある。

@findex debug-on-quit
一つは変数 @code{debug-on-quit} を @code{t} にセットすることで、こうする
と @kbd{C-g} (@code{keyboard-quit}) をタイプすることで常に @code{debug}
を開始することが出来る。これは無限ループをデバッグする際に有効である。

@need 1500
@cindex @code{(debug)} in code
もう一つは、コードの中のデバッグを開始したい所に @code{(debug)} を呼び出す
行を挿入する方法である。例えば次のような感じである。

@smallexample
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (debug)                         ; @r{デバッガ起動}
      (setq number (1= number)))      ; @r{ここでエラー}
    total))
@end group
@end smallexample

@code{debug} 関数は次の中で詳しく説明されている。 @ref{Debugger, , The
Lisp Debugger, elisp, The GNU Emacs Lisp Reference Manual}.

@node edebug
@section ソースレベルのデバッガ @code{edebug}
@cindex Source level debugger
@findex edebug

Edebug は通常デバッグをしているコードのソースを表示してくれる。そして、
現在どの行を実行しているかを左側の矢印で示してくれる。

関数を一行ごとに実行することも出来るし、実行を止める @dfn{breakpoint}
の所まで一気に走らせることも出来る。

Edebug については次の所に説明がある。@ref{edebug, , Edebug, elisp, The
GNU Emacs Lisp Reference Manual}.

@need 1250
次にバグを含んだ @code{triangle-recursively} の関数定義を挙げておく。こ
れについて復習したい場合には、次を参照。@ref{Recursive triangle
function, , カウンタの代わりに再帰を使う}. この例は、後で説明されている
ように @code{defun} の左のインデント無しで表示されている。

@smallexample
@group
(defun triangle-recursively-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)
      1
    (+ number
       (triangle-recursively-bugged
        (1= number)))))               ; @r{ここでエラー}
@end group
@end smallexample

@noindent
普通は、この関数定義をインストールするにはカーソルを関数の最後の閉じ括弧
の後で @kbd{C-x C-e} (@code{eval-last-sexp}) とタイプするか、関数定義内
にカーソルを置いて @kbd{C-M-x} (@code{eval-defun}) とタイプする。(デフォ
ルトでは @code{eval-defun} コマンドは Emacs Lisp mode か Lisp
Interaction mode でしか動作しない。)

@need 1500
しかしながら、Edebug を使ってこの関数をデバッグする際には、まず最初に別
の関数を使って、コードの @dfn{膳立て} (@dfn{instrument}) をする必要があ
る。Emacs version 19 では関数定義内で次のようにタイプする。

@smallexample
M-x edebug-defun RET
@end smallexample

@noindent
こうすることで、もし Edebug が Emacs にインストールされていなければ自動
的にインストールし、関数を適切に膳立てする。

関数の膳立てをした後、カーソルを次のＳ式のすぐ後に持っていって
@kbd{C-x C-e} (@code{eval-last-sexp}) とタイプしよう。

@smallexample
(triangle-recursively-bugged 3)
@end smallexample

@noindent
You will be jumped back to the source for
@code{triangle-recursively-bugged} and the cursor positioned at the
beginning of the @code{if} line of the function.  Also, you will see
an arrowhead at the left hand side of that line.  The arrowhead marks
the line where the function is executing.  (In the following examples,
we show the arrowhead with @samp{=>}; in a windowing system, you may
see the arrowhead as a solid triangle in the window `fringe'.)

（旧訳）すると @code{triangle-recursively-bugged} のソースに戻ってカーソルがこの
関数内の @code{if} の行の最初に移動する。また、@samp{=>} という矢印がそ
の行の左側に表示される。この矢印は関数が実行されている場所を指している。

@smallexample
=>@point{}(if (= number 1)
@end smallexample

@noindent
@iftex
例の中で、星印 @samp{@point{}} はポイントを表している (これは Info では
@samp{-!-} と表示される。)。
@end iftex
@ifnottex
例の中で、@samp{@point{}} はポイントの位置を表している (これは印刷された
本の中では五つの点からなる星印になっている)。
@end ifnottex

さて、ここで @kbd{SPC} を押すと、ポイントは次に実行されるＳ式に移動する。
従って、この行が次のようになる。

@smallexample
=>(if @point{}(= number 1)
@end smallexample

@noindent
続けて @kbd{SPC} を押していくと、ポイントはＳ式からＳ式へと移動していく。
同時にＳ式が値を返すごとにその値がエコー領域に表示される。例えばポイント
が @code{number} の所を通過すると、次のように表示されるはずだ。

@smallexample
Result: 3 (#o3, #x3, ?\C-c)
@end smallexample

@noindent
これは @code{number} の値が3、つまり三番目の @sc{ascii} コードである
@sc{ascii} @key{CTL-C} であることを意味している。(C はアルファベットの三
番目の文字である。) (訳註：暇な人は @code{(char-to-string 3)} 等を評価し
てみよう。)

こうしてエラーのある行まで移動することが出来る。これを表示する直前には、
この行は次のように表示されている。

@smallexample
=>        @point{}(1= number)))))               ; @r{ここでエラー}
@end smallexample

@need 1250
@noindent
ここでもう一度 @kbd{SPC} を押すと次のようなエラーメッセージが表示される。

@smallexample
Symbol's function definition is void:@: 1=
@end smallexample

@noindent
これがバグである。

Edebug を終了するには @samp{q} を押せばよい。

この関数定義の膳立てを解くには、 単に膳立てしないようなコマンドでその関
数を評価しなおせばよい。例えば、関数定義の最後の閉じ括弧の後で @kbd{C-x
C-e} とタイプするだけでよい。

Edebug は単に関数を一つずつ実行していくだけではなく他にも沢山のことをし
てくれる。自動的に関数を実行していってエラーが起きた所で止まるように設定
することも出来るし、特定の場所で止まるようにすることも可能である。様々な
Ｓ式の値の変化を表示させることも出来るし、ある関数が何回実行されたかも調
べることも出来る。その他にもいろいろなことが出来る。

Edebug については次で説明されている。 @ref{edebug, , Edebug, elisp, The
GNU Emacs Lisp Reference Manual}.

@need 1500
@node Debugging Exercises
@section デバッグについての練習問題

@itemize @bullet
@item
@code{count-words-region} 関数をインストールし、それを呼び出した時に内部
デバッガが起動するようにしなさい。二つの単語を含むような region の上でこ
の関数を実行しなさい。@kbd{d} をかなりの回数押す必要があるだろう。あなた
の システムではこのコマンドが終了した時点で何かフックが呼ばれますか？
(フックについての情報は次を参照。 @ref{Command Overview, , Command Loop
Overview, elisp, The GNU Emacs Lisp Reference Manual}.)

@item
@code{count-words-region} を @file{*scratch*} バッファにコピーして、必要
なら @code{defun} の先頭のスペースを取り除いてから、この関数を Edebug の
ために膳立てしなさい。そして、この関数を1ステップずつ実行しなさい。この
場合、必ずしも関数にはバグがある必要はない。バグがあった方がよければバグ
を設定してもよい。もしこの関数にバグがなければ、問題なく最後まで実行出来
るはずだ。

@item
Edebug を実行している間に、@kbd{?} とタイプして全ての Edebug のコマンド
のリストを見なさい。(@code{global-edebug-prefix} は普通 @kbd{C-x X}、つ
まり @:@kbd{@key{CTL}-x} に続く大文字の @kbd{X} になっている。Edebug の
デバッグバッファの外でのコマンドにはこの前置キーを使うようにする。)

@item
Edebug のデバッギングバッファで @kbd{p}
(@code{edebug-bounce-point}) コマンドを使ってリージョンの何処で
@code{count-words-region} が動作しているかを見なさい。

@item
ポイントを関数の下の方に持って行き、@kbd{h}
(@code{edebug-goto-here}) コマンドをタイプすることでその場所にジャンプし
なさい。

@item
@kbd{t} (@code{edebug-trace-mode}) コマンドを使って、Edebug が自分自身で
関数の上を走るようにしなさい。同様に大文字の @kbd{T} を使って
@code{edebug-Trace-fast-mode} に入りなさい。

@item
ブレークポイントを設定し、その位置まで Edebug を Trace mode で走らせなさ
い。
@end itemize

@node Conclusion
@chapter まとめ

この入門書はこれで終わりである。以上であなたは Emacs Lisp でのプログラミ
ングについて十分学んだので、値をセットしたり、簡単な @file{.emacs} ファ
イルを自分自身や友人のために書いたり、Emacs にちょっとしたカスタマイズや
拡張を施すことが出来るようになっているはずである。

もっとも、これは一つの段階に過ぎない。望むなら、もっと先に進み、自分自身
で学んでいくことが出来る。

You have learned some of the basic nuts and bolts of programming.  But
only some.  There are a great many more brackets and hinges that are
easy to use that we have not touched.

ここからは GNU Emacs のソースや
@ifnotinfo
@cite{The GNU Emacs Lisp Reference Manual}.
@end ifnotinfo
@ifinfo
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual},
@end ifinfo
などが参考になるだろう。

Emacs Lisp のソースを見ることは一種の探検である。ソースを読んで見慣れな
い関数やＳ式に出逢った場合には、それが何であるかを解読したり調べたりしな
ければならない。

まずリファレンスマニュアルを開こう。これは徹底して書かれた、完全な、しか
も読みやすい Emacs Lisp の説明書である。これは熟練者のためだけではなく、
あなたが現在知っているような知識しかない人向けにも書かれている。
(@cite{Reference Manual} は標準的な GNU Emacs の配布に含まれている。この
入門書と同様、これも Texinfo のソースファイルとして配布されている。従っ
て、オンラインでも読めるし、タイプセットして印刷された本としても読むこと
も出来る。)

また、他の GNU Emacs 附属のオンラインヘルプも読んでみよう。全ての関数に
は説明文字列がついているし、@code{find-tag} というソースを見つけてくれ
るプログラムもある。

例として私がソースを探検する方法を紹介しよう。もう随分と昔のことになるが、
最初に私は、その名前に魅かれて @file{simple.el} というファイルを見た。往々
にしてそんなものだが、@file{simple.el} の中の幾つかの関数は複雑だった。
少なくとも、ぱっと見には複雑そうに見えた。例えば一番最初の
@code{open-line} 関数からして、いかにも複雑という感じだ。

あなたは、この関数を @code{forward-sentence} 関数の時のように、ゆっくり
と眺めたいかもしれない。
(@xref{forward-sentence, The
@code{forward-sentence} function}.)
あるいは、この関数は飛ばして他のもっと簡単そうな @code{split-line} 等の
関数を見たいかもしれない。これらの関数を全て読む必要はない。
@code{count-words-in-defun} を使うと、@code{split-line} 関数は102個の単語
とシンボルを含んでいることが分る。

@code{split-line} は、その短さにも関わらず、まだ我々が学んでいない四つの
Ｓ式を含んでいる。@code{skip-chars-forward}、@code{indent-to}、
@code{current-column}、そして @samp{insert-and-inherit} である。

例えば @code{skip-chars-forward} 関数を考えてみよう。(これについては復習のセクション
である次の所でちょこっと触れられている。)
@ref{Review, , Review}

In GNU Emacs, you can find out more about @code{skip-chars-forward} by
typing @kbd{C-h f} (@code{describe-function}) and the name of the
function.  This gives you the function documentation.

You may be able to guess what is done by a well named function such as
@code{indent-to}; or you can look it up, too.  Incidentally, the
@code{describe-function} function itself is in @file{help.el}; it is
one of those long, but decipherable functions.  You can look up
@code{describe-function} using the @kbd{C-h f} command!

In this instance, since the code is Lisp, the @file{*Help*} buffer
contains the name of the library containing the function's source.
You can put point over the name of the library and press the RET key,
which in this situation is bound to @code{help-follow}, and be taken
directly to the source, in the same way as @kbd{M-.}
(@code{find-tag}).

The definition for @code{describe-function} illustrates how to
customize the @code{interactive} expression without using the standard
character codes; and it shows how to create a temporary buffer.

(The @code{indent-to} function is written in C rather than Emacs Lisp;
it is a `built-in' function.  @code{help-follow} takes you to its
source as does @code{find-tag}, when properly set up.)

You can look at a function's source using @code{find-tag}, which is
bound to @kbd{M-.}  Finally, you can find out what the Reference
Manual has to say by visiting the manual in Info, and typing @kbd{i}
(@code{Info-index}) and the name of the function, or by looking up the
function in the index to a printed copy of the manual.

（旧訳）Emacs 上で @kbd{C-h f} (@code{describe-function}) に続けて @code{skip-chars-forward}
とタイプすれば、この関数についてより詳しいことを知ることが出来る。これは
関数の説明文字列を表示してくれる関数である。ソース
を見る場合は @code{find-tag} を使う。これは @kbd{M-.} にバインドされてい
る。(もっとも今の場合にはあまり役に立たない。この関数は Lisp ではなく C
で書かれたプリミティブだからだ。) 最後に、この関数についてのリファレンス
マニュアルの記述は次のようにして探せる。まず Info を起動する。そして
@kbd{i} (@code{Info-index}) に続けてこの関数の名前をタイプする。もしくは
印刷されたマニュアルのインデックスから @code{insert} を探してもよい。

Similarly, you can find out what is meant by
@code{insert-and-inherit}.

（旧訳）同様に、@samp{?\n} の意味も調べることが出来る。@code{Info-index} で
@samp{?\n} を探してみるとよい。やってみると分るがこれは失敗する。しかし
諦めてはいけない。インデックスで @samp{?} 無しの @samp{\n} を探してみれ
ば、マニュアルの中で関係するセクションを見つけることが出来る。
(@samp{?\n} が改行文字を表していることは次の所に出ている。
@ref{Character Type, , Character Type, elisp, The GNU Emacs Lisp
Reference Manual}.)

（旧訳）@code{skip-chars-forward} と @code{indent-to} で何が行われているかは推察
することが出来るだろう。勿論詳しく見ることだって出来る。(ついでだが、
@code{describe-function} 関数そのものは @file{help.el} にある。これは、
長い割には解読しやすい関数の一つである。これの定義を見れば、どうやって標準
の文字コードを使わずに @code{interactive} 式をカスタマイズ出来るかとか、
どうやってテンポラリバッファを生成するかということが分る。

Other interesting source files include @file{paragraphs.el},
@file{loaddefs.el}, and @file{loadup.el}.  The @file{paragraphs.el}
file includes short, easily understood functions as well as longer
ones.  The @file{loaddefs.el} file contains the many standard
autoloads and many keymaps.  I have never looked at it all; only at
parts.  @file{loadup.el} is the file that loads the standard parts of
Emacs; it tells you a great deal about how Emacs is built.
(@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp
Reference Manual}, for more about building.)

（旧訳）他の面白いソースとしては、@file{paragraphs.el} や @file{loaddefs.el} そ
れに @file{loadup.el} などがあげられる。@file{paragraphs.el} ファイルに
は、長い関数だけでなく短くて簡単に理解出来る関数も含まれている。
@file{loaddefs.el} ファイルには沢山の標準オートロード式や沢山のキーマッ
プが含まれている。@file{loadup.el} は Emacs の標準部分をロードするファイ
ルである。これを見れば、Emacs がどういうふうに作成されるかがよく分る。
(Emacs の作成については次を参照。@ref{Building Emacs, , Building Emacs,
elisp, The GNU Emacs Lisp Reference Manual}.)

前にも言ったように、これまでに Emacs の部品についてはいくらか学習してき
た。しかし、これは大切なことなのだが、プログラミングの多くの部分について
はほとんど触れることは出来なかった。私は情報のソートについては既に定義さ
れた @code{sort} 関数を使うこと以外全く触れることが出来なかった。また、
変数やリストを使うこと以外の事柄については、例えば情報を貯めておくにはど
うしたらいいかといったことにも触れられなかった。プログラムを書くプログラ
ムについても同様だ。これらの話題については、他の別の種類の本で本書とは異
なる学習形態で学ぶべきであろう。

ともかく、以上で GNU Emacs を使って沢山の実際の仕事をする準備が整った。
出発点に辿り着いたわけである。これは始まりの終わりなのだ。

@c ================ Appendix ================

@node the-the
@appendix 関数 @code{the-the}
@findex the-the
@cindex Duplicated words function
@cindex Words, duplicated

文章を書いていると、時々単語を二重に書いてしまうことがある---例えば
``you you'' (訳註：原文では実際にこの文の先頭で you が二重になっている。)
と書いてしまったりする。個人的には ``the'' をよく二重に書いてしまう。そ
こで、二重になっている単語を見つける関数のことを @code{the-the} と呼ぶこ
とにする。

@need 1250
まず最初の段階として、取り敢えず次の正規表現を使えば、このような二重の単
語を表現出来そうなことが分る。

@smallexample
\\(\\w+[ \t\n]+\\)\\1
@end smallexample

@noindent
この正規表現(の前半)は一つ以上の単語構成文字に続いて一つ以上のスペース、
タブないしは改行がくるものにマッチする。しかし、これでは二行に渡るものは
見つけられない。というのも、最初の単語の終わりに改行が来た場合に、次の行
の同じ単語の後にスペースが来ればマッチしないからである。(正規表現につい
ての詳細は、@ref{Regexp Search, , 正規表現の検索}, や
@ref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs
Manual}, それに @ref{Regular Expressions, , Regular Expressions, elisp,
The GNU Emacs Lisp Reference Manual}, を参照。)

単に単語の部分だけを検索すればよいのではと考えるかもしれないが、これでは
`with the' の中の `th' のようなものまで引っかけてしまう。

上とは別の正規表現検索で、単語構成文字に続いて非単語構成文字が続き、更に
最初の単語が来るものにマッチするものがある。次の式で @w{@samp{\\w+}} は
一つ以上の単語構成文字にマッチし、@w{@samp{\\W*}} は零個以上の非単語構成
文字にマッチする。

@smallexample
\\(\\(\\w+\\)\\W*\\)\\1
@end smallexample

@noindent
が、これも役に立たない。

次に私が使っているものを挙げる。これは完全ではないが、十分使いものになる。
@w{@samp{\\b}} は単語の始まりもしくは終わりの空文字列にマッチし、
@w{@samp{[^@@ \n\t]+}} は一つ以上の @@ マーク、空白、改行、もしくはタブの
いずれでもない文字の連続にマッチする。

@smallexample
\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
@end smallexample

もっと複雑な式を書くことも出来るが、私自身はこの式で十分であると分ったの
で、これを使っている。

以下が @code{the-the} 関数である。これを使いやすいキーバインディングと共に
@file{.emacs} ファイルに記述している。

@smallexample
@group
(defun the-the ()
  "Search forward for for a duplicated word."
  (interactive)
  (message "Searching for for duplicated words ...")
  (push-mark)
@end group
@group
  ;; This regexp is not perfect
  ;; but is fairly good over all:
  (if (re-search-forward
       "\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
      (message "Found duplicated word.")
    (message "End of buffer")))
@end group

@group
;; Bind `the-the' to  C-c \
(global-set-key "\C-c\\" 'the-the)
@end group
@end smallexample

@sp 1
以下がテスト用の文章である。

@smallexample
@group
one two two three four five
five six seven
@end group
@end smallexample

関数定義の中の正規表現を上に挙げた他の正規表現で置き換えて、このリストの
上で試してみることも出来る。

@node Kill Ring
@appendix Kill リングの扱い
@cindex Kill ring handling
@cindex Handling the kill ring
@cindex Ring, making a list like a

kill リングは @code{rotate-yank-pointer} の働きによってリングの形態に変
換されたリストである。@code{yank} 及び @code{yank-pop} コマンドは
@code{rotate-yank-pointer} 関数を利用している。

この Appendix では、
@code{yank} や @code{yank-pop} と共に、@code{rotate-yank-pointer} 関数も
説明することにする。

@menu
* What the Kill Ring Does::
* current-kill::                リストの中でのポインタの移動と巡回
* yank::                        切り取ったテキストを貼り付ける
* yank-pop::                    ポインタが指しているテキストを貼り付ける
* ring file::
@end menu

@ifnottex
@node What the Kill Ring Does
@unnumberedsec What the Kill Ring Does
@end ifnottex

@need 1250
The kill ring has a default maximum length of sixty items; this number
is too large for an explanation.  Instead, set it to four.  Please
evaluate the following:

@smallexample
@group
(setq old-kill-ring-max kill-ring-max)
(setq kill-ring-max 4)
@end group
@end smallexample

@noindent
Then, please copy each line of the following indented example into the
kill ring.  You may kill each line with @kbd{C-k} or mark it and copy
it with @kbd{M-w}.

@noindent
(In a read-only buffer, such as the @file{*info*} buffer, the kill
command, @kbd{C-k} (@code{kill-line}), will not remove the text,
merely copy it to the kill ring.  However, your machine may beep at
you.  Alternatively, for silence, you may copy the region of each line
with the @kbd{M-w} (@code{kill-ring-save}) command.  You must mark
each line for this command to succeed, but it does not matter at which
end you put point or mark.)

@need 1250
@noindent
Please invoke the calls in order, so that five elements attempt to
fill the kill ring:

@smallexample
@group
first some text
second piece of text
third line
fourth line of text
fifth bit of text
@end group
@end smallexample

@need 1250
@noindent
Then find the value of @code{kill-ring} by evaluating

@smallexample
kill-ring
@end smallexample

@need 800
@noindent
It is:

@smallexample
@group
("fifth bit of text" "fourth line of text"
"third line" "second piece of text")
@end group
@end smallexample

@noindent
The first element, @samp{first some text}, was dropped.

@need 1250
To return to the old value for the length of the kill ring, evaluate:

@smallexample
(setq kill-ring-max old-kill-ring-max)
@end smallexample

@node current-kill
@appendixsec 関数 @code{current-kill}
@findex current-kill

The @code{current-kill} function changes the element in the kill ring
to which @code{kill-ring-yank-pointer} points.  (Also, the
@code{kill-new} function sets @code{kill-ring-yank-pointer} to point
to the latest element of the kill ring.  The @code{kill-new}
function is used directly or indirectly by @code{kill-append},
@code{copy-region-as-kill}, @code{kill-ring-save}, @code{kill-line},
and @code{kill-region}.)

@menu
* Code for current-kill::
* Understanding current-kill::
@end menu

@ifnottex
@node Code for current-kill
@unnumberedsubsec The code for @code{current-kill}
@end ifnottex


@need 1500
The @code{current-kill} function is used by @code{yank} and by
@code{yank-pop}.  Here is the code for @code{current-kill}:

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill.
If N is zero, `interprogram-paste-function' is set, and calling it
returns a string, then that string is added to the front of the
kill ring and returned as the latest kill.
@end group
@group
If optional arg DO-NOT-MOVE is non-nil, then don't actually move the
yanking point; just return the Nth kill forward."
  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
@end group
@group
    (if interprogram-paste
        (progn
          ;; Disable the interprogram cut function when we add the new
          ;; text to the kill ring, so Emacs doesn't try to own the
          ;; selection, with identical text.
          (let ((interprogram-cut-function nil))
            (kill-new interprogram-paste))
          interprogram-paste)
@end group
@group
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element)))))
@end group
@end smallexample

Remember also that the @code{kill-new} function sets
@code{kill-ring-yank-pointer} to the latest element of the kill
ring, which means that all the functions that call it set the value
indirectly: @code{kill-append}, @code{copy-region-as-kill},
@code{kill-ring-save}, @code{kill-line}, and @code{kill-region}.

@need 1500
Here is the line in @code{kill-new}, which is explained in
@ref{kill-new function, , The @code{kill-new} function}.

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

@ifnottex
@node Understanding current-kill
@unnumberedsubsec @code{current-kill} in Outline
@end ifnottex

The @code{current-kill} function looks complex, but as usual, it can
be understood by taking it apart piece by piece.  First look at it in
skeletal form:

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill."
  (let @var{varlist}
    @var{body}@dots{})
@end group
@end smallexample

This function takes two arguments, one of which is optional.  It has a
documentation string.  It is @emph{not} interactive.

@menu
* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::
@end menu

@ifnottex
@node Body of current-kill
@unnumberedsubsubsec The Body of @code{current-kill}
@end ifnottex

The body of the function definition is a @code{let} expression, which
itself has a body as well as a @var{varlist}.

The @code{let} expression declares a variable that will be only usable
within the bounds of this function.  This variable is called
@code{interprogram-paste} and is for copying to another program.  It
is not for copying within this instance of GNU Emacs.  Most window
systems provide a facility for interprogram pasting.  Sadly, that
facility usually provides only for the last element.  Most windowing
systems have not adopted a ring of many possibilities, even though
Emacs has provided it for decades.

The @code{if} expression has two parts, one if there exists
@code{interprogram-paste} and one if not.

@need 2000
Let us consider the `if not' or else-part of the @code{current-kill}
function.  (The then-part uses the @code{kill-new} function, which
we have already described.  @xref{kill-new function, , The
@code{kill-new} function}.)

@smallexample
@group
(or kill-ring (error "Kill ring is empty"))
(let ((ARGth-kill-element
       (nthcdr (mod (- n (length kill-ring-yank-pointer))
                    (length kill-ring))
               kill-ring)))
  (or do-not-move
      (setq kill-ring-yank-pointer ARGth-kill-element))
  (car ARGth-kill-element))
@end group
@end smallexample

@noindent
The code first checks whether the kill ring has content; otherwise it
signals an error.

@need 1000
Note that the @code{or} expression is very similar to testing length
with an @code{if}:

@findex zerop
@findex error
@smallexample
@group
(if (zerop (length kill-ring))          ; @r{if-part}
    (error "Kill ring is empty"))       ; @r{then-part}
  ;; No else-part
@end group
@end smallexample

@noindent
If there is not anything in the kill ring, its length must be zero and
an error message sent to the user: @samp{Kill ring is empty}.  The
@code{current-kill} function uses an @code{or} expression which is
simpler.  But an @code{if} expression reminds us what goes on.

This @code{if} expression uses the function @code{zerop} which returns
true if the value it is testing is zero.  When @code{zerop} tests
true, the then-part of the @code{if} is evaluated.  The then-part is a
list starting with the function @code{error}, which is a function that
is similar to the @code{message} function
(@pxref{message, , The @code{message} Function}) in that
it prints a one-line message in the echo area.  However, in addition
to printing a message, @code{error} also stops evaluation of the
function within which it is embedded.  This means that the rest of the
function will not be evaluated if the length of the kill ring is zero.

Then the @code{current-kill} function selects the element to return.
The selection depends on the number of places that @code{current-kill}
rotates and on where @code{kill-ring-yank-pointer} points.

Next, either the optional @code{do-not-move} argument is true or the
current value of @code{kill-ring-yank-pointer} is set to point to the
list.  Finally, another expression returns the first element of the
list even if the @code{do-not-move} argument is true.

@ifnottex
@node Digression concerning error
@unnumberedsubsubsec Digression about the word `error'
@end ifnottex

In my opinion, it is slightly misleading, at least to humans, to use
the term `error' as the name of the @code{error} function.  A better
term would be `cancel'.  Strictly speaking, of course, you cannot
point to, much less rotate a pointer to a list that has no length, so
from the point of view of the computer, the word `error' is correct.
But a human expects to attempt this sort of thing, if only to find out
whether the kill ring is full or empty.  This is an act of
exploration.

From the human point of view, the act of exploration and discovery is
not necessarily an error, and therefore should not be labeled as one,
even in the bowels of a computer.  As it is, the code in Emacs implies
that a human who is acting virtuously, by exploring his or her
environment, is making an error.  This is bad.  Even though the computer
takes the same steps as it does when there is an `error', a term such as
`cancel' would have a clearer connotation.

@ifnottex
@node Determining the Element
@unnumberedsubsubsec Determining the Element
@end ifnottex

Among other actions, the else-part of the @code{if} expression sets
the value of @code{kill-ring-yank-pointer} to
@code{ARGth-kill-element} when the kill ring has something in it and
the value of @code{do-not-move} is @code{nil}.

@need 800
The code looks like this:

@smallexample
@group
(nthcdr (mod (- n (length kill-ring-yank-pointer))
             (length kill-ring))
        kill-ring)))
@end group
@end smallexample

This needs some examination.  Unless it is not supposed to move the
pointer, the @code{current-kill} function changes where
@code{kill-ring-yank-pointer} points.
That is what the
@w{@code{(setq kill-ring-yank-pointer ARGth-kill-element))}}
expression does.  Also, clearly, @code{ARGth-kill-element} is being
set to be equal to some @sc{cdr} of the kill ring, using the
@code{nthcdr} function that is described in an earlier section.
(@xref{copy-region-as-kill}.)  How does it do this?

As we have seen before (@pxref{nthcdr}), the @code{nthcdr} function
works by repeatedly taking the @sc{cdr} of a list---it takes the
@sc{cdr} of the @sc{cdr} of the @sc{cdr} @dots{}

@need 800
The two following expressions produce the same result:

@smallexample
@group
(setq kill-ring-yank-pointer (cdr kill-ring))

(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
@end group
@end smallexample

However, the @code{nthcdr} expression is more complicated.  It uses
the @code{mod} function to determine which @sc{cdr} to select.

(You will remember to look at inner functions first; indeed, we will
have to go inside the @code{mod}.)

The @code{mod} function returns the value of its first argument modulo
the second; that is to say, it returns the remainder after dividing
the first argument by the second.  The value returned has the same
sign as the second argument.

@need 800
Thus,

@smallexample
@group
(mod 12 4)
  @result{} 0  ;; @r{because there is no remainder}
(mod 13 4)
  @result{} 1
@end group
@end smallexample

@need 1250
In this case, the first argument is often smaller than the second.
That is fine.

@smallexample
@group
(mod 0 4)
  @result{} 0
(mod 1 4)
  @result{} 1
@end group
@end smallexample

We can guess what the @code{-} function does.  It is like @code{+} but
subtracts instead of adds; the @code{-} function subtracts its second
argument from its first.  Also, we already know what the @code{length}
function does (@pxref{length}).  It returns the length of a list.

And @code{n} is the name of the required argument to the
@code{current-kill} function.

@need 1250
So when the first argument to @code{nthcdr} is zero, the @code{nthcdr}
expression returns the whole list, as you can see by evaluating the
following:

@smallexample
@group
;; kill-ring-yank-pointer @r{and} kill-ring @r{have a length of four}
;; @r{and} (mod (- 0 4) 4) @result{} 0
(nthcdr (mod (- 0 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@need 1250
When the first argument to the @code{current-kill} function is one,
the @code{nthcdr} expression returns the list without its first
element.

@smallexample
@group
(nthcdr (mod (- 1 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@cindex @samp{global variable} defined
@cindex @samp{variable, global}, defined
Incidentally, both @code{kill-ring} and @code{kill-ring-yank-pointer}
are @dfn{global variables}.  That means that any expression in Emacs
Lisp can access them.  They are not like the local variables set by
@code{let} or like the symbols in an argument list.
Local variables can only be accessed
within the @code{let} that defines them or the function that specifies
them in an argument list (and within expressions called by them).

@ignore
@c texi2dvi fails when the name of the section is within ifnottex ...
(@xref{Prevent confusion, , @code{let} Prevents Confusion}, and
@ref{defun, , The @code{defun} Macro}.)
@end ignore

@node yank
@appendixsec @code{yank}
@findex yank

@code{current-kill} について学んだ後では、@code{yank} 関数のコー
ドは全く易しく見えるだろう。

The @code{yank} function does not use the
@code{kill-ring-yank-pointer} variable directly.  It calls
@code{insert-for-yank} which calls @code{current-kill} which sets the
@code{kill-ring-yank-pointer} variable.

（旧訳）これには一箇所だけトリッキーな部分がある。
@code{rotate-yank-pointer} に渡す引数の計算の所だ。

@need 1250
コードは以下の通りである。

@c in GNU Emacs 22
@smallexample
@group
(defun yank (&optional arg)
  "Reinsert (\"paste\") the last stretch of killed text.
More precisely, reinsert the stretch of killed text most recently
killed OR yanked.  Put point at end, and set mark at beginning.
With just \\[universal-argument] as argument, same but put point at
beginning (and mark at end).  With argument N, reinsert the Nth most
recently killed stretch of killed text.

When this command inserts killed text into the buffer, it honors
`yank-excluded-properties' and `yank-handler' as described in the
doc string for `insert-for-yank-1', which see.

See also the command \\[yank-pop]."
@end group
@group
  (interactive "*P")
  (setq yank-window-start (window-start))
  ;; If we don't get all the way thru, make last-command indicate that
  ;; for the following command.
  (setq this-command t)
  (push-mark (point))
@end group
@group
  (insert-for-yank (current-kill (cond
                                  ((listp arg) 0)
                                  ((eq arg '-) -2)
                                  (t (1- arg)))))
  (if (consp arg)
      ;; This is like exchange-point-and-mark,
      ;;     but doesn't activate the mark.
      ;; It is cleaner to avoid activation, even though the command
      ;; loop would deactivate the mark because we inserted text.
      (goto-char (prog1 (mark t)
                   (set-marker (mark-marker) (point) (current-buffer)))))
@end group
@group
  ;; If we do get all the way thru, make this-command indicate that.
  (if (eq this-command t)
      (setq this-command 'yank))
  nil)
@end group
@end smallexample

The key expression is @code{insert-for-yank}, which inserts the string
returned by @code{current-kill}, but removes some text properties from
it.

However, before getting to that expression, the function sets the value
of @code{yank-window-start} to the position returned by the
@code{(window-start)} expression, the position at which the display
currently starts.  The @code{yank} function also sets
@code{this-command} and pushes the mark.

After it yanks the appropriate element, if the optional argument is a
@sc{cons} rather than a number or nothing, it puts point at beginning
of the yanked text and mark at its end.

(The @code{prog1} function is like @code{progn} but returns the value
of its first argument rather than the value of its last argument.  Its
first argument is forced to return the buffer's mark as an integer.
You can see the documentation for these functions by placing point
over them in this buffer and then typing @kbd{C-h f}
(@code{describe-function}) followed by a @kbd{RET}; the default is the
function.)

The last part of the function tells what to do when it succeeds.

@node yank-pop
@appendixsec @code{yank-pop}
@findex yank-pop

@code{yank} と @code{current-kill} を理解してしまえば、
@code{yank-pop} 関数は簡単に理解出来る。
スペースの節約のために説明文字列を省くと、コードは次の通りである。

@c GNU Emacs 22
@smallexample
@group
(defun yank-pop (&optional arg)
  "@dots{}"
  (interactive "*p")
  (if (not (eq last-command 'yank))
      (error "Previous command was not a yank"))
@end group
@group
  (setq this-command 'yank)
  (unless arg (setq arg 1))
  (let ((inhibit-read-only t)
        (before (< (point) (mark t))))
@end group
@group
    (if before
        (funcall (or yank-undo-function 'delete-region) (point) (mark t))
      (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
    (setq yank-undo-function nil)
@end group
@group
    (set-marker (mark-marker) (point) (current-buffer))
    (insert-for-yank (current-kill arg))
    ;; Set the window start back where it was in the yank command,
    ;; if possible.
    (set-window-start (selected-window) yank-window-start t)
@end group
@group
    (if before
        ;; This is like exchange-point-and-mark,
        ;;     but doesn't activate the mark.
        ;; It is cleaner to avoid activation, even though the command
        ;; loop would deactivate the mark because we inserted text.
        (goto-char (prog1 (mark t)
                     (set-marker (mark-marker)
                                 (point)
                                 (current-buffer))))))
  nil)
@end group
@end smallexample

The function is interactive with a small @samp{p} so the prefix
argument is processed and passed to the function.  The command can
only be used after a previous yank; otherwise an error message is
sent.  This check uses the variable @code{last-command} which is set
by @code{yank} and is discussed elsewhere.
(@xref{copy-region-as-kill}.)

The @code{let} clause sets the variable @code{before} to true or false
depending whether point is before or after mark and then the region
between point and mark is deleted.  This is the region that was just
inserted by the previous yank and it is this text that will be
replaced.

@code{funcall} calls its first argument as a function, passing
remaining arguments to it.  The first argument is whatever the
@code{or} expression returns.  The two remaining arguments are the
positions of point and mark set by the preceding @code{yank} command.

There is more, but that is the hardest part.

@node ring file
@appendixsec The @file{ring.el} File
@cindex @file{ring.el} file

Interestingly, GNU Emacs posses a file called @file{ring.el} that
provides many of the features we just discussed.  But functions such
as @code{kill-ring-yank-pointer} do not use this library, possibly
because they were written earlier.

@node Full Graph
@appendix ラベルと軸が付いたグラフ

座標軸を描くと、グラフを理解する手助けになる。目盛もつけたい。以前の章で
は (@ref{Readying a Graph, ,  グラフを描く準備}, 参照) グラフの本体を描
くコードを書いたのであった。ここではその本体にそって縦軸と横軸を表示し、
ラベルをつけるコードを書くことにしよう。

@menu
* Labeled Example::             最終的なグラフはどんな形になるか
* print-graph Varlist::         @code{print-graph} の中の @code{let} 式
* print-Y-axis::                縦軸のラベルの表示
* print-X-axis::                横軸のラベルの表示
* Print Whole Graph::           完全なグラフを表示する関数
@end menu

@ifnottex
@node Labeled Example
@unnumberedsec ラベルのついたグラフのサンプル
@end ifnottex

ここでの挿入は、バッファのポイントの下方を右方向に向って埋めていくので、
新しいグラフ表示関数では、まず Y 軸ないしは縦軸を表示し、ついで本体を、
そして最後に X 軸ないしは横軸を表示するという順番になる。この流れから、
関数の中身のレイアウトは次のような感じになる。

@enumerate
@item
コードの下準備。

@item
Y 軸の表示。

@item
グラフ本体の表示。

@item
X 軸の表示。
@end enumerate

以下に出来上がったグラフの例がどうあるべきかを載せておく。

@smallexample
@group
    10 -
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
@end group
@end smallexample

@noindent
このグラフでは、縦軸と横軸には数によるラベルがついている。しかしながら、
グラフの種類によっては横軸が時間で、月によるラベルをつけた方が良い場合も
多いだろう。次のような感じだ。

@smallexample
@group
     5 -      *
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
         Jan  June   Jan
@end group
@end smallexample

実際には、ちょっと考えれば横軸や縦軸について様々な形式を思いつく。複雑な
関数にすることも可能だ。しかし複雑さは混乱を招く。それよりも、最初は単純
な形式を選んで、後でそれを修正ないしは置き換えるのが良いだろう。

以上のことを考慮すると、次のようなアウトラインで @code{print-graph} 関数
を書いていくのがいいだろう。

@smallexample
@group
(defun print-graph (numbers-list)
@c   "@var{documentation}@dots{}"
  "@var{説明文字列}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

この @code{print-graph} 関数の雛型を元にして、各々の部分を順に書いていく
ことにしよう。

@node print-graph Varlist
@appendixsec @code{print-graph} の変数リスト
@cindex @code{print-graph} varlist

@code{print-graph} 関数を書く際に、まずやらなければならないことは、
@code{let} 式の変数リストを書くことである。(取り敢えず、インタラクティブ
式や説明文字列のことは置いておく。)

変数リストでは幾つかの値を設定しなければならない。縦軸のラベルの一番上は
少なくともグラフの高さでなくてはいけないので、まずこれについての情報が必
要になる。@code{print-graph-body} 関数でもこの情報が必要だったことを思い
出そう。同じ計算を別の場所で二度行う理由はどこにもないので、以前定義した
@code{print-graph-body} を書き換えてこの計算を一度だけにするべきである。

同様に、X 軸のラベルを表示する関数と @code{print-graph-body} 関数のどち
らにおいても記号の幅の値を知る必要がある。これも以前の章の
@code{print-graph-body} の定義を書き換えて、最初に計算をすませてしまうべ
きであろう。

横軸のラベルの長さは少なくともグラフの長さの分はなければならない。しかし、
この情報は横軸を表示する関数だけに必要なものである。従って、ここでやらな
くとも良い。

以上のことから、@code{print-graph} の @code{let} 式の変数リストは次のよ
うな感じになる。

@smallexample
@group
(let ((height (apply 'max numbers-list)) ; @r{最初のバージョン}
      (symbol-width (length graph-blank)))
@end group
@end smallexample

@noindent
が、後で見るように、これではちょっとまずい。

@need 2000
@node print-Y-axis
@appendixsec 関数 @code{print-Y-axis}
@cindex Axis, print vertical
@cindex Y axis printing
@cindex Vertical axis printing
@cindex Print vertical axis

@code{print-Y-axis} 関数の仕事は、縦軸として次のようなラベルを表示するこ
とである。

@smallexample
@group
    10 -




     5 -



     1 -
@end group
@end smallexample

@noindent
この関数には、グラフの高さを渡してやる必要がある。それを元に適切な目盛と
数を構成し、挿入するわけである。

@menu
* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         割った余りの計算方法
* Y Axis Element::              Y 軸の各行の構成
* Y-axis-column::               Y 軸のラベルのリストの生成
* print-Y-axis Penultimate::          縦軸の表示、最終版
@end menu

@ifnottex
@node print-Y-axis in Detail
@unnumberedsubsec The @code{print-Y-axis} Function in Detail
@end ifnottex

図で見ると、Y 軸のラベルがどうなるべきかは一目瞭然である。しかし、これを
言葉で表しその仕事をする関数を書くとなると、少々ややこしくなる。単に5行
ごとに数や目盛をつければよいというのは間違いである。@samp{1} と @samp{5}
の間には三行しかない (2、3、4行)。しかし、@samp{5} と @samp{10} の間には
四行ある (6、7、8、9行)。まずは一行目にベースとなる行として数1と目盛をつ
け、その他に最下行から5行ごとに目盛と数をつけていく方がよいだろう。

@ifnottex
@node Height of label
@unnumberedsubsec What height should the label be?
@end ifnottex

次の問題は、ラベルの高さをどうするかである。例えば、グラフの縦の列の中で
最も高いものの高さが7だったとしよう。この場合、最も上のラベルは
@samp{5 -} にして、グラフを上に突き出させるべきだろうか。それとも7以上の
最大の5の倍数として @samp{10 -} の所までラベルを付けるべきだろうか。

これは後者の方がよいだろう。大抵のグラフは長方形のなかに描かれており、側
面は刻み幅の整数倍になっている。今の場合なら、5、10、15というふうな5の倍
数である。しかし、縦軸の仕様としてこのようなものを採用するとなると、以前
の関数の変数リストでの、単純に高さを計算するＳ式ではまずいことに気付く。
これは @code{(apply 'max numbers-list)} というものだったが、これでは単に
正確なグラフの縦の列の高さの最大値が出るだけで、5の倍数になるような調整
はしてはくれない。もっと複雑な関数が必要なわけである。

いつものことだが、複雑な問題も幾つかの小さな問題に分割して考えれば単純
な問題になることが多い。

最初に、いつグラフの高さが5の整数倍になるかを考えてみよう。これは5、10、
15等の5の倍数の時である。この場合は、この値を即、Y 軸の高さとしてよい。

ある数が5の倍数になるかどうかを見るには、この数を5で割ってみて、余りがど
うなるかを見るのが早い。もし余りが無ければ、その数は5の倍数である。7の場
合は余りが2になるので、これは5の倍数ではない。ちょっと言い方を変えて小学
校ふうに説明するなら、5は7の中に一回だけ含まれて、残りは2になる。一方、5
は10の中には2回含まれ、残りはない。従って、10は5の倍数ということになる。

@node Compute a Remainder
@appendixsubsec 寄り道: 剰余の計算

@findex % @r{(remainder function)}
@cindex Remainder function, @code{%}
Lisp では余りを計算する関数は @code{%} である。この関数は最初の引数を二
番目の引数で割った時の余りを返す。あいにく、@code{%} という Emacs Lisp
関数は @code{apropos} では見つけられない。つまり、@kbd{M-x apropos
@key{RET} remainder @key{RET}} とすると、何も見つけられない。@code{%} と
いう関数の存在を知るためにはこの文書などの本を見るか、Emacs Lisp のソー
スを眺めるしか方法がない。

@code{%} 関数を試してみるには、次の二つのＳ式を評価してみると良い。

@smallexample
@group
(% 7 5)

(% 10 5)
@end group
@end smallexample

@noindent
最初のＳ式は2を返すし、二番目のＳ式は0を返す。

返された値が0かそうでないかのテストには @code{zerop} 関数が使える。この
関数は引数として数値を取り、それが零なら @code{t} を返す。

@smallexample
@group
(zerop (% 7 5))
     @result{} nil

(zerop (% 10 5))
     @result{} t
@end group
@end smallexample

というわけで、次のようなＳ式を書けば、高さが5で割切れる場合には @code{t}
が返される。

@smallexample
(zerop (% height 5))
@end smallexample

@noindent
(@code{height} の値は勿論 @code{(apply 'max numbers-list)}. で分る。)

一方、もし @code{height} が5の倍数でない場合、値が5の倍数になるように再
設定する必要がある。これは既にお馴染みの関数を使えば単純な算数にすぎない。
まずは @code{height} を5で割ってこの中に何回5が含まれるかを調べる。例え
ば12なら2回含まれる。この値に1加えて5倍すれば、棒グラフの最大の高さより
も大きい最初の5の倍数が得られる。5は12の中には2回含まれるので、これに1を
足して5倍すると15が求まる。これが12を越える最初の5の倍数であ。この作業を
行うＳ式は次の通りである。

@smallexample
(* (1+ (/ height 5)) 5)
@end smallexample

@noindent
例えばもし次のＳ式を評価したなら、結果は15になる。

@smallexample
(* (1+ (/ 12 5)) 5)
@end smallexample

これまでの議論では「5」を Y 軸についての目盛幅としてきたわけだが、ここは
他の値を使っても構わない。一般性のために、5を他の値も設定出来るように変
数で置き換えよう。私としては、この変数は @code{Y-axis-label-spacing} と
名付けるのが良いと思う。この変数と @code{if} 式を使うと、次のＳ式が出来
る。

@need 1250
Using this term, and an @code{if} expression, we produce the
following:

@smallexample
@group
(if (zerop (% height Y-axis-label-spacing))
    height
  ;; @r{else}
  (* (1+ (/ height Y-axis-label-spacing))
     Y-axis-label-spacing))
@end group
@end smallexample

@noindent
このＳ式は、もし @code{height} が @code{Y-axis-label-spacing} の値の倍数
なら @code{height} の値そのものを返し、そうでない場合は、それより大きい
最小の @code{Y-axis-label-spacing} の倍数の値を計算して返す。

それでは、このＳ式を @code{print-graph} 関数の中の @code{let} 式の中に
(@code{Y-axis-label-spacing} の設定の後で) 埋め込んでみよう。
@vindex Y-axis-label-spacing

@smallexample
@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
@dots{}
(let* ((height (apply 'max numbers-list))
       (height-of-top-line
        (if (zerop (% height Y-axis-label-spacing))
            height
@end group
@group
          ;; @r{else}
          (* (1+ (/ height Y-axis-label-spacing))
             Y-axis-label-spacing)))
       (symbol-width (length graph-blank))))
@dots{}
@end group
@end smallexample

@noindent
(@code{let*} 関数を使っていることに注意。始めに変数 height の初期値が
@code{(apply 'max numbers-list)} 式で計算され、その値を使って他の変数の
値を計算しているためである。@code{let*} についての詳細は、次を参照。
@ref{fwd-para let, , @code{let＊} 式}.)

@node Y Axis Element
@appendixsubsec Y 軸の要素の構成

縦軸を表示する際には、@w{@samp{5 -}} とか @w{@samp{10 -}} 等を5行ごと
に挿入したい。更に、数は下の部分を揃えたい。つまり、小さな桁の数は、前に
空白を置くことになる。もし二桁の数が出てきた時には、一桁の数の先頭には一
つの空白を置くことになるわけである。

@findex number-to-string
数の長さを求めるには、@code{length} 関数が使われる。しかし、
@code{length} 関数は文字列に対してしかうまく動作せず、数値は扱えない。そ
こでまず、数を数値から文字列に変換する必要がある。これは、
@code{number-to-string} 関数を使って行うことが出来る。例えば、次のような感
じである。

@smallexample
@group
(length (number-to-string 35))
     @result{} 2

(length (number-to-string 100))
     @result{} 3
@end group
@end smallexample

@noindent
(@code{number-to-string} is also called @code{int-to-string}; you will
see this alternative name in various sources.)

更に、各ラベルにおいて、各々の数には @w{@samp{ - }} のような文字列を付け
加えたい。これを、@code{Y-axis-tic} マーカと呼ぶことにしよう。この変数は、
@code{defvar} を使って定義する。

@vindex Y-axis-tic
@smallexample
@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group
@end smallexample

Y ラベルの長さは、Y axis tick mark とグラフの一番上の数の桁数の和になる。

@smallexample
(length (concat (number-to-string height) Y-axis-tic)))
@end smallexample

この値は、@code{print-graph} 関数の中の変数リストの所で、
@code{full-Y-label-width} の値として計算される。(我々が最初にこの関数を
考えた時には、この関数は変数リストの中に入れることは考えていなかったこと
に注意しよう。)

縦軸を完成させるには、目盛記号を数と結合する必要がある。そして、その前に
は数の桁数によって空白が付いたりする。というわけで、ラベルには三つのパー
トがあることになる。先頭の空白 (無い場合もある)、数、そして目盛記号であ
る。この関数には、指定された行に対する数の値と一番上の行の幅が渡される。
これらの値は @code{print-graph} によって (一回だけ) 計算される。

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

@code{Y-axis-element} 関数は、(もしあれば) 先頭の空白と、文字列としての
数と、目盛記号を結合するものである。

先頭にいくつ空白をつければよいかは、ラベルの実質部分の長さ---数の長さと
目盛記号の長さの和---を望まれるラベルの長さから引くことで求められる。

@findex make-string
空白は @code{make-string} 関数を使って挿入される。この関数は、二つの引数
を取る。一つは文字列の長さ、もう一つは特定の形式で書かれた挿入する文字の
シンボルである。今の場合、この形式は @samp{? } のように、疑問符に続く空
白という形をしている。このような文字の表し方についての説明は、次を参照。
@ref{Character Type, , Character Type, elisp, The GNU Emacs Lisp
Reference Manual}.

@code{number-to-string} 関数は、結合式の中で数を文字列に変換するために使わ
れている。文字列に変換してから先頭の空白と目盛記号と結合するのである。

@node Y-axis-column
@appendixsubsec Y 軸全体の構成

前節までの関数で、縦軸のラベルとして挿入する番号と空白のついた文字列の
リストを生成する関数を構成するのに必要なツールが全て揃う。

@findex Y-axis-column
@smallexample
@group
(defun Y-axis-column (height width-of-label)
  "Construct list of Y axis labels and blank strings.
For HEIGHT of line above base and WIDTH-OF-LABEL."
  (let (Y-axis)
@group
@end group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{ラベル挿入}
          (setq Y-axis
                (cons
                 (Y-axis-element height width-of-label)
                 Y-axis))
@group
@end group
        ;; @r{そうでなければ空白挿入}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
    ;; @r{ベースライン挿入}
    (setq Y-axis
          (cons (Y-axis-element 1 width-of-label) Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

この関数では、まず @code{height} の値から出発してその値を一つずつ減らし
ていき、各々の引き算が終わった所でその値が @code{Y-axis-label-spacing}
の整数倍になっているかどうかを判定する。そして、もしそうなっていれば、
@code{Y-axis-element} 関数を使って番号付きのラベルを作成し、そうでなけれ
ば @code{make-string} 関数を使って空白のラベルを作成する。最下行は、番号
1と目盛記号からなっている。

@need 2000
@node print-Y-axis Penultimate
@appendixsubsec @code{print-Y-axis} 最終版

(訳註：題名に最終版と書いてあるが、実際には @ref{Print Whole Graph, ,
グラフ全体の表示}, に出ているものが真の最終版である。原文ではここに最終版
が載っていたのだが、そうすると、中で使っている @code{y-axis-column} 関数
が最終版でないために、その次に述べられているテストでエラーが出てしまう。)

@code{Y-axis-column} 関数によって構成されたリストは @code{print-Y-axis}
関数に渡される。これが実際にそのリストを挿入する。

@findex print-Y-axis
@smallexample
@group
(defun print-Y-axis (height full-Y-label-width)
  "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the maximum height of the graph.
Full width is the width of the highest label element."
;; Value of height and full-Y-label-width
;; are passed by `print-graph'.
@end group
@group
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width))
@c Bug
@c     (Y-axis-column height full-Y-label-width vertical-step))
    ;; @r{グラフ挿入の準備としてポイントを移動}
    (goto-char start)
    ;; full-Y-label-width @r{の値の分だけポイントを前方に移動}
    (forward-char full-Y-label-width)))
@end group
@end smallexample

@code{print-Y-axis} は @code{Y-axis-column} によって作成された Y 軸のラ
ベルを挿入するのに @code{insert-rectangle} を使っている。更に、グラフの
本体部分を挿入するための適切な位置にポイントを移動している。

以下のようにして @code{print-Y-axis} をテストしてみることが出来る。

@enumerate
@item
まず次の変数や関数をインストールする。

@smallexample
@group
Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
@end group
@end smallexample
@c (訳註：この節には @code{Y-axis-label-spacing} は出てきていないので、便宜
@c 上、再掲しておくことにする。他のものは、この節を最初から読んでおればイン
@c ストールされているはずである。)
@c
@c @example
@c @group
@c (defvar Y-axis-label-spacing 5
@c   "Number of lines from one Y axis label to next.")
@c @end group
@c @end example

@item
次のＳ式をコピーする。

@smallexample
(print-Y-axis 12 5)
@end smallexample

@item
@file{*scratch*} バッファに移り、カーソルを縦軸のラベルを挿入したい位置
まで移動する。

@item
@kbd{M-:} (@code{eval-expression}) とタイプする。(訳註：Emacs 19.28 ベー
スの Mule では @kbd{M-@key{ESC}}.)

@item
@code{print-Y-axis} 式をミニバッファに @kbd{C-y} (@code{yank}) を使っ
てヤンクする。

@item
このＳ式を評価するために @key{RET} を押す。
@end enumerate

Emacs はラベルを縦に表示する。一番上は @w{@samp{10 -@w{ }}} である。
(@code{print-graph} 関数は、@code{height-of-top-line} の値を渡すのだが、
今の場合これは15である。) (訳註：ここは原文も混乱しているみたいである。
@code{print-Y-axis} は @code{print-graph} の中で使われている。その中では
@code{print-Y-axis} に第一引数として渡されるのは
@code{height-of-top-line} の値なのであるが、@code{print-graph} 関数の中
の局所変数としての @var{height} の値が12で @var{Y-axis-label-spacing} の
値が5だったとすると、この @code{height-of-top-line} の値が15になるという
ことを言いたかったのであろう。詳しくは最終版 @code{print-graph} を参照の
こと。)

@need 2000
@node print-X-axis
@appendixsec 関数 @code{print-X-axis}
@cindex Axis, print horizontal
@cindex X axis printing
@cindex Print horizontal axis
@cindex Horizontal axis printing

X 軸のラベルは Y 軸のラベルと大変似ている。違うのは、目盛記号が数の上に
のっていることである。ラベルは次のようになる。

@smallexample
@group
    |   |    |    |
    1   5   10   15
@end group
@end smallexample

最初の目盛はグラフの最初の桁の下の部分にきており、その前には幾つかの空
白がある。これらの空白は、Y 軸のラベルが上に来る部分である。二番目、三番
目、四番目、あるいはそれに続く目盛は全て等間隔で並んでいる。この間隔は
@code{X-axis-label-spacing} の値で決まる。

X 軸の二行目は、空白に続く数からなる。この数字の間隔もまた
@code{X-axis-label-spacing} の値による。

変数 @code{X-axis-label-spacing} の値そのものは @code{symbol-width} とい
う単位を元に決められるべきである。棒グラフを表示するためのシンボルの幅を
変更する時に、ラベルの付け方まで変えなければならないなんて事態は避けたい
だろう。

@menu
* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            横軸に目盛記号を入れる
@end menu

@ifnottex
@node Similarities differences
@unnumberedsubsec Similarities and differences
@end ifnottex

@code{print-X-axis} 関数は多かれ少なかれ @code{print-Y-axis} 関数と同じ
形をしている。違うのは、目盛の行と数字の行の二行あるということである。こ
の二つは各々別の関数で書いて、@code{print-X-axis} の中で一緒にすることに
する。

以下が、これから行う三段階のステップである。

@enumerate
@item
X 軸の目盛記号を表示する関数 @code{print-X-axis-tic-line} を書く。

@item
X 軸の数字を表示する関数 @code{print-X-axis-numbered-line} を書く。

@item
この @code{print-X-axis-tic-line} と
@code{print-X-axis-numbered-line} を使って、上の二つの行を両方とも表示す
る関数 @code{print-X-axis} を書く。
@end enumerate

@node X Axis Tic Marks
@appendixsubsec X 軸の目盛記号

最初の関数では、X 軸の目盛記号を表示する。まずは、目盛記号とその間の記号
を指定しないといけない。

@smallexample
@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end smallexample

@noindent
(@code{graph-blank} の値はまた別の @code{defvar} で設定されることに注意
しよう。@code{boundp} という述語は、既に何かの値がセットされているかどう
かを判定するものである。もし何もセットされていなければ、@code{boundp} は
@code{nil} を返す。もし @code{graph-blank} が設定されず、また、この条件
分岐式がなかったとすると、@code{Symbol's value as variable is void} とい
うエラーメッセージを受けとることになる。

@need 1200
Here is the @code{defvar} for @code{X-axis-tic-symbol}:

@smallexample
@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group
@end smallexample

@need 1250
目標は、次のような行を作成することである。

@smallexample
       |   |    |    |
@end smallexample

最初の目盛は、Y 軸のラベルのためのスペースを空けるためにインデントされた
最初の棒グラフの開始の桁と同じだけインデントしないといけない。

目盛の要素は、ある目盛から次の目盛までのスペースと目盛記号からなる。空白
の数は目盛記号の幅と @code{X-axis-label-spacing} から決まる。

@need 1250
コードは次の通りである。

@smallexample
@group
;;; X-axis-tic-element
@dots{}
(concat
 (make-string
  ;; @r{空白の文字列を作成}
  (-  (* symbol-width X-axis-label-spacing)
      (length X-axis-tic-symbol))
  ? )
 ;; @r{空白を目盛記号と結合}
 X-axis-tic-symbol)
@dots{}
@end group
@end smallexample

次に、最初の目盛をグラフの開始位置までインデントするために、どれだけ空白
が要るかを数える必要がある。これには、@code{print-graph} 関数によって渡
された @code{full-Y-label-width} の値を利用する。

@need 1250
@code{X-axis-leading-spaces} を作るためのコードは次の通りである。

@smallexample
@group
;; X-axis-leading-spaces
@dots{}
(make-string full-Y-label-width ? )
@dots{}
@end group
@end smallexample

また、横軸の長さも決めなければならない。これは、数のリストの長である。
更に、横軸の目盛の数も決める必要がある。

@smallexample
@group
;; X-length
@dots{}
(length numbers-list)
@end group

@group
;; tic-width
@dots{}
(* symbol-width X-axis-label-spacing)
@end group

@group
;; number-of-X-tics
(if (zerop (% X-length tic-width))
    (/ X-length tic-width)
  (1+ (/ X-length tic-width)))
@end group
@end smallexample

@need 1250
これらを使うと、X 軸の目盛の行を表示する関数は次のようになる。

@findex print-X-axis-tic-line
@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print ticks for X axis."
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{最初の桁の下に}
@end group
@group
    ;; @r{右の位置に二番目の目盛記号を挿入}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{二番目の目盛記号まで空白を挿入}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{残りの目盛記号を挿入}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

数字の行も同様にして簡単に書ける。

@need 1250
まずは前に空白の付いた番号を作成する。

@findex X-axis-element
@smallexample
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

次に、数字のついた行を表示するための関数を作る。これはまず最初の桁に数
``1'' を付けるところから始まる。

@findex print-X-axis-numbered-line
@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing))
    (insert X-axis-leading-spaces)
    (insert "1")
@end group
@group
    (insert (concat
             (make-string
              ;; @r{次の数字の所まで空白を挿入}
              (-  (* symbol-width X-axis-label-spacing) 2)
              ? )
             (number-to-string number)))
@end group
@group
    ;; @r{残りの数字を挿入}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element number))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

最後に、@code{print-X-axis-tic-line} と
@code{print-X-axis-numbered-line} を使って、@code{print-X-axis} を書く。

この関数では @code{print-X-axis-tic-line} と
@code{print-X-axis-numbered-line} の両方で使われている局所変数の値を決定
してから、これらの関数を呼び出さなければならない。また、二つの行の区切り
に復帰コードを表示する必要もある。

この関数は、5つの局所変数を指定する変数リストと二つの行を表示する関数の
呼び出しからなる。

@findex print-X-axis
@smallexample
@group
(defun print-X-axis (numbers-list)
  "Print X axis labels to length of NUMBERS-LIST."
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
@end group
@group
       ;; symbol-width @r{は} graph-body-print @r{で与えられる。}
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
@end group
@group
          ;; @r{空白の文字列を作成}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{空白を目盛記号と結合}
         X-axis-tic-symbol))
@end group
@group
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group
@group
    (print-X-axis-tic-line tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line tic-number leading-spaces)))
@end group
@end smallexample

@need 1250
これで、@code{print-X-axis} のテストが出来る。

@enumerate
@item
まずは @code{X-axis-tic-symbol},  @code{X-axis-label-spacing},
@code{print-X-axis-tic-line}, などの変数とともに @code{X-axis-element},
@code{print-X-axis-numbered-line}, @code{print-X-axis} という関数をイン
ストールする。

@item
次のＳ式をコピーする。

@smallexample
@group
(progn
 (let ((full-Y-label-width 5)
       (symbol-width 1))
   (print-X-axis
    '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
@end group
@end smallexample

@item
@file{*scratch*} バッファに移り、カーソルを軸のラベルを表示したい位置に
まで動かす。

@item
@kbd{M-:} (@code{eval-expression}) とタイプする。(訳註：Emacs 19.28 ベー
スの Mule では @kbd{M-@key{ESC}}.)

@item
@kbd{C-y} (@code{yank)} を使って、テストのＳ式をヤンクする。

@item
その式を評価するために、@key{RET} を押す。
@end enumerate

@need 1250
これで Emacs は次のような横軸を表示してくれるはずだ。

@smallexample
@group
     |   |    |    |    |
     1   5   10   15   20
@end group
@end smallexample

@node Print Whole Graph
@appendixsec グラフ全体の表示
@cindex Printing the whole graph
@cindex Whole graph printing
@cindex Graph, printing all

さて、これでグラフ全体を表示する準備が整った。

きちんとしたラベルが付いたグラフを表示する関数を書く際には、以前作成した
アウトラインに従うわけだが (@ref{Full Graph, , ラベルと軸の付いたグラフ},
参照)、幾つか追加することがある。

@need 1250
アウトラインは以下のようなものだった。

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{説明文字列}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

@menu
* The final version::           A few changes.
* Test print-graph::            簡単なテスト
* Graphing words in defuns::    最終的なコードの実行
* lambda::                      無名関数の書き方
* mapcar::                      要素のリストに関数を作用させる
* Another Bug::                 でもまだバグが潜んでいる @dots{}
* Final printed graph::         これがグラフだ！
@end menu

@ifnottex
@node The final version
@unnumberedsubsec Changes for the Final Version
@end ifnottex

最終的なバージョンは、上の計画とは二つの点で違っている。まず、変数リスト
の中で追加して計算するものがある。次に、ラベルの増加のさせ方を指定するオ
プションがある。後者の特徴はかなり本質的である。そうしないことには、画面
や紙面に合わなくなってしまう可能性があるからだ。

この新しい特徴を実現するには、@code{Y-axis-column} 関数にいくらか変更を
加えて @code{vertical-step} という変数を加える必要がある。同時に、
@code{print-Y-axis} も書き換える。新しい関数は次のようになる。

@findex Y-axis-column @r{Final version.}
@smallexample
@group
;;; @r{最終バージョン。}
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.  For example, a step of 5 means
that each line is five units of the graph."
@end group
@group
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
@end group
@group
          ;; @r{ラベルの挿入}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{そうでない場合は, 空白の挿入}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{ベースラインの挿入}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

グラフの最大の高さの値とシンボルの幅は @code{print-graph} の中の
@code{let} 式によって計算される。従って、@code{graph-body-print} はそれ
らを受け取ることが出来るように変更しなければならない。

@findex graph-body-print @r{Final version.}
@smallexample
@group
;;; @r{最終バージョン。}
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{各桁ごとにグラフを描写}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{X 軸のラベルのためにポイントを移動}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@need 1250
最後に、@code{print-graph} 関数のコードを載せておこう。

@findex print-graph @r{Final version.}
@smallexample
@group
;;; @r{最終バージョン。}
(defun print-graph
  (numbers-list &optional vertical-step)
  "Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units."
@end group
@group
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{は最大の数でもあり、}
         ;; @r{最大桁の数でもある。}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
@end group
@group
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group

@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
@end group
@group
    (graph-body-print
     numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list)))
@end group
@end smallexample

@node Test print-graph
@appendixsubsec @code{print-graph} のテスト

@need 1250
@code{print-graph} 関数を短い数のリストで試してみよう。

@enumerate
@item
(他のコードに加えて) @code{Y-axis-column}、@code{print-Y-axis}、
@code{graph-body-print}、そして @code{print-graph} の各最終バージョンを
インストールする。

@item
次のＳ式をコピーする。

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@item
@file{*scratch*} バッファに移り、カーソルをグラフを表示したい位置にまで
移動する。

@item
@kbd{M-:} (@code{eval-expression}) とタイプする。(訳註：Emacs 19.28 ベー
スの Mule では @kbd{M-@key{ESC}}.)

@item
@kbd{C-y} (@code{yank}) を使って、上のＳ式をミニバッファにヤンクする。

@item
このＳ式を評価するために @kbd{RET} を押す。
@end enumerate

@need 1250
Emacs は次のようなグラフを表示する。

@smallexample
@group
10 -


         *
        **   *
 5 -   ****  *
       **** ***
     * *********
     ************
 1 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@need 1200
一方、次のＳ式を評価して @code{print-graph} に @code{vertical-step} とし
て2を与えてみたとする。

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
@end smallexample

@need 1250
@noindent
するとグラフは次のようになるはずだ。

@smallexample
@group
20 -


         *
        **   *
10 -   ****  *
       **** ***
     * *********
     ************
 2 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@noindent
(疑問：横軸の左の `2' はバグだろうか、仕様だろうか。もしバグであると思う
のなら、そして `2' ではなく `1' であるべきだと思うのなら (あるいは `0'
であるべきだと思うのなら)、ソースを修正すればよい。)

@node Graphing words in defuns
@appendixsubsec 単語やシンボルの数のグラフ化

さて、やっと目的のグラフの所まで来た。いよいよ単語やシンボルの数が10より
少ない関数定義がどれだけあるか、10から19までの間だとどれだけか、20から29
までだとどうか、といったことを示してくれるグラフを描く関数を書くわけであ
る。

これは幾つかのプロセスに分けて行う。まずは、必要なコードを全てロードし
てあることを確認しよう。

@need 1500
異なる値を設定してしまった場合に備えて、@code{top-of-ranges} の値を再設
定しておく方がよいだろう。それには以下を評価すればよい。

@smallexample
@group
(setq top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
@end group
@end smallexample

@noindent
次に、各々の範囲に入っている単語やシンボルの数のリストを作成しよう。

@need 1500
@noindent
まず次を評価する。

@smallexample
@group
(setq list-for-graph
       (defuns-per-range
         (sort
          (recursive-lengths-list-many-files
           (directory-files "/usr/local/emacs/lisp"
                            t ".+el$"))
          '<)
         top-of-ranges))
@end group
@end smallexample

@noindent
私の機械では、これに一時間程かかった。私の持っている Emacs version 19.23
だと303の Lisp ファイルを見ていることになる。この計算の後では、
@code{list-for-graph} の値は次のようになる。

@smallexample
@group
(537 1027 955 785 594 483 349 292 224 199 166 120 116 99
90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
@end group
@end smallexample

@noindent
これは、私の Emacs には10以下の単語やシンボルしか持たない関数定義が537個
あり、10以上19未満の単語やシンボルを持つものが1,027個、20から29までだと
955個、などというふうになっていることを示している。

このリストから明らかに見て取れることは、殆どの関数定義では、中に含まれる
単語やシンボルの数は、10から30までだということである。

さて、これをグラフに表示することにしよう。我々は、1,030行もの高さのグラ
フは描きたく@emph{ない}。そうではなく、25行以下程度のグラフを描きたいの
である。この高さのグラフであれば、大抵のモニタで表示出来るだろう。また、
紙にも印刷しやすい。

これは、今の場合、@code{list-for-graph} の各々の値を50分の1に縮小しない
といけないということである。

この操作をやってくれる簡単な関数を、以下に挙げる。この関数には、今までに
出てこなかった二つの関数 @code{mapcar} と @code{lambda} が出てくる。

@smallexample
@group
(defun one-fiftieth (full-range)
  "Return list, each number one-fiftieth of previous."
 (mapcar (lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@node lambda
@appendixsubsec @code{lambda} 式
@cindex Anonymous function
@findex lambda

@code{lambda} は無名関数、即ち名前のない関数のシンボルである。無名関数を
使う場合には毎回本体を全て含めて書かなければならない。

@need 1250
@noindent
従って、

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
であれば、常に @code{arg} として渡されたものを50で割った値を返す、という
関数定義になる。

例えば、以前、@code{multiply-by-seven} 関数というのを説明したことがある。
これは引数を7倍するものであった。今回の関数も同様である。異なる点は、引
数を50で割るということと、名前がないということだけである。
@code{multiply-by-seven} を無名関数で書き直すと次のようになる。

@smallexample
(lambda (number) (* 7 number))
@end smallexample

@noindent
(@ref{defun, , 特殊形式 @code{defun}}, を参照。)

@need 1250
@noindent
もし3を7倍したいなら、次のように書くことが出来る。

@c !!! Clear if machine is too small and cannot handle all 10 figures.
@c lear print-postscript-figures
@c set print-postscript-figures
@c lambda example diagram #1
@ifnottex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
このＳ式は21を返す。

@need 1250
@noindent
同様に、次のようにも書ける。

@c lambda example diagram #2
@ifnottex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end iftex
@end ifclear

@need 1250
@noindent
100を50で割る場合は次のように書く。

@c lambda example diagram #3
@ifnottex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function    argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
このＳ式は2を返す。上の100は関数に渡されるもので、その数を関数が50で割っ
ているのである。

@code{lambda} についてのより詳しいことは、@ref{Lambda Expressions, ,
Lambda Expressions, elisp, The GNU Emacs Lisp Reference Manual}, を参照
せよ。Lisp や lambda 式は、Lambda 計算から派生したものである。

@node mapcar
@appendixsubsec 関数 @code{mapcar}
@findex mapcar

@code{mapcar} は最初の引数を二番目の引数の各々の要素にともに、順に呼び出
す関数である。二番目の引数はシーケンス (sequence) でないといけない。

The @samp{map} part of the name comes from the mathematical phrase,
`mapping over a domain', meaning to apply a function to each of the
elements in a domain.  The mathematical phrase is based on the
metaphor of a surveyor walking, one step at a time, over an area he is
mapping.  And @samp{car}, of course, comes from the Lisp notion of the
first of a list.

@need 1250
@noindent
例えば、

@smallexample
@group
(mapcar '1+ '(2 4 6))
     @result{} (3 5 7)
@end group
@end smallexample

@noindent
という感じである。関数 @code{1+} は引数に1を加える関数であるが、これがそ
の後のリストの各要素について実行され、新しいリストを返すわけである。

これを @code{apply} と比較してみよう。こちらは最初の要素に対し、二番目以
降の全ての引数を引数として渡して実行させるものだった。(@code{apply} の説
明については @ref{Readying a Graph, , グラフを描く準備}, を参照。)

@need 1250
@code{one-fiftieth} の定義では、最初の引数は、

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
という無名関数である。また、二番目の引数は @code{full-range} であり、こ
れは @code{list-for-graph} にバインドされる。

@need 1250
Ｓ式全体は次の通りである。

@smallexample
(mapcar (lambda (arg) (/ arg 50)) full-range))
@end smallexample

@code{mapcar} についての詳細は @ref{Mapping Functions, , Mapping
Functions, elisp, The GNU Emacs Lisp Reference Manual}, を参照。

@code{one-fiftieth} 関数を使うと、各々の要素が、対応する
@code{list-for-graph} の要素の50分の1であるようなリストを生成することが
出来る。

@smallexample
@group
(setq fiftieth-list-for-graph
      (one-fiftieth list-for-graph))
@end group
@end smallexample

@need 1250
結果として出来るリストは次のようになる。

@smallexample
@group
(10 20 19 15 11 9 6 5 4 3 3 2 2
1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
@end group
@end smallexample

@noindent
これは、今すぐにでも表示出来そうである！ (もっともここで情報が失われてい
ることにも気付く。上の方の範囲の多くの要素は0である。これは、その範囲の
単語やシンボルを持つ関数定義の数が50未満であることを示しているだけであっ
て、そういう関数定義が全くないといっているわけではない。)

@node Another Bug
@appendixsubsec まだバグがある@dots{}
@cindex Bug, most insidious type
@cindex Insidious type of bug

私は、「今すぐにでも表示出来そう」と書いた。勿論、@code{print-graph} に
はバグがあるのだ@dots{} これには @code{vertical-step} オプションがあるが、
@code{horizontal-step} オプションはない。@code{top-of-range} の範囲は、
10ごとに10から300まである。しかし、@code{print-graph} は1ずつしか表示出
来ない。

これは、ある人々が最も見つけにくいタイプのバグだと考えている、考慮不足に
よるバグ (訳註：原文では bug of omission. これはどう訳すべきか) の古典的
な例である。これは、コードを調べることで見つかるようなバグではない。コー
ド自体に誤りはないからだ。これは単に何かが欠落しているということである。
このようなバグに対するもっとも正しい態度は、プログラムをなるべく早く、何
回もテストしてみることである。そして、コードを出来るだけ理解しやすく簡単
に変更出来るようにアレンジしていくのである。また、一度書いたものは、すぐ
にではなくともいつかは書き換えられるものだということを頭に入れておくよう
にしよう。これはなかなか実行が困難な格言ではあるが。

作業対象となるのは @code{print-X-axis-numbered-line} 関数である。また、
@code{print-X-axis} と @code{print-graph} もそれに合わせて書き換える必要
がある。もっともやることはそれ程多いわけではない。一つだけ面倒な部分があ
る。数字が目盛記号の下に綺麗に並ばなければならないということである。この
点はちょっとばかし頭をひねる必要がある。

@need 1250
以下が修正した @code{print-X-axis-numbered-line} である。

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; @r{頭の余計な空白を削除}
    (delete-char
     (- (1-
         (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
@end group
@group
              ;; @r{空白を挿入}
              (-  (* symbol-width
                     X-axis-label-spacing)
                  (1-
                   (length
                    (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string
              (* number horizontal-step))))
@end group
@group
    ;; @r{残りの数を挿入}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element
               (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@need 1500
もしあなたがこれを Info の中で読んでいるなら、@code{print-X-axis} と
@code{print-graph} の新しいバージョンを見ることが出来る。もしこれを印刷
された本で読んでいるとしたら、変更する行が下に書かれているはずだ。(印刷
するにはコードがちょっと多過ぎるので。)

@iftex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  @dots{}
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list
   &optional vertical-step horizontal-step)
  @dots{}
    (print-X-axis numbers-list horizontal-step))
@end group
@end smallexample
@end iftex

@ifnottex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width
;; are passed by `print-graph'.
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{は} graph-body-print @r{で与えらえる。}
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{空白の文字列を作成。}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{空白を目盛記号と結合。}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{は最大の数でもあり、}
         ;; @r{最大桁の数でもある。}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@end ifnottex

@c qqq
@ignore
グラフを表示するための定義を、もう一度書き並べておく。(訳註：原文ではこ
の部分が @@ignore によって無視されるようになっていた。これを訳者の判断で、
Info ではこの部分も表示されるようにした。その方が便利であろうと考える。)

@need 1250
以下が、グラフ表示のための定義の最終的な形である。

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250)
 "List specifying ranges for `defuns-per-range'.")
@end group

@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group

@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group

@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group

@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end smallexample

@smallexample
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group

@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group

@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
@end group

@group
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-many-files (list-of-files)
  "Return list of lengths of defuns in LIST-OF-FILES."
  (let (lengths-list)
;;; @r{真偽テスト}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list
@end group
@group
;;; @r{長さのリストの生成。}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
;;; @r{ファイルのリストを短くする。}
      (setq list-of-files (cdr list-of-files)))
;;; @r{長さのリストの最後の値を返す。}
    lengths-list))
@end group
@end smallexample

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{外側のループ。}
    (while top-of-ranges

      ;; @r{内側のループ。}
      (while (and
              ;; @r{数値のテストのための数字が必要。}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))

        ;; @r{現在の範囲内にある長さの定義の数をカウント。}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
@end group

@group
      ;; @r{内側のループは抜けるが外側のループにはまだ入っている。}

      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{カウントを零にリセット。}

      ;; @r{次の範囲に移動。}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{次の範囲の上限の値を指定。}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{外側のループを抜け、最も大きい範囲の上限の値よりも大きな}
    ;; @r{  関数定義の数をカウント。}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))

    ;; @r{最小から最大に向かって、各々の範囲にある関数定義の}
    ;; @r{  数のリストを返す。}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@smallexample
@group
(defun column-of-graph (max-graph-height actual-height)
  "Return list of MAX-GRAPH-HEIGHT strings;
ACTUAL-HEIGHT are graph-symbols.
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))

    ;; @r{@code{graph-symbols} の部分。}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{@code{graph-blanks} の部分。}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{リスト全体を返す}
    insert-list))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

@smallexample
@group
(defun print-Y-axis
  (height full-Y-label-width &optional vertical-step)
  "Insert Y axis by HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the  maximum height of the graph.
Full width is the width of the highest label element.
Optionally, print according to VERTICAL-STEP."
@end group
@group
;; Value of height and full-Y-label-width
;; are passed by `print-graph'.
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width vertical-step))
@end group
@group
    ;; @r{グラフを挿入する準備としてのポイントの移動}
    (goto-char start)
    ;; full-Y-label-width @r{の値だけポイントを移動}
    (forward-char full-Y-label-width)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print ticks for X axis."
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{グラフの最初の桁の真下}
@end group
@group
    ;; @r{適切な位置に二番目の目盛記号を挿入}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{二番目の目盛記号まで空白を挿入}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{残りの目盛記号を挿入}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

@smallexample
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

@smallexample
@group
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{各列ごとにグラフを挿入}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{X 軸のラベルのためにポイントを移動}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
@end group
@group
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.  For example, a step of 5 means
that each line is five units of the graph."
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
@end group
@group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{ラベルの挿入}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{そうでない場合、空白を挿入}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{ベースラインの挿入}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; line up number
    (delete-char (- (1- (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
              ;; @r{次の数まで空白を挿入}
              (-  (* symbol-width X-axis-label-spacing)
                  (1- (length (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string (* number horizontal-step))))
@end group
@group
    ;; @r{残りの数を挿入}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width
;; are passed by `print-graph'.
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{は} graph-body-print @r{で与えられる}
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{空白のストリングを作成}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{空白と目盛記号を結合}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun one-fiftieth (full-range)
  "Return list, each number of which is 1/50th previous."
 (mapcar (lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labeled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{は最大の数でもあり、}
         ;; @r{最大桁の数でもある。}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group

    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@c qqq
@end ignore

@page
@node Final printed graph
@appendixsubsec 表示されたグラフ

全てをインストールし終ったら、@code{print-graph} コマンドを次のようにし
て呼び出そう。
@sp 1

@smallexample
@group
(print-graph fiftieth-list-for-graph 50 10)
@end group
@end smallexample
@sp 1

次のようなグラフが表示されるはずだ。
@sp 2

@smallexample
@group
1000 -  *
        **
        **
        **
        **
 750 -  ***
        ***
        ***
        ***
        ****
 500 - *****
       ******
       ******
       ******
       *******
 250 - ********
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350
@end group
@end smallexample

@sp 2

@noindent
最も大きな関数のグループは、10から19までの単語やシンボルを含んでいる
もののグループである。

@node Free Software and Free Manuals
@appendix Free Software and Free Manuals

@strong{by Richard M. Stallman}
@sp 1

The biggest deficiency in free operating systems is not in the
software---it is the lack of good free manuals that we can include in
these systems.  Many of our most important programs do not come with
full manuals.  Documentation is an essential part of any software
package; when an important free software package does not come with a
free manual, that is a major gap.  We have many such gaps today.

Once upon a time, many years ago, I thought I would learn Perl.  I got
a copy of a free manual, but I found it hard to read.  When I asked
Perl users about alternatives, they told me that there were better
introductory manuals---but those were not free.

Why was this?  The authors of the good manuals had written them for
O'Reilly Associates, which published them with restrictive terms---no
copying, no modification, source files not available---which exclude
them from the free software community.

That wasn't the first time this sort of thing has happened, and (to
our community's great loss) it was far from the last.  Proprietary
manual publishers have enticed a great many authors to restrict their
manuals since then.  Many times I have heard a GNU user eagerly tell me
about a manual that he is writing, with which he expects to help the
GNU project---and then had my hopes dashed, as he proceeded to explain
that he had signed a contract with a publisher that would restrict it
so that we cannot use it.

Given that writing good English is a rare skill among programmers, we
can ill afford to lose manuals this way.

Free documentation, like free software, is a matter of freedom, not
price.  The problem with these manuals was not that O'Reilly Associates
charged a price for printed copies---that in itself is fine.  The Free
Software Foundation @uref{http://shop.fsf.org, sells printed copies} of
free @uref{http://www.gnu.org/doc/doc.html, GNU manuals}, too.
But GNU manuals are available in source code form, while these manuals
are available only on paper.  GNU manuals come with permission to copy
and modify; the Perl manuals do not.  These restrictions are the
problems.

The criterion for a free manual is pretty much the same as for free
software: it is a matter of giving all users certain
freedoms.  Redistribution (including commercial redistribution) must be
permitted, so that the manual can accompany every copy of the program,
on-line or on paper.  Permission for modification is crucial too.

As a general rule, I don't believe that it is essential for people to
have permission to modify all sorts of articles and books.  The issues
for writings are not necessarily the same as those for software.  For
example, I don't think you or I are obliged to give permission to
modify articles like this one, which describe our actions and our
views.

But there is a particular reason why the freedom to modify is crucial
for documentation for free software.  When people exercise their right
to modify the software, and add or change its features, if they are
conscientious they will change the manual too---so they can provide
accurate and usable documentation with the modified program.  A manual
which forbids programmers to be conscientious and finish the job, or
more precisely requires them to write a new manual from scratch if
they change the program, does not fill our community's needs.

While a blanket prohibition on modification is unacceptable, some
kinds of limits on the method of modification pose no problem.  For
example, requirements to preserve the original author's copyright
notice, the distribution terms, or the list of authors, are ok.  It is
also no problem to require modified versions to include notice that
they were modified, even to have entire sections that may not be
deleted or changed, as long as these sections deal with nontechnical
topics.  (Some GNU manuals have them.)

These kinds of restrictions are not a problem because, as a practical
matter, they don't stop the conscientious programmer from adapting the
manual to fit the modified program.  In other words, they don't block
the free software community from making full use of the manual.

However, it must be possible to modify all the technical content of
the manual, and then distribute the result in all the usual media,
through all the usual channels; otherwise, the restrictions do block
the community, the manual is not free, and so we need another manual.

Unfortunately, it is often hard to find someone to write another
manual when a proprietary manual exists.  The obstacle is that many
users think that a proprietary manual is good enough---so they don't
see the need to write a free manual.  They do not see that the free
operating system has a gap that needs filling.

Why do users think that proprietary manuals are good enough? Some have
not considered the issue.  I hope this article will do something to
change that.

Other users consider proprietary manuals acceptable for the same
reason so many people consider proprietary software acceptable: they
judge in purely practical terms, not using freedom as a
criterion.  These people are entitled to their opinions, but since
those opinions spring from values which do not include freedom, they
are no guide for those of us who do value freedom.

Please spread the word about this issue.  We continue to lose manuals
to proprietary publishing.  If we spread the word that proprietary
manuals are not sufficient, perhaps the next person who wants to help
GNU by writing documentation will realize, before it is too late, that
he must above all make it free.

We can also encourage commercial publishers to sell free, copylefted
manuals instead of proprietary ones.  One way you can help this is to
check the distribution terms of a manual before you buy it, and prefer
copylefted manuals to non-copylefted ones.

@sp 2
@noindent
Note: The Free Software Foundation maintains a page on its Web site
that lists free books available from other publishers:@*
@uref{http://www.gnu.org/doc/other-free-books.html}

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@cindex FDL, GNU Free Documentation License
@include doclicense.texi

@node Index
@unnumbered Index

@ignore
MENU ENTRY: NODE NAME.
@end ignore

@printindex cp

@iftex
@c Place biographical information on right-hand (verso) page

@tex
\par\vfill\supereject
\ifodd\pageno
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}\page
\else
%    \par\vfill\supereject
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}%\page
    %\page\hbox{}%\page
\fi
@end tex

@c page
@w{ }

@c ================ Biographical information ================

@w{ }
@sp 8
@center About the Author
@sp 1
@end iftex

@ifnottex
@node About the Author
@unnumbered About the Author
@end ifnottex

@c @quotation
@c Robert J. Chassell は1985年から GNU Emacs の仕事に携わっている。彼は
@c Emacs や Emacs Lisp を書き、編集し、教えている。また、@w{Free Software
@c Foundation, Inc.} の理事 (director) であり、秘書/会計係 でもある。彼は社
@c 会や経済の歴史にずっと興味を持ち続けており、また自家用機の手入れが好きで
@c ある。(訳註：この部分の訳は全く自信がないので、原文を以下に載せておく。
@c 間抜けな訳をするんじゃない! というお叱り歓迎。)
@c @end quotation

(訳註：以下は原文をそのまま載せておくことにする。)

@quotation
Robert J. Chassell has worked with GNU Emacs since 1985.  He writes
and edits, teaches Emacs and Emacs Lisp, and speaks throughout the
world on software freedom.  Chassell was a founding Director and
Treasurer of the Free Software Foundation, Inc.  He is co-author of
the @cite{Texinfo} manual, and has edited more than a dozen other
books.  He graduated from Cambridge University, in England.  He has an
abiding interest in social and economic history and flies his own
airplane.
@end quotation

@c @page
@c @w{ }
@c
@c @c Prevent page number on blank verso, so eject it first.
@c @tex
@c \par\vfill\supereject
@c @end tex

@c @iftex
@c @headings off
@c @evenheading @thispage @| @| @thistitle
@c @oddheading            @| @| @thispage
@c @end iftex

@bye
